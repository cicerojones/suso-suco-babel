* 
  :PROPERTIES:
  :header-args: :results silent
  :END:

** ugens
#+name: ablock
#+BEGIN_SRC sclang
    // parabolic approximation of sine
    // { LFPar.ar(LFPar.kr(LFPar.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play;
    // { LFPar.ar(LFPar.kr(LFPar.kr(0.2,0,8,10),0, 400,800),0,0.003) }.play;

  { MulAdd.new(LFPar.ar(LFPar.kr(LFPar.kr(0.2,0,8,10),0, 400,800),0,0.1), MouseY.kr(0.005, 0.1)) }.play;
#+END_SRC

#+name: 0-block
#+BEGIN_SRC sclang
  // { LFPar.ar(LFPar.kr(0.2, 0, 400,800),0,0.003) }.play;

  f = { LFPar.ar(LFPar.kr(0.2, 0, 400,800),0,0.1) };

{MulAdd.new(f, MouseY.kr(0.003, 0.1))}.play
#+END_SRC

#+name: 1-block
#+BEGIN_SRC sclang
  { LFPar.ar(800,0,0.02) }.play;
  // { LFPar.ar(800,0,0.003) }.play;
#+END_SRC

#+name: 2-block
#+BEGIN_SRC sclang
// since it is not band limited, there are aliasing artifacts
{ LFPar.ar(XLine.kr(100,15000,6),0,0.1) }.play;
#+END_SRC

#+name: 3-block
#+BEGIN_SRC sclang
// cubic approximation of sine
{ LFCub.ar(LFCub.kr(LFCub.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play;
#+END_SRC

#+name: 4-block
#+BEGIN_SRC sclang
{ LFCub.ar(LFCub.kr(0.2, 0, 400,800),0,0.1) }.play;
#+END_SRC

#+name: 5-block
#+BEGIN_SRC sclang
{ LFCub.ar(800,0,0.1) }.play;
#+END_SRC

#+name: 6-block
#+BEGIN_SRC sclang
{ LFCub.ar(XLine.kr(100,15000,6),0,0.1) }.play;
#+END_SRC

#+name: 7-block
#+BEGIN_SRC sclang
{ LFTri.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play;
#+END_SRC

#+name: 8-block
#+BEGIN_SRC sclang
{ LFTri.ar(LFTri.kr(0.2, 0, 400,800),0,0.1) }.play;
#+END_SRC

#+name: 9-block
#+BEGIN_SRC sclang
{ LFTri.ar(800,0,0.1) }.play;
#+END_SRC

#+name: 10-block
#+BEGIN_SRC sclang
{ LFTri.ar(XLine.kr(100,15000,6),0,0.1) }.play;
#+END_SRC

#+name: 11-block
#+BEGIN_SRC sclang
{ LFSaw.ar(LFSaw.kr(LFSaw.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play;
#+END_SRC

#+name: 12-block
#+BEGIN_SRC sclang
{ LFSaw.ar(LFSaw.kr(0.2, 0, 400,800),0,0.1) }.play;
#+END_SRC

#+name: 13-block
#+BEGIN_SRC sclang
{ LFSaw.ar(100,0,0.1) }.play;
#+END_SRC

#+name: 14-block
#+BEGIN_SRC sclang
{ LFSaw.ar(XLine.kr(100,15000,6),0,0.1) }.play;
#+END_SRC

#+name: 15-block
#+BEGIN_SRC sclang
{ Impulse.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play;
#+END_SRC

#+name: 16-block
#+BEGIN_SRC sclang
{ Impulse.ar(LFTri.kr(0.2, 0, 400,800),0,0.1) }.play;
#+END_SRC

#+name: 17-block
#+BEGIN_SRC sclang
{ Impulse.ar(100,0,0.1) }.play;

{ Impulse.ar(XLine.kr(100,15000,6),0,0.1) }.play;
#+END_SRC

#+name: 18-block
#+BEGIN_SRC sclang
{ LFPulse.ar(LFPulse.kr(LFPulse.kr(0.2,0,0.5,8,10),0,0.5, 400,800),0,0.5,0.1) }.play;
#+END_SRC

#+name: 19-block
#+BEGIN_SRC sclang
{ LFPulse.ar(LFPulse.kr(3, 0, 0.3, 200, 200), 0, 0.2, 0.1) }.play;
#+END_SRC

#+name: 20-block
#+BEGIN_SRC sclang
{ LFPulse.ar(XLine.kr(100,15000,6),0,0.5,0.1) }.play;
#+END_SRC

#+name: 21-block
#+BEGIN_SRC sclang
// pulse width modulation
{ LFPulse.ar(100,0,MouseY.kr(0,1),0.1) }.play;
#+END_SRC

#+name: 22-block
#+BEGIN_SRC sclang
{ LFPulse.ar(100,0,LFTri.kr(0.2,0,0.5,0.5),0.1) }.play;
#+END_SRC

#+name: 23-block
#+BEGIN_SRC sclang
{ VarSaw.ar(VarSaw.kr(VarSaw.kr(0.2,0,0.2,8,10),0,0.2, 400,800),0,0.2,0.1) }.play;
#+END_SRC

#+name: 24-block
#+BEGIN_SRC sclang
{ VarSaw.ar(VarSaw.kr(0.2, 0, 0.2, 400,800),0,0.2,0.1) }.play;
#+END_SRC

#+name: 25-block
#+BEGIN_SRC sclang
{ VarSaw.ar(XLine.kr(100,15000,6),0,0.2,0.1) }.play;
#+END_SRC

#+name: 26-block
#+BEGIN_SRC sclang
// pulse width modulation
{ VarSaw.ar(100,0,MouseY.kr(0,1),0.1) }.play;
#+END_SRC

#+name: 27-block
#+BEGIN_SRC sclang
{ VarSaw.ar(100,0,LFTri.kr(0.2,0,0.5,0.5),0.1) }.play;
#+END_SRC

#+name: 28-block
#+BEGIN_SRC sclang
{ SyncSaw.ar(100, MouseX.kr(100, 1000), 0.1) }.play;
#+END_SRC

#+name: 29-block
#+BEGIN_SRC sclang
{ SyncSaw.ar(100, Line.kr(100, 800, 12), 0.1) }.play;
#+END_SRC

#+name: 30-block
#+BEGIN_SRC sclang
  { SinOsc.ar(SinOsc.kr(SinOsc.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play;
#+END_SRC

#+name: 31-block
#+BEGIN_SRC sclang
  { SinOsc.ar(SinOsc.kr(0.2, 0, 400,800),0,0.1) }.play;
#+END_SRC

#+name: 32-block
#+BEGIN_SRC sclang
  { SinOsc.ar(800,0,0.1) }.play;
#+END_SRC

#+name: 33-block
#+BEGIN_SRC sclang
  { SinOsc.ar(XLine.kr(100,15000,6),0,0.1) }.play;
#+END_SRC

#+name: 34-block
#+BEGIN_SRC sclang
{ FSinOsc.ar(800,0,0.1) }.play;
#+END_SRC

#+name: 35-block
#+BEGIN_SRC sclang
// FSinOsc should not be frequency modulated.
// Since it is based on a filter at the edge of stability, it will blow up:
{ FSinOsc.ar(FSinOsc.kr(FSinOsc.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play;
#+END_SRC

#+name: 36-block
#+BEGIN_SRC sclang
{ Blip.ar(XLine.kr(20000,200,6),100,0.2) }.play(1);
#+END_SRC

#+name: 37-block
#+BEGIN_SRC sclang
{ Blip.ar(XLine.kr(100,15000,6),100,0.2) }.play(1); // no aliasing
#+END_SRC

#+name: 38-block
#+BEGIN_SRC sclang
// modulate number of harmonics
{ Blip.ar(200,Line.kr(1,100,20),0.2) }.play(1);
#+END_SRC

#+name: 39-block
#+BEGIN_SRC sclang
{ Saw.ar(XLine.kr(20000,200,6),0.2) }.play(1);
#+END_SRC

#+name: 40-block
#+BEGIN_SRC sclang
{ Saw.ar(XLine.kr(100,15000,6),0.2) }.play(1); // no aliasing
#+END_SRC

#+name: 41-block
#+BEGIN_SRC sclang
{ Pulse.ar(XLine.kr(20000,200,6),0.3,0.2) }.play(1);
#+END_SRC

#+name: 42-block
#+BEGIN_SRC sclang
{ Pulse.ar(XLine.kr(100,15000,6),0.3,0.2) }.play(1); // no aliasing
#+END_SRC

#+name: 43-block
#+BEGIN_SRC sclang


// modulate pulse width
{ Pulse.ar(200, Line.kr(0.01,0.99,8), 0.2) }.play(1);
#+END_SRC

#+name: 44-block
#+BEGIN_SRC sclang

// two band limited square waves thru a resonant low pass filter
{ RLPF.ar(Pulse.ar([100,250],0.5,0.1), XLine.kr(8000,400,5), 0.05) }.play(1);
#+END_SRC

#+name: 45-block
#+BEGIN_SRC sclang
{ Klang.ar(`[ [800, 1000, 1200],[0.3, 0.3, 0.3],[pi,pi,pi]], 1, 0) * 0.4}.play(1);
#+END_SRC

#+name: 46-block
#+BEGIN_SRC sclang

{ Klang.ar(`[ {exprand(400, 2000)}.dup(16), nil, nil ], 1, 0) * 0.04 }.play(1);
#+END_SRC

** use buffers
#+name: 47-block
#+BEGIN_SRC sclang
(
b = Buffer.alloc(s, 2048, 1, bufnum: 80);
b.sine1(1.0/(1..6), true, true, true);
)

#+END_SRC

#+name: 48-block
#+BEGIN_SRC sclang
{ Osc.ar(80, 100, 0, 0.1) }.play;
#+END_SRC

#+name: 49-block
#+BEGIN_SRC sclang
b.sine1(1.0/(1..12));
#+END_SRC

#+name: 50-block
#+BEGIN_SRC sclang
b.sine1(1.0/(1..24));
#+END_SRC

#+name: 51-block
#+BEGIN_SRC sclang
b.sine1(1.0/(1..32));
#+END_SRC

#+name: 52-block
#+BEGIN_SRC sclang
b.sine1([1.0/(1,3..12), 0].flop.flat.postln);
#+END_SRC

#+name: 53-block
#+BEGIN_SRC sclang
b.sine1([1.0/(1,3..32).squared, 0].flop.flat.postln);
#+END_SRC

#+name: 54-block
#+BEGIN_SRC sclang
b.sine1((1.dup(4) ++ 0.dup(8)).scramble.postln);
#+END_SRC

#+name: 55-block
#+BEGIN_SRC sclang
b.sine1((1.dup(4) ++ 0.dup(8)).scramble.postln);
#+END_SRC

#+name: 56-block
#+BEGIN_SRC sclang
b.sine1((1.dup(4) ++ 0.dup(8)).scramble.postln);
#+END_SRC

#+name: 57-block
#+BEGIN_SRC sclang
b.sine1((1.dup(4) ++ 0.dup(8)).scramble.postln);
#+END_SRC

#+name: 58-block
#+BEGIN_SRC sclang
b.sine1({1.0.rand2.cubed}.dup(8).round(1e-3).postln);
#+END_SRC

#+name: 59-block
#+BEGIN_SRC sclang
b.sine1({1.0.rand2.cubed}.dup(12).round(1e-3).postln);
#+END_SRC

#+name: 60-block
#+BEGIN_SRC sclang
b.sine1({1.0.rand2.cubed}.dup(16).round(1e-3).postln);
#+END_SRC

#+name: 61-block
#+BEGIN_SRC sclang
b.sine1({1.0.rand2.cubed}.dup(24).round(1e-3).postln);

#+END_SRC

#+name: 62-block
#+BEGIN_SRC sclang
b.sine1(1.0/(1..6), true, true, true);
#+END_SRC

#+name: 63-block
#+BEGIN_SRC sclang

{ COsc.ar(80, 100, 1, 0.1) }.play;


#+END_SRC

#+name: 64-block
#+BEGIN_SRC sclang
// change buffer as above.
(
// allocate tables 80 to 87
8.do {|i| s.sendMsg(\b_alloc, 80+i, 1024); };
)
#+END_SRC

#+name: 65-block
#+BEGIN_SRC sclang

(
// fill tables 80 to 87
8.do({|i|
	var n, a;
	// generate array of harmonic amplitudes
	n = (i+1)**2; // num harmonics for each table: [1,4,9,16,25,36,49,64]
	a = {|j| ((n-j)/n).squared }.dup(n);
	// fill table
	s.listSendMsg([\b_gen, 80+i, \sine1, 7] ++ a);
});
)
#+END_SRC

#+name: 66-block
#+BEGIN_SRC sclang
{ VOsc.ar(MouseX.kr(80,87), 120, 0, 0.3) }.play;
#+END_SRC

#+name: 67-block
#+BEGIN_SRC sclang
(
// allocate and fill tables 80 to 87
8.do({|i|
	// generate array of harmonic amplitudes
	a = {1.0.rand2.cubed }.dup((i+1)*4);
	// fill table
	s.listSendMsg([\b_gen, 80+i, \sine1, 7] ++ a);
});
)
#+END_SRC

#+name: 68-block
#+BEGIN_SRC sclang
// chorusing
{ VOsc3.ar(MouseX.kr(80,87), 120, 121.04, 119.37, 0.2) }.play;
#+END_SRC

#+name: 69-block
#+BEGIN_SRC sclang
// chords

{ VOsc3.ar(MouseX.kr(80,87), 120, 151.13, 179.42, 0.2) }.play;
#+END_SRC

#+name: 70-block
#+BEGIN_SRC sclang
{ LFClipNoise.ar(MouseX.kr(200, 10000, 1), 0.125) }.play(1);
#+END_SRC

#+name: 71-block
#+BEGIN_SRC sclang
{ LFNoise0.ar(MouseX.kr(200, 10000, 1), 0.25) }.play(1);

{ LFNoise1.ar(MouseX.kr(200, 10000, 1), 0.25) }.play(1);
#+END_SRC

#+name: 72-block
#+BEGIN_SRC sclang
{ LFNoise2.ar(MouseX.kr(200, 10000, 1), 0.25) }.play(1);
#+END_SRC

#+name: 73-block
#+BEGIN_SRC sclang
// used as controls
{ LFPar.ar(LFClipNoise.kr(MouseX.kr(0.5, 64, 1), 200, 400), 0, 0.2) }.play;
#+END_SRC

#+name: 74-block
#+BEGIN_SRC sclang
{ LFPar.ar(LFNoise0.kr(MouseX.kr(0.5, 64, 1), 200, 400), 0, 0.2) }.play;
#+END_SRC

#+name: 75-block
#+BEGIN_SRC sclang
{ LFPar.ar(LFNoise1.kr(MouseX.kr(0.5, 64, 1), 200, 400), 0, 0.2) }.play;
#+END_SRC

#+name: 76-block
#+BEGIN_SRC sclang
{ LFPar.ar(LFNoise2.kr(MouseX.kr(0.5, 64, 1), 200, 400), 0, 0.2) }.play;

#+END_SRC

#+name: 77-block
#+BEGIN_SRC sclang
{ ClipNoise.ar(0.2) }.play(1);
#+END_SRC

#+name: 78-block
#+BEGIN_SRC sclang
  // { WhiteNoise.ar(0.2) }.play(1);
  { WhiteNoise.ar(0.01) }.play(1);
#+END_SRC

#+name: 79-block
#+BEGIN_SRC sclang
  { PinkNoise.ar(0.1) }.play(1);
  // { PinkNoise.ar(0.4) }.play(1);
#+END_SRC

#+name: 80-block
#+BEGIN_SRC sclang
{ BrownNoise.ar(0.2) }.play(1);
#+END_SRC

#+name: 81-block
#+BEGIN_SRC sclang
{ GrayNoise.ar(0.2) }.play(1);

#+END_SRC

#+name: 82-block
#+BEGIN_SRC sclang
{ Dust.ar(MouseX.kr(1,10000,1), 0.4) }.play;
#+END_SRC

#+name: 83-block
#+BEGIN_SRC sclang
{ Dust2.ar(MouseX.kr(1,10000,1), 0.4) }.play;

#+END_SRC

#+name: 84-block
#+BEGIN_SRC sclang
{ Crackle.ar(MouseX.kr(1,2), 0.5) }.play(1);
#+END_SRC

#+name: 85-block
#+BEGIN_SRC sclang
{ LPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2) }.play(1);
#+END_SRC

#+name: 86-block
#+BEGIN_SRC sclang
{ HPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2) }.play(1);
#+END_SRC

#+name: 87-block
#+BEGIN_SRC sclang
{ LPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2) }.play(1);
#+END_SRC

#+name: 88-block
#+BEGIN_SRC sclang
{ HPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2) }.play(1);
#+END_SRC

#+name: 89-block
#+BEGIN_SRC sclang
{ BPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.4, 0.4) }.play(1);
#+END_SRC

#+name: 90-block
#+BEGIN_SRC sclang
{ BRF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.4, 0.2) }.play(1);
#+END_SRC

#+name: 91-block
#+BEGIN_SRC sclang
{ BPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.4, 0.4) }.play(1);
#+END_SRC

#+name: 92-block
#+BEGIN_SRC sclang
{ BRF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.4, 0.2) }.play(1);
#+END_SRC

#+name: 93-block
#+BEGIN_SRC sclang
// modulating the bandwidth
{ BPF.ar(WhiteNoise.ar, 3000, MouseX.kr(0.01,0.7,1), 0.4) }.play(1);
#+END_SRC

#+name: 94-block
#+BEGIN_SRC sclang
{ RLPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.play(1);
#+END_SRC

#+name: 95-block
#+BEGIN_SRC sclang
{ RHPF.ar(WhiteNoise.ar, MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.play(1);
#+END_SRC

#+name: 96-block
#+BEGIN_SRC sclang
{ RLPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.play(1);
#+END_SRC

#+name: 97-block
#+BEGIN_SRC sclang
{ RHPF.ar(Saw.ar(100), MouseX.kr(1e2,2e4,1), 0.2, 0.2) }.play(1);
#+END_SRC

#+name: 98-block
#+BEGIN_SRC sclang
// modulate frequency
{ Resonz.ar(WhiteNoise.ar(0.5), XLine.kr(1000,8000,10), 0.05) }.play(1);
#+END_SRC

#+name: 99-block
#+BEGIN_SRC sclang

// modulate bandwidth
{ Resonz.ar(WhiteNoise.ar(0.5), 2000, XLine.kr(1, 0.001, 8)) }.play(1);

#+END_SRC

#+name: 100-block
#+BEGIN_SRC sclang
// modulate bandwidth opposite direction
{ Resonz.ar(WhiteNoise.ar(0.5), 2000, XLine.kr(0.001, 1, 8)) }.play(1);
#+END_SRC

#+name: 101-block
#+BEGIN_SRC sclang
{ Ringz.ar(Dust.ar(3, 0.3), 2000, 2) }.play;
#+END_SRC

#+name: 102-block
#+BEGIN_SRC sclang
{ Ringz.ar(WhiteNoise.ar(0.005), 2000, 0.5) }.play(1);
#+END_SRC

#+name: 103-block
#+BEGIN_SRC sclang
// modulate frequency
{ Ringz.ar(WhiteNoise.ar(0.005), XLine.kr(100,3000,10), 0.5) }.play;
#+END_SRC

#+name: 104-block
#+BEGIN_SRC sclang
{ Ringz.ar(Impulse.ar(6, 0, 0.3),  XLine.kr(100,3000,10), 0.5) }.play;

#+END_SRC

#+name: 105-block
#+BEGIN_SRC sclang
// modulate ring time
{ Ringz.ar(Impulse.ar(6, 0, 0.3), 2000, XLine.kr(0.04, 4, 8)) }.play;
#+END_SRC

#+name: 106-block
#+BEGIN_SRC sclang
{ OnePole.ar(WhiteNoise.ar(0.5), MouseX.kr(-0.99, 0.99)) }.play(1);
#+END_SRC

#+name: 107-block
#+BEGIN_SRC sclang
{ OneZero.ar(WhiteNoise.ar(0.5), MouseX.kr(-0.49, 0.49)) }.play(1);
#+END_SRC

#+name: 108-block
#+BEGIN_SRC sclang
// a signal with impulse noise.
{ Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.play(1);
#+END_SRC

#+name: 109-block
#+BEGIN_SRC sclang
// after applying median filter
{ Median.ar(3, Saw.ar(500, 0.1) + Dust2.ar(100, 0.9)) }.play(1);
#+END_SRC

#+name: 110-block
#+BEGIN_SRC sclang

// a signal with impulse noise.
{ Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.play(1);
#+END_SRC

#+name: 111-block
#+BEGIN_SRC sclang
// after applying slew rate limiter
{ Slew.ar(Saw.ar(500, 0.1) + Dust2.ar(100, 0.9),1000,1000) }.play(1);
#+END_SRC

#+name: 112-block
#+BEGIN_SRC sclang
{ Formlet.ar(Impulse.ar(MouseX.kr(2,300,1), 0, 0.4), 800, 0.01, 0.1) }.play;
#+END_SRC

#+name: 113-block
#+BEGIN_SRC sclang
{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play;
#+END_SRC

#+name: 114-block
#+BEGIN_SRC sclang
{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Dust.ar(8, 0.1)) }.play;
#+END_SRC

#+name: 115-block
#+BEGIN_SRC sclang

{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar(0.007)) }.play;
#+END_SRC

#+name: 116-block
#+BEGIN_SRC sclang

{ Klank.ar(`[ {exprand(200, 4000)}.dup(12), nil, nil ], PinkNoise.ar(0.007)) }.play(1);
#+END_SRC

#+name: 117-block
#+BEGIN_SRC sclang

{ Klank.ar(`[ (1..13)*200, 1/(1..13), nil ], PinkNoise.ar(0.01)) }.play(1);
#+END_SRC

#+name: 118-block
#+BEGIN_SRC sclang

{ Klank.ar(`[ (1,3..13)*200, 1/(1,3..13), nil ], PinkNoise.ar(0.01)) }.play(1);
#+END_SRC

#+name: 119-block
#+BEGIN_SRC sclang
{ SinOsc.ar(300, 0, 0.2) }.play(1);
#+END_SRC

#+name: 120-block
#+BEGIN_SRC sclang
{ SinOsc.ar(300, 0, 0.2).abs }.play(1);
#+END_SRC

#+name: 121-block
#+BEGIN_SRC sclang
{ SinOsc.ar(300, 0, 0.2).max(0) }.play(1);
#+END_SRC

#+name: 122-block
#+BEGIN_SRC sclang
{ SinOsc.ar(300, 0).squared * 0.2 }.play(1);
#+END_SRC

#+name: 123-block
#+BEGIN_SRC sclang
{ SinOsc.ar(300, 0).cubed * 0.2 }.play(1);
#+END_SRC

#+name: 124-block
#+BEGIN_SRC sclang
{ SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).distort * 0.2 }.play(1);
#+END_SRC

#+name: 125-block
#+BEGIN_SRC sclang
{ SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).softclip * 0.2 }.play(1);
#+END_SRC

#+name: 126-block
#+BEGIN_SRC sclang
{ SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).clip2(1) * 0.2 }.play(1);
#+END_SRC

#+name: 127-block
#+BEGIN_SRC sclang
{ SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).fold2(1) * 0.2 }.play(1);
#+END_SRC

#+name: 128-block
#+BEGIN_SRC sclang
{ SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).wrap2(1) * 0.2 }.play(1);
#+END_SRC

#+name: 129-block
#+BEGIN_SRC sclang
{ SinOsc.ar(300, 0, MouseX.kr(0.1,80,1)).wrap2(1) * 0.2 }.play(1);
#+END_SRC

#+name: 130-block
#+BEGIN_SRC sclang
{ SinOsc.ar(200, 0, 0.2).scaleneg(MouseX.kr(-1,1)) }.play(1);
#+END_SRC

#+name: 131-block
#+BEGIN_SRC sclang
(
{
	var in;
	in = SinOsc.ar(300, 0, MouseX.kr(0.1,8pi,1));
	SinOsc.ar(0, in, 0.2); // 0 Hz sine oscillator
}.play(1);
)
#+END_SRC

#+name: 132-block
#+BEGIN_SRC sclang
s.sendMsg(\b_alloc, 80, 1024); // allocate table
// fill with chebyshevs
s.listSendMsg([\b_gen, 80, \cheby, 7] ++ {1.0.rand2.squared}.dup(6));

#+END_SRC

#+name: 133-block
#+BEGIN_SRC sclang
{ Shaper.ar(80, SinOsc.ar(600, 0, MouseX.kr(0,1))) * 0.3; }.play(1);
#+END_SRC

#+name: 134-block
#+BEGIN_SRC sclang

s.listSendMsg([\b_gen, 80, \cheby, 7] ++ {1.0.rand2.squared}.dup(6));
#+END_SRC

#+name: 135-block
#+BEGIN_SRC sclang
s.listSendMsg([\b_gen, 80, \cheby, 7] ++ {1.0.rand2.squared}.dup(6));
#+END_SRC

#+name: 136-block
#+BEGIN_SRC sclang
(
s = Server.internal;
Server.default = s;
s.quit;
s.options.numOutputBusChannels = 8;
s.options.numInputBusChannels = 8;
s.boot;
)
#+END_SRC

#+name: 137-block
#+BEGIN_SRC sclang
{ Pan2.ar(BrownNoise.ar, MouseX.kr(-1,1), 0.3) }.play(2);
#+END_SRC

#+name: 138-block
#+BEGIN_SRC sclang
{ Pan2.ar(BrownNoise.ar, SinOsc.kr(0.2), 0.3) }.play(2);
#+END_SRC

#+name: 139-block
#+BEGIN_SRC sclang
{ LinPan2.ar(BrownNoise.ar, MouseX.kr(-1,1), 0.3) }.play(2);
#+END_SRC

#+name: 140-block
#+BEGIN_SRC sclang
{ LinPan2.ar(BrownNoise.ar, SinOsc.kr(0.2), 0.3) }.play(2);
#+END_SRC

#+name: 141-block
#+BEGIN_SRC sclang
{ Balance2.ar(BrownNoise.ar, BrownNoise.ar, MouseX.kr(-1,1), 0.3) }.play(2);
#+END_SRC

#+name: 142-block
#+BEGIN_SRC sclang
{ Pan4.ar(BrownNoise.ar, MouseX.kr(-1,1), MouseY.kr(1,-1), 0.3) }.play(4);
#+END_SRC

#+name: 143-block
#+BEGIN_SRC sclang
{ PanAz.ar(5, BrownNoise.ar, MouseX.kr(-1,1), 0.3, 2) }.play(5);
#+END_SRC

#+name: 144-block
#+BEGIN_SRC sclang
// change width to 3
{ PanAz.ar(5, BrownNoise.ar, MouseX.kr(-1,1), 0.3, 3) }.play(5);
#+END_SRC

#+name: 145-block
#+BEGIN_SRC sclang
{ XFade2.ar(BrownNoise.ar, SinOsc.ar(500), MouseX.kr(-1,1), 0.3) }.play(1);
#+END_SRC

#+name: 146-block
#+BEGIN_SRC sclang
(
{
	var w, x, y, p, lf, rf, rr, lr;

	p = BrownNoise.ar; // source

	// B-format encode
	#w, x, y = PanB2.ar(p, MouseX.kr(-1,1), 0.3);

	// B-format decode to quad. outputs in clockwise order
	#lf, rf, rr, lr = DecodeB2.ar(4, w, x, y);

	[lf, rf, lr, rr] // reorder to my speaker arrangement: Lf Rf Lr Rr
}.play(4);
)
#+END_SRC

#+name: 147-block
#+BEGIN_SRC sclang
(
{
	// rotation of stereo sound via mouse
	var x, y;
	x = Mix.fill(4, { LFSaw.ar(200 + 2.0.rand2, 0, 0.1) }); // left in
	y = WhiteNoise.ar * LFPulse.kr(3,0,0.7,0.2); // right in
	#x, y = Rotate2.ar(x, y, MouseX.kr(0,2));
	[x,y]
}.play(2);
)
#+END_SRC

#+name: 148-block
#+BEGIN_SRC sclang
(
{
	// play with the room size
	var x;
	x = Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Dust.ar(2, 0.1));
	x = Pan2.ar(x, -0.2);
	x = [x[0], DelayC.ar(x[1], 0.01, 0.01)]; // de-correlate
	FreeVerb.ar(x, 0.75, 0.9, 0.4);
}.play;
)
#+END_SRC

#+name: 149-block
#+BEGIN_SRC sclang
(
{
	// play with the room size
	var x;
	x = Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], Dust.ar(2, 0.1));
	GVerb.ar(x, 105, 5, 0.7, 0.8, 60, 0.1, 0.5, 0.4) + x;
}.play;
)
#+END_SRC

#+name: 150-block
#+BEGIN_SRC sclang
(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
DelayN.ar(z, 0.1, 0.1, 1, z); // input is mixed with delay via the add input
}.play
)
#+END_SRC

#+name: 151-block
#+BEGIN_SRC sclang
(
{
z = Decay.ar(Impulse.ar(2,0,0.4), 0.3, WhiteNoise.ar);
DelayL.ar(z, 0.3, MouseX.kr(0,0.3), 1, z); // input is mixed with delay via the add input
}.play
)
#+END_SRC

#+name: 152-block
#+BEGIN_SRC sclang
// used as an echo.
{ CombN.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;
#+END_SRC

#+name: 153-block
#+BEGIN_SRC sclang

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ CombN.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play(1);
#+END_SRC

#+name: 154-block
#+BEGIN_SRC sclang

{ CombL.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play(1);
#+END_SRC

#+name: 155-block
#+BEGIN_SRC sclang

{ CombC.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play(1);
#+END_SRC

#+name: 156-block
#+BEGIN_SRC sclang

// with negative feedback:
{ CombN.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play(1);
#+END_SRC

#+name: 157-block
#+BEGIN_SRC sclang

{ CombL.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play(1);
#+END_SRC

#+name: 158-block
#+BEGIN_SRC sclang

{ CombC.ar(WhiteNoise.ar(0.02), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play(1);
#+END_SRC

#+name: 159-block
#+BEGIN_SRC sclang

{ CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/100, 1/100, 3) }.play;
#+END_SRC

#+name: 160-block
#+BEGIN_SRC sclang
{ CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/200, 1/200, 3) }.play;
#+END_SRC

#+name: 161-block
#+BEGIN_SRC sclang
{ CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/300, 1/300, 3) }.play;
#+END_SRC

#+name: 162-block
#+BEGIN_SRC sclang
{ CombC.ar(Decay.ar(Dust.ar(1,0.1), 0.2, WhiteNoise.ar), 1/400, 1/400, 3) }.play;
#+END_SRC

#+name: 163-block
#+BEGIN_SRC sclang
(
{
	var z;
	z = Decay.ar(Dust.ar(1,0.5), 0.1, WhiteNoise.ar);
	8.do { z = AllpassL.ar(z, 0.04, 0.04.rand, 2) };
	z
}.play(1);
)
#+END_SRC

#+name: 164-block
#+BEGIN_SRC sclang
// read sound
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

{ SinOsc.ar(800 + (700 * PlayBuf.ar(1,b, BufRateScale.kr(b),  loop:1)),0,0.3) }.play(1);

#+END_SRC

#+name: 165-block
#+BEGIN_SRC sclang
// loop is true

{ PlayBuf.ar(1,b, BufRateScale.kr(b), loop:1) }.play(1);
#+END_SRC

#+name: 166-block
#+BEGIN_SRC sclang
// trigger one shot on each pulse
(
{
	var trig;
	trig = Impulse.kr(2.0);
	PlayBuf.ar(1,b,BufRateScale.kr(b),trig,0,0);
}.play(1);
)

#+END_SRC

#+name: 167-block
#+BEGIN_SRC sclang
// trigger one shot on each pulse
(
{
	var trig;
	trig = Impulse.kr(XLine.kr(0.1,100,30));
	PlayBuf.ar(1,b,BufRateScale.kr(b),trig,5000,0);
}.play(1);
)
#+END_SRC

#+name: 168-block
#+BEGIN_SRC sclang
// mouse control of trigger rate and startpos
(
{
	var trig;
	trig = Impulse.kr(MouseY.kr(0.5,200,1));
	PlayBuf.ar(1,b,BufRateScale.kr(b),trig,MouseX.kr(0,BufFrames.kr(b)),1)
}.play(1);
)

#+END_SRC

#+name: 169-block
#+BEGIN_SRC sclang

// accelerating pitch
(
{
	var rate;
	rate = XLine.kr(0.1,100,60);
	PlayBuf.ar(1, b, rate, 1.0,0.0, 1.0)
}.play(1);
)

#+END_SRC

#+name: 170-block
#+BEGIN_SRC sclang

// sine wave control of playback rate. negative rate plays backwards
(
{
	var rate;
	rate = FSinOsc.kr(XLine.kr(0.2,8,30), 0, 3, 0.6);
	PlayBuf.ar(1,b,BufRateScale.kr(b)*rate,1,0,1)
}.play(1);
)


#+END_SRC

#+name: 171-block
#+BEGIN_SRC sclang
// zig zag around sound
(
{
	var rate;
	rate = LFNoise2.kr(XLine.kr(1,20,60), 2);
	PlayBuf.ar(1,b,BufRateScale.kr(b) * rate,1,0,1)
}.play(1);
)

#+END_SRC

#+name: 172-block
#+BEGIN_SRC sclang


// free sound
b.free;
#+END_SRC

#+name: 173-block
#+BEGIN_SRC sclang
// read sound
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
{
	var trate, dur;
	trate = MouseY.kr(2,200,1);
	dur = 4 / trate;
	TGrains.ar(2, Impulse.ar(trate), b, 1, MouseX.kr(0,BufDur.kr(b)), dur, 0, 0.1, 2);
}.play;
)

#+END_SRC

#+name: 174-block
#+BEGIN_SRC sclang

(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(8,120,1);
	dur = 12 / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.play;
)

#+END_SRC

#+name: 175-block
#+BEGIN_SRC sclang

// 4 channels
(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(8,120,1);
	dur = 12 / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(4, clk, b, 1, pos, dur, pan, 0.1);
}.play;
)

#+END_SRC

#+name: 176-block
#+BEGIN_SRC sclang

(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(8,120,1);
	dur = 4 / trate;
	clk = Dust.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.play;
)

#+END_SRC

#+name: 177-block
#+BEGIN_SRC sclang



(
{
	var trate, dur, clk, pos, pan;
	trate = LinExp.kr(LFTri.kr(MouseY.kr(0.1,2,1)),-1,1,8,120);
	dur = 12 / trate;
	clk = Impulse.ar(trate);
	pos = MouseX.kr(0,BufDur.kr(b));
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.play;
)

#+END_SRC

#+name: 178-block
#+BEGIN_SRC sclang


(
{
	var trate, dur, clk, pos, pan;
	trate = 12;
	dur = MouseY.kr(0.2,24,1) / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.play;
)


#+END_SRC

#+name: 179-block
#+BEGIN_SRC sclang

(
{
	var trate, dur, clk, pos, pan;
	trate = 100;
	dur = 8 / trate;
	clk = Impulse.kr(trate);
	pos = Integrator.kr(BrownNoise.kr(0.001));
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.play;
)

#+END_SRC

#+name: 180-block
#+BEGIN_SRC sclang

(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(1,400,1);
	dur = 8 / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b));
	pan = WhiteNoise.kr(0.8);
	TGrains.ar(2, clk, b, 2 ** WhiteNoise.kr(2), pos, dur, pan, 0.1);
}.play;
)

#+END_SRC

#+name: 181-block
#+BEGIN_SRC sclang

(
{
	var trate, dur;
	trate = MouseY.kr(2,120,1);
	dur = 1.2 / trate;
	TGrains.ar(2, Impulse.ar(trate), b, (1.2 ** WhiteNoise.kr(3).round(1)), MouseX.kr(0,BufDur.kr(b)), dur, WhiteNoise.kr(0.6), 0.1);
}.play;
)


#+END_SRC

#+name: 182-block
#+BEGIN_SRC sclang

// free sound
b.free;
#+END_SRC

#+name: 183-block
#+BEGIN_SRC sclang
( // using default window
{
	var trigrate, winsize, trig;
	trigrate = MouseX.kr(2, 120);
	winsize = trigrate.reciprocal;
	trig = Impulse.ar(trigrate);
	GrainSin.ar(2, trig, winsize, TRand.ar(440.0, 880.0, trig), LFNoise1.kr(0.2),
		-1, 0.2)
}.play;
)


#+END_SRC

#+name: 184-block
#+BEGIN_SRC sclang

b = Buffer.sendCollection(s, Env([0, 1, 0], [0.5, 0.5], [8, -8]).discretize, 1);

( // using user supplied window
{
	var trigrate, winsize, trig;
	trigrate = MouseX.kr(2, 120);
	winsize = trigrate.reciprocal;
	trig = Impulse.ar(trigrate);
	GrainSin.ar(2, trig, winsize, TRand.ar(440.0, 880.0, trig), LFNoise1.kr(0.2),
		b, 0.2)
}.play;
)
#+END_SRC

#+name: 185-block
#+BEGIN_SRC sclang
{ WhiteNoise.ar * Decay.ar(Impulse.ar(1), 0.9, 0.2) }.play;
#+END_SRC

#+name: 186-block
#+BEGIN_SRC sclang
{ WhiteNoise.ar * Decay.ar(Dust.ar(3), 0.9, 0.2) }.play;
#+END_SRC

#+name: 187-block
#+BEGIN_SRC sclang
{ SinOsc.ar(Decay.ar(Dust.ar(4), 0.5, 1000, 400), 0, 0.2) }.play;
#+END_SRC

#+name: 188-block
#+BEGIN_SRC sclang
{ WhiteNoise.ar * Decay2.ar(Impulse.ar(1), 0.2, 0.9, 0.2) }.play;
#+END_SRC

#+name: 189-block
#+BEGIN_SRC sclang
{ WhiteNoise.ar * Decay2.ar(Dust.ar(3), 0.2, 0.9, 0.2) }.play;
#+END_SRC

#+name: 190-block
#+BEGIN_SRC sclang
{ SinOsc.ar(Lag.ar(LFPulse.ar(2,0,0.5,800,400), MouseX.kr(0,0.5)), 0, 0.2) }.play;
#+END_SRC

#+name: 191-block
#+BEGIN_SRC sclang
{ SinOsc.ar(Integrator.ar(Dust2.ar(8), 0.99999, 200, 800), 0, 0.2) }.play(1)
#+END_SRC

#+name: 192-block
#+BEGIN_SRC sclang
// amplitude determined by amplitude of trigger

{ Trig.ar(Dust.ar(2), 0.2) * FSinOsc.ar(800, 0, 0.4) }.play;
#+END_SRC

#+name: 193-block
#+BEGIN_SRC sclang
// amplitude always the same.
{ Trig1.ar(Dust.ar(2), 0.2) * FSinOsc.ar(800, 0, 0.4) }.play
#+END_SRC

#+name: 194-block
#+BEGIN_SRC sclang
#+END_SRC

#+name: 195-block
#+BEGIN_SRC sclang
(
{
	var trig;
	trig = Dust.ar(2);
	[(Trig1.ar(trig, 0.05) * FSinOsc.ar(600, 0, 0.2)),
	(Trig1.ar(TDelay.ar(trig, 0.1), 0.05) * FSinOsc.ar(800, 0, 0.2))]
}.play;
)
#+END_SRC

#+name: 196-block
#+BEGIN_SRC sclang
{ Blip.ar(Latch.ar(WhiteNoise.ar, Impulse.ar(9)) * 400 + 500, 4, 0.2) }.play;
#+END_SRC

#+name: 197-block
#+BEGIN_SRC sclang
{ Blip.ar(Latch.ar(SinOsc.ar(0.3), Impulse.ar(9)) * 400 + 500, 4, 0.2) }.play;
#+END_SRC

#+name: 198-block
#+BEGIN_SRC sclang
{ Blip.ar(Gate.ar(LFNoise2.ar(40), LFPulse.ar(1)) * 400 + 500, 4, 0.2) }.play;
#+END_SRC

#+name: 199-block
#+BEGIN_SRC sclang
(
{
SinOsc.ar(
			PulseCount.ar(Impulse.ar(10), Impulse.ar(0.4)) * 200,
			0, 0.05
		)
}.play;
)
#+END_SRC

#+name: 200-block
#+BEGIN_SRC sclang
(
{
	var p, a, b;
	p = Impulse.ar(8);
	a = SinOsc.ar(1200, 0, Decay2.ar(p, 0.005, 0.1));
	b = SinOsc.ar(600,  0, Decay2.ar(PulseDivider.ar(p, MouseX.kr(1,8).round(1)), 0.005, 0.5));

	[a, b] * 0.4
}.play;
)
#+END_SRC

#+name: 201-block
#+BEGIN_SRC sclang
{ EnvGen.kr(Env.perc, doneAction:2) * SinOsc.ar(880,0,0.2) }.play;
{ EnvGen.kr(Env.perc(1,0.005,1,4), doneAction:2) * SinOsc.ar(880,0,0.2) }.play;
#+END_SRC

#+name: 202-block
#+BEGIN_SRC sclang

{ EnvGen.kr(Env.perc, Impulse.kr(2)) * SinOsc.ar(880,0,0.2) }.play;
#+END_SRC

#+name: 203-block
#+BEGIN_SRC sclang
{ EnvGen.kr(Env.perc, Dust.kr(3)) * SinOsc.ar(880,0,0.2) }.play;

#+END_SRC

#+name: 204-block
#+BEGIN_SRC sclang
// for sustain envelopes a gate is required
z = { arg gate=1; EnvGen.kr(Env.adsr, gate, doneAction:2) * SinOsc.ar(880,0,0.2) }.play;

#+END_SRC

#+name: 205-block
#+BEGIN_SRC sclang
z.release;

#+END_SRC

#+name: 206-block
#+BEGIN_SRC sclang
(
// randomly generated envelope
z = { arg gate=1;
	var env, n=32;
	env = Env(
				[0]++{1.0.rand.squared}.dup(n-1) ++ [0],
				{rrand(0.005,0.2)}.dup(n),
				\lin, n-8, 8 );
	EnvGen.kr(env, gate, doneAction: 2) * LFTri.ar(220,0,0.4)
}.play;
)

#+END_SRC

#+name: 207-block
#+BEGIN_SRC sclang
z.release;
#+END_SRC

#+name: 208-block
#+BEGIN_SRC sclang
// alloc a buffer for the FFT
b = Buffer.alloc(s,2048,1);

#+END_SRC

#+name: 209-block
#+BEGIN_SRC sclang
// read a sound
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");


#+END_SRC

#+name: 210-block
#+BEGIN_SRC sclang
(
// do nothing
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	0.5 * IFFT(chain);
}.play(1);
)

#+END_SRC

#+name: 211-block
#+BEGIN_SRC sclang

(
// pass only magnitudes above a threshold
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	chain = PV_MagAbove(chain, MouseX.kr(0.1,512,1));
	0.5 * IFFT(chain);
}.play(1);
)

#+END_SRC

#+name: 212-block
#+BEGIN_SRC sclang

(
// pass only magnitudes below a threshold
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	chain = PV_MagBelow(chain, MouseX.kr(0.1,512,1));
	0.5 * IFFT(chain);
}.play(1);
)

#+END_SRC

#+name: 213-block
#+BEGIN_SRC sclang

(
// brick wall filter.
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	chain = PV_BrickWall(chain, MouseX.kr(-1,1));
	0.5 * IFFT(chain);
}.play(1);
)

#+END_SRC

#+name: 214-block
#+BEGIN_SRC sclang

(
// pass random frequencies. Mouse controls how many to pass.
// trigger changes the frequencies periodically
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	chain = PV_RandComb(chain, MouseX.kr(0,1), Impulse.kr(0.4));
	0.5 * IFFT(chain);
}.play(1);
)

#+END_SRC

#+name: 215-block
#+BEGIN_SRC sclang

(
// rectangular comb filter
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	chain = PV_RectComb(chain, 8, MouseY.kr(0,1), MouseX.kr(0,1));
	0.5 * IFFT(chain);
}.play(1);
)

#+END_SRC

#+name: 216-block
#+BEGIN_SRC sclang

(
// freeze magnitudes
{
	var in, chain;
	in = PlayBuf.ar(1,c, BufRateScale.kr(c), loop:1);
	chain = FFT(b, in);
	chain = PV_MagFreeze(chain, LFPulse.kr(1, 0.75));
	0.5 * IFFT(chain);
}.play(1);
)
#+END_SRC

#+name: 217-block
#+BEGIN_SRC sclang
{ var x; x = BrownNoise.ar(0.2); [x,x] }.play(2); // correlated
{ {BrownNoise.ar(0.2)}.dup }.play(2); // not correlated
#+END_SRC

#+name: 218-block
#+BEGIN_SRC sclang


// correlated
{ var x; x = LPF.ar(BrownNoise.ar(0.2), MouseX.kr(100,10000)); [x,x] }.play(2);
#+END_SRC

#+name: 219-block
#+BEGIN_SRC sclang
// not correlated

{ LPF.ar({BrownNoise.ar(0.2)}.dup, MouseX.kr(100,10000)) }.play(2);
#+END_SRC

#+name: 220-block
#+BEGIN_SRC sclang


#+END_SRC

#+name: 221-block
#+BEGIN_SRC sclang
// correlated
(
{ var x;
	x = Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar(7e-3));
	[x,x]
}.play(2))


#+END_SRC

#+name: 222-block
#+BEGIN_SRC sclang
// not correlated
{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar([7e-3,7e-3])) }.play(2);
#+END_SRC

#+name: 223-block
#+BEGIN_SRC sclang

// two waves mixed together coming out both speakers
{ var x; x = Mix.ar(VarSaw.ar([100,101], 0, 0.1, 0.2)); [x,x] }.play(2);
#+END_SRC

#+name: 224-block
#+BEGIN_SRC sclang
// two waves coming out each speaker independantly
{ VarSaw.ar([100,101], 0, 0.1, 0.2 * 1.414) }.play(2); // * 1.414 to compensate for power
#+END_SRC

#+name: 225-block
#+BEGIN_SRC sclang

// delays as cues to direction
// mono
{ var x; x = LFTri.ar(1000,0,Decay2.ar(Impulse.ar(4,0,0.2),0.004,0.2)); [x,x]}.play(2);
#+END_SRC

#+name: 226-block
#+BEGIN_SRC sclang

(

// inter-speaker delays
{ var x; x = LFTri.ar(1000,0,Decay2.ar(Impulse.ar(4,0,0.2),0.004,0.2));
	[DelayC.ar(x,0.01,0.01),DelayC.ar(x,0.02,MouseX.kr(0.02, 0))]
}.play(2);
)


#+END_SRC

#+name: 227-block
#+BEGIN_SRC sclang


(
// mixing two delays together
// you hear a phasing sound but the sound is still flat.
{ var x; x = BrownNoise.ar(0.2);
	x = Mix.ar([DelayC.ar(x,0.01,0.01),DelayC.ar(x,0.02,MouseX.kr(0,0.02))]);
	[x,x]
}.play(2);
)

#+END_SRC

#+name: 228-block
#+BEGIN_SRC sclang

(
// more spatial sounding. phasing causes you to perceive directionality
{ var x; x = BrownNoise.ar(0.2);
	[DelayC.ar(x,0.01,0.01),DelayC.ar(x,0.02,MouseX.kr(0.02, 0))]
}.play(2);
)
#+END_SRC

#+name: 229-block
#+BEGIN_SRC sclang
(
{
	// mixing sine oscillators in parallel
	var n = 16; // number of structures to make
	// mix together  parallel structures
	Mix.fill(n,
			// this function creates an oscillator at a random frequency
			{ FSinOsc.ar(200 + 1000.0.rand) }
	) / (2*n)			// scale amplitude
}.play(1);
)

#+END_SRC

#+name: 230-block
#+BEGIN_SRC sclang

(
{
	// mixing sine oscillators in parallel
	var n = 16; // number of structures to make
	// mix together  parallel structures
	Mix.fill(n,
			// this function creates an oscillator at a random frequency
			{ FSinOsc.ar(200 + 1000.0.rand + [0, 0.5]) }
	) / (2*n)			// scale amplitude
}.play(2);
)

#+END_SRC

#+name: 231-block
#+BEGIN_SRC sclang

(
{
	// mixing sine oscillators in parallel
	var n = 16; // number of structures to make
	// mix together  parallel structures
	Mix.fill(n,
			{
				var amp;
				amp = FSinOsc.kr(exprand(0.1,1),2pi.rand).max(0);
				Pan2.ar(
					FSinOsc.ar(exprand(100,1000.0), 0, amp),
					1.0.rand2)
			}
	) / (2*n)			// scale amplitude
}.play(2);
)

#+END_SRC












#+name: 232-block
#+BEGIN_SRC sclang


(
{
	var n;
	n = 8; // number of 'voices'
	Mix.ar( // mix all stereo pairs down.
		Pan2.ar( // pan the voice to a stereo position
			CombL.ar( // a comb filter used as a string resonator
				Dust.ar( // random impulses as an excitation function
					// an array to cause expansion of Dust to n channels
					// 1 means one impulse per second on average
					1.dup(n),
					0.3 // amplitude
				),
				0.01, // max delay time in seconds
				// array of different random lengths for each 'string'
				{0.004.rand+0.0003}.dup(n),
				4 // decay time in seconds
			),
			{1.0.rand2}.dup(n) // give each voice a different pan position
		)
	)
}.play;
)
#+END_SRC


