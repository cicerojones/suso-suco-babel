* help files for Supercollider CLASSES
  :PROPERTIES:
  :HEADER-ARGS: :results  silent
  :END:

** class:: A2K
summary:: Audio to control rate converter.
related:: Classes/K2A
categories::  UGens>Conversion


Description::

Audio to control rate converter. Only needed in specific cases.


classmethods::

method::kr

argument::in
The input signal.

** class:: APF
summary:: FIXME: APF purpose.
categories::  UGens>Filters>Linear, UGens>Undocumented


Description::

FIXME: APF description.


classmethods::

method::ar, kr

argument::in

FIXME: explain parameter in.


argument::freq

FIXME: explain parameter freq.


argument::radius

FIXME: explain parameter radius.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.

** CLASS:: AbstractDispatcher
summary:: Dispatches incoming messages to Functions
categories:: External Control>Abstract Classes
related:: Classes/AbstractWrappingDispatcher, Classes/OSCMessageDispatcher, Classes/OSCMessagePatternDispatcher, Classes/MIDIMessageDispatcher, Classes/OSCFunc, Classes/OSCdef, Classes/MIDIFunc, Classes/MIDIdef, Classes/AbstractResponderFunc

DESCRIPTION::
Instances of AbstractDispatcher dispatch incoming messages (e.g. MIDI, OSC), to registered instances of link::Classes/AbstractResponderFunc::. There will be a default dispatcher for each message type, but one can have multiple dispatchers per type in order to implement custom dispatching for groups of ResponderFuncs. (The main example of this is OSC pattern matching with link::Classes/OSCMessagePatternDispatcher::.) Normally users do not need to access dispatcher instances directly.

Dispatchers must be registered at the appropriate central point (e.g. Main:recvOSCfunc for OSC messages). In this capacity their interfaces mimic link::Classes/Function:: and link::Classes/FunctionList::.


CLASSMETHODS::
private:: initClass

METHOD:: all
Get a collection of all currently active dispatchers.

returns:: An link::Classes/IdentitySet::.

METHOD:: new
Make a new dispatcher.

returns:: A new instance.


INSTANCEMETHODS::
private:: init

METHOD:: add
Add a responder func to this dispatcher. Subclasses should override this to do any necessary bookkeeping. Generally this method should add this dispatcher as a dependant of the responder func, so that it can respond to any changes.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc:: to add.

METHOD:: remove
Remove a responder func from this dispatcher.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc:: to remove.

METHOD:: value
Evaluate an incoming message to see if it matches. Subclasses should override this message to take appropriate arguments. If a matching responder func is found, this method should call value on it, passing the message.

METHOD:: valueArray
As link::#-value:: above, but with the arguments passed as a single link::Classes/Array::. This method is needed so that subclasses can work in FunctionLists in central message registration points such as Main:recvOSCMessage.

argument:: args
An link::Classes/Array:: containing the message and appropriate arguments.

METHOD:: register
Register this dispatcher at the appropriate central point (e.g. Main:recvOSCfunc) to receive its message type. Subclasses should take care to not override any other registered objects. (So for example use Main:addOSCFunc for OSC messages rather than Main:recvOSCfunc_.) Generally speaking, dispatchers should register themselves automatically if needed when a responder func is added.

METHOD:: unregister
Remove this dispatcher from the appropriate central registration point, i.e. deactivate it. Generally speaking a dispatcher should unregister itself automatically when its last responder func is removed.

METHOD:: free
link::#-unregister:: this dispatcher and remove it from link::#*all::. After this the dispatcher should be discarded.

METHOD:: typeKey
Subclasses should override this method to return a key indicating the type of message this dispatcher responds to, e.g. code::'OSC matched':: or code::'MIDI control'::.

returns:: A link::Classes/Symbol::.

METHOD:: update
Subclasses should override this to do any necessary updating when a dispatchers responder funcs indicate they have changed via the standard dependancy mechanism. The default implementation does nothing.

** class::AbstractFunction
summary::An object which responds to a set of messages that represent mathematical functions
categories::Core>Kernel
related::Classes/UGen,Classes/Pattern,Classes/Function,Overviews/Operators

description::

An AbstractFunction is an object which responds to a set of messages that represent
mathematical functions. Subclasses override a smaller set of messages to respond
to the mathematical functions. The intent is to provide a mechanism for functions
that do not calculate values directly but instead compose structures for calculating.

Function, Pattern, Stream and UGen are subclasses of AbstractFunction.
For example, if you multiply two UGens together the receiver responds by answering a new
instance of class BinaryOpUGen which has the two operands as inputs.

For an overview of common operators, see link::Overviews/Operators::.
To see which classes implements a specific method, see that method in the generated link::Overviews/Methods:: overview.

instanceMethods::

subsection::Unary Messages

All of the following messages send the message composeUnaryOp to the receiver with the
unary message selector as an argument.
See link::Classes/UnaryOpFunction::.

method::neg
method::reciprocal
method::bitNot
method::abs
method::asFloat
method::asInt
method::ceil
method::floor
method::frac
method::sign
method::squared
method::cubed
method::sqrt
method::exp
method::midicps
method::cpsmidi
method::midiratio
method::ratiomidi
method::ampdb
method::dbamp
method::octcps
method::cpsoct
method::log
method::log2
method::log10
method::sin
method::cos
method::tan
method::asin
method::acos
method::atan
method::sinh
method::cosh
method::tanh
method::rand
method::rand2
method::linrand
method::bilinrand
method::sum3rand
method::distort
method::softclip
method::coin
method::even
method::odd
method::isPositive
method::isNegative
method::isStrictlyPositive
method::rho
method::theta

subsection::Binary Messages

All of the following messages send the message composeBinaryOp to the receiver with the
binary message selector and the second operand as arguments.
See: link::Classes/BinaryOpFunction::.

method::+
method::-
method::*
method::/
method::div
method::%
method::**
method::min
method::max
method::<
method::<=
method::>
method::>=
method::&
method::|
method::lcm
method::gcd
method::round
method::trunc
method::atan2
method::hypot
method::hypotApx
method::>>
method::+>>
method::ring1
method::ring2
method::ring3
method::ring4
method::difsqr
method::sumsqr
method::sqrdif
method::absdif
method::amclip
method::scaleneg
method::clip2
method::excess
method::<!
method::rrand
method::exprand
method::rotate
method::dist
method::bitAnd
method::bitOr
method::bitXor
method::bitHammingDistance
method::@

subsection:: Messages with more arguments

All of the following messages send the message code::composeNAryOp:: to the receiver with the
binary message selector and the other operands as arguments.
See link::Classes/NAryOpFunction::.

method::clip
method::wrap
method::fold
method::blend
method::linlin
method::linexp
method::explin
method::expexp

subsection:: other

method::applyTo

Interface that allows us to combine selectors (Symbols) and Functions. Sends valueArray(args) to this.
discussion::
code::
#+BEGIN_SRC sclang
// example:

f = [{ |a, b| a * b * 100.rand }, { |a, b| sin(a) * sin(b) }, '*', '/'];
f.choose.postcs.applyTo(3, 4);

// this is used in SequenceableCollection reduce:
(1..10).reduce('+');
(1..10).reduce({ |a, b| a * b * 1.0.rand });
#+END_SRC

::

method::asUGenInput

returns:: the result of sending the value(for) message to this.
discussion::
code::
#+BEGIN_SRC sclang
// example:
(
var f, g, product;
f = { SinOsc.ar(400) };
g = { LFPulse.kr(8)  };
product = f * g * 0.1;
{ Pan2.ar(product, SinOsc.kr(0.3)) }.play;
)
#+END_SRC

#+RESULTS:
: // example:
: (
: var f, g, product;
: f = { SinOsc.ar(400) };
: g = { LFPulse.kr(8)  };
: product = f * g * 0.1;
: { Pan2.ar(product, SinOsc.kr(0.3)) }.play;
: )

::

method::sampled
Sample a function.
discussion::
code::
#+BEGIN_SRC sclang
//sample a function
f = { |x| sin(3*x)*cos(8*x) }
f.plotGraph2(from:0,to:2);
f.sampled(10,0,2).plotGraph2(from:0,to:2);
f.sampled(80,0,2).plotGraph2(from:0,to:2);

//on complicated functions a sampled function is less cpy heavy.
f = { |x| 60.collect{ 2**((x-rrand(0.0,1.0))) }.sum/60 };
f.plotGraph2(from:0,to:1);
g = f.sampled(200);
g.plotGraph2(from:0,to:1);
{ 200.collect{ f.(rand(0.0,1.0)) } }.bench;
{ 200.collect{ g.(rand(0.0,1.0)) } }.bench;
#+END_SRC

::

subsection::Function Composition

When unary, binary or n-ary operators are applied to an abstract function, it returns an object that represents
this operation, without evaluating the function: link::Classes/UnaryOpFunction::, link::Classes/BinaryOpFunction::, link::Classes/NAryOpFunction::.
Note that different subclasses like link::Classes/Pattern:: or link::Classes/UGen:: have their own composition scheme analogous to the one of AbstractFunction itself. For more about functions, see link::Classes/Function::.

examples::

code::
#+BEGIN_SRC sclang
// examples

a = { 1.0.rand } + 8;
a.value;


y = { 8 } + { 1.0.rand };
y.value;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// arguments are passed into both functions

y = { |x=0| x } + { 1.0.rand };
y.value(10);


y = { |x=0| x * 3 } + { |x=0| x + 1.0.rand };
y.value(10);

y.postcs;

y = { |x=0| x * 3 } + { |x=0| x + 1.0.rand } * { |x=0| [50, 100].choose + x } + 1.0;
y.value(10);
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// environments can be used as a lookup with valueEnvir:

(
Environment.use {
	~y = 10;
	~x = 2;
	~z = { |x=8| x } + { |y=0| y + 1.0.rand };
	~z.valueEnvir;
}
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// n-ary operators:

a = blend({ 3.0.rand }, { 1000.rand }, { |frac| frac });
a.value(0.5);

a.value((0, 0.06..1)); // creates a range of values..
#+END_SRC

::

** class:: AbstractIn
summary:: Abstract class for in ugens
categories:: UGens>InOut

** CLASS:: AbstractMessageMatcher
summary:: Matches incoming messages to Functions
categories:: External Control>Abstract Classes
related:: Classes/AbstractResponderFunc, Classes/AbstractWrappingDispatcher

DESCRIPTION::
Instances of subclasses of AbstractMessageMatcher are used by subclasses of link::Classes/AbstractWrappingDispatcher:: to match multiple parameters of incoming messages (i.e. OSC or MIDI) to instances of subclasses of link::Classes/AbstractResponderFunc::. This class and its subclasses are private and generally users should not need to address them directly.


CLASSMETHODS::


INSTANCEMETHODS::

METHOD:: func
Get or set this object's response link::Classes/Function::.

returns:: A link::Classes/Function:: or similar object.

METHOD:: value
Evaluate an incoming message to see if it matches. Subclasses should override this message to take appropriate arguments. If a match is found, this method should call value on this object's func, passing the message as appropriate arguments.

METHOD:: valueArray
As link::#-value:: above, but with the arguments passed as a single link::Classes/Array::. This method is needed so that subclasses can work in FunctionLists.

argument:: args
An link::Classes/Array:: containing the message and appropriate arguments.
** class:: AbstractOut
summary:: Abstract class for out ugens
categories:: UGens>InOut

classmethods::
private:: categories

instancemethods::
method:: numOutputs
returns::
number of output buses (default: 0, overridden in subclasses)

** CLASS:: AbstractResponderFunc
summary:: Abstract superclass of responder func objects
categories:: External Control>Abstract Classes
related:: Classes/OSCFunc, Classes/OSCdef, Classes/MIDIFunc, Classes/MIDIdef, Classes/AbstractDispatcher

DESCRIPTION::
AbstractResponderFunc is the abstract superclass of responder funcs, which are classes which register one or more functions to respond to a particular type of input. It provides some common functionality such as introspection. Its two main subclasses are link::Classes/OSCFunc::, and link::Classes/MIDIFunc::. By default responder funcs do not persist beyond Cmd-. (see link::#-permanent:: below).

Instances will register with a dispatcher (an instance of a subclass of link::Classes/AbstractDispatcher::), which will actually dispatch incoming messages to an instance's Function(s).


CLASSMETHODS::

private:: initClass

METHOD:: allFuncProxies
Get all current instances of this classes concrete subclasses, sorted by type.

returns:: An link::Classes/IdentityDictionary::.

METHOD:: allEnabled
As allFuncProxies above, but only return those instances currently listening for input.

returns:: An link::Classes/IdentityDictionary::.

METHOD:: allDisabled
As allFuncProxies above, but only return those instances currently not listening for input.

returns:: An link::Classes/IdentityDictionary::.


INSTANCEMETHODS::
private:: cmdPeriod, prFunc

METHOD:: func
Get or set this objects response function.

returns:: The getter returns a link::Classes/Function:: or similar object.

METHOD:: srcID
Get this object's source.

returns:: The return type will depend on subclass. For link::Classes/OSCFunc:: this will be a link::Classes/NetAddr::, for link::Classes/MIDIFunc:: a UID. This can can be nil, which indicates that the object will respond to any source.

METHOD:: enabled
Check if this object is currently responding to incoming messages.

returns:: A link::Classes/Boolean::.

METHOD:: dispatcher
et this object's dispatcher. This is the object which matches incoming messages with responder funcs. Instances can use custom dispatchers to support arbitrary matching schemes.

returns:: An instance of an appropriate subclass of link::Classes/AbstractDispatcher::. (The return type will depend on subclass.)

METHOD:: permanent
Get or set whether this responder func is persists when the user executes Cmd-. If false this will be disabled and removed from the global lists. The default is false.

argument:: bool
A link::Classes/Boolean:: indicating if this object is permanent.

returns:: The getter returns a link::Classes/Boolean::.

METHOD:: enable
Enable this object to receive incoming messages. This is done automatically at creation time.

METHOD:: disable
Stop this object from receiving incoming messages.

METHOD:: add
Add a new function to the list of functions which will be executed when this object receives an incoming message.

argument:: newFunc
A link::Classes/Function:: or similar object to be added.

METHOD:: remove
Remove a function from the list of functions which will be executed when this object receives an incoming message.

argument:: removeFunc
The link::Classes/Function:: to be removed.

METHOD:: gui
Open a subclass specific GUI. (Not yet implemented)

returns:: The GUI object.

METHOD:: oneShot
Indicate that this object should execute only once and then free itself.

METHOD:: fix
A synonym for link::#permanent::

METHOD:: free
Disable this object and remove it from the global lists. This should be done when you are finished using this object.

METHOD:: clear
Remove all active functions from this object's function list.


EXAMPLES::

See link::Classes/OSCFunc:: and link::Classes/MIDIFunc::.
** class:: AbstractServerAction
summary:: register actions to be taken for a server
related:: Classes/Server, Classes/ServerBoot, Classes/ServerTree, Classes/ServerQuit
categories:: Control

description::

This is an strong::abstract superclass:: for singletons like link::Classes/ServerQuit::, which provides a place for registering functions and objects for events that should happen when something happens in the server.
No direct call to AbstractServerAction is required.

note:: not fully working on linux and windows.
Setting the computer to sleep on these systems causes the actions to be called.
As to date in linux, JACK does not survive a sleep, it nevertheless behaves correctly for the time being.
::

ClassMethods::

method::functionSelector
Subclasses return specific function selectors for objects that implement this as interface.
Selectors are:
list::
## doOnServerBoot - link::Classes/ServerBoot::
## doOnServerQuit - link::Classes/ServerQuit::
## doOnServerTree - link::Classes/ServerTree::
::

not for registry with a server, but analogous are:
list::
## doOnCmdPeriod - link::Classes/CmdPeriod::
## doOnStartUp - link::Classes/StartUp::
## doOnShutDown - link::Classes/ShutDown::
::

method::add
Add an action or object for registry.

argument::object
Can either be a link::Classes/Function:: to be evaluated (as first arg the server is passed in), or an link::Classes/Object:: that implements the message returned by link::#-functionSelector::. strong::One object is only registered once::, so that multiple additions don't cause multiple calls.

argument::server
Server for which to register. If the symbol strong::\default:: is passed in, the action is called for the current default server. If the symbol strong::\all:: is passed in, the action is called for all current servers. If server is nil, it is added to \default.

method::remove
Remove an item or object from registry. If server is nil, remove from strong::default:: key.

method::removeServer
Remove all items that are registered for a given server.

Examples::

code::
#+BEGIN_SRC sclang
// ServerBoot
s.boot;
f = { |server| "------------The server '%' has booted.------------\n".postf(server) };
ServerBoot.add(f, \default);
s.quit; // quit the server and observe the post
s.boot;
ServerBoot.remove(f, \default); // remove it again
s.quit;
s.boot;// no post.
ServerBoot.add(f, Server.internal);
Server.internal.quit;
Server.internal.boot;
ServerBoot.removeAll; // clear all
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// ServerQuit
s.boot;
f = { |server| "------------The server '%' has quit.------------\n".postf(server) };
ServerQuit.add(f, \default);
s.quit; // quit the server and observe the post
s.boot;
ServerQuit.remove(f, \default); // remove it again
s.quit; // no post.
ServerQuit.add(f, Server.internal);
Server.internal.boot;
Server.internal.quit;
ServerQuit.removeAll; // clear all
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// ServerTree
s.quit;
f = { |server| "-------The server '%' has initialised tree.-------\n".postf(server) };
g = { |server| 10.do { Group(server).postln } };
ServerBoot.add(f, \default);
ServerTree.add(g, \default);
s.boot; // boot and see how the actions are evaluated in order
// "cmd-period" (or equivalent) resends the groups.

ServerBoot.removeAll; // clear all
ServerTree.removeAll; // clear all
#+END_SRC

::
** class:: AbstractSystemAction
summary:: register actions to be taken for system events
related:: Classes/CmdPeriod, Classes/StartUp, Classes/ShutDown, Classes/ServerBoot, Classes/ServerTree, Classes/ServerQuit
categories:: Control


ClassMethods::

method::removeAll
Remove all items from registry.
** CLASS:: AbstractWrappingDispatcher
summary:: A dispatcher which wraps functions to support multiple paramter matching
categories:: External Control>Abstract Classes
related:: Classes/AbstractDispatcher, Classes/AbstractMessageMatcher, Classes/OSCMessageDispatcher, Classes/OSCMessagePatternDispatcher, Classes/MIDIMessageDispatcher, Classes/OSCFunc, Classes/OSCdef, Classes/MIDIFunc, Classes/MIDIdef, Classes/AbstractResponderFunc

DESCRIPTION::
AbstractWrappingDispatcher extends AbstractDispatcher to provide the facility to wrap response functions in specialised objects (instances of subclasses of link::Classes/AbstractMessageMatcher:: to efficiently support matching of multiple parameters. Its subclasses link::Classes/OSCMessageDispatcher:: and link::Classes/MIDIMessageDispatcher:: match using a flat dictionary lookup of the 'most significant' parameter, and only attempt to match other parameters if an initial match is found. This approach is faster than others (such as multi-level dictionaries) for most configurations.


CLASSMETHODS::


INSTANCEMETHODS::
private:: init

METHOD:: wrappedFuncs
Get a dictionary of all currently wrapped functions, stored using their owning responder funcs as keys.

returns:: An link::Classes/IdentityDictionary::.

METHOD:: add
Add a responder func to this dispatcher. Subclasses should extend this to do any necessary bookkeeping. Generally this method should add this dispatcher as a dependant of the responder func, so that it can respond to any changes.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc:: to add.

METHOD:: remove
Remove a responder func from this dispatcher.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc:: to remove.

METHOD:: updateFuncForFuncProxy
This method is called within link::#-update:: to update any changes to one of this dispatcher's responder funcs' function(s). Users should not call this method directly, but subclasses may need to extend this method to do additional bookkeeping.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc::.

METHOD:: wrapFunc
Subclasses should override this method to implement wrapping of functions by instances of appropriate subclasses of link::Classes/AbstractMessageMatcher::.

METHOD:: getKeysForFuncProxy
Subclasses should override this to return an Array containing all the keys at which the specified responder func's functions are stored in this dispatchers active dictionary.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc::.

returns:: An link::Classes/Array::.

METHOD:: update
Subclasses of link::Classes/AbstractResponderFunc:: should call update on their dispatcher whenever their function (or something else significant) changes.

argument:: funcProxy
An instance of a subclass of link::Classes/AbstractResponderFunc::.

argument:: what
A link::Classes/Symbol:: indicating what has changed. Currently the only thing supported is code::\function::.

METHOD:: free
This method removes this dispatcher from its responder func's dependants dictionaries, and deactivates it. Users should only call this method if you are finished with this dispatcher.

** class:: AllpassC                                             :ugen:delays:
summary:: All pass delay line with cubic interpolation.
related:: Classes/AllpassL, Classes/AllpassN, Classes/BufAllpassC
categories::  UGens>Delays


Description::

All pass delay line with cubic interpolation. See also
link::Classes/AllpassN::  which uses no interpolation, and
link::Classes/AllpassL::  which uses linear interpolation.
Cubic interpolation is more computationally expensive than linear,
but more accurate.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. Used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+END_SRC

#+BEGIN_SRC sclang

// Since the allpass delay has no audible effect as a resonator on
// steady state sound ...

{ AllpassC.ar(WhiteNoise.ar(0.1), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

#+END_SRC

#+BEGIN_SRC sclang
// ...these examples add the input to the effected sound and compare variants so that you can hear
// the effect of the phase comb:

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassN.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

#+END_SRC

#+BEGIN_SRC sclang
(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassL.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

#+END_SRC

#+BEGIN_SRC sclang
(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassC.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

#+END_SRC

#+BEGIN_SRC sclang

// used as an echo - doesn't really sound different than Comb,
// but it outputs the input signal immediately (inverted) and the echoes
// are lower in amplitude.
{ AllpassC.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;
#+END_SRC

::

** class:: AllpassL                                             :ugen:delays:
summary:: All pass delay line with linear interpolation.
related:: Classes/AllpassC, Classes/AllpassN, Classes/BufAllpassL
categories::  UGens>Delays


Description::

All pass delay line with linear interpolation. See also
link::Classes/AllpassN::  which uses no interpolation, and
link::Classes/AllpassC::  which uses cubic interpolation.
Cubic interpolation is more computationally expensive than linear,
but more accurate.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. Used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang

// Since the allpass delay has no audible effect as a resonator on
// steady state sound ...

{ AllpassC.ar(WhiteNoise.ar(0.1), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// ...these examples add the input to the effected sound and compare variants so that you can hear
// the effect of the phase comb:

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassN.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassL.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassC.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

// used as an echo - doesn't really sound different than Comb,
// but it outputs the input signal immediately (inverted) and the echoes
// are lower in amplitude.
{ AllpassL.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;
#+END_SRC

::

** class:: AllpassN                                             :ugen:delays:
summary:: All pass delay line with no interpolation.
related:: Classes/AllpassC, Classes/AllpassL, Classes/BufAllpassN
categories::  UGens>Delays


Description::

All pass delay line with no interpolation. See also
link::Classes/AllpassL::  which uses linear interpolation, and
link::Classes/AllpassC::  which uses cubic interpolation.
Cubic interpolation is more computationally expensive than linear,
but more accurate.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. Used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang

// Since the allpass delay has no audible effect as a resonator on
// steady state sound ...

{ AllpassC.ar(WhiteNoise.ar(0.1), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// ...these examples add the input to the effected sound and compare variants so that you can hear
// the effect of the phase comb:

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassN.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassL.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + AllpassC.ar(z, 0.01, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

// used as an echo - doesn't really sound different than Comb,
// but it outputs the input signal immediately (inverted) and the echoes
// are lower in amplitude.
{ AllpassN.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;
#+END_SRC

::

** class:: AmpComp                                  :ugen:analysis:amplitude:
summary:: Basic psychoacoustic amplitude compensation.
related:: Classes/AmpCompA
categories::  UGens>Analysis>Amplitude


Description::

Implements the (optimized) formula:

code::
#+BEGIN_SRC sclang
compensationFactor = (root / freq) ** exp
#+END_SRC

::


Higher frequencies are normally perceived as louder, which AmpComp
compensates.


classmethods::

method::ar, kr, ir

argument::freq

Input frequency value. For freq == root, the output is 1.0.


argument::root

Root freq relative to which the curve is calculated
(usually lowest freq).


argument::exp

Exponent: how steep the curve decreases for increasing freq.

discussion::
Note that for frequencies very much smaller than root the amplitudes can become very high.
In this case limit the freq with code::freq.max(minval)::, or use AmpCompA.

Examples::

code::
#+BEGIN_SRC sclang
// compare a sine without compensation

{ SinOsc.ar(MouseX.kr(300, 15000, 1)) * 0.1 }.play;

// with one that uses amplitude compensation
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	SinOsc.ar(freq) * 0.1 * AmpComp.kr(freq, 300)
}.play;
)


// different sounds cause quite different loudness perception,
// and the desired musical behavior can vary, so the exponent can be tuned:
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	Pulse.ar(freq) * 0.1 * AmpComp.kr(freq, 300, 1.3)
}.play;
)

// the curves:

// exp = 0.3333
(200,210..10000).collect {|freq| (200/freq) ** 0.3333 }.plot;

// nearly linear for semitone steps:

(48..72).midicps.collect {|freq| (48.midicps/freq) ** 0.3333 }.plot;
{ AmpComp.ar(Line.ar(48, 72, 1).midicps, 48.midicps) }.plot(1.0);

// exp = 1.2
(200,210..10000).collect {|freq| (200/freq) ** 1.2 }.plot;
(48..72).midicps.collect {|freq| (200/freq) ** 1.2 }.plot;
{ AmpComp.ar(Line.ar(48, 72, 1).midicps, 48.midicps, 1.2) }.plot(1.0);


// amplitude compensation in frequency modulation
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	freq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);
	SinOsc.ar(freq) * 0.1 * AmpComp.ar(freq, 300)
}.play;
)

// without amplitude compensation
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	freq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);
	SinOsc.ar(freq) * 0.1
}.play;
)

// in granular synthesis:
(
SynthDef("pgrain",
	{ arg out = 0, sustain=0.01, amp=0.5, pan = 0;
		var freq = MouseX.kr(300, 7000, 1);
		var window = Env.sine(sustain, amp * AmpComp.ir(freq));
		Out.ar(out,
			Pan2.ar(
				SinOsc.ar(freq),
				pan
			) * EnvGen.ar(window, doneAction:2)
		)
	}
).send(s);
)

// send grains
(
fork {
	loop {
		s.sendBundle(0.1, [\s_new, \pgrain, -1,1,1]);
		0.02.wait;
	};
}
)


// try different synth defs:


// without AmpComp:

(
SynthDef("pgrain",
	{ arg out = 0, sustain=0.01, amp=0.5, pan = 0;
		var freq = MouseX.kr(300, 7000, 1);
		var window = Env.sine(sustain, amp);
		Out.ar(out,
			Pan2.ar(
				SinOsc.ar(freq),
				pan
			) * EnvGen.ar(window, doneAction:2)
		)
	}
).send(s);
)

// with AmpCompA
(
SynthDef("pgrain",
	{ arg out = 0, sustain=0.01, amp=0.5, pan = 0;
		var freq = MouseX.kr(300, 7000, 1);
		var window = Env.sine(sustain, amp * AmpCompA.ir(freq));
		Out.ar(out,
			Pan2.ar(
				SinOsc.ar(freq),
				pan
			) * EnvGen.ar(window, doneAction:2)
		)
	}
).send(s);
)
#+END_SRC

::

** class:: AmpCompA
summary:: Basic psychoacoustic amplitude compensation (ANSI A-weighting curve).
related:: Classes/AmpComp
categories::  UGens>Analysis>Amplitude


Description::

Higher frequencies are normally perceived as louder, which AmpCompA
compensates. Following the measurings by Fletcher and Munson, the
ANSI standard describes a function for loudness vs. frequency.

Note that this curve is only valid for standardized amplitude.
footnote::
Function freq → dB,
derived from http://www.beis.de/Elektronik/AudioMeasure/WeightingFilters.html
and modified to map freq → amp.
code::
#+BEGIN_SRC sclang
(
var k =  3.5041384e16;
var c1 = 424.31867740601;
var c2 = 11589.093052022;
var c3 = 544440.67046057;
var c4 = 148698928.24309;
f = {|f|
var r = squared(f);
var m1 = pow(r,4);
var n1 = squared(c1 + r);
var n2 = c2 + r;
var n3 = c3 + r;
var n4 = squared(c4 + r);
var level = k * m1 / (n1 * n2 * n3 * n4);
sqrt(level)
};
)
#+END_SRC

::

::


For a simpler but more flexible curve, see  link::Classes/AmpComp::

classmethods::

method::ar, kr, ir

argument::freq
Input frequency value. For freq == root, the output is rootAmp.

argument::root
Root freq relative to which the curve is calculated (usually lowest freq).

argument::minAmp
Amplitude at the minimum point of the curve (around 2512 Hz).

argument::rootAmp
Amplitude at the root frequency.

discussion::
Apart from code::freq::, the values are not modulatable

Examples::

code::
#+BEGIN_SRC sclang

// compare a sine without compensation

{ SinOsc.ar(MouseX.kr(300, 15000, 1)) * 0.1 }.play;

// with one that uses amplitude compensation
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	SinOsc.ar(freq) * 0.3 * AmpCompA.kr(freq)
}.play;
)


// adjust the minimum and root amp
// (in this way one can flatten out the curve for higher amplitudes)

(
{
	var freq;
	freq = MouseX.kr(300, 18000, 1);
	Formant.ar(300, freq, 20, 0.1) * AmpCompA.kr(freq, 300, 0.6, 0.3)
}.play;
)

// the curve:

{ AmpCompA.ar(Line.ar(48, 120, 1).midicps, 48.midicps) }.plot(1.0);

// freqs:

{ AmpCompA.ar(Line.ar(0, 20000, 1)) }.plot(1.0);

// compare with AmpComp (exponential decay)

{ AmpComp.ar(Line.ar(48, 120, 1).midicps, 48.midicps) }.plot(1.0);

// freqs:

{ AmpComp.ar(Line.ar(40, 20000, 1), 40) }.plot(1.0);



// amplitude compensation in frequency modulation (using Fletscher-Munson curve)
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	freq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);
	SinOsc.ar(freq) * 0.1 * AmpCompA.ar(freq, 300)
}.play;
)

// amplitude compensation in frequency modulation (using AmpComp exponential decay)
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	freq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);
	SinOsc.ar(freq) * 0.1 * AmpComp.ar(freq, 300)
}.play;
)


// without amplitude compensation
(
{
	var freq;
	freq = MouseX.kr(300, 15000, 1);
	freq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);
	SinOsc.ar(freq) * 0.1
}.play;
)





[1] Function freq -> dB,
	derived from http://www.beis.de/Elektronik/AudioMeasure/WeightingFilters.html
	and modified to map freq -> amp

(
var k =  3.5041384e16;
var c1 = 424.31867740601;
var c2 = 11589.093052022;
var c3 = 544440.67046057;
var c4 = 148698928.24309;
f = {|f|
  var r = squared(f);
  var m1 = pow(r,4);
  var n1 = squared(c1 + r);
  var n2 = c2 + r;
  var n3 = c3 + r;
  var n4 = squared(c4 + r);
  var level = k * m1 / (n1 * n2 * n3 * n4);
  sqrt(level)
 };
)
#+END_SRC

::

** class:: Amplitude
summary:: Amplitude follower
categories:: UGens>Analysis>Amplitude

description::
Tracks the peak amplitude of a signal.

classmethods::

method:: ar, kr

argument::in
Input signal

argument::attackTime
60dB convergence time for following attacks.

argument::releaseTime
60dB convergence time for following decays.

argument::mul

argument::add

examples::

code::
#+BEGIN_SRC sclang
(
// use input amplitude to control SinOsc frequency
{
    SinOsc.ar(
            Amplitude.kr(
                        Blip.ar(3, 20) * LFNoise1.kr(0.1).range(0, 1),
                        MouseX.kr(0.001, 1, 1),
                        MouseY.kr(0.001, 1, 1),
                        1200,
                        400
            ),
            0, 0.3)
}.play;
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// use input amplitude to control Pulse amplitude - use headphones to prevent feedback.
{ Pulse.ar(90, 0.3, Amplitude.kr(SoundIn.ar(0))) }.play;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
// use input amplitude to control SinOsc frequency - use headphones to prevent feedback.
{
    SinOsc.ar(
            Amplitude.kr(
                        SoundIn.ar(0),
                        0.01,
                        0.01,
                        1200,
                        400
            ),
            0, 0.3)
}.play;
)
#+END_SRC

::
** CLASS::AppClock
categories::Scheduling>Clocks
summary::Clock running on main application thread
related::Classes/SystemClock, Classes/TempoClock

DESCRIPTION::
SystemClock is more accurate, but cannot call Cocoa primitives. AppClock is less accurate (uses NSTimers) but can call Cocoa primitives.

You will need to use the link::Classes/SystemClock:: to get accurate/musical scheduling.

See link::Classes/Clock:: for general explanation of how clocks operate.

CLASSMETHODS::

private::initClass

method::sched
The float you return specifies the delta to resched the function for. Returning nil will stop the task from being rescheduled.
code::
#+BEGIN_SRC sclang
(
AppClock.sched(0.0,{ arg time;
	["AppClock has been playing for ",time].postln;
	rrand(0.1,0.9);
});
)
#+END_SRC

::
code::
#+BEGIN_SRC sclang
(
AppClock.sched(2.0,{
	"2.0 seconds later".postln;
	nil;
});
)
#+END_SRC

::

method::clear
Clear the AppClock's scheduler to stop it.
code::
#+BEGIN_SRC sclang
AppClock.clear;
#+END_SRC

::

method::play
The link::Classes/Routine:: (or link::Classes/Task::) yields a float value indicating the delta (secs) for the AppClock to wait until resuming the Routine.
code::
#+BEGIN_SRC sclang
(
var w, r;
w = Window.new("trem", Rect(512, 256, 360, 130));
w.front;
r = Routine({ arg appClockTime;
	["AppClock has been playing for secs:",appClockTime].postln;
	60.do({ arg i;
		0.05.yield;
		w.bounds = w.bounds.moveBy(10.rand2, 10.rand2);
		w.alpha = cos(i*0.1pi)*0.5+0.5;
	});
	1.yield;
	w.close;
});
AppClock.play(r);
)
#+END_SRC

::

method::tick
AppClock.tick is called periodically by the SuperCollider application itself. This updates the link::Classes/Scheduler:: and causes any scheduled tasks to be executed. You should never call this method yourself.
** class:: ApplicationStart
summary:: register functions to be evaluated on Application start
related:: Classes/StartUp, Classes/ServerBoot
categories:: Control, Platform>OSX

description::

Available in OSX SuperCollider.app only.

ApplicationStart allows you to register functions or objects to perform an action only  on application start.
The functions will be evaluated last; After the library has been compiled, the startup file has run and StartUp actions have been evaluated.

See also link::Classes/StartUp:: for functions that are evaluated emphasis::every:: time the ClassLibrary is recompiled.

ClassMethods::

method::add
Registers an object or function. Objects will be receive a strong::doOnApplcationStart:: message on application start. Functions will be evaluated.

method::remove
Removes a function that was previously registered.

method::run
Evaluates the functions or objects in order.

Examples::

code::
#+BEGIN_SRC sclang
SomeStartClass {
	*initClass {
		ApplicationStart.add {
			// something to do when the app has been launched...
		}
	}
}

// or...
SomeStartClass {
	*initClass {
		ApplicationStart.add(this);
	}
	*doOnApplicationStart { "something started".postln }
}
#+END_SRC

::
** CLASS::Archive
summary::storing objects to file
categories:: Collections, Files
related::Classes/Library, Classes/Object, Classes/LibraryBase

DESCRIPTION::
Archives can write any object to disk and read from file again. Compex structures of objects can thus be restored. Writing an object to file as a strong::compile string:: is usually more readable, but does not account for the internal structure of the object.

There is only one global instance: Archive.global, which is initialized automatically.

CLASSMETHODS::

private::initClass

method::global
set or get the global archive instance

method::archiveDir
set or get the directory that the archive is written to.
Default: link::Classes/Platform::.userAppSupportDir.

method::write
write the global archive now. This is called automatically when SuperCollider quits.
The default filename is "/archive.sctxar"

method::read
read the global archive now. This is called automatically when SuperCollider recompiles or starts.
The default filename is "/archive.sctxar"

EXAMPLES::

code::
#+BEGIN_SRC sclang
// make a storage place for various objects:
q = (); // Event

q[\a_long_array] = Array.rand(128, 0.0, 1.0);
q[\pi_squared] = pi * pi;
q[\favourite_sound] = { { SinOsc.ar([300, 330]).sum * LFPulse.kr(2 + [0, 0.01]) * 0.1 }.play };
q[\same_long_array] = q[\a_long_array]; // same objects may appear several times

Archive.global.put(\myData, q);


Archive.global.at(\myData).postcs;

// after a recompile:
s.boot;

q = Archive.global.at(\myData);
q.postcs;
q[\favourite_sound].value;
#+END_SRC

::
** class:: Array
summary:: fixed size collection
related:: Reference/Literals, Classes/List
categories:: Collections>Ordered

description::
Arrays are ArrayedCollections whose slots may contain any object. Arrays have a fixed maximum size beyond which they cannot grow. For expandable arrays, use the link::Classes/List:: class.

strong::Literal Arrays:: can be created at compile time, and are very efficient. See link::Reference/Literals:: for information.

For handling strong::multidimensional arrays::, there are specific methods which are covered in the helpfile link::Guides/J-concepts-in-SC::.

note::
For Arrays, the code::add:: method may or may not return the same Array object. It will add the argument to the receiver if there is space, otherwise it returns a new Array object with the argument added. Thus the proper usage of code::add:: with an Array is to always assign the result as follows:
code::
#+BEGIN_SRC sclang
    z = z.add(obj);
#+END_SRC

::
This allows an efficient use of resources, only growing the array when it needs to. The link::Classes/List:: class manages the Array internally, and in many cases is more suitable.
::

Elements can be put into an existing slot with code::a.put(2,obj):: and accessed with
code::a.at(2):: or code::a[2]::


See link::Classes/ArrayedCollection:: for the principal methods: at, put, clipAt, wrapAt, etc...


ClassMethods::

method::new
Create a new array with size 0 that can grow up to the fixed size.
argument::maxSize
The maximum size of the array.

method::newClear
Create a new array with all slots filled with nils.
argument::indexedSize
The size of the array.

method::with
Create a new Array whose slots are filled with the given arguments.
This is the same as the method in ArrayedCollection, but is reimplemented here to be more efficient.


code::
#+BEGIN_SRC sclang
Array.with(7, 'eight',  9).postln;
#+END_SRC

::

copymethod:: Collection *fill

copymethod:: Collection *fill2D

copymethod:: Collection *fillND

copymethod:: Collection *newFrom

copymethod:: ArrayedCollection *geom

copymethod:: ArrayedCollection *series

copymethod:: ArrayedCollection *iota

copymethod:: Collection *interpolation

copymethod:: Collection *rand

copymethod:: Collection *rand2

copymethod:: Collection *linrand

copymethod:: Collection *exprand

copymethod:: Collection *fib





InstanceMethods::

copymethod:: ArrayedCollection -at

copymethod:: ArrayedCollection -put

copymethod:: ArrayedCollection -insert

copymethod:: ArrayedCollection -overWrite

copymethod:: ArrayedCollection -clipAt

copymethod:: ArrayedCollection -wrapAt

copymethod:: ArrayedCollection -foldAt

copymethod:: ArrayedCollection -slice

copymethod:: ArrayedCollection -clipPut

copymethod:: ArrayedCollection -wrapPut

copymethod:: ArrayedCollection -foldPut

copymethod:: ArrayedCollection -swap

copymethod:: ArrayedCollection -replace

copymethod:: ArrayedCollection -++

copymethod:: ArrayedCollection -add

copymethod:: ArrayedCollection -addAll

copymethod:: ArrayedCollection -addFirst

copymethod:: ArrayedCollection -removeAt

copymethod:: ArrayedCollection -collect

copymethod:: ArrayedCollection -do

copymethod:: ArrayedCollection -reverseDo

copymethod:: ArrayedCollection -deepCollect

copymethod:: ArrayedCollection -reshape

copymethod:: ArrayedCollection -bubble

copymethod:: ArrayedCollection -unbubble

copymethod:: ArrayedCollection -windex

copymethod:: ArrayedCollection -size

copymethod:: ArrayedCollection -normalize

copymethod:: ArrayedCollection -normalizeSum

copymethod:: ArrayedCollection -plot

method::reverse
Returns a new Array whose elements are reversed. The receiver is unchanged.
code::
#+BEGIN_SRC sclang
x = [1, 2, 3];
z = x.reverse;
x.postln;
z.postln;
#+END_SRC

::

method::scramble
Returns a new Array whose elements have been scrambled. The receiver is unchanged.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4, 5, 6].scramble.postln;
#+END_SRC

::

method::mirror
Return a new Array which is the receiver made into a palindrome.
The receiver is unchanged.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4].mirror.postln;
#+END_SRC

::

method::mirror1
Return a new Array which is the receiver made into a palindrome with the last element removed.
This is useful if the list will be repeated cyclically, the first element will not get played twice.
The receiver is unchanged.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4].mirror1.postln;
#+END_SRC

::

method::mirror2
Return a new Array which is the receiver concatenated with a reversal of itself.
The center element is duplicated. The receiver is unchanged.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4].mirror2.postln;
#+END_SRC

::

method::stutter
Return a new Array whose elements are repeated n times. The receiver is unchanged.
code::
#+BEGIN_SRC sclang
[1, 2, 3].stutter(2).postln;
#+END_SRC

::
argument::n
Number of repeats.

method::rotate
Return a new Array whose elements are in rotated order. The receiver is unchanged.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4, 5].rotate(1).postln;
[1, 2, 3, 4, 5].rotate(-1).postln;
[1, 2, 3, 4, 5].rotate(3).postln;
#+END_SRC

::
argument::n
Number of elements to rotate. Negative n values rotate left, postive n values
rotate right.

method::pyramid
Return a new Array whose elements have been reordered via one of 10 "counting" algorithms.
Run the examples to see the algorithms.
code::
#+BEGIN_SRC sclang
10.do({ arg i;
	[1, 2, 3, 4].pyramid(i + 1).postcs;
});
#+END_SRC

::
argument::patternType
Choose counting algorithm. The algorithms are numbered 1 through 10.

method::pyramidg
Like pyramid, but keep the resulting values grouped in subarrays.
code::
#+BEGIN_SRC sclang
// compare:
[1, 2, 3, 4].pyramid(1).postln;
[1, 2, 3, 4].pyramidg(1).postln;
#+END_SRC

::

method::sputter
Return a new Array of length maxlen with the items partly repeated (random choice of given probability).
code::
#+BEGIN_SRC sclang
// compare:
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].sputter(0.5, 16).postln;
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].sputter(0.8, 8).postln;
#+END_SRC

::
argument::probability
Probability of repeat.
argument::maxlen
The length of the new Array.

method::lace
Returns a new Array whose elements are interlaced sequences of the elements of the receiver's subcollections, up to size length. The receiver is unchanged.
code::
#+BEGIN_SRC sclang
x = [ [1, 2, 3], 6, List["foo", 'bar']];
y = x.lace(12);
x.postln;
y.postln;
#+END_SRC

::

method::permute
Returns a new Array whose elements are the nthPermutation of the elements of the receiver. The receiver is unchanged.
code::
#+BEGIN_SRC sclang
x = [ 1, 2, 3];
6.do({|i| x.permute(i).postln;});
#+END_SRC

::

method::allTuples
Returns a new Array whose elements contain all possible combinations of the receiver's subcollections.
code::
#+BEGIN_SRC sclang
[[1, 2, 3, 4, 5], [10, 20, 30]].allTuples;
[[1, 2, 3, 4, 5], [10, 20, 30], [5, 6]].allTuples;
#+END_SRC

::

method::wrapExtend
Returns a new Array whose elements are repeated sequences of the receiver, up to size length. The receiver is unchanged.
code::
#+BEGIN_SRC sclang
x = [ 1, 2, 3, "foo", 'bar' ];
y = x.wrapExtend(9);
x.postln;
y.postln;
#+END_SRC

::

method::foldExtend
Same as wrapExtend but the sequences fold back on the list elements.
code::
#+BEGIN_SRC sclang
x = [ 1, 2, "foo"];
y = x.foldExtend(9);
x.postln;
y.postln;
#+END_SRC

::

method::clipExtend
Same as wrapExtend but the sequences "clip" (return their last element) rather than wrapping.
code::
#+BEGIN_SRC sclang
x = [ 1, 2, "foo"];
y = x.clipExtend(9);
x.postln;
y.postln;
#+END_SRC

::

method::slide
Return a new Array whose elements are repeated subsequences from the receiver.
Easier to demonstrate than explain.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4, 5, 6].slide(3, 1).postcs;
[1, 2, 3, 4, 5, 6].slide(3, 2).postcs;
[1, 2, 3, 4, 5, 6].slide(4, 1).postcs;
#+END_SRC

::

method::shift
Shift the values of the array n steps to the right (n positive) or to the left(n negative),
dropping the excess and filling empty space with zero.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4, 5, 6].shift(3).postln;
[1, 2, 3, 4, 5, 6].shift(-3).postln;
#+END_SRC

::

method::containsSeqColl
Returns true if the receiver Array contains any instance of SequenceableCollection
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4].containsSeqColl.postln
[1, 2, [3], 4].containsSeqColl.postln
#+END_SRC

::

method::powerset
Returns all possible combinations of the array's elements.
code::
#+BEGIN_SRC sclang
[1, 2, 3].powerset.postln
[1, 2, 3].powerset.sort({ |a, b| a.size > b.size }); // sort by size, big first
[1, 2, 3].powerset.sort({ |a, b| a.size > b.size }).reverse; // by size, small first
#+END_SRC

::
powerset is also supported in Collection:
code::
#+BEGIN_SRC sclang
Set[1, 2, 3].powerset;
List[1, 2, 3].powerset
(a: 1, b: 2, c: 3).powerset;
#+END_SRC

::

method::envirPairs
Given an array of symbols, this returns an array of pairs of (symbol, value) from the current environment.
This can then be used as arguments for a Synth, or in an OSC message.
code::
#+BEGIN_SRC sclang
e = (freq: 340, amp: 0.001, strangeness: 0.85);
e.use {
	[\amp, \taste, \strangeness].envirPairs;
}
#+END_SRC

::

method::flop
Invert rows and colums in a two dimensional Array (turn inside out).
See also: Function, SequenceableCollection.
code::
#+BEGIN_SRC sclang
[[1, 2, 3], [4, 5, 6]].flop;
[[1, 2, 3], [4, 5, 6], [7, 8]].flop; // shorter array wraps
[].flop; // result is always 2-d.
#+END_SRC

::

method::multiChannelExpand
Used by UGens to perform multi channel expansion. Same as flop.

method::source
Some UGens return Arrays of OutputProxy when instantiated. This method allows you to
get at the source UGen.
code::
#+BEGIN_SRC sclang
z = Pan2.ar;
z.postln;
z.source.postln;
#+END_SRC

::

method::fork
Used within Routines and assumes an array of functions, from which subroutines are created. The subroutines are played while the outer Routine carries on. The join parameter expresses after how many subroutines complete the outer Routine is allowed to go on. By default this happens after all subroutines have completed.
code::
#+BEGIN_SRC sclang
// an array of routine functions:
(
a = [
	{ 1.wait; \done_one.postln },
	{ 0.5.wait; \done_two.postln },
	{ 0.2.wait; \done_three.postln }
];
)
// join after 0
(
Routine {
	"join = 0.".postcln;
	a.fork(0); \doneAll.postln;
}.play;
)
// join after 1
(
Routine {
	"join = 1.".postcln;
	a.fork(1); \doneAll.postln;
}.play;
)
// join after all
(
Routine {
	"join = a.size (default).".postcln;
	a.fork; \doneAll.postln;
}.play;
)

poll(trig, label, trigid)
apply an array of Poll units to an array of UGens (see those helpfiles for more details).

s.boot;
(
x = {
	SinOsc.ar([0.1, 0.2], 0).poll * 0.1
}.play;
)
x.trace; // By tracing the Synth you can see the two Poll units we created
x.free
#+END_SRC

::

method::dpoll
apply an array of Dpoll units to an array of UGens (see those helpfiles for more details).

method::atIdentityHash
This method is used by IdentitySet to search for a key among its members.

method::atIdentityHashInPairs
This method is used by IdentityDictionary to search for a key among its members.

method::asString
Returns a string representing the Array. May not be compileable due to ellision (...) of excessive arguments.

method::asCompileString
Returns a string that will compile to return an Array equal to the receiver.

method::isValidUGenInput
Returns true. Arrays are valid UGen inputs.

method::asRawOSC
Returns the OSC measse as an Int8Array. Receiver must be a bundle.
code::
#+BEGIN_SRC sclang
[0.1, [\s_new, \default, -1, 1, 1, \freq, 1961]].asRawOSC;
#+END_SRC

::

** CLASS::Array2D
summary::two-dimensional array
related::Classes/Array
categories::Collections>Ordered

DESCRIPTION::
Represents a two-dimensional array of data. The number of rows and columns is fixed.

note:: It is possible to implement a similar behaviour using an "array-of-arrays" - see the examples towards the bottom of this page for comparison.::

CLASSMETHODS::

method::new
Create an array of the specified size.
code::
#+BEGIN_SRC sclang
a = Array2D.new(3,4);
a[2,2] = 1;
a.postln
#+END_SRC

::

method::fromArray
Build an Array2D from the supplied array.
code::
#+BEGIN_SRC sclang
a = Array2D.fromArray(3,4, [9,8,7,6,5,4,3,2,1,2,3,4]);
a[2,2] = 1;
a.postln
#+END_SRC

::

INSTANCEMETHODS::

private::printOn, storeOn

method::at
Get a value from the array.
code::
#+BEGIN_SRC sclang
a.at(2,3);
a[2,3];
#+END_SRC

::

method::put
Put a value into the array.
code::
#+BEGIN_SRC sclang
a.put(2,3, 72);
a[2,3];
#+END_SRC

::

method::colsDo
Iterate over the columns. Each column will be passed to strong::func:: in turn.
code::
#+BEGIN_SRC sclang
a.colsDo(_.postln);
#+END_SRC

::

method::rowsDo
Iterate over the rows. Each row will be passed to strong::func:: in turn.
code::
#+BEGIN_SRC sclang
a.rowsDo(_.postln);
#+END_SRC

::

method::colAt
Retrieve a single column.
code::
#+BEGIN_SRC sclang
a.colAt(2);
#+END_SRC

::

method::rowAt
Retrieve a single row.
code::
#+BEGIN_SRC sclang
a.rowAt(2);
#+END_SRC

::

method::asArray
Return a flat array containing the elements.
code::
#+BEGIN_SRC sclang
a.postln;
a.asArray.postln;
#+END_SRC

::
returns:: link::Classes/Array::

EXAMPLES::

code::
#+BEGIN_SRC sclang
// "a" is an array-of-arrays
a = { { 100.0.rand }.dup(100) }.dup(100);
// "b" is an equivalent Array2D, made using the "fromArray" class method
b = Array2D.fromArray(100,100, a.flat);

// Accessing
a[15][22]
b[15, 22]

// Speed comparison 1: random access
bench { 100.do(a[100.rand][100.rand]) }
bench { 100.do(b[100.rand, 100.rand]) }

// Speed comparison 2: iteration
bench { 100.do(a.do { |row| row.do { |item| item * 2 } }) }
bench { 100.do(b.do { |item| item * 2 }) }
#+END_SRC

::
** CLASS::ArrayedCollection
categories::Collections>Ordered
summary:: Abstract superclass of Collections of fixed maximum size

DESCRIPTION::
ArrayedCollection is an abstract class, a subclass of SequenceableCollections whose elements are held in a vector of slots. Instances of ArrayedCollection have a fixed maximum size beyond which they may not grow.

Its principal subclasses are link::Classes/Array:: (for holding objects), and link::Classes/RawArray::, from which link::Classes/Int8Array::, link::Classes/FloatArray::, link::Classes/Signal:: etc. inherit.

CLASSMETHODS::

method::newClear
Creates a new instance with strong::indexedSize:: indexable slots. The slots are filled with link::Classes/Nil::, zero or something else appropriate to the type of indexable slots in the object.
code::
#+BEGIN_SRC sclang
Array.newClear(4).postln;
#+END_SRC

::

method::with
Create a new ArrayedCollection whose slots are filled with the given arguments.
code::
#+BEGIN_SRC sclang
Array.with(7, 'eight',  9).postln;
#+END_SRC

::

method::series
Fill an ArrayedCollection with an arithmetic series.
code::
#+BEGIN_SRC sclang
Array.series(5, 10, 2).postln;
#+END_SRC

::

method::geom
Fill an ArrayedCollection with a geometric series.
code::
#+BEGIN_SRC sclang
Array.geom(5, 1, 3).postln;
#+END_SRC

::

method::iota
Fills an ArrayedCollection with a counter. See link::Guides/J-concepts-in-SC:: for more examples.
code::
#+BEGIN_SRC sclang
Array.iota(2, 3);
Array.iota(2, 3, 4);
#+END_SRC

::


INSTANCEMETHODS::

method::size
Return the number of elements the ArrayedCollection.

method::maxSize
Return the maximum number of elements the ArrayedCollection can hold. For example, link::Classes/Array::s may initialise themselves with a larger capacity than the number of elements added.
code::
#+BEGIN_SRC sclang
[4, 5, 6].maxSize; // gosh
#+END_SRC

::

method::at
Return the item at strong::index::.

The index can also be an Array of indices to extract specified elements. Example:
code::
#+BEGIN_SRC sclang
x = [10,20,30];
y = [0,0,2,2,1];
x[y]; // returns [ 10, 10, 30, 30, 20 ]
#+END_SRC

::

method::clipAt
Same as link::#-at::, but values for strong::index:: greater than the size of the ArrayedCollection will be clipped to the last index.
code::
#+BEGIN_SRC sclang
y = [ 1, 2, 3 ];
y.clipAt(13).postln;
#+END_SRC

::

method::wrapAt
Same as link::#-at::, but values for strong::index:: greater than the size of the ArrayedCollection will be wrapped around to 0.
code::
#+BEGIN_SRC sclang
y = [ 1, 2, 3 ];
y.wrapAt(3).postln; // this returns the value at index 0
y.wrapAt(4).postln; // this returns the value at index 1
y.wrapAt([-2, 1])   // index can also be a collection or negative numbers
#+END_SRC

::

method::foldAt
Same as link::#-at::, but values for strong::index:: greater than the size of the ArrayedCollection will be folded back.
code::
#+BEGIN_SRC sclang
y = [ 1, 2, 3 ];
y.foldAt(3).postln; // this returns the value at index 1
y.foldAt(4).postln; // this returns the value at index 0
y.foldAt(5).postln; // this returns the value at index 1
#+END_SRC

::

method::plot
Plot data in a GUI window. See link::Reference/plot:: for more details.

method::swap
Swap the values at indices i and j.
code::
#+BEGIN_SRC sclang
[ 1, 2, 3 ].swap(0, 2).postln;
#+END_SRC

::

method::put
Put strong::item:: at strong::index::, replacing what is there.

method::clipPut
Same as link::#-put::, but values for strong::index:: greater than the size of the ArrayedCollection will be clipped to the last index.

method::wrapPut
Same as link::#-put::, but values for strong::index:: greater than the size of the ArrayedCollection will be wrapped around to 0.

method::foldPut
Same as link::#-put::, but values for strong::index:: greater than the size of the ArrayedCollection will be folded back.

method::putEach
Put the strong::values:: in the corresponding indices given by strong::keys::. If one of the two argument arrays is longer then it will wrap.
code::
#+BEGIN_SRC sclang
y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
y.putEach([4, 7], [\smelly, \head]);
y.putEach([2, 3, 5, 6], \wotsits);
#+END_SRC

::

method::indexOf
Return the first index containing an item which matches strong::item::.
code::
#+BEGIN_SRC sclang
y = [ \the, \symbol, \collection, \contains, \my, \symbol ];
y.indexOf(\symbol);
#+END_SRC

::

method::includes
Return a boolean indicating whether the collection contains anything matching strong::item::.
code::
#+BEGIN_SRC sclang
y = [ \the, \symbol, \collection, \contains, \my, \symbol ];
y.includes(\symbol);
y.includes(\solipsism);
#+END_SRC

::

method::indexOfGreaterThan
Return the first index containing an item which is greater than strong::item::.
code::
#+BEGIN_SRC sclang
y = [ 10, 5, 77, 55, 12, 123];
y.indexOfGreaterThan(70);
#+END_SRC

::

method::removeAt
Remove and return the element at strong::index::, shrinking the size of the ArrayedCollection.
code::
#+BEGIN_SRC sclang
y = [ 1, 2, 3 ];
y.removeAt(1);
y.postln;
#+END_SRC

::

method::takeAt
Similar to link::#-removeAt::, but does not maintain the order of the items following the one that was removed. Instead, the last item is placed into the position of the removed item and the array's size decreases by one.
code::
#+BEGIN_SRC sclang
y = [ 1, 2, 3, 4, 5 ];
y.takeAt(1);
y.postln;
#+END_SRC

::

method::takeThese
Removes all items in the receiver for which the strong::func:: answers true. The function is passed two arguments, the item and an integer index. Note that order is not preserved. See link::#-takeAt::.
code::
#+BEGIN_SRC sclang
y = [ 1, 2, 3, 4 ];
y.takeThese({ arg item, index; item.odd; });	//remove odd items
y.postln;
#+END_SRC

::

method::add
Adds an item to an ArrayedCollection if there is space. This method may return a new ArrayedCollection. For this reason, you should always assign the result of add to a variable - never depend on code::add:: changing the receiver.
code::
#+BEGIN_SRC sclang
(
// z and y are the same object
var y, z;
z = [1, 2, 3];
y = z.add(4);
z.postln;
y.postln;
)

(
// in this case a new object is returned
var y, z;
z = [1, 2, 3, 4];
y = z.add(5);
z.postln;
y.postln;
)
#+END_SRC

::

method::addAll
Adds all the elements of aCollection to the contents of the receiver. This method may return a new ArrayedCollection. For this reason, you should always assign the result of code::addAll:: to a variable - never depend on add changing the receiver.
code::
#+BEGIN_SRC sclang
(
// in this case a new object is returned
var y, z;
z = [1, 2, 3, 4];
y = z.addAll([7, 8, 9]);
z.postln;
y.postln;
)
#+END_SRC

::

method::extend
Extends the object to match strong::size:: by adding a number of strong::item::s. If strong::size:: is less than receiver size then truncate. This method may return a new ArrayedCollection. For this reason, you should always assign the result of code::extend:: to a variable - never depend on add changing the receiver.
code::
#+BEGIN_SRC sclang
(
var y, z;
z = [1, 2, 3, 4];
y = z.extend(10, 9);		//fill up with 9 until the size equals 10
z.postln;
y.postln;
)
#+END_SRC

::

method::fill
Inserts the item into the contents of the receiver. note::the difference between this and link::Classes/Collection#fill#Collection's *fill::.::
code::
#+BEGIN_SRC sclang
(
var z;
z = [1, 2, 3, 4];
z.fill(4).postln;
z.fill([1,2,3,4]).postln;
)
#+END_SRC

::

method::insert
Inserts the item into the contents of the receiver. This method may return a new ArrayedCollection. For this reason, you should always assign the result of code::insert:: to a variable - never depend on add changing the receiver.
code::
#+BEGIN_SRC sclang
(
// in this case a new object is returned
var y, z;
z = [1, 2, 3, 4];
y = z.insert(1, 999);
z.postln;
y.postln;
)
#+END_SRC

::

method::addFirst
Inserts the item before the contents of the receiver, possibly returning a new collection.
code::
#+BEGIN_SRC sclang
(
// in this case a new object is returned
var y, z;
z = [1, 2, 3, 4];
y = z.addFirst(999);
z.postln;
y.postln;
)
#+END_SRC

::

method::pop
Remove and return the last element of the ArrayedCollection.
code::
#+BEGIN_SRC sclang
(
var z;
z = [1, 2, 3, 4];
z.pop.postln;
z.postln;
)
#+END_SRC

::

method::grow
Increase the size of the ArrayedCollection by strong::sizeIncrease:: number of slots, possibly returning a new collection.

method::growClear
Increase the size of the ArrayedCollection by strong::sizeIncrease:: number of slots, returning a new collection with link::Classes/Nil::s in the added slots.
code::
#+BEGIN_SRC sclang
// Compare:
[4,5,6].grow(5);
[4,5,6].growClear(5);
#+END_SRC

::

method::copyRange
Return a new ArrayedCollection which is a copy of the indexed slots of the receiver from strong::start:: to strong::end::.
code::x.copyRange(a, b):: can also be written as code::x[a..b]::
#+BEGIN_SRC sclang
code::
(
var y, z;
z = [1, 2, 3, 4, 5];
y = z.copyRange(1,3);
z.postln;
y.postln;
)
#+END_SRC

::

method::copySeries
Return a new ArrayedCollection consisting of the values starting at strong::first::, then every step of the distance between strong::first:: and strong::second::, up until strong::last::.
code::x.copySeries(a, b, c):: can also be written as code::x[a, b..c]::
#+BEGIN_SRC sclang
code::
(
var y, z;
z = [1, 2, 3, 4, 5, 6];
y = z.copySeries(0, 2, 5);
y.postln;
)
#+END_SRC

::

method::seriesFill
Fill the receiver with an arithmetic progression. The first element will be strong::start::, the second strong::start + step::, the third strong::start + step + step:: ...
code::
#+BEGIN_SRC sclang
(
var y;
y = Array.newClear(15);
y.seriesFill(5, 3);
y.postln;
)
#+END_SRC

::

method::putSeries
Put strong::value:: at every index starting at strong::first::, then every step of the distance between strong::first:: and strong::second::, up until strong::last::.
code::x.putSeries(a, b, c, val):: can also be written as code::x[a, b..c] = val::
#+BEGIN_SRC sclang
code::
(
var y, z;
z = [1, 2, 3, 4, 5, 6];
y = z.putSeries(0, 2, 5, "foo");
y.postln;
)
#+END_SRC

::

method::++
Concatenate the contents of the two collections into a new ArrayedCollection.
code::
#+BEGIN_SRC sclang
(
var y, z;
z = [1, 2, 3, 4];
y = z ++ [7, 8, 9];
z.postln;
y.postln;
)
#+END_SRC

::

method::reverse
Return a new ArrayedCollection whose elements are reversed.
code::
#+BEGIN_SRC sclang
(
var y, z;
z = [1, 2, 3, 4];
y = z.reverse;
z.postln;
y.postln;
)
#+END_SRC

::

method::do
Iterate over the elements in order, calling the function for each element. The function is passed two arguments, the element and an index.
code::
#+BEGIN_SRC sclang
['a', 'b', 'c'].do({ arg item, i; [i, item].postln; });
#+END_SRC

::

method::reverseDo
Iterate over the elements in reverse order, calling the function for each element. The function is passed two arguments, the element and an index.
code::
#+BEGIN_SRC sclang
['a', 'b', 'c'].reverseDo({ arg item, i; [i, item].postln; });
#+END_SRC

::

method::collect
Answer a new collection which consists of the results of function evaluated for each item in the collection. The function is passed two arguments, the item and an integer index. See link::Classes/Collection:: helpfile for examples.

method::deepCollect
The same as link::#-collect::, but can look inside sub-arrays up to the specified strong::depth::.
code::
#+BEGIN_SRC sclang
a = [99, [4,6,5], [[32]]];
a.deepCollect(1, {|item| item.isArray}).postln;
a.deepCollect(2, {|item| item.isArray}).postln;
a.deepCollect(3, {|item| item.isArray}).postln;
#+END_SRC

::

method::windex
Interprets the array as a list of probabilities which should sum to 1.0 and returns a random index value based on those probabilities.
code::
#+BEGIN_SRC sclang
(
Array.fill(10, {
	[0.1, 0.6, 0.3].windex;
}).postln;
)
#+END_SRC

::

method::normalizeSum
Returns the Array resulting from :
code::
#+BEGIN_SRC sclang
(this / this.sum)
#+END_SRC

::
so that the array will sum to 1.0.

This is useful for using with windex or wchoose.
code::
#+BEGIN_SRC sclang
[1, 2, 3].normalizeSum.postln;
#+END_SRC

::

method::normalize
Returns a new Array with the receiver items normalized between strong::min:: and strong::max::.
code::
#+BEGIN_SRC sclang
[1, 2, 3].normalize;			//default min=0, max= 1
[1, 2, 3].normalize(-20, 10);
#+END_SRC

::

method::perfectShuffle
Returns a copy of the receiver with its items split into two equal halves, then reconstructed by interleaving the two halves. note::use an even number of item pairs in order to not loose any items in the shuffle.::
code::
#+BEGIN_SRC sclang
(
var y, z;
z = [ 1, 2, 3, 4, 5, 6 ];
y = z.perfectShuffle;
z.postln;
y.postln;
)
#+END_SRC

::

method::performInPlace
Performs a method in place, within a certain region [from..to], returning the same array.
code::
#+BEGIN_SRC sclang
a = (0..10);
a.performInPlace(\normalizeSum, 3, 6);
#+END_SRC

::

method::rank
Rank is the number of dimensions in a multidimensional array.
code::
#+BEGIN_SRC sclang
a = [4,7,6,8];
a.rank;
a = [[4,7],[6,8]];
a.rank;
#+END_SRC

::

method::shape
For a multidimensional array, returns the number of elements along each dimension.
code::
#+BEGIN_SRC sclang
a = [4,7,6,8];
a.shape;
a = [[4,7],[6,8]];
a.shape;
#+END_SRC

::

method::reshape
For a multidimensional array, rearranges the data using the desired number of elements along each dimension. The data may be extended using wrapExtend if needed.
code::
#+BEGIN_SRC sclang
a = [4,7,6,8];
a.reshape(2,2);
a.reshape(2,3);
#+END_SRC

::

method::find
Finds the starting index of a number of elements contained in the array.
code::
#+BEGIN_SRC sclang
a = (0..10);
a.find([4, 5, 6]);
#+END_SRC

::

method::replace
Return a new array in which a number of elements have been replaced by another.
code::
#+BEGIN_SRC sclang
a = (0..10) ++ (0..10);
a.replace([4, 5, 6], 100);
a.replace([4, 5, 6], [1734, 1985, 1860]);
#+END_SRC

::
this method is inherited by link::Classes/String:: :
code::
#+BEGIN_SRC sclang
a = "hello world";
a.replace("world", "word");
#+END_SRC

::

method::asRandomTable
Return an integral table that can be used to generate random numbers with a specified distribution.
(see link::Guides/Randomness:: helpfile for a more detailed example)
code::
#+BEGIN_SRC sclang
(
a = (0..100) ++ (100..50) / 100; // distribution
a = a.asRandomTable;
)
#+END_SRC

::

method::tableRand
Returns a new random number from a random table.
code::
#+BEGIN_SRC sclang
(
a = (0..100) ++ (100..50) / 100; // distribution
a = a.asRandomTable;
20.do { a.tableRand.postln };
)
#+END_SRC

::

method::msgSize
Return the size of an osc message in bytes
code::
#+BEGIN_SRC sclang
a = ["/s_new", "default", -1, "freq", 440];
a.msgSize;
#+END_SRC

::

method::bundleSize
Return the size of an osc bundle in bytes
code::
#+BEGIN_SRC sclang
a = [["/s_new", "default", -1, "freq", 440], ["/s_new", "default", -1, "freq", 220]];
a.bundleSize;
#+END_SRC

::

method::asciiPlot
For an ArrayedCollection containing numbers (e.g. audio data) this renders a plot in the post window using asterisks and spaces (works best if you use a monospace font in your post window).
code::
#+BEGIN_SRC sclang
a = (0, pi/10 .. 5pi).collect{|val| val.sin};
a.asciiPlot;
#+END_SRC

::
** CLASS::Association
summary::relate two objects
categories::Collections

DESCRIPTION::
Associates a key with a value.
Associations can be created via the -> operator which is defined in class link::Classes/Object::.

Associations are used internally in link::Classes/Dictionary::.

CLASSMETHODS::

method::new
Create an Association between two objects.
code::
#+BEGIN_SRC sclang
(
x = 'name' -> 100;
x.postln;
)
#+END_SRC

::
argument::key
any object
argument::value
any object

INSTANCEMETHODS::

subsection::Accessing

method::key
the key object.

method::value
the value object.

subsection::Testing

method::==
Compare the keys of two Associations.

method::<
Compare the keys of two Associations.

method::hash
Compute the hash value of the Association.

subsection::Writing to streams

method::printOn
Write a string representation to the stream.

method::storeOn
Write a compileable string representation to the stream.

EXAMPLES::

code::
#+BEGIN_SRC sclang
// associations can be a good way to store named data in order:
(
a = [\x -> 700, \y -> 200, \z -> 900];

fork {
	a.do { |assoc|
		assoc.key.postln;
		assoc.value.postln;
		(freq: assoc.value).play;
		2.wait;
	}
};
)
#+END_SRC

::
** class:: AudioIn                                                  :ugen:io:
summary:: Read audio input.
related:: Classes/In, Classes/SoundIn
categories::  UGens>InOut


Description::

Reads audio from the sound input hardware.

note::
This is provided for backwards compatibility with SC2 code. For normal use link::Classes/SoundIn::, which has bus numbers beginning at 0, as AudioIn may be deprecated and removed at some point in the future.
::

classmethods::

method::ar

argument::channel

Input channel number to read. Channel numbers begin at 1.

argument::mul

argument::add

Examples::
Patching input to output
code::
#+BEGIN_SRC sclang
// patching input to output

// watch the feedback

(
SynthDef("help-AudioIn",{ arg out=0;
	Out.ar(out,
		AudioIn.ar(1)
	)
}).play;
)
#+END_SRC

::
Stereo through patching from input to output
code::
#+BEGIN_SRC sclang
// stereo through patching from input to output

// watch the feedback

(
SynthDef("help-AudioIn",{ arg out=0;
	Out.ar(out,
		AudioIn.ar([1,2])
	)
}).play;
)
#+END_SRC

::

** class:: BAllPass                                            :ugen:filters:
summary:: All Pass Filter
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::
method:: ar
argument:: in
input signal to be processed.
argument:: freq
center frequency.
argument:: rq
the reciprocal of Q. bandwidth / cutoffFreq.
argument:: mul
argument:: add

examples::
code::
#+BEGIN_SRC sclang
s.boot;
(
z = { // thru
BAllPass.ar(
	SoundIn.ar([0, 1]),
	MouseX.kr(10, 18000, \exponential),
	0.8, // rq
	0.5); // mul
}.play)
z.release;

(
z = { // like a bandpass
	var sig;
	sig = SoundIn.ar([0,1]), * 0.5;
	BAllPass.ar(sig, MouseX.kr(10, 18000, \exponential), 0.8) + sig.neg
}.play)
z.release;
#+END_SRC

::
** class:: BBandPass                                           :ugen:filters:
summary:: Band Pass Filter
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
center frequency.
argument:: bw
the bandwidth in octaves between -3 dB frequencies.
argument:: mul
argument:: add

examples::
code::
#+BEGIN_SRC sclang
s.boot;
(
z = {
BBandPass.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(20, 20000, \exponential),
	MouseY.kr(0.0, 10.0, \linear), // bw
	0.5); // mul
}.play)
z.release;

(
z = {
BBandPass.ar(
	WhiteNoise.ar ! 2,
	MouseX.kr(20, 20000, \exponential),
	MouseY.kr(0.0, 10.0, \linear), // bw
	0.5); // mul
}.play)
z.release;
#+END_SRC

::
** class:: BBandStop                                           :ugen:filters:
summary:: Band reject filter
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
center frequency.
argument:: bw
the bandwidth in octaves between -3 dB frequencies.
argument:: mul
argument:: add

examples::
code::
#+BEGIN_SRC sclang
s.boot;
(
z = {
BBandStop.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(20, 20000, \exponential),
	MouseY.kr(0.0, 10.0, \linear), // bw
	0.5); // mul
}.play)
z.release;

(
z = {
BBandStop.ar(
	WhiteNoise.ar ! 2,
	MouseX.kr(20, 20000, \exponential),
	MouseY.kr(0.0, 10.0, \linear), // bw
	0.1); // mul
}.play)
z.release;

(
z = { // drill...
BBandStop.ar(
	SinOsc.ar(1000) ! 2,
	MouseX.kr(800, 1200, \exponential),
	MouseY.kr(0.0, 10.0, \linear), // bw
	0.1); // mul
}.play)
z.release;

(
z = { // nada
BBandStop.ar(
	SinOsc.ar(1000) ! 2,
	1000,
	MouseY.kr(0.0, 10.0, \linear), // bw
	0.5); // mul
}.play)
z.release;
#+END_SRC

::
** class:: BEQSuite                                            :ugen:filters:
summary:: Base class for B Equalization Suite
categories:: UGens>Filters>BEQSuite

description::

definitionList::
## link::Classes/BLowPass:: || 12dB/oct rolloff - 2nd order resonant Low Pass Filter
## link::Classes/BLowPass4:: || 24dB/oct rolloff - 4th order resonant Low Pass Filter (pseudo UGen)
## link::Classes/BHiPass:: || 12dB/oct rolloff - 2nd order resonant Hi Pass Filter
## link::Classes/BHiPass4:: || 24dB/oct rolloff - 4th order resonant Hi Pass Filter (pseudo UGen)
## link::Classes/BPeakEQ:: || Parametric Equalizer
## link::Classes/BLowShelf:: || Low resonant Shelf
## link::Classes/BHiShelf:: || High resonant Self
## link::Classes/BBandPass:: || Band Pass Filter
## link::Classes/BBandStop:: || Band Reject Filter
## link::Classes/BAllPass:: || All Pass Filter
::

The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

SC3 port and coding - blackrain 06.17.2005

SC3 plugin UGens - Joshua Parmenter 06.22.2005

Some ideas from emphasis::"Cookbook formulae for audio EQ biquad filter coefficients":: by Robert Bristow-Johnson.

** class:: BHiPass                                             :ugen:filters:
summary:: 12db/oct rolloff - 2nd order resonant  Hi Pass Filter
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
cutoff frequency.
argument:: rq
the reciprocal of Q.  bandwidth / cutoffFreq.
argument:: mul
argument:: add

method:: sc
calculate filter coefficients.

examples::
code::
#+BEGIN_SRC sclang
s.boot;
(
z = {
	BHiPass.ar(
		SoundIn.ar([0,1]),
		MouseX.kr(10, 20000, \exponential), // cutoff freq.
		MouseY.kr(0.0, 1.0, \linear), // rq
		0.5); // mul
}.play
)
z.release;
#+END_SRC

::
** class:: BHiPass4                                            :ugen:filters:
summary:: 24db/oct rolloff - 4th order resonant  Hi Pass Filter [1]
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

[1] this is a pseudo link::Classes/UGen::. BHiPass4 is built by cascading 2 link::Classes/SOS:: sections.

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
cutoff frequency.
argument:: rq
the reciprocal of Q.  bandwidth / cutoffFreq.
argument:: mul
argument:: add

examples::
code::
#+BEGIN_SRC sclang
s.boot;
(
z = {
	BHiPass4.ar(
		SoundIn.ar([0,1]),
		MouseX.kr(10, 20000, \exponential), // cutoff freq.
		MouseY.kr(0.1, 1.0, \linear), // rq
		0.5); // mul
}.play)
z.release;
#+END_SRC

::
** class:: BHiShelf                                            :ugen:filters:
summary:: Hi Shelf
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
center frequency.
argument:: rs
the reciprocal of S. Shell boost/cut slope. When S = 1, the shelf slope is as steep as it can be and remain monotonically increasing or decreasing gain with frequency. The shelf slope, in dB/octave, remains proportional to S for all other values for a fixed code::freq/SampleRate.ir:: and code::db::.
argument:: db
gain. boost/cut the center frequency in dBs.
argument:: mul
argument:: add

examples::
code::
#+BEGIN_SRC sclang
s.boot;
(
z = { // toy around with boost/cut
BHiShelf.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(2200, 18000, \exponential),
	1.0, // rs
	MouseY.kr(18.0, -18.0, \linear),
	0.5); // mul
}.play)
z.release;

(
z = { // toy around with rs
BHiShelf.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(2200, 18000, \exponential),
	MouseY.kr(0.1, 1.0, \linear), // rs
	6, // db
	0.5); // mul
}.play)
z.release;
#+END_SRC

::
** class:: BLowPass                                            :ugen:filters:
summary:: 12db/oct rolloff - 2nd order resonant Low Pass Filter
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
cutoff frequency.
argument:: rq
the reciprocal of Q. bandwidth / cutoffFreq.
argument:: mul
argument:: add

method:: sc
calculate filter coefficients.

examples::
code::
#+BEGIN_SRC sclang
s.boot;
(
z = {
	BLowPass.ar(
		SoundIn.ar([0,1]),
		MouseX.kr(10, 20000, \exponential), // cutoff freq.
		MouseY.kr(0.0, 1.0, \linear), // rq
		0.5); // mul
}.play
)
z.release;
#+END_SRC

::
** class:: BLowPass4                                           :ugen:filters:
summary:: 24db/oct rolloff - 4th order resonant Low Pass Filter [1]
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

[1] this is a composite pseudo link::Classes/UGen::. BLowPass4 is built by cascading 2 link::Classes/SOS:: sections.

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
cutoff frequency.
argument:: rq
the reciprocal of Q. bandwidth / cutoffFreq.
argument:: mul
argument:: add

examples::
code::
#+BEGIN_SRC sclang
s.boot;
(
z = {
	BLowPass4.ar(
		SoundIn.ar([0,1]),
		MouseX.kr(10, 20000, \exponential), // cutoff freq.
		MouseY.kr(0.1, 1.0, \linear), // rq - compensate for 2 biquad sections.
		0.5); // mul
}.play)
z.release;
#+END_SRC

::
** class:: BLowShelf                                           :ugen:filters:
summary:: Low Shelf
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
center frequency.
argument:: rs
the reciprocal of S. Shell boost/cut slope. When S = 1, the shelf slope is as steep as it can be and remain monotonically increasing or decreasing gain with frequency. The shelf slope, in dB/octave, remains proportional to S for all other values for a fixed code::freq/SampleRate.ir:: and code::db::.
argument:: db
gain. boost/cut the center frequency in dBs.
argument:: mul
argument:: add

examples::
code::
#+BEGIN_SRC sclang
s.boot;
(
z = { // toy around with boost/cut
BLowShelf.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(40, 6000, \exponential),
	1.0, // rs
	MouseY.kr(24.0, -24.0, \linear),
	0.5); // mul
}.play)
z.release;

(
z = { // toy around with rs
BLowShelf.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(20, 6000, \exponential),
	MouseY.kr(0.1, 1.0, \linear), // rs
	6,
	0.5); // mul
}.play)
z.release;
#+END_SRC

::
** class:: BPF                                                 :ugen:filters:
summary:: 2nd order Butterworth bandpass filter.
related:: Classes/BRF, Classes/HPF, Classes/LPF
categories::  UGens>Filters>Linear


Description::

A second order band pass filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Centre frequency in Hertz.


argument::rq

The reciprocal of Q. Q is conventionally defined as cutoffFreq / bandwidth, meaning rq = (bandwidth / cutoffFreq).

argument::mul

argument::add

Examples::

code::
#+BEGIN_SRC sclang
{ BPF.ar(Saw.ar(200,0.5), FSinOsc.kr(XLine.kr(0.7,300,20),0,3600,4000), 0.3) }.play;

{ BPF.ar(Saw.ar(200,0.5), MouseX.kr(100, 10000, 1), 0.3) }.play;

	// BPF on control signals:
(
{ 	var vib = BPF.kr(PinkNoise.kr, MouseX.kr(1, 100, 1), 0.3) * 10;
	SinOsc.ar(vib * 200 + 600) * 0.2 }.play;
)
#+END_SRC

::

** class:: BPZ2                                                :ugen:filters:
summary:: Two zero fixed midpass.
related:: Classes/BRZ2, Classes/HPZ2, Classes/LPZ2
categories::  UGens>Filters>Linear


Description::

A special case fixed filter. Implements the formula:

code::
#+BEGIN_SRC sclang
out(i) = 0.5 * (in(i) - in(i - 2)).
#+END_SRC

::

This filter cuts out 0 Hz and the Nyquist frequency.


classmethods::

method::ar, kr

argument::in

The input signal.

Examples::

code::
#+BEGIN_SRC sclang
//Compare:

{ WhiteNoise.ar(0.25) }.play;

{ BPZ2.ar(WhiteNoise.ar(0.25)) }.play;
#+END_SRC

::

** class:: BPeakEQ                                             :ugen:filters:
summary:: Parametric equalizer
categories:: UGens>Filters>BEQSuite
related:: Classes/SOS, Classes/BLowPass, Classes/BLowPass4, Classes/BHiPass, Classes/BHiPass4, Classes/BPeakEQ, Classes/BLowShelf, Classes/BHiShelf, Classes/BBandPass, Classes/BBandStop, Classes/BAllPass

description::
The B equalization suite is based on the Second Order Section (link::Classes/SOS::) biquad UGen.

note::
Biquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.
::

classmethods::

method:: ar
argument:: in
input signal to be processed.
argument:: freq
center frequency.
argument:: rq
the reciprocal of Q. bandwidth / cutoffFreq.
argument:: db
boost/cut the center frequency (in dBs).
argument:: mul
argument:: add

examples::
code::
#+BEGIN_SRC sclang
s.boot;
(
z = { // toy with boost/cut
BPeakEQ.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(20, 20000, \exponential),
	0.8, // rq
	MouseY.kr(12.0, -12.0, \linear),
	0.5); // mul
}.play)
z.release;

(
z = { // toy with rq
BPeakEQ.ar(
	SoundIn.ar([0,1]),
	MouseX.kr(20, 20000, \exponential),
	MouseY.kr(10, 0.4, \linear), // rq
	6, // boost/cut - +6dB
	0.5); // mul
}.play)
z.release;
#+END_SRC

::
** class:: BRF                                                 :ugen:filters:
summary:: 2nd order Butterworth band reject filter.
related:: Classes/BPF, Classes/HPF, Classes/LPF
categories::  UGens>Filters>Linear


Description::

A second order band reject filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Cutoff frequency in Hertz.


argument::rq

The reciprocal of Q (bandwidth / cutoffFreq).


Examples::

code::
#+BEGIN_SRC sclang
{ BRF.ar(Saw.ar(200,0.1), FSinOsc.kr(XLine.kr(0.7,300,20),0,3800,4000), 0.3) }.play;

{ BRF.ar(Saw.ar(200,0.5), MouseX.kr(100, 10000, 1), 0.3) }.play;


	// BRF on control signals:
(
{ 	var vib = BRF.kr(SinOsc.kr([1, 3, 10], 0, [1, 0.5, 0.25]).sum, MouseX.kr(1, 10, 1), 0.3);
	SinOsc.ar(vib * 200 + 600) * 0.2 }.play;
)
#+END_SRC

::

** class:: BRZ2                                                :ugen:filters:
summary:: Two zero fixed midcut.
related:: Classes/BPZ2, Classes/HPZ2, Classes/LPZ2
categories::  UGens>Filters>Linear


Description::

A special case fixed filter. Implements the formula:

code::
#+BEGIN_SRC sclang
out(i) = 0.5 * (in(i) + in(i - 2)).
#+END_SRC

::


This filter cuts out frequencies around ½ of the Nyquist frequency.


classmethods::

method::ar, kr

argument::in

The input signal.


Examples::

code::
#+BEGIN_SRC sclang
//Compare:

{ WhiteNoise.ar(0.25) }.play;

{ BRZ2.ar(WhiteNoise.ar(0.25)) }.play;
#+END_SRC

::

** CLASS::Bag
summary::Unordered collection of objects
related::Classes/IdentityBag, Classes/Set
categories::Collections>Unordered

DESCRIPTION::
A Bag is an unordered collection of objects. In some languages it is referred to as a counted set. A Bag keeps track of the number of times objects are inserted and requires that objects be removed the same number of times. There is only one instance of an object in a Bag even if the object has been added to the Bag multiple times (test is for strong::equality::)

Most of Bag's methods are inherited from Collection.
The contents of a Bag are unordered. You must not depend on the order of items in a set.

CLASSMETHODS::

method::new
Creates a Bag with an initial capacity for strong::n:: objects.

INSTANCEMETHODS::

private::setDictionary

method::contents
Returns the dictionary that stores the objects in pairs (obj -> numberOfObjects)
code::
#+BEGIN_SRC sclang
Bag["a", "b", "c", "c"].contents;
#+END_SRC

::
returns:: link::Classes/Dictionary::

method::itemCount
Count the number of strong::item::s.
code::
#+BEGIN_SRC sclang
Bag[1, 2, 2, 3, 300, 2].itemCount(2);
#+END_SRC

::

subsection::Adding and Removing

method::add
Add an object to the Bag. A Bag may contain multiple entries of the same object.
code::
#+BEGIN_SRC sclang
Bag[1, 2, 3].add(4).postln;

Bag[1, 2, 3].add(3).postln;

Bag["abc", "def", "ghi"].add("jkl").postln;

Bag["abc", "def", "ghi"].add("def").postln;
#+END_SRC

::

method::remove
Remove an object from the Bag.
code::
#+BEGIN_SRC sclang
Bag[1, 2, 3].remove(3).postln;
#+END_SRC

::

subsection::Iteration

method::do
Evaluates strong::function:: for each item in the Bag.
The function is passed two arguments, the item and an integer index.
code::
#+BEGIN_SRC sclang
Bag[1, 2, 3, 300].do({ arg item, i; item.postln });

Bag[1, 2, 2, 3, 300].do({ arg item, i; item.postln });
#+END_SRC

::
argument::function
args to function: item, i

method::countsDo
Evaluates strong::function:: for each unique item in the Bag along with that item's count.
The function is passed two arguments, the item, the quantity of that item in the Bag and an integer index.
code::
#+BEGIN_SRC sclang
Bag[1, 2, 3, 300].countsDo({ arg item, count, i; [item,count].postln });

Bag[1, 2, 2, 3, 300].countsDo({ arg item, count, i; [item,count].postln });
#+END_SRC

::

subsection::Testing

method::includes
Answer whether an object is contained in the Bag.
code::
#+BEGIN_SRC sclang
Bag[1, 2, 3, 4].includes(3);
#+END_SRC

::
returns:: link::Classes/Boolean::

EXAMPLES::

subsection::Difference between Bag and IdentityBag:
code::
#+BEGIN_SRC sclang
// the two strings are equal, but not identical
"something" == "something"; // true
"something" === "something" // false

a = Bag.new;
a.add("something");
a.add("something");
a.contents; // only one object in the bag really

a = IdentityBag.new;
a.add("something");
a.add("something");
a.contents; // two objects in the bag
#+END_SRC

::

** class:: Balance2
summary:: Stereo signal balancer
related:: Classes/LinPan2, Classes/Pan2, Classes/Pan4, Classes/PanAz
categories::  UGens>Multichannel>Panners


Description::

Equal power panning balances two channels; by panning, you are favouring one or other channel in the mix, and the other loses power.

classmethods::
private:: categories

method::ar, kr

argument::left
channel 1 of input stereo signal

argument::right
channel 2 of input stereo signal

argument::pos
pan position, -1 is left, +1 is right

argument::level
a control rate level input.

discussion::
The middle pan position (pos=0.0) corresponds to the original stereo mix; full left (pos of -1) is essentially just left channel playing, full right (pos of 1) just the right. The output of Balance2 remains a stereo signal.

Examples::
code::
#+BEGIN_SRC sclang
{Balance2.ar(LFSaw.ar(44),Pulse.ar(33),FSinOsc.kr(0.5), 0.1) }.play;

{var source; source= SinOsc.ar([440,550]); Balance2.ar(source[0],source[1],LFNoise0.kr(4),0.3) }.play;
#+END_SRC

::

** class:: Ball
summary:: physical model of bouncing object
categories:: UGens>Filters>Nonlinear, UGens>Generators>PhysicalModels
related:: Classes/TBall, Classes/Spring

Description::
Ball models the path of a bouncing object that is reflected by a vibrating surface.

classmethods::
private:: categories

method:: ar, kr

argument::in
modulated surface level

argument::g
gravity

argument::damp
damping on impact

argument::friction
proximity from which on attraction to surface starts

examples::
mouse x controls switch of level:
code::
#+BEGIN_SRC sclang
(
{
	var f, sf;
	sf = K2A.ar(MouseX.kr > 0.5) > 0;
	f = Ball.ar(sf, MouseY.kr(0.01, 20, 1), 0.01);
	f = f * 10 + 500;
	SinOsc.ar(f, 0, 0.2)
}.play;
)
#+END_SRC

::

mouse x controls modulation rate, mouse y controls gravity:
code::
#+BEGIN_SRC sclang
(
{
	var f, sf, g;
	sf = LFNoise0.ar(MouseX.kr(1, 100, 1));
	g = MouseY.kr(0.1, 10, 1);
	f = Ball.ar(sf, g, 0.01, 0.01);
	f = f * 140 + 500;
	SinOsc.ar(f, 0, 0.2)
}.play;
)
#+END_SRC

::

the general german police choir. mouse x controls damping, mouse y controls gravity:
code::
#+BEGIN_SRC sclang
(
{
	var f, sf, g;
	sf = LFPulse.ar(0.6, 0.2, 0.5);
	g = MouseY.kr(0.1, 10, 1);
	d = MouseX.kr(0.0001, 1, 1);
	f = Ball.ar(sf, g, d);
	f = f * 140 + 400;
	SinOsc.ar(f, 0, 0.2)
}.play;
)
#+END_SRC

::

** class:: BasicOpUGen
summary:: Common superclass to operations on UGen
categories:: UGens>Algebraic
related:: Classes/UnaryOpUGen, Classes/BinaryOpUGen, Overviews/Operators

description::
Common superclass to operations on UGens

instancemethods::

method::operator
set or get the operator

** class:: BeatTrack
summary:: Autocorrelation beat tracker
categories:: UGens>Analysis, UGens>FFT
related:: Classes/BeatTrack2

description::
Autocorrelation based beat tracker; footnote::
Research note: This UGen is a derivation following:
Davies, M. E. P.  and Plumbley, M. D. Beat Tracking With A Two State Model. Proceedings of the IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP 2005), Philadelphia, USA, March 19-23, 2005

The UGen was converted by Nick Collins for beat tracking research in the course of his PhD and uses an original C implementation of Matthew Davies' MATLAB model. It first appeared as part of BBCut2 as AutoTrack but has now been added to core to enhance SuperCollider's realtime machine listening options.
:: the underlying model assumes 4/4, but it should work on any isochronous beat structure, though there are biases to 100-120 bpm; a fast 7/8 may not be tracked in that sense.
There are four k-rate outputs, being ticks at quarter, eighth and sixteenth level from the determined beat, and the current detected tempo. Note that the sixteenth note output won't necessarily make much sense if the music being tracked has swing; it is provided just as a convenience.

This beat tracker determines the beat, biased to the midtempo range by weighting functions. It does not determine the measure level, only a tactus.
It is also slow reacting, using a 6 second temporal window for its autocorrelation maneouvres. Don't expect human musician level predictive tracking.

On the other hand, it is tireless, relatively general (though obviously best at transient 4/4 heavy material without much expressive tempo variation), and can form the basis of computer processing that is decidedly faster than human.

classmethods::
private:: categories

method:: kr

argument:: chain
[fft] Audio input to track, already passed through an FFT UGen; the expected size of FFT is 1024 for 44100 and 48000 sampling rate, and 2048 for double those. No other sampling rates are supported.
argument:: lock
[sk] If this argument is greater than 0.5, the tracker will lock at its current periodicity and continue from the current phase. Whilst it updates the model's phase and period, this is not reflected in the output until lock goes back below 0.5.
returns::
Four k-rate outputs:
code::
#+BEGIN_SRC sclang
#quarternotetick, eighthnotetick, sixteenthnotetick, tempo = BeatTrack.kr(chain, 0)
#+END_SRC

::

instancemethods::
private:: init

examples::

code::
#+BEGIN_SRC sclang
b = Buffer.alloc(s,1024,1); //for sampling rates 44100 and 48000
//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000

//this is a one minute pop song; you should load something equivalent for testing
d=Buffer.read(s,"/Volumes/data/stevebeattrack/samples/100.wav");


//you can also test at 48000 and it should work
(
a= SynthDef(\help_beattrack,{arg vol=1.0, beepvol=1.0, lock=0;
var in, fft, resample;
var trackb,trackh,trackq,tempo;
var bsound,hsound,qsound, beep;

in= PlayBuf.ar(1,d,BufRateScale.kr(d),1,0,1);
//in = SoundIn.ar(0);

fft = FFT(b, in);

#trackb,trackh,trackq,tempo=BeatTrack.kr(fft, lock);

beep= SinOsc.ar(1000,0.0,Decay.kr(trackb,0.1));

Out.ar(0,Pan2.ar((vol*in)+(beepvol*beep),0.0));
}).play
)

a.set(\vol,0.0);
a.set(\vol,1.0);

a.set(\beepvol,1.0);
a.set(\beepvol,0.0);

a.set(\lock,1); //fix it rigidly from current phase/period solution
a.set(\lock,0); //unfix, back to tracking
#+END_SRC

::

track audio in (try clapping a beat or beatboxing, but allow up to 6 seconds for tracking to begin) and spawning stuff at quarters, eighths and sixteenths:
code::
#+BEGIN_SRC sclang
(
SynthDef(\help_beattrack2,{
var trackb,trackh,trackq,tempo;
var source;
var bsound,hsound,qsound;

source= SoundIn.ar(0);

#trackb,trackh,trackq,tempo=BeatTrack.kr(FFT(b, source));

bsound= Pan2.ar(LPF.ar(WhiteNoise.ar*(Decay.kr(trackb,0.05)),1000),0.0);

hsound= Pan2.ar(BPF.ar(WhiteNoise.ar*(Decay.kr(trackh,0.05)),3000,0.66),-0.5);

qsound= Pan2.ar(HPF.ar(WhiteNoise.ar*(Decay.kr(trackq,0.05)),5000),0.5);

Out.ar(0, bsound+hsound+qsound);
}).play;
)
#+END_SRC

::

** class:: BeatTrack2
summary:: Template matching beat tracker
categories:: UGens>Analysis, UGens>FFT
related:: Classes/BeatTrack

description::
This beat tracker footnote::
Research note: Designed by Nick Collins following work by Jean Laroche
:: is based on exhaustively testing particular template patterns against feature streams; the testing takes place every 0.5 seconds. The two basic templates are a straight (groove=0) and a swung triplet (groove=1) pattern of 16th notes; this pattern is tried out at scalings corresponding to the tempi from 60 to 180 bpm.
This is the cross-corellation method of beat tracking. A majority vote is taken on the best tempo detected, but this must be confirmed by a consistency check after a phase estimate. Such a consistency check helps to avoid wild fluctuating estimates, but is at the expense of an additional half second delay.
The latency of the beat tracker with default settings is thus at least 2.5 seconds; because of block-based amortisation of calculation, it is actually around 2.8 seconds latency for a 2.0 second temporal window.

This beat tracker is designed to be flexible for user needs; you can try out different window sizes, tempo weights and combinations of features. However, there are no guarantees on stability and effectiveness, and you will need to explore such parameters for a particular situation.

classmethods::
private:: categories

method:: kr

argument:: busindex
[sk] Audio input to track, already analysed into N features, passed in via a control bus number from which to retrieve consecutive streams.

argument:: numfeatures
[s] How many features (ie how many control buses) are provided

argument:: windowsize
[s] Size of the temporal window desired (2.0 to 3.0 seconds models the human temporal window). You might use longer values for stability of estimate at the expense of reactiveness.

argument:: phaseaccuracy
[s] Relates to how many different phases to test. At the default, 50 different phases spaced by phaseaccuracy seconds would be tried out for 60bpm; 16 would be trialed for 180 bpm. Larger phaseaccuracy means more tests and more CPU cost.

argument:: lock
[sk] If this argument is greater than 0.5, the tracker will lock at its current periodicity and continue from the current phase. Whilst it updates the model's phase and period, this is not reflected in the output until lock goes back below 0.5.

argument:: weightingscheme
[s] Use (-2.5) for flat weighting of tempi, (-1.5) for compensation weighting based on the number of events tested (because different periods allow different numbers of events within the temporal window) or otherwise a bufnum from 0 upwards for passing an array of 120 individual tempo weights; tempi go from 60 to 179 bpm in steps of one bpm, so you must have a buffer of 120 values.

returns::
Six k-rate outputs:
code::
#+BEGIN_SRC sclang
#beattick, eighthtick, groovetick, tempo, phase, groove = BeatTrack2.kr(busindex, numfeatures)
#+END_SRC

::

instancemethods::
private:: init

examples::

code::
#+BEGIN_SRC sclang
//required for MFCCs used below
b = Buffer.alloc(s,1024,1); //for sampling rates 44100 and 48000
//b = Buffer.alloc(s,2048,1); //for sampling rates 88200 and 96000

//this is a one minute pop song; you should load something equivalent for testing
d=Buffer.read(s,"/Volumes/data/stevebeattrack/samples/100.wav");
d=Buffer.read(s,"/Volumes/data/stevebeattrack/samples/019.wav");


//very feature dependent
(
a= SynthDef(\help_beattrack2_1,{arg vol=1.0, beepvol=1.0, lock=0;
var in, kbus;
var trackb,trackh,trackq,tempo, phase, period, groove;
var bsound,hsound,qsound, beep;
var fft;
var feature1, feature2, feature3;

in= PlayBuf.ar(1,d.bufnum,BufRateScale.kr(d.bufnum),1,0,1);
//in = SoundIn.ar(0);

//Create some features
fft = FFT(b.bufnum, in);

feature1= RunningSum.rms(in,64);
feature2= MFCC.kr(fft,2); //two coefficients
feature3= A2K.kr(LPF.ar(in,1000));

kbus= Out.kr(0, [feature1, feature3]++feature2);

//Look at four features
#trackb,trackh,trackq,tempo, phase, period, groove=BeatTrack2.kr(0,4,2.0, 0.02, lock, -2.5);

beep= SinOsc.ar(1000,0.0,Decay.kr(trackb,0.1));

Out.ar(0,Pan2.ar((vol*in)+(beepvol*beep),0.0));
}).play
)


a.set(\vol,0.0);
a.set(\vol,1.0);

a.set(\beepvol,1.0);
a.set(\beepvol,0.0);

a.set(\lock,1); //fix it rigidly from current phase/period solution
a.set(\lock,0); //unfix, back to tracking

a.free;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
//same thing, trying with Onsets UGen raw output
(
a= SynthDef(\help_beattrack2_1,{arg vol=1.0, beepvol=1.0, lock=0;
var in, kbus;
var trackb,trackh,trackq,tempo, phase, period, groove;
var bsound,hsound,qsound, beep;
var fft;
var feature1, feature2, feature3;

in= PlayBuf.ar(1,d.bufnum,BufRateScale.kr(d.bufnum),1,0,1);
//in = SoundIn.ar(0);

//Create some features
fft = FFT(b.bufnum, in);

feature1= Onsets.kr(fft,odftype:\mkl, rawodf:1);

feature2= Onsets.kr(fft,odftype:\complex, rawodf:1);//two coefficients

kbus= Out.kr(0, [feature1,feature2]);

//Look at four features
#trackb,trackh,trackq,tempo, phase, period, groove=BeatTrack2.kr(0,2,3.0, 0.02, lock, -2.5);

beep= SinOsc.ar(1000,0.0,Decay.kr(trackb,0.1));

Out.ar(0,Pan2.ar((vol*in)+(beepvol*beep),0.0));
}).play
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
//favour higher tempi in own weighting scheme
(
c=Array.fill(120,{arg i; 0.5+(0.5*(i/120))});
e=Buffer.sendCollection(s, c, 1);
)
#+END_SRC

::

track audio in (try clapping a beat or beatboxing, but allow up to 6 seconds for tracking to begin) and spawning stuff at quarters, eighths and sixteenths
code::
#+BEGIN_SRC sclang
(
SynthDef(\help_beattrack2_2,{
var trackb,trackh,trackq,tempo;
var source, kbus;
var bsound,hsound,qsound;

source= SoundIn.ar(0); //PlayBuf.ar(1,d.bufnum,BufRateScale.kr(d.bufnum),1,0,1);

//downsampling automatic via kr from ar
kbus= Out.kr(0, LPF.ar(source,1000)); //([feature1, feature3]++feature2);

#trackb,trackh,trackq,tempo=BeatTrack2.kr(0,1,weightingscheme:e.bufnum);

bsound= Pan2.ar(LPF.ar(WhiteNoise.ar*(Decay.kr(trackb,0.05)),1000),0.0);

hsound= Pan2.ar(BPF.ar(WhiteNoise.ar*(Decay.kr(trackh,0.05)),3000,0.66),-0.5);

qsound= Pan2.ar(HPF.ar(WhiteNoise.ar*(Decay.kr(trackq,0.05)),5000),0.5);

Out.ar(0, source + bsound+hsound+qsound);
}).play;
)
#+END_SRC

::

geometric tempo placement very similar to linear, and linear easier to deal with looking up related tempi at double and half speed
code::
#+BEGIN_SRC sclang
(
var startbps= 1, endbps=3;
var numtempi=100;
var ratio;
var tempi, periods;

ratio= (endbps/startbps)**((numtempi-1).reciprocal);

tempi= Array.geom(numtempi, startbps, ratio);

periods= tempi.reciprocal;

Post << (tempi*60) << nl;
Post << periods << nl;
)

//create linear periods
Post << ((Array.series(120,1,2/120)).reciprocal) << nl;

//tempo weights
 Post << (Array.fill(120,{arg i;  0.2*((1.0- ((abs(i-60))/60.0))**0.5) + 0.8; })) << nl;
#+END_SRC

::

** class:: BendResponder
summary:: allow functions to be registered to respond to MIDI pitchbend events
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIResponder, Classes/CCResponder
categories:: External Control>MIDI

Description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. They still lack some features of the MIDIresponder classes.::

ClassMethods::

method::new

argument::function
A link::Classes/Function:: to be evaluated. Arguments passed to the function are: src, chan, value.

argument::src
The src number may be the system UID (obtained from code:: MIDIClient.sources[index].uid ::) or the index of the source in the code:: MIDIClient.sources :: array. nil matches all.

argument::chan
An link::Classes/Integer:: between 0 and 15 that selects which MIDI channel to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 2 }

argument::value
An link::Classes/Integer:: between 0 and 16383 to filter values. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 50 }

argument::install
If true, install the responder automatically so it is active and ready to respond. If false, then it will be inactive.

argument::swallowEvent
If true, then if the midi event is matched, cease testing any further responders. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

InstanceMethods::

method::learn
Wait for the next pitch bend message, reset self to match src, chan.
code::
#+BEGIN_SRC sclang
(
c = BendResponder({ |src,chan,value|
		[src,chan,value].postln;
	});
	c.learn; // wait for the first bend message
)
BendResponder.removeAll
#+END_SRC

::


Examples::

code::
#+BEGIN_SRC sclang
(
	c = BendResponder({ |src,chan,val|
		[src,chan,val].postln;
		},
		nil, // any source
		nil, // any channel
		nil // any value
	)
)

c.remove
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
	c = BendResponder({ |src,chan,val|
		[src,chan,val].postln;
		},
		nil, // any source
		(3..6), // only channels 3 - 6
		nil // any value
	)
)

c.remove
#+END_SRC

::
** class:: BiPanB2
summary:: 2D Ambisonic B-format panner.
related:: Classes/DecodeB2, Classes/PanB, Classes/PanB2, Classes/Rotate2
categories::  UGens>Multichannel>Ambisonics


Description::

Encode a two channel signal to two dimensional ambisonic B-format. This
puts two channels at opposite poles of a 2D ambisonic field. This is one
way to map a stereo sound onto a soundfield. It is equivalent to:

code::
#+BEGIN_SRC sclang
PanB2(inA, azimuth, gain) + PanB2(inB, azimuth + 1, gain)
#+END_SRC

::

classmethods::

method::ar, kr

argument::inA
Input signal A

argument::inB
Input signal B.

argument::azimuth
Position around the circle from -1 to +1.

-1 is behind, -0.5 is left, 0 is forward, +0.5 is right, +1 is behind.

argument::gain
Amplitude control.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	var w, x, y, p, q, a, b, c, d;

	p = LFSaw.ar(200);
	q = LFSaw.ar(301);

	// B-format encode
	#w, x, y = BiPanB2.ar(p, q, MouseX.kr(-1,1), 0.1);

	// B-format decode to quad
	#a, b, c, d = DecodeB2.ar(4, w, x, y);

	[a, b, d, c] // reorder to my speaker arrangement: Lf Rf Lr Rr
}.play;
)
#+END_SRC

::

** class:: BinaryOpFunction
summary:: represent a binary operation on a function
categories:: Core
related:: Classes/UnaryOpFunction,Classes/NAryOpFunction,Classes/BinaryOpStream,Classes/Pbinop

description::

Operating on functions instead of numbers, what results is not a result of the calculation, but a structure that represents that calculation.

instanceMethods::

private::storeOn

method::value

Executes each of the operand functions and then performs the selector on the result.

method::valueArray

the same as link::#-value::

examples::

code::
#+BEGIN_SRC sclang
// example
a = 5 + 7; // result is 12.
a = { b } + 7; // result is  a BinaryOpFunction
b = 5;
a.value; // now it is evaluated, and the result is calculated
b = 8;
a.value; // again, with a different value.
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// sound example
(
var a = { 19.rand };
var b = { [5, 8, 9].choose };
var c = a + b;
fork {
	15.do {
		(instrument: \default, note: [c.value, a.value]).play;
		0.3.wait;
	}
}
)
#+END_SRC

::
** class:: BinaryOpStream
summary:: two streams combined by a binary operator
related:: Classes/UnaryOpStream, Classes/NAryOpStream
categories:: Streams-Patterns-Events

description::

A BinaryOpStream is created as a result of a binary math operation on a pair of Streams. It is defined to respond to strong::next:: by returning the result of the math operation on the strong::next:: value from both streams. It responds to strong::reset:: by resetting both Streams.

Examples::

code::
#+BEGIN_SRC sclang
x = Routine { 6.do { arg i; i.yield; } } + 64;
x.dump
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
x = Routine { 6.do { arg i; i.yield; } } + 64;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
x = Routine { 6.do { arg i; i.yield; } } + Routine { (1..7).do { arg i; (1 / i).yield; } };
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
)
#+END_SRC

::
** class:: BinaryOpUGen
summary:: Apply a binary operation to the values of an input UGen
related:: Classes/UnaryOpUGen, Classes/BinaryOpFunction, Classes/Pbinop, Overviews/Operators
categories:: UGens>Algebraic

description::
BinaryOpUGens are created as the result of a binary operator applied to a link::Classes/UGen::.
code::
#+BEGIN_SRC sclang
(SinOsc.ar(200) * ClipNoise.ar).dump;
(SinOsc.ar(200).thresh(0.5)).dump;
#+END_SRC

::
The use of the binary operators code::*:: and code::thresh:: above each instantiate a BinaryOpUGen. The operators themselves  (which are methods) are not to be confused with the resulting BinaryOpUGen (which is an object). The unary and binary operators are defined in link::Classes/UGen::'s superclass link::Classes/AbstractFunction::, which creates the
BinaryOpUGen as a result of the operation.

When operating on UGens instead of numbers, what results is not a result of the calculation, but a structure that represents that calculation. For the immediate operations on numbers, see for example link::Classes/SimpleNumber::.

See link::Overviews/Operators:: for an overview of common operators.

classmethods::
private:: new1

method::new
return a new instance that applies the operator code::selector:: to the UGens code::a:: and code::b:: normally, this is implicitly called when applying an operator to a link::Classes/UGen::.
argument:: selector
The selector symbol for the binary operator
argument:: a
left operand
argument:: b
right operand
returns:: A new instance of BinaryOpUGen

instancemethods::
private:: init, optimizeGraph, constantFolding

examples::

code::
#+BEGIN_SRC sclang
a = WhiteNoise.ar; // a WhiteNoise
b = a + 2; // a BinaryOpUGen.
b.operator; // +

// sound example
(
{
	var a = LFSaw.ar(300);
	var b = LFSaw.ar(329.1);
	a % b * 0.1
}.play;
)
#+END_SRC

::

subsection::The comparison operators

The operators code:: >, >=, <, <= :: are particularly useful for triggering. They should not be confused with their use in conditionals. Compare:

code::
#+BEGIN_SRC sclang
if(1 > 0) { "1 is greater than 0".postln }; // > returns a boolean
#+END_SRC

::

with

code::
#+BEGIN_SRC sclang
// trigger an envelope
(
{
    var trig;
    trig = SinOsc.ar(1) > 0.1;
    EnvGen.kr(Env.perc, trig, doneAction: 0) * SinOsc.ar(440,0,0.1)
}.play
) // > outputs 0 or 1
#+END_SRC

::

See link::Overviews/Operators:: or the implementation of these in link::Classes/AbstractFunction:: for more detail.

Since the equality operator ( code::==:: ) is used to distinguish objects including UGens, it cannot be used to create a BinaryOpUGen by application. Instead, to get a trigger value each time two signals are the same (instead of just finding out whether two UGens are the same), one can instantiate a BinaryOpUGen directly:

code::
#+BEGIN_SRC sclang
(
{
    var a = SinOsc.ar(1).round(0.1);
    var b = SinOsc.ar(1.2).round(0.1);
    BinaryOpUGen('==', a, b) * 0.1
}.play;
)
#+END_SRC

::

** class:: Blip
summary:: Band limited impulse oscillator.
related:: Classes/Impulse
categories::  UGens>Generators>Deterministic


Description::

Band Limited ImPulse generator. All harmonics have equal amplitude.
This is the equivalent of 'buzz' in  emphasis::MusicN:: languages.

emphasis::Synth-O-Matic:: (1990) had an impulse generator
called blip, hence that name here rather than 'buzz'.

It is improved from other implementations in that it will crossfade
in a control period when the number of  harmonics changes,
so that there are no audible pops. It also eliminates the divide in
the formula by using a 1/sin table (with special precautions taken for
1/0).  The lookup tables are linearly interpolated for better quality.

warning::
This waveform in its raw form could be damaging to your ears at high
amplitudes or for long periods.
::

classmethods::

method::ar

argument::freq
Frequency in Hertz.

argument::numharm
Number of harmonics. This may be lowered internally if it would cause aliasing.

argument::mul

argument::add

Examples::

code::
#+BEGIN_SRC sclang
// modulate frequency
{ Blip.ar(XLine.kr(20000,200,6),100,0.2) }.play;

// modulate numharmonics
{ Blip.ar(200,Line.kr(1,100,20),0.2) }.play;
#+END_SRC

::

** class::Boolean
summary:: abstract class whose instances represent a logical value
categories::Core
related:: Reference/Control-Structures

description::
Boolean is the superclass of link::Classes/True:: and link::Classes/False:: which are the concrete realizations.
In code True and False are represented by the literal values code::true:: and code::false::.

instanceMethods::

private:: while
private:: storeOn
private:: trace
private:: printOn
private:: archiveAsCompileString

method::xor

returns:: the exclusive or of the receiver and another Boolean.

method::and

If the receiver is true then answer the evaluation of function.
If the receiver is false then function is not evaluated and the message answers false.

method::or

If the receiver is false then answer the evaluation of function.
If the receiver is true then function is not evaluated and the message answers true.

method::&&

returns:: true if the receiver is true and aBoolean is true.

method::||

returns:: true if either the receiver is true or aBoolean is true.

method::nand

returns:: true unless both the operands are true (Sheffer stroke)

method::not

returns:: true if the receiver is false, and false if the receiver is true.

method::if

If the receiver is true, answer the evaluation of the trueFunc. If the receiver is false, answer the evaluation of the falseFunc.

method::asInteger
method::binaryValue

returns:: 1 if the receiver is true, and 0 if the receiver is false.

method::asBoolean
method::booleanValue
Returns:: The receiver. The same message is understood by link::Classes/SimpleNumber:: and can be used to convert it to boolean.

method::keywordWarnings

turn on/off warnings if a keyword argument is not found


** class:: BrownNoise
summary:: Brown Noise.
related:: Classes/ClipNoise, Classes/GrayNoise, Classes/PinkNoise, Classes/WhiteNoise
categories::  UGens>Generators>Stochastic

Description::
Generates noise whose spectrum falls off in power by 6 dB per octave.

classmethods::

method::ar, kr

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

compare:
code::
#+BEGIN_SRC sclang
{ BrownNoise.ar(0.1) }.play;
{ WhiteNoise.ar(0.1) }.play;
#+END_SRC

::

brownian noise as a frequency modulator:
code::
#+BEGIN_SRC sclang
{ SinOsc.ar(BrownNoise.ar(100, 200)) * 0.1 }.play;
#+END_SRC

::

filtered brown noise:
code::
#+BEGIN_SRC sclang
{ BPF.ar(BrownNoise.ar(0.1.dup), MouseX.kr(40, 17000, 1), 0.2) }.play;
#+END_SRC

::
** class:: BufAllpassC
summary:: Buffer based all pass delay line with cubic interpolation.
related:: Classes/BufAllpassL, Classes/BufAllpassN, Classes/AllpassC
categories::  UGens>Delays>Buffer


Description::

All pass delay line with cubic interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufAllpassN::  which uses no
interpolation, and  which  link::Classes/BufAllpassL::  uses linear
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar

argument::buf
Buffer number.

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

discussion::
warning::
For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::
#+BEGIN_SRC sclang

// allocate buffer
b = Buffer.alloc(s,44100,1);

// Since the allpass delay has no audible effect as a resonator on
// steady state sound ...

{ BufAllpassC.ar(b.bufnum, WhiteNoise.ar(0.1), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// ...these examples add the input to the effected sound and compare variants so that you can hear
// the effect of the phase comb:

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassN.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassL.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassC.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

// used as an echo - doesn't really sound different than Comb,
// but it outputs the input signal immediately (inverted) and the echoes
// are lower in amplitude.
{ BufAllpassN.ar(b.bufnum, Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 3) }.play;
#+END_SRC

::

** class:: BufAllpassL
summary:: Buffer based all pass delay line with linear interpolation.
related:: Classes/BufAllpassC, Classes/BufAllpassN, Classes/AllpassL
categories::  UGens>Delays>Buffer


Description::

All pass delay line with linear interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufAllpassN::  which uses no
interpolation, and  which  link::Classes/BufAllpassC::  uses cubic
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar

argument::buf
Buffer number.

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

discussion::
warning::
For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::
#+BEGIN_SRC sclang

// allocate buffer
b = Buffer.alloc(s,44100,1);

// Since the allpass delay has no audible effect as a resonator on
// steady state sound ...

{ BufAllpassC.ar(b.bufnum, WhiteNoise.ar(0.1), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// ...these examples add the input to the effected sound and compare variants so that you can hear
// the effect of the phase comb:

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassN.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassL.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassC.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

// used as an echo - doesn't really sound different than Comb,
// but it outputs the input signal immediately (inverted) and the echoes
// are lower in amplitude.
{ BufAllpassL.ar(b.bufnum, Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 3) }.play;
#+END_SRC

::

** class:: BufAllpassN
summary:: Buffer based all pass delay line with no interpolation.
related:: Classes/BufAllpassC, Classes/BufAllpassL, Classes/AllpassN
categories::  UGens>Delays>Buffer


Description::

All pass delay line with no interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufAllpassC::  which uses cubic
interpolation, and  which  link::Classes/BufAllpassL::  uses linear
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.

classmethods::

method::ar

argument::buf
Buffer number.

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

discussion::
warning::
For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::
#+BEGIN_SRC sclang

// allocate buffer
b = Buffer.alloc(s,44100,1);

// Since the allpass delay has no audible effect as a resonator on
// steady state sound ...

{ BufAllpassC.ar(b.bufnum, WhiteNoise.ar(0.1), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// ...these examples add the input to the effected sound and compare variants so that you can hear
// the effect of the phase comb:

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassN.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassL.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

(
{
	z = WhiteNoise.ar(0.2);
	z + BufAllpassC.ar(b.bufnum, z, XLine.kr(0.0001, 0.01, 20), 0.2)
}.play)

// used as an echo - doesn't really sound different than Comb,
// but it outputs the input signal immediately (inverted) and the echoes
// are lower in amplitude.
{ BufAllpassN.ar(b.bufnum, Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 3) }.play;
#+END_SRC

::

** class:: BufChannels
summary:: Current number of channels of soundfile in buffer.
related:: Classes/BufDur, Classes/BufFrames, Classes/BufRateScale, Classes/BufSampleRate, Classes/BufSamples
categories::  UGens>Buffer>Info

Description::
Get the current number of channels of soundfile.

classmethods::

method::kr, ir

argument::bufnum
Buffer index.

returns:: the current number of channels.

discussion::
warning::
The  code::.ir::  method is not the safest choice.
Since a buffer can be reallocated at any time, using
code::.ir::  will not track the changes. Use code::.kr:: instead.
#+BEGIN_SRC sclang

#+END_SRC
::

** class:: BufCombC
summary:: Buffer based comb delay line with cubic interpolation.
related:: Classes/BufCombL, Classes/BufCombN, Classes/CombC
categories::  UGens>Delays>Buffer


Description::

Comb delay line with cubic interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufCombN::  which uses no
interpolation, and  link::Classes/BufCombL::  which uses linear
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar

argument::buf
Buffer number.

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

discussion::
Warning:: For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::
#+BEGIN_SRC sclang

// These examples compare the variants, so that you can hear the difference in interpolation

// allocate buffer
b = Buffer.alloc(s,44100,1);

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ BufCombN.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ BufCombL.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ BufCombC.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// with negative feedback:
{ BufCombN.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ BufCombL.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ BufCombC.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

// used as an echo.
{ BufCombC.ar(b.bufnum, Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 3) }.play;
#+END_SRC

::

** class:: BufCombL
summary:: Buffer based comb delay line with linear interpolation.
related:: Classes/BufCombC, Classes/BufCombN, Classes/CombL
categories::  UGens>Delays>Buffer


Description::

Comb delay line with linear interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufCombN::  which uses no
interpolation, and  link::Classes/BufCombC::  which uses cubic
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar

argument::buf
Buffer number.

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

discussion::
Warning:: For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::
#+BEGIN_SRC sclang

// These examples compare the variants, so that you can hear the difference in interpolation

// allocate buffer
b = Buffer.alloc(s,44100,1);

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ BufCombN.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ BufCombL.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ BufCombC.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// with negative feedback:
{ BufCombN.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ BufCombL.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ BufCombC.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

// used as an echo.
{ BufCombL.ar(b.bufnum, Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 3) }.play;
#+END_SRC

::

** class:: BufCombN
summary:: Buffer based comb delay line with no interpolation.
related:: Classes/BufCombC, Classes/BufCombL, Classes/CombN
categories::  UGens>Delays>Buffer


Description::

Comb delay line with no interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufCombL::  which uses linear
interpolation, and  link::Classes/BufCombC::  which uses cubic
interpolation. Cubic interpolation is more computationally
expensive than linear, but more accurate.


classmethods::

method::ar

argument::buf
Buffer number.

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

argument::mul

argument::add

discussion::
Warning:: For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::
#+BEGIN_SRC sclang

// These examples compare the variants, so that you can hear the difference in interpolation

// allocate buffer
b = Buffer.alloc(s,44100,1);

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ BufCombN.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ BufCombL.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ BufCombC.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// with negative feedback:
{ BufCombN.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ BufCombL.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ BufCombC.ar(b.bufnum, WhiteNoise.ar(0.01), XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

// used as an echo.
{ BufCombN.ar(b.bufnum, Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 3) }.play;
#+END_SRC

::

** class:: BufDelayC
summary:: Buffer based simple delay line with cubic interpolation.
related:: Classes/BufDelayL, Classes/BufDelayN, Classes/DelayC
categories::  UGens>Delays>Buffer


Description::

Simple delay line with cubic interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufDelayN::  which uses no
interpolation, and  link::Classes/BufDelayL::  which uses linear
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar, kr

argument::buf
Buffer number.

note:: The buffers provided to any of the BufDelay units must be one channel. If you want to delay a multichannel signal, you must provide as many separate (one-channel) buffers as there are input channels.::

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

discussion::
Warning:: For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::
#+BEGIN_SRC sclang

// allocate buffer
b = Buffer.alloc(s,44100,1);

(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
BufDelayC.ar(b.bufnum, z, 0.2, 1, z); // input is mixed with delay via the add input
}.play
)

b.free;


// multichannel

// two channels, two buffers
b = Buffer.allocConsecutive(2, s, 32768, 1);

a = { |bufs = #[0, 1]|
	var sig = SinOsc.ar([440, 880]) * Decay2.kr(Impulse.kr([2, 4]), 0.01, 0.15);
	sig + BufDelayC.ar(bufs, sig, delaytime: 0.125)
}.play(args: [bufs: b]);

a.free;
b.do(_.free);
#+END_SRC

::

** class:: BufDelayL
summary:: Buffer based simple delay line with linear interpolation.
related:: Classes/BufDelayC, Classes/BufDelayN, Classes/DelayL
categories::  UGens>Delays>Buffer


Description::

Simple delay line with linear interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufDelayN::  which uses no
interpolation, and  link::Classes/BufDelayC::  which uses cubic
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar, kr

argument::buf
Buffer number.

note:: The buffers provided to any of the BufDelay units must be one channel. If you want to delay a multichannel signal, you must provide as many separate (one-channel) buffers as there are input channels.::

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

discussion::
Warning:: For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::
#+BEGIN_SRC sclang

// allocate buffer
b = Buffer.alloc(s,44100,1);

(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
BufDelayL.ar(b.bufnum, z, 0.2, 1, z); // input is mixed with delay via the add input
}.play
)

b.free;


// multichannel

// two channels, two buffers
b = Buffer.allocConsecutive(2, s, 32768, 1);

a = { |bufs = #[0, 1]|
	var sig = SinOsc.ar([440, 880]) * Decay2.kr(Impulse.kr([2, 4]), 0.01, 0.15);
	sig + BufDelayL.ar(bufs, sig, delaytime: 0.125)
}.play(args: [bufs: b]);

a.free;
b.do(_.free);
#+END_SRC

::

** class:: BufDelayN
summary:: Buffer based simple delay line with no interpolation.
related:: Classes/BufDelayC, Classes/BufDelayL, Classes/DelayN
categories::  UGens>Delays>Buffer


Description::

Simple delay line with no interpolation which uses a buffer for its
internal memory. See also  link::Classes/BufDelayL::  which uses linear
interpolation, and  link::Classes/BufDelayC::  which uses cubic
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar, kr

argument::buf
Buffer number.

note:: The buffers provided to any of the BufDelay units must be one channel. If you want to delay a multichannel signal, you must provide as many separate (one-channel) buffers as there are input channels.::

argument::in
The input signal.

argument::delaytime
Delay time in seconds.

argument::mul

argument::add

discussion::
Warning:: For reasons of efficiency, the effective buffer size is limited to the previous power of two. So, if 44100 samples are allocated, the maximum delay would be 32768 samples.
::

Examples::

code::
#+BEGIN_SRC sclang

// allocate buffer
b = Buffer.alloc(s,44100,1);

(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
BufDelayN.ar(b.bufnum, z, 0.2, 1, z); // input is mixed with delay via the add input
}.play
)

b.free;


// multichannel

// two channels, two buffers
b = Buffer.allocConsecutive(2, s, 32768, 1);

a = { |bufs = #[0, 1]|
	var sig = SinOsc.ar([440, 880]) * Decay2.kr(Impulse.kr([2, 4]), 0.01, 0.15);
	sig + BufDelayN.ar(bufs, sig, delaytime: 0.125)
}.play(args: [bufs: b]);

a.free;
b.do(_.free);
#+END_SRC

::

** class:: BufDur
summary:: Current duration of soundfile in buffer.
related:: Classes/BufChannels, Classes/BufFrames, Classes/BufRateScale, Classes/BufSampleRate, Classes/BufSamples
categories::  UGens>Buffer>Info

Description::
Get the current duration of soundfile.

classmethods::

method::kr, ir

argument::bufnum
Buffer index.

returns:: the current duration.

discussion::
warning::
The  code::.ir::  method is not the safest choice.
Since a buffer can be reallocated at any time, using
code::.ir::  will not track the changes.
#+BEGIN_SRC sclang

#+END_SRC
::

Examples::

code::
#+BEGIN_SRC sclang
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

{ BufRd.ar(1, b,  Sweep.ar(Impulse.ar(BufDur.kr(b).reciprocal), BufSampleRate.kr(b))) }.play;

b.free
#+END_SRC

::

** class:: BufFrames
summary:: Current number of frames allocated in the buffer.
related:: Classes/BufChannels, Classes/BufDur, Classes/BufRateScale, Classes/BufSampleRate, Classes/BufSamples
categories::  UGens>Buffer>Info

Description::
Get the current number of allocated frames.

classmethods::

method::kr, ir

argument::bufnum
Buffer index.

returns:: the current number of allocated frames.

discussion::
warning::
The  code::.ir::  method is not the safest choice.
Since a buffer can be reallocated at any time, using
code::.ir::  will not track the changes.
#+BEGIN_SRC sclang

#+END_SRC
::

Examples::

code::
#+BEGIN_SRC sclang

b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// indexing with a phasor
{ BufRd.ar(1, b, Phasor.ar(0, BufRateScale.kr(b), 0, BufFrames.kr(b))) }.play;

// indexing by hand
{ BufRd.ar(1, b, K2A.ar(MouseX.kr(0, BufFrames.kr(b)))) }.play;

b.free
#+END_SRC

::

** class:: BufInfoUGenBase
categories:: UGens>Base
summary:: Base class for buffer info ugens

description::
This is the superclass for the various buffer info ugens.

** class:: BufRateScale
summary:: Buffer rate scaling in respect to server samplerate.
related:: Classes/BufChannels, Classes/BufDur, Classes/BufFrames, Classes/BufSampleRate, Classes/BufSamples
categories::  UGens>Buffer>Info


Description::
Returns a ratio by which the playback of a soundfile is to be scaled.

classmethods::

method::kr, ir

argument::bufnum
Buffer index.

Returns:: a ratio by which the playback of a soundfile is to be scaled.

discussion::
warning::
The  code::.ir::  method is not the safest choice.
Since a buffer can be reallocated at any time, using
code::.ir::  will not track the changes.
#+BEGIN_SRC sclang

#+END_SRC
::

Examples::

code::
#+BEGIN_SRC sclang
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
x = { arg rate=1;
	BufRd.ar(1, b, Phasor.ar(0, BufRateScale.kr(b) * rate, 0, BufFrames.kr(b)))
}.play;
)
#+END_SRC

::

** class:: BufRd
summary:: Buffer reading oscillator.
related:: Classes/BufWr
categories::  UGens>Buffer


Description::

Read the content of a buffer at an index.

In comparison to link::Classes/PlayBuf:: :
PlayBuf plays through the buffer by itself, BufRd only moves its read point by the phase input and
therefore has no pitch input. BufRd has variable interpolation.

classmethods::
private:: categories
method::ar, kr

argument::numChannels
Number of channels that the buffer will be. This must be a fixed
integer. The architechture of the SynthDef cannot change after it
is compiled.
warning::
If you supply a  code::bufnum::  of a buffer that has a
different  code::numChannels::  then you have specified to
the BufRd, it will fail silently.
::

argument::bufnum
The index of the buffer to use.

argument::phase
Audio rate modulateable index into the buffer.
Warning:: The phase argument only offers precision for addressing 2**24 samples (about 6.3 minutes at 44100Hz). ::

argument::loop
1 means true, 0 means false. This is modulateable.


argument::interpolation
1 means no interpolation, 2 is linear, 4 is cubic interpolation.

instancemethods::
private:: init, argNamesInputsOffset, checkInputs

Examples::

code::
#+BEGIN_SRC sclang

(
// read a whole sound into memory
s = Server.local;
// note: not *that* columbia, the first one
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)

//use any AUDIO rate ugen as an index generator

{ BufRd.ar(1, b, SinOsc.ar(0.1) * BufFrames.ir(b)) }.play;
{ BufRd.ar(1, b, LFNoise1.ar(1) * BufFrames.ir(b)) }.play;
{ BufRd.ar(1, b, LFNoise1.ar(10) * BufFrames.ir(b)) }.play;
{ BufRd.ar(1, b, LFTri.ar(0.1) + LFTri.ar(0.23) * BufFrames.ir(b)) }.play;
// original duration
{ BufRd.ar(1, b, LFSaw.ar(BufDur.ir(b).reciprocal).range(0, BufFrames.ir(b)) ) }.play;


//use a phasor index into the file

{ BufRd.ar(1, b, Phasor.ar(0, BufRateScale.kr(b), 0, BufFrames.kr(b))) }.play;


//change rate and interpolation
(
x = { arg rate=1, inter=2;
	BufRd.ar(1, b, Phasor.ar(0, BufRateScale.kr(b) * rate, 0, BufFrames.kr(b)), 1, inter)
}.play;
)

x.set(\rate, 0.9);
x.set(\rate, 0.6);
x.set(\inter, 1);
x.set(\inter, 0);


//write into the buffer with a BufWr
(
y = { arg rate=1;
	var in;
	in = SinOsc.ar(LFNoise1.kr(2, 300, 400), 0, 0.1);
	BufWr.ar(in, b, Phasor.ar(0, BufRateScale.kr(b) * rate, 0, BufFrames.kr(b)));
	0.0 //quiet
}.play;
)

//read it with a BufRd
(
x = { arg rate=1;
	BufRd.ar(1, b, Phasor.ar(0, BufRateScale.kr(b) * rate, 0, BufFrames.kr(b)))
}.play;
)



x.set(\rate, 5);
y.set(\rate, 2.0.rand);
x.set(\rate, 2);

b.free
#+END_SRC

::

** class:: BufSampleRate
summary:: Buffer sample rate.
related:: Classes/BufChannels, Classes/BufDur, Classes/BufFrames, Classes/BufRateScale, Classes/BufSamples
categories::  UGens>Buffer>Info


Description::
Returns the buffer's current sample rate.

classmethods::

method::kr, ir

argument::bufnum
Buffer index.

returns::
the buffer's current sample rate.

discussion::
warning::
The  code::.ir::  method is not the safest choice.
Since a buffer can be reallocated at any time, using
code::.ir::  will not track the changes.
#+BEGIN_SRC sclang

#+END_SRC
::

Examples::

code::
#+BEGIN_SRC sclang
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// compares a 1102.5 Hz sine tone (11025 * 0.1, left) with a 1100 Hz tone (right)
// the apollo sample has a sample rate of 11.025 kHz
(
{
	var freq;
	freq = [ BufSampleRate.kr(b) * 0.1, 1100];
	SinOsc.ar(freq, 0, 0.1)
}.play;
)

b.free;
#+END_SRC

::

** class:: BufSamples
summary:: Current number of samples in buffer.
related:: Classes/BufChannels, Classes/BufDur, Classes/BufFrames, Classes/BufRateScale, Classes/BufSampleRate
categories::  UGens>Buffer>Info

Description::

Returns the current number of allocated samples. A sample is not the same as a frame (compare with link::Classes/BufFrames:: ); a frame includes the samples in each channel of the buffer. Only for a mono buffer are samples the same as frames.
code::
#+BEGIN_SRC sclang
samples = frames * numChannels
#+END_SRC

::


classmethods::

method::kr, ir

argument::bufnum
Buffer index.

discussion::
warning::
The  code::.ir::  method is not the safest choice.
Since a buffer can be reallocated at any time, using
code::.ir::  will not track the changes.
#+BEGIN_SRC sclang

#+END_SRC
::

examples::
code::
#+BEGIN_SRC sclang
// example; this buffer is mono, so the number of samples matches the number of frames
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// indexing with a phasor
{ BufRd.ar(1, b, Phasor.ar(0, BufRateScale.kr(b), 0, BufSamples.kr(b))) }.play;

// indexing by hand
{ BufRd.ar(1, b, K2A.ar(MouseX.kr(0, BufSamples.kr(b)))) }.play;

b.free;
#+END_SRC

::

** class:: BufWr
summary:: Buffer writing oscillator.
related:: Classes/BufRd
categories::  UGens>Buffer

Description::
Write to a buffer at an index.

note:: BufWr (in difference to  link::Classes/BufRd:: ) does not do multichannel expansion, because input is an array. ::

classmethods::
private:: categories

method::ar, kr

argument::inputArray
Input UGens (channelArray).

argument::bufnum
The index of the buffer to use.

argument::phase
Modulateable index into the buffer (has to be audio rate).
Warning:: The phase argument only offers precision for addressing 2**24 samples (about 6.3 minutes at 44100Hz) ::

argument::loop
1 means true, 0 means false. This is modulateable.

instancemethods::
private:: checkInputs

Examples::

code::
#+BEGIN_SRC sclang

(
// allocate a buffer for writinig into
s = Server.local;
s.sendMsg("/b_alloc", 0, 44100 * 2);
)


//write into the buffer with a BufWr
(
y = { arg rate=1;
	var in;
	in = SinOsc.ar(LFNoise1.kr(2, 300, 400), 0, 0.1);
	BufWr.ar(in, 0, Phasor.ar(0, BufRateScale.kr(0) * rate, 0, BufFrames.kr(0)));
	0.0 //quiet
}.play;
)

//read it with a BufRd
(
x = { arg rate=1;
	BufRd.ar(1, 0, Phasor.ar(0, BufRateScale.kr(0) * rate, 0, BufFrames.kr(0)))
}.play(s);
)



x.set(\rate, 5);
y.set(\rate, 2.0.rand);
x.set(\rate, 2);
#+END_SRC

::

** class:: Buffer
summary:: Client-side representation of a buffer on a server
categories:: Server>Abstractions

description::

A buffer is most often used to hold sampled audio, such as a soundfile loaded into memory, but can be used to hold other types of data as well. It is a globally available array of floating-point numbers on the server. The Buffer class encapsulates a number of common tasks, OSC messages, and capabilities related to server-side buffers – see the examples lower down this document for many examples of using Buffers for sound playback and recording.

Buffers are commonly used with link::Classes/PlayBuf::, link::Classes/RecordBuf::, link::Classes/DiskIn::, link::Classes/DiskOut::, link::Classes/BufWr::, link::Classes/BufRd::, and other UGens. (See their individual help files for more examples.) Buffers can be freed or altered even while being accessed. See link::Reference/Server-Architecture:: for some technical details.

Buffer objects should not be created or modified within a link::Classes/SynthDef::. If this is needed, see link::Classes/LocalBuf::.

subsection:: Buffer Numbers and Allocation

Although the number of buffers on a server is set at the time it is booted, memory must still be allocated within the server app before they can hold values. (At boot time all buffers have a size of 0.)

link::Classes/Server::-side buffers are identified by number, starting from 0. When using Buffer objects, buffer numbers are automatically allocated from the Server's bufferAllocator, unless you explicitly supply one. When you call code::.free:: on a Buffer object it will release the buffer's memory on the server, and free the buffer number for future reallocation. See link::Classes/ServerOptions:: for details on setting the number of available buffers.

Normally you should not need to supply a buffer number. You should only do so if you are sure you know what you are doing. Similarly, in normal use you should not need to access the buffer number, since instances of Buffer can be used directly as link::Classes/UGen:: inputs or link::Classes/Synth:: args.

subsection:: Multichannel Buffers

Multichannel buffers interleave their data. Thus the actual number of available values when requesting or setting values by index using methods such as code::set, setn, get, getn::, etc., is equal to code::numFrames * numChannels::.
Indices start at 0 and go up to code::(numFrames * numChannels) - 1::.
In a two channel buffer for instance, index 0 will be the first value of the first channel, index 1 will be the first value of the second channel, index 2 will be the second value of the first channel, and so on.

In some cases it is simpler to use multiple single channel buffers instead of a single multichannel one.

subsection:: Completion Messages and Action Functions

Many buffer operations (such as reading and writing files) are asynchronous, meaning that they will take an arbitrary amount of time to complete. Asynchronous commands are passed to a background thread on the server so as not to steal CPU time from the audio synthesis thread.
Since they can last an aribitrary amount of time it is convenient to be able to specify something else that can be done immediately on completion.
The ability to do this is implemented in two ways in Buffer's various methods: completion messages and action functions.

A completion message is a second OSC command which is included in the message which is sent to the server. (See link::Guides/NodeMessaging:: for a discussion of OSC messages.)
The server will execute this immediately upon completing the first command.
An action function is a link::Classes/Function:: which will be evaluated when the client receives the appropriate reply from the server, indicating that the previous command is done.
Action functions are therefore inherently more flexible than completion messages, but slightly less efficient due to the small amount of added latency involved in message traffic. Action functions are passed the Buffer object as an argument when they are evaluated.

With Buffer methods that take a completion message, it is also possible to pass in a function that returns an OSC message. As in action functions this will be passed the Buffer as an argument.
It is important to understand however that this function will be evaluated after the Buffer object has been created (so that its bufnum and other details are accessible), but before the corresponding message is sent to the server.

subsection:: Bundling

Many of the methods below have two versions: a regular one which sends its corresponding message to the server immediately, and one which returns the message in an link::Classes/Array:: so that it can be added to a bundle.
It is also possible to capture the messages generated by the regular methods using Server's automated bundling capabilities.
See link::Classes/Server:: and link::Guides/Bundled-Messages:: for more details.

classmethods::
private:: initClass, initServerCache, clearServerCaches

subsection:: Creation with Immediate Memory Allocation

method:: alloc
Create and return a Buffer and immediately allocate the required memory on the server. The buffer's values will be initialised to 0.0.
argument:: server
The server on which to allocate the buffer. The default is the default Server.
argument:: numFrames
The number of frames to allocate. Actual memory use will correspond to numFrames * numChannels.
argument:: numChannels
The number of channels for the Buffer. The default is 1.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
argument:: bufnum
An explicitly specified buffer number. Generally this is not needed.
discussion::
code::
#+BEGIN_SRC sclang
// Allocate 8 second stereo buffer
s.boot;
b = Buffer.alloc(s, s.sampleRate * 8.0, 2);
b.free;
#+END_SRC

::

method:: allocConsecutive
Allocates a range of consecutively-numbered buffers, for use with UGens like link::Classes/VOsc:: and link::Classes/VOsc3:: that require a contiguous block of buffers, and returns an array of corresponding Buffer objects.
argument:: numBufs
The number of consecutively indexed buffers to allocate.
argument:: server
The server on which to allocate the buffers. The default is the default Server.
argument:: numFrames
The number of frames to allocate in each buffer. Actual memory use will correspond to numFrames * numChannels.
argument:: numChannels
The number of channels for each buffer. The default is 1.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed each Buffer and its index in the array as arguments when evaluated.
argument:: bufnum
An explicitly specified buffer number for the initial buffer. Generally this is not needed.
discussion::
N.B. You must treat the array of Buffers as a group. Freeing them individually or resuing them can result in allocation errors. You should free all Buffers in the array at the same time by iterating over it with do.
code::
#+BEGIN_SRC sclang
s.boot;
// allocate an array of Buffers and fill them with different harmonics
(
b = Buffer.allocConsecutive(8, s, 4096, 1, { |buf, i|
	buf.sine1Msg((1..((i+1)*6)).reciprocal) // completion Messages
});

a = { VOsc.ar(SinOsc.kr(0.5, 0).range(b.first.bufnum + 0.1, b.last.bufnum - 0.1),
	[440, 441], 0, 0.2) }.play;
)
a.free;

// iterate over the array and free it
b.do(_.free);
#+END_SRC

::

method:: read
Allocate a buffer and immediately read a soundfile into it. This method sends a query message as a completion message so that the Buffer's instance variables will be updated automatically.
argument:: server
The server on which to allocate the buffer.
argument:: path
A String representing the path of the soundfile to be read.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
argument:: bufnum
An explicitly specified buffer number. Generally this is not needed.

discussion::
N.B. You cannot rely on the buffer's instance variables being instantly updated, as there is a small amount of latency involved. action will be evaluated upon receipt of the reply to the query, so use this in cases where access to instance variables is needed.
code::
#+BEGIN_SRC sclang
// read a soundfile
s.boot;
p = Platform.resourceDir +/+ "sounds/a11wlk01.wav";
b = Buffer.read(s, p);

// now play it
(
x = SynthDef(\help_Buffer, { arg out = 0, bufnum;
    Out.ar( out,
	    PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum))
    )
}).play(s,[\bufnum, b]);
)
x.free; b.free;

// with an action function
// note that the vars are not immediately up-to-date
(
b = Buffer.read(s, p, action: { arg buffer;
    ("After update:" + buffer.numFrames).postln;
    x = { PlayBuf.ar(1, buffer, BufRateScale.kr(buffer)) }.play;
});
("Before update:" + b.numFrames).postln;
)
x.free; b.free;
#+END_SRC

::

method:: readChannel
As link::#*read:: above, but takes an link::Classes/Array:: of channel indices to read in, allowing one to read only the selected channels.
argument:: server
The server on which to allocate the buffer.
argument:: path
A String representing the path of the soundfile to be read.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file.
argument:: channels
An Array of channels to be read from the soundfile. Indices start from zero. These will be read in the order provided.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
argument:: bufnum
An explicitly specified buffer number. Generally this is not needed.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
// first a standard read so we can see what's in the file
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff");
// Platform.resourceDir +/+ "sounds/SinedPink.aiff" contains SinOsc on left, PinkNoise on right
b.plot;
b.free;

// Now just the sine
b = Buffer.readChannel(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff", channels: [0]);
b.plot;
b.free;

// Now just the pink noise
b = Buffer.readChannel(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff", channels: [1]);
b.plot;
b.free;

// Now reverse channel order
b = Buffer.readChannel(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff", channels: [1, 0]);
b.plot;
b.free;
#+END_SRC

::

method:: readNoUpdate
As link::#*read:: above, but without the automatic update of instance variables. Call code::updateInfo:: (see below) to update the vars.
argument:: server
The server on which to allocate the buffer.
argument:: path
A String representing the path of the soundfile to be read.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file.
argument:: bufnum
An explicitly specified buffer number. Generally this is not needed.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
discussion::
code::
#+BEGIN_SRC sclang
// with a completion message
s.boot;
(
SynthDef(\help_Buffer,{ arg out=0, bufnum;
	Out.ar( out,
		PlayBuf.ar(1,bufnum,BufRateScale.kr(bufnum))
	)
}).add;

y = Synth.basicNew(\help_Buffer); // not sent yet
b = Buffer.readNoUpdate(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav",
	completionMessage: { arg buffer;
		// synth add its s_new msg to follow
		// after the buffer read completes
		y.newMsg(s,[\bufnum, buffer],\addToTail)
	});
)
// note vars not accurate
b.numFrames; // nil
b.updateInfo;
b.numFrames; // 188893
// when done...
y.free;
b.free;
#+END_SRC

::

method:: cueSoundFile
Allocate a buffer and preload a soundfile for streaming in using link::Classes/DiskIn::.
argument:: server
The server on which to allocate the buffer.
argument:: path
A String representing the path of the soundfile to be read.
argument:: startFrame
The frame of the soundfile that DiskIn will start playing at.
argument:: numChannels
The number of channels in the soundfile.
argument:: bufferSize
This must be a multiple of  (2 * the server's block size). 32768 is the default and is suitable for most cases.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
(
SynthDef(\help_Buffer_cue,{ arg out=0,bufnum;
	Out.ar(out,
		DiskIn.ar( 1, bufnum )
	)
}).add;
)

(
s.makeBundle(nil, {
	b = Buffer.cueSoundFile(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav", 0, 1);
	y = Synth(\help_Buffer_cue, [\bufnum, b], s);
});
)
b.free; y.free;
#+END_SRC

::

method:: loadCollection
Load a large collection into a buffer on the server. Returns a Buffer object.
argument:: server
The server on which to create the buffer.
argument:: collection
A subclass of Collection (i.e. an Array) containing only floats and integers. Multi-dimensional arrays will not work.
argument:: numChannels
The number of channels that the buffer should have. Note that buffers interleave multichannel data. You are responsible for providing an interleaved collection if needed. Multi-dimensional arrays will not work.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.

discussion::
This is accomplished through writing the collection to a SoundFile and loading it from there. For this reason this method will only work with a server on your local machine. For a remote server use code::sendCollection::, below. The file is automatically deleted after loading. This allows for larger collections than setn, below, and is in general the safest way to get a large collection into a buffer. The sample rate of the buffer will be the sample rate of the server on which it is created.
code::
#+BEGIN_SRC sclang
s.boot;
(
a = FloatArray.fill(44100 * 5.0, {1.0.rand2}); // 5 seconds of noise
b = Buffer.loadCollection(s, a);
)

// test it
b.get(20000,{|msg| (msg == a[20000]).postln});
// play it
x = { PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 0) * 0.5 }.play;
b.free; x.free;

// interleave a multi-dimensional array
(
l = Signal.sineFill(16384, Array.fill(200, {0}).add(1));
r = Array.fill(16384, {1.0.rand2});
m = [Array.newFrom(l), r]; // a multi-dimensional array
m = m.lace(32768); // interleave the two collections
b = Buffer.loadCollection(s, m, 2, {|buf|
	x = { PlayBuf.ar(2, buf, BufRateScale.kr(buf), loop: 1) * 0.5 }.play;
});
)
b.plot;
x.free; b.free;
#+END_SRC

::

method:: sendCollection
Stream a large collection into a buffer on the server using multiple setn messages. Returns a Buffer object.
argument:: server
The server on which to create the buffer.
argument:: collection
A subclass of Collection (i.e. an Array) containing only floats and integers. Multi-dimensional arrays will not work.
argument:: numChannels
The number of channels that the buffer should have. Note that buffers interleave multichannel data. You are responsible for providing an interleaved collection if needed. Multi-dimensional arrays will not work. See the example in link::#*loadCollection:: above, to see how to do this.
argument:: wait
An optional wait time between sending setn messages. In a high traffic situation it may be safer to set this to something above zero, which is the default.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
discussion::
This allows for larger collections than setn, below. This is not as safe as link::#*loadCollection:: above, but will work with servers on remote machines. The sample rate of the buffer will be the sample rate of the server on which it is created.
code::
#+BEGIN_SRC sclang
s.boot;
(
a = Array.fill(2000000,{ rrand(0.0,1.0) }); // a LARGE collection
b = Buffer.sendCollection(s, a, 1, 0, {arg buf; "finished".postln;});
)
b.get(1999999, {|msg| (msg == a[1999999]).postln});
b.free;
#+END_SRC

::

method:: loadDialog
As link::#*read:: above, but gives you a load dialog window to browse for a file. Cocoa and SwingOSC compatible.
argument:: server
The server on which to allocate the buffer.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
argument:: bufnum
An explicitly specified buffer number. Generally this is not needed.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
(
b = Buffer.loadDialog(s, action: { arg buffer;
	x = { PlayBuf.ar(buffer.numChannels, buffer, BufRateScale.kr(buffer)) }.play;
});
)
x.free; b.free;
#+END_SRC

::

subsection:: Creation without Immediate Memory Allocation
method:: new
Create and return a new Buffer object, without immediately allocating the corresponding memory on the server. This combined with 'message' methods can be flexible with bundles.
argument:: server
The server on which to allocate the buffer. The default is the default Server.
argument:: numFrames
The number of frames to allocate. Actual memory use will correspond to numFrames * numChannels.
argument:: numChannels
The number of channels for the Buffer. The default is 1.
argument:: bufnum
An explicitly specified buffer number. Generally this is not needed.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.new(s, 44100 * 8.0, 2);
c = Buffer.new(s, 44100 * 4.0, 2);
b.query; // numFrames = 0
s.sendBundle(nil, b.allocMsg, c.allocMsg); // sent both at the same time
b.query; // now it's right
c.query;
b.free; c.free;
#+END_SRC

::

subsection:: Cached Buffers

To assist with automatic updates of buffer information (see code::updateInfo:: and code::read::), buffer objects are cached in a collection associated with the link::Classes/Server:: object hosting the buffers.
Freeing a buffer removes it from the cache; quitting the server clears all the cached buffers. (This also occurs if the server crashes unexpectedly.)

You may access cached buffers using the following methods.

It may be simpler to access them through the server object:
code::
#+BEGIN_SRC sclang
myServer.cachedBufferAt(bufnum)
myServer.cachedBuffersDo(func)

b = Buffer.alloc(s, 2048, 1);
Buffer.cachedBufferAt(s, 0);	// assuming b has bufnum 0
s.cachedBufferAt(0);			// same result
s.cachedBuffersDo({ |buf| buf.postln });
#+END_SRC

::

method:: cachedBufferAt
Access a buffer by its number.

method:: cachedBuffersDo
Iterate over all cached buffers. The iteration is not in any order, but will touch all buffers.


InstanceMethods::

subsection:: Variables

The following variables have getter methods.

method:: server
Returns the Buffer's Server object.

method:: bufnum
Returns the buffer number of the corresponding server-side buffer. In normal use you should not need to access this value, since instances of Buffer can be used directly as UGen inputs or Synth args.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.alloc(s,44100 * 8.0,2);
b.bufnum.postln;
b.free;
#+END_SRC

::

method:: numFrames
Returns the number of sample frames in the corresponding server-side buffer. Note that multichannel buffers interleave their samples, so when dealing with indices in methods like get and getn, the actual number of available values is numFrames * numChannels.

method:: numChannels
Returns the number of channels in the corresponding server-side buffer.

method:: sampleRate
Returns the sample rate of the corresponding server-side buffer.

method:: path
Returns a string containing the path of a soundfile that has been loaded into the corresponding server-side buffer.


subsection:: Explicit allocation

These methods allocate the necessary memory on the server for a Buffer previously created with link::#*new::.

method:: alloc, allocMsg
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.new(s, 44100 * 8.0, 2);
b.query; // numFrames = 0
b.alloc;
b.query; // numFrames = 352800
b.free;
#+END_SRC

::

method:: allocRead, allocReadMsg
Read a soundfile into a buffer on the server for a Buffer previously created with link::#*new::. Note that this will not autoupdate instance variables. Call code::updateInfo:: in order to do this.
argument:: argpath
A String representing the path of the soundfile to be read.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.new(s);
b.allocRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
x = { PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 1) * 0.5 }.play;
x.free; b.free;
#+END_SRC

::

method:: allocReadChannel, allocReadChannelMsg
As link::#-allocRead:: above, but allows you to specify which channels to read.
argument:: argpath
A String representing the path of the soundfile to be read.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file.
argument:: channels
An Array of channels to be read from the soundfile. Indices start from zero. These will be read in the order provided.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.new(s);
// read only the first channel (a Sine wave) of a stereo file
b.allocReadChannel(Platform.resourceDir +/+ "sounds/SinedPink.aiff", channels: [0]);
x = { PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 1) * 0.5 }.play;
x.free; b.free;
#+END_SRC

::

subsection:: Other methods

method:: read, readMsg
Read a soundfile into an already allocated buffer.
argument:: argpath
A String representing the path of the soundfile to be read.
argument:: fileStartFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file.
argument:: bufStartFrame
The index of the frame in the buffer at which to start reading. The default is 0, which is the beginning of the buffer.
argument:: leaveOpen
A boolean indicating whether or not the Buffer should be left 'open'. For use with DiskIn you will want this to be true, as the buffer will be used for streaming the soundfile in from disk. (For this the buffer must have been allocated with a multiple of (2 * synth block size).
A common number is 32768 frames. cueSoundFile below, provides a simpler way of doing this.) The default is false which is the correct value for all other cases.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.

discussion::
Note that if the number of frames in the file is greater than the number of frames in the buffer, it will be truncated. Note that readMsg will not auto-update instance variables. Call updateInfo in order to do this.

method:: readChannel, readChannelMsg
As link::#-read:: above, but allows you to specify which channels to read.
argument:: argpath
A String representing the path of the soundfile to be read.
argument:: fileStartFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: numFrames
The number of frames to read. The default is -1, which will read the whole file.
argument:: bufStartFrame
The index of the frame in the buffer at which to start reading. The default is 0, which is the beginning of the buffer.
argument:: leaveOpen
A boolean indicating whether or not the Buffer should be left 'open'. For use with DiskIn you will want this to be true, as the buffer will be used for streaming the soundfile in from disk. (For this the buffer must have been allocated with a multiple of (2 * synth block size).
A common number is 32768 frames. cueSoundFile below, provides a simpler way of doing this.) The default is false which is the correct value for all other cases.
argument:: channels
An Array of channels to be read from the soundfile. Indices start from zero. These will be read in the order provided. The number of channels requested must match this Buffer's numChannels.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.

method:: cueSoundFile, cueSoundFileMsg
A convenience method to cue a soundfile into the buffer for use with a link::Classes/DiskIn::. The buffer must have been allocated with a multiple of (2 * the server's block size) frames.  A common size is 32768 frames.
argument:: path
A String representing the path of the soundfile to be read.
argument:: startFrame
The first frame of the soundfile to read. The default is 0, which is the beginning of the file.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
//create with cueSoundFile class method
b = Buffer.cueSoundFile(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 1);
x = { DiskIn.ar(1, b) }.play;
b.close;	// must call close in between cueing
// now use like named instance method, but different arguments
b.cueSoundFile(Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff");
// have to do all this to clean up properly!
x.free; b.close; b.free;
#+END_SRC

::

method:: write, writeMsg
Write the contents of the buffer to a file. See link::Classes/SoundFile:: for information on valid values for headerFormat and sampleFormat.
argument:: path
A String representing the path of the soundfile to be written.
If no path is given, Buffer writes into the default recording directory with a generic name.
argument:: headerFormat
A String.
argument:: sampleFormat
A String.
argument:: numFrames
The number of frames to write. The default is -1, which will write the whole buffer.
argument:: startFrame
The index of the frame in the buffer from which to start writing. The default is 0, which is the beginning of the buffer.
argument:: leaveOpen
A boolean indicating whether or not the Buffer should be left 'open'. For use with DiskOut you will want this to be true. The default is false which is the correct value for all other cases.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.

method:: free, freeMsg
Release the buffer's memory on the server and return the bufferID back to the server's buffer number allocator for future reuse.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.

method:: zero, zeroMsg
Sets all values in this buffer to 0.0.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.

method:: set, setMsg
Set the value in the buffer at index to be equal to float. Additional pairs of indices and floats may be included in the same message.
discussion::
Note that multichannel buffers interleave their sample data, therefore the actual number of available values is equal to code::numFrames * numChannels::. Indices start at 0.
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.alloc(s, 4, 2);
b.set(0, 0.2, 1, 0.3, 7, 0.4); // set the values at indices 0, 1, and 7.
b.getn(0, 8, {|msg| msg.postln});
b.free;
#+END_SRC

::

method:: setn, setnMsg
Set a contiguous range of values in the buffer starting at the index startAt to be equal to the Array of floats or integers, values. The number of values set corresponds to the size of values. Additional pairs of starting indices and arrays of values may be included in the same message.
discussion::
Note that multichannel buffers interleave their sample data, therefore the actual number of available values is equal to code::numFrames * numChannels::. You are responsible for interleaving the data in values if needed. Multi-dimensional arrays will not work. Indices start at 0.

N.B. The maximum number of values that you can set with a single setn message is 1633 when the server is using UDP as its communication protocol. Use link::#-loadCollection:: and link::#-sendCollection:: to set larger ranges of values.
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.alloc(s,16);
b.setn(0, Array.fill(16, { rrand(0,1) }));
b.getn(0, b.numFrames, {|msg| msg.postln});
b.setn(0, [1, 2, 3], 4, [1, 2, 3]);
b.getn(0, b.numFrames, {|msg| msg.postln});
b.free;
#+END_SRC

::

method:: loadCollection
Load a large collection into this buffer. This is accomplished through writing the collection to a SoundFile and loading it from there. For this reason this method will only work with a server on your local machine. For a remote server use sendCollection, below. The file is automatically deleted after loading.
argument:: collection
A subclass of Collection (i.e. an Array) containing only floats and integers. Multi-dimensional arrays will not work.
argument:: startFrame
The index of the frame at which to start loading the collection. The default is 0, which is the start of the buffer.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.

discussion::
This allows for larger collections than setn, above, and is in general the safest way to get a large collection into a buffer. The sample rate of the buffer will be the sample rate of the server on which it was created.
The number of channels and frames will have been determined when the buffer was allocated. You are responsible for making sure that the size of collection is not greater than numFrames, and for interleaving any data if needed.
code::
#+BEGIN_SRC sclang
s.boot;
(
v = Signal.sineFill(128, 1.0/[1,2,3,4,5,6]);
b = Buffer.alloc(s, 128);
)
(
b.loadCollection(v, action: {|buf|
	x = { PlayBuf.ar(buf.numChannels, buf, BufRateScale.kr(buf), loop: 1)
		* 0.2 }.play;
});
)
x.free; b.free;

// interleave a multi-dimensional array
(
l = Signal.sineFill(16384, Array.fill(200, {0}).add(1));
r = Array.fill(16384, {1.0.rand2});
m = [Array.newFrom(l), r]; // a multi-dimensional array
m = m.lace(32768); // interleave the two collections
b = Buffer.alloc(s, 16384, 2);
)
(
b.loadCollection(m, 0, {|buf|
	x = { PlayBuf.ar(2, buf, BufRateScale.kr(buf), loop: 1) * 0.5 }.play;
});
)
b.plot;
x.free; b.free;
#+END_SRC

::

method:: sendCollection
Stream a large collection into this buffer using multiple setn messages.
argument:: collection
A subclass of Collection (i.e. an Array) containing only floats and integers. Multi-dimensional arrays will not work.
argument:: startFrame
The index of the frame at which to start streaming in the collection. The default is 0, which is the start of the buffer.
argument:: wait
An optional wait time between sending setn messages. In a high traffic situation it may be safer to set this to something above zero, which is the default.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
discussion::
This allows for larger collections than setn. This is not as safe as loadCollection, above, but will work with servers on remote machines. The sample rate of the buffer will be the sample rate of the server on which it is created.
code::
#+BEGIN_SRC sclang
s.boot;
(
a = Array.fill(2000000,{ rrand(0.0,1.0) });
b = Buffer.alloc(s, 2000000);
)
b = b.sendCollection(a, action: {arg buf; "finished".postln;});
b.get(1999999, {|msg| (msg == a[1999999]).postln});
b.free;
#+END_SRC

::

method:: get, getMsg
Send a message requesting the value in the buffer at index. action is a Function which will be passed the value as an argument and evaluated when a reply is received.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.alloc(s,16);
b.setn(0, Array.fill(16, { rrand(0.0, 1.0) }));
b.get(0, {|msg| msg.postln});
b.free;
#+END_SRC

::

method:: getn, getMsg
Send a message requesting the a contiguous range of values of size count starting from index. action is a Function which will be passed the values in an Array as an argument and evaluated when a reply is received. See setn above for an example.
discussion::
N.B. The maximum number of values that you can get with a single getn message is 1633 when the server is using UDP as its communication protocol. Use link::#-loadToFloatArray:: and link::#-getToFloatArray:: to get larger ranges of values.

method:: loadToFloatArray
Write the buffer to a file and then load it into a FloatArray.
argument:: index
The index in the buffer to begin writing from. The default is 0.
argument:: count
The number of values to write. The default is -1, which writes from index until the end of the  buffer.
argument:: action
A Function which will be passed the resulting FloatArray as an argument and evaluated when loading is finished.
discussion::
This is safer than getToFloatArray but only works with a server on your local machine. In general this is the safest way to get a large range of values from a server buffer into the client app.
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
// same as Buffer.plot
b.loadToFloatArray(action: { arg array; a = array; {a.plot;}.defer; "done".postln;});
b.free;
#+END_SRC

::

method:: getToFloatArray
Stream the buffer to the client using a series of getn messages and put the results into a FloatArray.
argument:: index
The index in the buffer to begin writing from. The default is 0.
argument:: count
The number of values to write. The default is -1, which writes from index until the end of the  buffer.
argument:: wait
The amount of time in seconds to wait between sending getn messages. Longer times are safer. The default is 0.01 seconds which seems reliable under normal circumstances. A setting of 0 is not recommended.
argument:: timeout
The amount of time in seconds after which to post a warning if all replies have not yet been received. the default is 3.
argument:: action
A Function which will be passed the resulting FloatArray as an argument and evaluated when all replies have been received.
discussion::
This is more risky than loadToFloatArray but does works with servers on remote machines. In high traffic situations it is possible for data to be lost. If this method has not received all its replies by timeout it will post a warning saying that the method has failed. In general use loadToFloatArray instead wherever possible.
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
// like Buffer.plot
b.getToFloatArray(wait:0.01,action:{arg array; a = array; {a.plot;}.defer;"done".postln;});
b.free;
#+END_SRC

::

method:: normalize, normalizeMsg
Normalizes the buffer so that the peak absolute value is newmax (which defaults to 1). If your buffer is in Wavetable format then set the asWavetable argument to true.

method:: fill, fillMsg
Starting at the index startAt, set the next numFrames to value. Additional ranges may be included in the same message.

method:: copyData, copyMsg
Starting at the index srcStartAt, copy numSamples samples from this to the destination buffer buf starting at dstStartAt. If numSamples is negative, the maximum number of samples possible is copied. The default is start from 0 in the source and copy the maximum number possible starting at 0 in the destination.

discussion::
Note: This method used to be called copy, but this conflicts with the method for object-copying. Therefore Buffer:copy is now intended to create a copy of the client-side Buffer object. Its use for copying buffer data on the server is deprecated. If you see a deprecation warning, the data will still be copied on the server and your code will still work, but you should update your code for the new method name.
code::
#+BEGIN_SRC sclang
s.boot;
(
SynthDef(\help_Buffer_copy, { arg out=0, buf;
	Line.ar(0, 0, dur: BufDur.kr(buf), doneAction: 2); // frees itself
	Out.ar(out, PlayBuf.ar(1, buf));
}).add;
)

(
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
c = Buffer.alloc(s, 120000);
)

Synth(\help_Buffer_copy, [\buf, b]);

// copy the whole buffer
b.copyData(c);
Synth(\help_Buffer_copy, [\buf, c]);

// copy some samples
c.zero;
b.copyData(c, numSamples: 4410);
Synth(\help_Buffer_copy, [\buf, c]);

// buffer "compositing"
c.zero;
b.copyData(c, numSamples: 4410);
b.copyData(c, dstStartAt: 4410, numSamples: 15500);
Synth(\help_Buffer_copy, [\buf, c]);

b.free;
c.free;
#+END_SRC

::

method:: close, closeMsg
After using a Buffer with a DiskOut or DiskIn, it is necessary to close the soundfile. Failure to do so can cause problems.
argument:: completionMessage
A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.

method:: plot
Plot the contents of the Buffer in a GUI window.
argument:: name
The name of the resulting window.
argument:: bounds
An instance of Rect determining the size of the resulting view.
argument:: minval
the minimum value in the plot
argument:: maxval
the maximum value in the plot
argument:: parent
a window to place the plot in. If nil, one will be created for you
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
b.plot;
b.free;
#+END_SRC

::

method:: play
Plays the contents of the buffer on the server and returns a corresponding Synth.
argument:: loop
A Boolean indicating whether or not to loop playback. If false the synth will automatically be freed when done. The default is false.
argument:: mul
A value by which to scale the output. The default is 1.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
b.play; // frees itself
x = b.play(true);
x.free; b.free;
#+END_SRC

::

method:: query
Sends a b_query message to the server, asking for a description of this buffer. The results are posted to the post window. Does not update instance vars.

method:: updateInfo
Sends a b_query message to the server, asking for a description of this buffer. Upon reply this Buffer's instance variables are automatically updated.
argument:: action
A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.readNoUpdate(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
b.numFrames; // incorrect, shows nil
b.updateInfo({|buf| buf.numFrames.postln; }); // now it's right
b.free;
#+END_SRC

::

subsection:: Buffer Fill Commands
These correspond to the various b_gen OSC Commands, which fill the buffer with values for use. See link::Reference/Server-Command-Reference:: for more details.

method:: gen, genMsg
This is a generalized version of the commands below.
argument:: genCommand
A String indicating the name of the command to use. See Server-Command-Reference for a list of valid command names.
argument:: genArgs
An Array containing the corresponding arguments to the command.
argument:: normalize
A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.
argument:: asWavetable
A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.
argument:: clearFirst
A Boolean indicating whether or not to clear the buffer before writing. The default is true.

method:: sine1, sine1Msg
Fill this buffer with a series of sine wave harmonics using specified amplitudes.
argument:: amps
An Array containing amplitudes for the harmonics. The first float value specifies the amplitude of the first partial, the second float value specifies the amplitude of the second partial, and so on.
argument:: normalize
A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.
argument:: asWavetable
A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.
argument:: clearFirst
A Boolean indicating whether or not to clear the buffer before writing. The default is true.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
(
b = Buffer.alloc(s, 512, 1);
b.sine1(1.0 / [1, 2, 3, 4], true, true, true);
x = { Osc.ar(b, 200, 0, 0.5) }.play;
)
x.free; b.free;
#+END_SRC

::

method:: sine2, sine2Msg
Fill this buffer with a series of sine wave partials using specified frequencies and amplitudes.
argument:: freqs
An Array containing frequencies (in cycles per buffer) for the partials.
argument:: amps
An Array containing amplitudes for the partials. This should contain the same number of items as freqs.
argument:: normalize
A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.
argument:: asWavetable
A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.
argument:: clearFirst
A Boolean indicating whether or not to clear the buffer before writing. The default is true.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
(
b = Buffer.alloc(s, 512, 1);
b.sine2([1.0, 3], [1, 0.5]);
x = { Osc.ar(b, 200, 0, 0.5) }.play;
)
x.free; b.free;
#+END_SRC

::

method:: sine3, sine3Msg
Fill this buffer with a series of sine wave partials using specified frequencies, amplitudes, and initial phases.
argument:: freqs
An Array containing frequencies (in cycles per buffer) for the partials.
argument:: amps
An Array containing amplitudes for the partials. This should contain the same number of items as freqs.
argument:: phases
An Array containing initial phase for the partials (in radians). This should contain the same number of items as freqs.
argument:: normalize
A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.
argument:: asWavetable
A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.
argument:: clearFirst
A Boolean indicating whether or not to clear the buffer before writing. The default is true.

method:: cheby, chebyMsg
Fill this buffer with a series of chebyshev polynomials, which can be defined as: code::cheby(n) = amplitude  * cos(n * acos(x))::. To eliminate a DC offset when used as a waveshaper, the wavetable is offset so that the center value is zero.
argument:: amplitudes
An Array containing amplitudes for the harmonics. The first float value specifies the amplitude for n = 1, the second float value specifies the amplitude for n = 2, and so on.
argument:: normalize
A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.
argument:: asWavetable
A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.
argument:: clearFirst
A Boolean indicating whether or not to clear the buffer before writing. The default is true.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.alloc(s, 512, 1, {arg buf; buf.chebyMsg([1,0,1,1,0,1])});
(
x = {
	Shaper.ar(
		b,
		SinOsc.ar(300, 0, Line.kr(0,1,6)),
		0.5
	)
}.play;
)
x.free; b.free;
#+END_SRC

::

** class:: Bus
summary:: Representation of a bus on the server
categories:: Server>Abstractions
related:: Classes/Server

description::
The clientside representation of an audio or control bus on a server.  Encapsulates all the link::Browse#OpenSoundControl#OSC:: messages a Bus can receive.  Manages allocation and deallocation of bus indices so that you don't need to worry about conflicts. The number of control busses, audio busses, and input and output busses is fixed and cannot be changed after the server has been booted.

For more information see link::Guides/ClientVsServer:: and link::Reference/Server-Architecture::.

Note that using the Bus class to allocate a multichannel bus does not 'create' a multichannel bus, but rather simply reserves a series of adjacent bus indices with the bus' link::Classes/Server:: object's bus allocators. code::abus.index:: simply returns the first of those indices. When using a Bus with an link::Classes/In:: or link::Classes/Out:: ugen there is nothing to stop you from reading to or writing from a larger range, or from hardcoding to a bus that has been allocated. You are responsible for making sure that the number of channels match and that there are no conflicts.

Bus objects should not be created or modified within a link::Classes/SynthDef::.

Note::
The lowest code::n:: bus indices are reserved for hardware output and input, where
code::
#+BEGIN_SRC sclang
n = server.options.numOutputBusChannels + server.options.numInputBusChannels
#+END_SRC

::
definitionlist::
## Hardware output buses || code:: 0 .. (numOutputBusChannels - 1) ::
## Hardware input buses || code:: numOutputBusChannels .. (numOutputBusChannels + numInputBusChannels - 1) ::
## First private bus index || code:: numOutputBusChannels + numInputBusChannels ::
::
Do not try to use hardware I/O buses as private buses.
::

ClassMethods::

method:: control
Allocate a control bus on the server.

argument:: server
The link::Classes/Server::. Defaults to Server.default.
argument:: numChannels
Number of channels to allocate

method:: audio
Allocate an audio bus on the server.

argument:: server
The link::Classes/Server::. Defaults to Server.default.
argument:: numChannels
Number of channels to allocate

method:: alloc
Allocate a bus of either rate as specified by code::rate::.
argument:: rate
Rate symbol: \control or \audio
argument:: server
The link::Classes/Server::. Defaults to Server.default.
argument:: numChannels
Number of channels to allocate

method:: new
This method does not allocate a bus index, but assumes that you
already have allocated the appropriate bus index and can supply it
yourself.

method:: newFrom
This method creates a new Bus that is a subset of the bus. The bus will be at the same rate as the input bus.
offset is the index into the given bus. numChannels is the desired number of channels.
If the combination of offset and numChannels is outside the input bus' range, an error will be thrown.

InstanceMethods::

method:: index
Get the Bus' index. Normally you should not need to do this since instances of Bus can be passed directly as link::Classes/UGen:: inputs or link::Classes/Synth:: args.

method:: free
Return the bus' indices to the server's bus allocator so they can be reallocated.

method:: rate
Get the Bus' rate. This is a symbol, either \control or \audio.

method:: numChannels
Get the Bus' number of channels.

method:: server
Get the Bus' server object.

method:: asMap
Returns:: a symbol consisting of the letter 'c' or 'a' (for control or audio) followed by the bus's index. This may be used when setting a synth node's control inputs to map the input to the control bus.
discussion::
See the link::Classes/Node:: help file for more information on mapping controls to buses.
code::
#+BEGIN_SRC sclang
(
a = Bus.control(s, 1).set(440);
b = Bus.control(s, 1).set(0.01);
)
(
SynthDef(\rlpf, { |ffreq, rq|
	Out.ar(0, RLPF.ar(WhiteNoise.ar(0.2), ffreq, rq))
}).play(s, [\ffreq, a.asMap, \rq, b.asMap]);
)
#+END_SRC

::

method:: subBus
Get a new Bus that is a subset of this bus (see code::newFrom::).

subsection:: Asynchronous Control Bus Methods

The following commands apply only to control buses and are asynchronous. For synchronous access to control busses please
consult link::#Synchronous control bus methods::.

method:: value
Set all channels to this float value. This command is asynchronous.

method:: set
A list of values for each channel of the control bus.  The list of values supplied should not be greater than the number of channels. This command is asynchronous.

method:: setn
As set but takes an array as an argument.

method:: get
Get the current value of this control bus. This command is asynchronous.
argument:: action
a function that will be evaluated when the server responds, with the current value of the bus passed as an argument. This will be a float for a single channel bus, or an array of floats for a multichannel bus. The default action posts the bus values.


method:: getn
Get the current values of this control bus. This command is asynchronous.
argument:: count
the number of channels to read, starting from this bus' first channel.
argument:: action
a function that will be evaluated when the server responds, with the current values of the bus in an array passed as an argument.


subsection:: Synchronous Control Bus Methods

Synchronous access to control busses only works for servers with a shared memory interface. You can check with link::Classes/Server#-hasShmInterface#hasShmInterface:: if the server provides these methods.

note:: Before 3.5 the the internal server could be controlled via shared control busses and link::Classes/SharedIn:: and
link::Classes/SharedOut::. These classes have been deprecated and will be removed.  ::

method:: getSynchronous
Get the current value of this control bus. This command is synchronous.

returns::
Value of the control bus.

method:: getnSynchronous
Get the current values of this control bus. This command is synchronous.
argument:: count
The number of channels to read, starting from this bus' first channel.
returns::
Array of values.

method:: setSynchronous
A list of values for each channel of the control bus.  The list of values supplied should not be greater than the number of channels. This command is synchronous.

method:: setnSynchronous
As setSynchronous but takes an array as an argument.


subsection:: Conveniences for multichannel buses
method:: setAt
set the bus value(s) beginning at offset. asynchronous.

method:: setnAt
set the bus to the list of values supplied. asynchronous.

method:: setPairs
set the bus values by pairs of index, value, ... asynchronous

subsection:: Using Buses like UGens

method:: kr, ar
use a bus like a UGen. The numChannels and offset arguments can be used to get a subset of the bus.
discussion::
By default, all the bus channels are used. E.g. in an 8 channel bus,
list::
## code::b.kr:: will return an link::Classes/In:: ugen reading from all the 8 channels of the bus;
## code::b.kr(4):: will return the first four channels, and
## code::b.kr(2, 5):: will return two channels, starting from the bus's channels at index 5 and 6.
::

subsection:: OSC Bundle Methods

method:: getMsg
Returns a msg of the type /c_get for use in osc bundles.

method:: getnMsg
Returns a msg of the type /c_getn for use in osc bundles.
argument:: count
the number of channels to read, starting from this bus' first channel. The default is this bus' numChannels.

method:: setMsg
Returns a msg of the type /c_set for use in osc bundles.

method:: setnMsg
Returns a msg of the type /c_setn for use in osc bundles.
argument:: values
an array of values to which adjacent channels should be set, starting at this bus' first channel.

method:: fillMsg
Returns a msg of the type /c_fill for use in osc bundles.
argument:: value
the value to which this bus' channels will be set.

subsection:: Monitoring with an oscilloscope

method:: scope
Displays a bus in a link::Classes/Stethoscope::, using the Bus' link::#-numChannels::, link::#-index::, and link::#-rate:: properties.
code::
#+BEGIN_SRC sclang
s.boot
b=Bus.audio(s, 2);
a={SinOsc.ar([330,440], 0, 0.4)}.play(s, b) //you won't hear this if you only have two channels
b.scope

a.free;
b.free;
#+END_SRC

::

Examples::
code::
#+BEGIN_SRC sclang
s.boot;

(
// something to play with
SynthDef(\help_Bus, { arg out=0,ffreq=100;
	var x;
	x = RLPF.ar(LFPulse.ar(SinOsc.kr(0.2, 0, 10, 21), [0,0.1], 0.1),
			ffreq, 0.1)
			.clip2(0.4);
	Out.ar(out, x);
}).add;

)

x = Synth(\help_Bus);

// get a bus
b = Bus.control(s);

// map the synth's second input (ffreq) to read
// from the bus' output index
x.map(1, b);

// By setting the bus' value you send a /c_fill message
// to each channel of the bus setting it to supplied float value
b.value = 100;
b.value = 1000;
b.value = 30;

// Since this is a single channel bus this has the same effect
b.set(300);
b.numChannels.postln;

// multi-channel:  b.set(300,350);
// Get the current value. This is asynchronous so you can't rely on it happening immediately.
(
a = "waiting";
b.get({arg value; a = value; ("after the server responds a is set to:" + a).postln;});
("a is now:" + a).postln;
)

x.free;

	// buses can also be used with kr or ar like UGens:
(

SynthDef(\help_Bus, {
	var ffreq = b.kr;
	Out.ar(0,
		RLPF.ar(
			LFPulse.ar(SinOsc.kr(0.2, 0, 10, 21), [0,0.1], 0.1),
			ffreq, 0.1
		).clip2(0.4)
	);
}).play;
)

b.free; // release it so it may be reallocated!


// using and setting multichannel buses:

(
b = Bus.control(s, 4);

x = SynthDef(\helpBusMulti, {
	var freqs = b.kr;
	Out.ar(0, Splay.ar(SinOsc.ar(freqs) * Decay2.ar(Dust.ar(10 ! 4), 0.001, 0.1)) * 0.5);
}).play;
)

	// set bus beginning at index 0:
	// none of these methods checks whether the indexes remain
	// within the bus's range.

b.set(234, 345, 456, 567);
b.getn;
b.setn([100, 200, 300, 400]);
b.getn;

	// get to individual channels
b.setAt(3, 500);
b.getn;
b.setAt(1, 300, 400);
b.getn;
b.setnAt(1, [250, 350]);
b.getn;
	// set by pairs of index, value ...
b.setPairs(3, 600, 0, 200);
b.getn;

b.set(300, 500, 700, 900);

(	// just get the first 2 channels
x = SynthDef(\helpBusMulti, {
	Out.ar(0, SinOsc.ar(b.kr(2)) * 0.2);
}).play;
)
b.set(300, 303);
x.free;

(	// just channels[[2, 3]];
y = SynthDef(\helpBusMulti, {
	Out.ar(0, LFNoise2.ar(b.kr(2, 2)) * 0.2);
}).play;
)
b.setAt(2, 1200);
b.setAt(3, 2400);

y.free;
b.free;
#+END_SRC

::
** class:: BusPlug
summary:: a listener on a bus
categories:: Libraries>JITLib>NodeProxy
related:: Classes/Bus

description::
BusPlug is mainly in use as a basic superclass of NodeProxy, but it can be applied for other things as well. Most methods are documented in the link::Classes/NodeProxy:: helpfile.

ClassMethods::

method::new
Create a new (neutral) instance on the given server

method::audio
Create a new audio rate instance on the given server

method::control
Create a new audio rate instance on the given server

InstanceMethods::

method::clear
Free the bus, end the monitor

method::ar, kr
Return a link to my output, which is limited by strong::numChannels::. If uninitialized, creates a matching bus. Normally, strong::ar defaults to stereo, kr to mono::. This can be set in the classvars: link::#*defaultNumAudio::, link::#*defaultNumControl::

method::play
Plays from a bus index ( strong::out:: ) with a number of channels to another index with a number of channels, within a strong::group:: (ie a target group or server).

argument::out
bus index

argument::numChannels
an link::Classes/Integer::

argument::group
target link::Classes/Group:: or link::Classes/Server::

argument::multi
keep old links and add new one

argument::vol
volume at which to monitor

argument::fadeTime
fade in fade out time

argument:: addAction

method::playN

argument::outs
array of destination channels

argument::amps
array of amplitudes for each channel

argument::ins
array of source channels

argument:: vol
argument:: fadetime
argument:: group
argument:: addAction

method::monitor
returns the current monitor (see link::Classes/Monitor::)

Examples::

code::
#+BEGIN_SRC sclang
// using as a control bus listener

s.boot;
z = Bus.control(s, 16);
a = BusPlug.for(z);

m = { Mix(SinOsc.ar(a.kr(16), 0, 0.1)) }.play;

z.setn(Array.rand(16, 300, 320).put(16.rand, rrand(500, 1000)));
z.setn(Array.rand(16, 300, 320).put(16.rand, rrand(500, 1000)));
z.setn(Array.rand(16, 300, 320).put(16.rand, rrand(500, 1000)));

m.free;


m = { SinOsc.ar(a.kr(2, MouseX.kr(0, 19)), 0, 0.1) }.play; // modulate channel offset

z.setn(Array.rand(16, 300, 1320).put(16.rand, rrand(500, 1000)));


m.free; z.free;

// using as a audio monitor

p = BusPlug.audio(s,2);
d = { Out.ar(p.index, PinkNoise.ar([0.1, 0.1])) }.play;


p.play; // monitor whatever plays in p (the execution order does not matter)



d.free;
d = { Out.ar(p.index, PinkNoise.ar([0.1, 0.1])) }.play;

p.stop;
p.play;

// also p can play to another bus:

p.stop;
p.play(12);

// listen to that bus for a test:
x = { InFeedback.ar(12,2) }.play;
x.free;
#+END_SRC

::
** class:: Button
redirect:: implClass
summary:: A multi-state button
categories:: GUI>Views

description::
A multi-state button.

subsection:: Some Important Issues Regarding Button

Failure to set any states at all results in an invisible button.

The button performs its action upon releasing the mouse. In musical contexts, you might want to use code::mouseDownAction_():: to set a function to be performed on pressing the mouse (see link::Classes/View::, and examples below).

If the drag contains a number, then code::valueAction_():: is performed using the code::currentDrag::. If the drag contains anything else, code::action:: is set to the current drag. You could, for example, drag a function to an Button, and action would then be set to that function.

classmethods::

method:: new
argument:: parent
The parent view.
argument:: bounds
An instance of link::Classes/Rect::, or a link::Classes/Point:: indicating code::width@height::.
discussion::
Example:
code::
#+BEGIN_SRC sclang
(
w = Window.new("The Four Noble Truths");

b = Button(w, Rect(20, 20, 340, 30))
		.states_([
			["there is suffering", Color.black, Color.red],
			["the origin of suffering", Color.white, Color.black],
			["the cessation of suffering", Color.red, Color.white],
			["there is a path to cessation of suffering", Color.blue, Color.clear]
		])
		.action_({ arg butt;
			butt.value.postln;
		});
w.front;
)
#+END_SRC

::

instancemethods::

method:: states
An array of labels and colors defining the states of the button.
argument:: stateArray
An link::Classes/Array:: of arrays of the form code:: [ [String, strColor, bgColor] , .... ] ::

method:: value
Sets or returns the index of the current state. This will strong::not:: evaluate the function assigned to strong::action:: (see link::Classes/View::).
argument:: argVal
The index of an item in the states array.

method:: valueAction
Sets the button to display the item at index strong::anInt:: of the states array, and evaluates strong::action:: (see link::Classes/View::), if the value has changed.
argument:: anInt
The index of an item in the states array.

method:: font
Sets the Font of the button. Default value is the default font: Font.default .
argument:: f
An instance of link::Classes/Font::.


subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: doAction
The method called by the primitive upon releasing the mouse.
argument:: modifiers
A key modifier number, which is passed to the strong::action:: as its second argument upon mouse-releasing the button.

method:: defaultKeyDownAction
discussion::
The default keydown actions are:
table::
## key || action || comment
## " " || value + 1 || space
## \r || value + 1
## \n || value + 1
## 3.asAscii || value + 1 || enter key or cmd-C on Mac OSX
::
To change these use code::defaultKeyDownAction_::, see link::Classes/View::.

method:: properties
A list of properties to which this view responds. See link::Classes/View::.
returns::
[ \bounds, \visible, \enabled, \canFocus, \resize, \background, \minWidth, \maxWidth, \minHeight, \maxHeight, \value, \font, \states, \focusColor ]

method:: defaultGetDrag
The method called by default when initiating a drag strong::from:: a Button. Returns the same as link::#-value::.

method:: defaultCanReceiveDrag
The method called by default when attempting to drop a drag in this object. By default, Button will respond only to drags where the drag contains a link::Classes/Number:: or link::Classes/Function::.

method:: defaultReceiveDrag
The default method called when a drag has been received. If the drag contains a number, then action is set to the current drag. Otherwise code::valueAction_():: is performed using the code::currentDrag::.

examples::
code::
#+BEGIN_SRC sclang
(
w = Window.new("Example");

b = Button(w, Rect(90, 20, 200, 30))
		.states_([
			["sine", Color.black, Color.rand],
			["saw", Color.black, Color.rand],
			["noise", Color.black, Color.rand],
			["pulse", Color.black, Color.rand]
		])
		.action_({ arg butt;
			butt.value.postln;
		});
w.front;
)

// does not do action
b.value = 2;

// does action if it results in a change of value
b.valueAction = 3;

// clips to size of states
b.valueAction = -1;

// floats no problem
b.valueAction = 3.3;
#+END_SRC

::

In a musical context, a button-down press is more meaningful than a button-up (release) as it's more intuitive to press a button on the beat. For that you can use link::Classes/View::'s link::Classes/View#mouseDownAction:: (a superclass of Button).
code::
#+BEGIN_SRC sclang
(
s.waitForBoot({
	w = Window.new;
	b = Button(w, Rect(20, 20, 80, 26))
			.states_([["play", Color.black, Color.rand]])
			.mouseDownAction_({
				a = {EnvGen.kr(Env.adsr, doneAction:2) * SinOsc.ar(440, 0, 0.4)}.play;
			})
			.action_({ arg butt, mod;
				a.release(0.3);
			});
	w.front;
})
)
#+END_SRC

::


If you drag a function to a button, the the button's action is set to that function. you can us this for swapping functions.
code::
#+BEGIN_SRC sclang
(
s.waitForBoot({
	var w, p, snd, b;

	w = Window.new;

	b = Button(w, Rect(20, 20, 80, 26))
			.states_([["start a sound", Color.black, Color.green], ["stop", Color.black, Color.red]])
			.action_({});

	v = VLayoutView(w, Rect(140, 20, 200, 300)); //Group the following views
	StaticText(v, Rect(20, 20, 180, 60))
		.string_("The button does nothing at first, so try dragging a function to the button");

	DragSource(v, Rect(20, 20, 80, 26))
		.object_(
			{|b| (b.value == 1).if{ snd = { SinOsc.ar(440,0,0.6) }.play} { snd.free }; } //a button action function
			)
		.string_("a play sine function").align_(\center).background_(Color.rand);

	DragSource(v, Rect(20, 20, 80, 26))
		.object_(
			{|b| (b.value == 1).if{ snd = { Saw.ar(440,0.4) }.play} { snd.free }; } //a button action function
			)
		.string_("a play saw function").align_(\center).background_(Color.rand);

	DragSource(v, Rect(20, 20, 80, 26))
		.object_(
			{|b| (b.value == 1).if{ snd = { WhiteNoise.ar(0.4) }.play } { snd.free }; } //a button action function
			)
		.string_("a play noise function").align_(\center).background_(Color.rand);

	p = CmdPeriod.add({ b.value_(0) }); // set button to 0 on hitting Cmd-period
	w.onClose_{ snd.free; CmdPeriod.removeAll };//clean up when window is closed
	w.front;
})
)
#+END_SRC

::

Using Routine to set button states on the fly.
code::
#+BEGIN_SRC sclang
(
var update, w, b;
	w = Window.new("State Window", Rect(150,Window.screenBounds.height - 140, 380, 60));

	// a convenient way to set the button label
	update = {
		|but, string| but.states = [[string.asString, Color.black, Color.red]];
		but.refresh;
	};

	b = Button(w, Rect(10, 10, 360, 40));
	b.font_(Font("Impact", 24));

	update.value(b, "there is only one state");

	// if an action should do something different each time it is called, a routine is the
	// right thing to use. This is better than creating variables outside and setting them
	// from the action function to keep state from one action to the next

	b.action_(Routine { |butt|
		rrand(15, 45).do { |i|
			update.value(butt, "%. there is still only 1 state".format(i + 2));
			0.yield; // stop here
		};
		w.close;
	});
	w.front;
)
#+END_SRC

::

Using Routine to set button states on the fly 2.
code::
#+BEGIN_SRC sclang
(
s.waitForBoot({
	var update, w, b;

	w = Window.new("State Window", Rect(150, Window.screenBounds.height - 140, 380, 60));

	// a convenient way to set the button label
	update = { |but, string|
	but.states = [[string.asString, Color.black, Color.red]]; but.refresh };

	b = Button(w, Rect(10, 10, 360, 40));
	b.font_(Font("Impact", 24));

	update.value(b, "there is only one state");

	// if an action should do something different each time it is called, a routine is the
	// right thing to use. This is better than creating variables outside and setting them
	// from the action function to keep state from one action to the next

	b.action_(Routine { |butt|
		var synth, guessVal;

		update.value(butt, "there are only two states");
		0.yield; // stop here

		update.value(butt, "click me");
		0.yield; // stop here

		update.value(butt, "click me again");
		0.yield; // stop here ..

		// create a synth
		synth = { |freq = 1000, rate = 5|
			Ringz.ar(
				Impulse.ar(rate.lag(4) * [1,1.01]), freq, rrand(0.01, 0.1), 0.3
			)
		}.play;
		0.yield;

		guessVal = exprand(200.0, 18000).round;
		synth.set(\freq, guessVal); // set the synth
		update.value(butt, "?");
		0.yield;

		update.value(butt, guessVal.asString + "Hz"); // display frequency
		0.yield;

		synth.set(\rate, rrand(10, 50)); // set trigger rate
		// start an independent process
		fork({ 5.wait; synth.release; update.value(butt, "."); 1.wait; w.close }, AppClock);
	});
	CmdPeriod.doOnce({w.close});
	w.front;
});
)
#+END_SRC

::

Complex drag and drop example try dragging the buttons to white slot, and then between white slots, or simply out of the view.
code::
#+BEGIN_SRC sclang
(
var w, f, slots;
var insert, remove;

slots = Dictionary.new;

remove = {arg slot, id;
	[slot, id].postln;
};

insert = {arg slot, fx;
	if(fx != ""){
		slots["slot"++slot].value_(0).states_([[fx, Color.white, Color.blue]]);
		[slot, fx].postln;
	}{
		slots["slot"++slot].value_(0).states_([["", Color.white, Color.white]]);
		remove.value(slot, fx);
	};
};

w = Window.new("",Rect(200, 400, 448, 180));
w.view.decorator = f = FlowLayout(w.view.bounds);

StaticText(w, 400@20).string_("Drag & Drop holding down Cmd-key");
f.nextLine;
6.do{arg i;
	var fxwin, winOpen = false, empty = ["", Color.white, Color.white];

	slots["slot" ++ i] = Button.new(w, 70@70)
		.states_([empty])
		.action_({|v|
			if((slots["slot" ++ i].states[0][0] != "") && ( winOpen == false)) {
				fxwin = Window(slots["slot" ++ i].states[0][0], Rect(rrand(0, 500),rrand(0, 500),200, 200)).front;
				fxwin.view.background_(Color.rand);
				fxwin.onClose_({ winOpen = false});
				winOpen = true
			} {
				if(winOpen == true) {
					fxwin.front
				}
			}; })
		.canReceiveDragHandler_({ View.currentDrag.isString })
		.receiveDragHandler_({ insert.value(i, View.currentDrag) })
		.beginDragAction_({
			var drag;
			drag = slots["slot" ++ i].states[0][0];
			slots["slot" ++ i].value_(0).states_([empty]);
			remove.value(i, View.currentDrag);
			drag; })
		.keyDownAction_({ arg view,char,modifiers,unicode,keycode;
			switch(keycode)
				{ 51 } {
					slots["slot"++i].value_(0).states_([empty]);
					slots["slot"++i].refresh;
					remove.value(i, View.currentDrag);
				}; });
};

f.nextLine;

["a", "b", "c", "d", "e", "f"].do{ arg item, i;
	Button.new(w, 70@70)
	.states_([ [ item ] ])
	.action_({ |v| })
	.beginDragAction_({item})
};
w.front;
)
#+END_SRC

::
** class:: CCResponder
summary:: allow functions to be registered to respond to MIDI control change events
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIResponder, Classes/NoteOnResponder
categories:: External Control>MIDI

Description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef:: They still lack some features of the MIDIresponder classes.::
ClassMethods::

method::new

argument::function
A link::Classes/Function:: to be evaluated. Arguments passed to the function are: src, chan, num, value.

argument::src
The src number may be the system UID (obtained from code:: MIDIClient.sources[index].uid ::) or the index of the source in the code:: MIDIClient.sources :: array. nil matches all.

argument::chan
An link::Classes/Integer:: between 0 and 15 that selects which MIDI channel to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 2 }

argument::num
An link::Classes/Integer:: between 0 and 127 that selects which controller number to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val >= 4 }

argument::value
An link::Classes/Integer:: between 0 and 127 to filter values. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 50 }

argument::install
If true, install the responder automatically so it is active and ready to respond. If false, then it will be inactive.

argument::swallowEvent
If true, then if the midi event is matched, cease testing any further responders. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

InstanceMethods::

method::learn
Wait for the next CC message, reset to match src, chan, cc num.
code::
#+BEGIN_SRC sclang
(

c = CCResponder({ |src,chan,num,value|
		[src,chan,num,value].postln;
	});
	c.learn; // wait for the first controller
)
CCResponder.removeAll
#+END_SRC

::


Examples::

code::
#+BEGIN_SRC sclang
(
	c = CCResponder({ |src,chan,num,value|
		[src,chan,num,value].postln;
		},
		nil, // any source
		nil, // any channel
		nil, // any CC number
		nil // any value
	)
)

c.remove
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
	c = CCResponder({ |src,chan,num,value|
		[src,chan,num,value].postln;
		},
		nil, // any source
		nil, // any channel
		80, // CC number 80
		{ |val| val < 50 } // any value less than 50
	)
)

c.remove
#+END_SRC

::
** class:: COsc
summary:: Chorusing wavetable oscillator.
related:: Classes/Osc, Classes/OscN, Classes/VOsc, Classes/VOsc3
categories::  UGens>Generators>Deterministic


Description::

Chorusing wavetable lookup oscillator. Produces sum of two signals at

code::
#+BEGIN_SRC sclang
(freq ± (beats / 2)).
#+END_SRC

::

Due to summing, the peak amplitude is twice that of the wavetable.


classmethods::

method::ar, kr

argument::bufnum

The number of a buffer filled in wavetable format.


argument::freq

Frequency in Hertz.


argument::beats

Beat frequency in Hertz.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang

(
b = Buffer.alloc(s, 512, 1, {arg buf; buf.sine1Msg(1.0/[1,2,3,4,5,6,7,8,9,10])});
{ COsc.ar(b.bufnum, 200, 0.7, 0.25) }.play;
)
#+END_SRC

::

** class:: CSVFileReader
summary:: file reader for comma separated data
related:: Classes/File
categories:: Files

description::
CSVFileReader reads comma-separated text files into 2D arrays line by line.

For tab delimited files use link::Classes/TabFileReader::. For semi-colon-delimited files use link::Classes/SemiColonFileReader::. For space-delimited files, or custom delimiters, use link::Classes/FileReader::.

Examples::

code::
#+BEGIN_SRC sclang
(
// write a test file:
f = File("CSVReadTest.sc", "w");
f.write(
"Some,comma,delimited,items, in line 1

and then, some more, with several commas,,,, in line 3
"
);
f.close;
)


	// open file, read and put strings into array, close file.
x = CSVFileReader.read("CSVReadTest.sc").postcs;

	// can skip empty lines:
x = CSVFileReader.read("CSVReadTest.sc", true).postcs;

	// can skip blank entries caused by multiple commas:
x = CSVFileReader.read("CSVReadTest.sc", true, true).postcs;

	// do file open/close by hand if you prefer:
f = File("CSVReadTest.sc", "r"); f.isOpen;
t = CSVFileReader(f);
t.read(true, true).postcs;
f.close;

(
// write a test file with numbers:
f = File("CSVReadTestNum.sc", "w");

(1..10).do { |n| f.write(n.asString ++ ","); };
f.close;
)

x = CSVFileReader.read("CSVReadTestNum.sc", true, true).postcs;
x.collect(_.collect(_.interpret));	// convert to numbers.

	// or do it immediately:
x = CSVFileReader.readInterpret("CSVReadTestNum.sc").postcs;

(
// write a test file with several lines of numbers:
f = File("CSVReadTestNum.sc", "w");

(1..100).do { |n|
	f.write(n.asString ++ if (n % 10 != 0, ",", Char.nl)); };
f.close;
)


x = CSVFileReader.readInterpret("CSVReadTestNum.sc", true, true).postln;
#+END_SRC

::class:: Changed
categories:: UGens>Triggers, UGens>Filters>Linear
summary:: Triggers when a value changes

description::
Triggers when a value changes.

classmethods::
method:: ar, kr
A special case fixed filter.

argument:: input
signal input
argument:: threshold
threshold

discussion::
Implements the formula:
code::
#+BEGIN_SRC sclang
out(i) = abs(in(i) - in(i-1)) > thresh
#+END_SRC

::

examples::

detect changes in a signal:
code::
#+BEGIN_SRC sclang
(
{
	var changingSignal = LFNoise0.ar(1000);
	var changed = Changed.ar(changingSignal);
	[changingSignal, changed]
}.plot2
);
#+END_SRC

::

** class:: ChaosGen
summary:: UGens that cause chaos
categories:: UGens>Generators>Chaotic

description::
"ChaosGen" is an emphasis::abstract class:: - in other words, a class that you do not use directly. Instead, use one of its subclasses.
Various things inherit from this abstract class, including link::Classes/HenonN::, link::Classes/LinCongL::, link::Classes/LatoocarfianL::, link::Classes/GbmanL::, link::Classes/CuspL::, link::Classes/StandardL::, and more.

These chaotic UGens generally each represent a deterministic set of equations, which can take different starting parameters. The equations define a system whose evolution over time is highly sensitive to initial conditions, and can exhibit highly intricate behaviour.

To learn more, start here: http://en.wikipedia.org/wiki/Chaos_theory

To see all classes which derive from the ChaosGen class, run this line:

code::
#+BEGIN_SRC sclang
ChaosGen.allSubclasses.do(_.postln)
#+END_SRC

::
** class::Char
summary::ascii character
categories:: Core

description::
Chars may be written as literals using the $ sign. For example $a, $b, $c.
See link::Reference/Literals::

Chars may be created from link::Classes/Integer::s using the methods link::Classes/Integer#-asAscii:: and link::Classes/Integer#-asDigit::.

classmethods::

method::nl
Returns code::($\n)::
method::ff
Returns code::($\f)::
method::tab
Returns code::($\t)::
method::space
Returns code::($ )::
method::comma
Returns code::($\,)::
method::bullet
Returns a bullet character (•) in SuperCollider.app on OSX, but a simple asterix (*) on other frontends.
This method is not recommended, since it's actually not cross-platform.

instancemethods::
private:: archiveAsCompileString

subsection::conversion

method::ascii

returns:: the integer ascii value of a Char.

method::digit

returns:: an integer value from 0 to 9 for chars $0 to $9, and values 10 to 35 for chars $a to $z
or $A to $Z.

method::toUpper

returns:: the upper case version of a char. Nonalphabetic chars return themselves.

method::toLower

returns:: a lower case version of a char. Nonalphabetic chars return themselves.

subsection:: Testing

method::isAlpha

returns:: whether the char is an alphabetic character.

method::isAlphaNum

returns:: whether the char is an alphabetic or numeric character.

method::isPrint

returns:: whether the char is printable.

method::isPunct

returns:: whether the char is a punctuation character

method::isSpace

returns:: true if the char is white space.

method::isDecDigit

returns:: true if the char is a decimal digit $0 to $9.

method::isFileSafe

returns:: true if the char is safe for use as in a filename.
excludes the path separators / and :
discussion::
code::
#+BEGIN_SRC sclang
 for(0,255,{ arg i;
	var a;
	[i,a = i.asAscii,a.isAlphaNum,a.isPrint,a.isPunct,a.isControl].postln;
});
#+END_SRC

::
** class:: CheckBadValues
summary:: Test for infinity, not-a-number, and denormals
categories:: UGens>Info

description::
This link::Classes/UGen:: tests for infinity, NaN (not a number), and denormals. If one of these is found, it posts a warning. Its output is as follows: 0 = a normal float, 1 = NaN, 2 = infinity, and 3 = a denormal.

classmethods::

method:: ar, kr
argument:: in
the link::Classes/UGen:: whose output is to be tested.
argument:: id
an id number to identify this link::Classes/UGen::. The default is 0.
argument:: post
One of three post modes:

list::
## 0 = no posting;
## 1 = post a line for every bad value;
## 2 = post a line only when the floating-point classification changes (e.g., normal -> NaN and vice versa)
::

The default post mode is 2. Post mode 1 is retained for backward compatibility; be aware that it generates a large amount of output.

examples::
code::
#+BEGIN_SRC sclang
{ CheckBadValues.kr(SinOsc.ar); 0}.play // nothing wrong here

{ CheckBadValues.kr(1 / 0, 1).poll; 0 }.play // check infinity

x = { arg test = -1; CheckBadValues.kr(test); 0 }.play // check NaN
x.set(\test, -1.sqrt);

// don't post, but do something with the output
(
x = { arg freq = 440;
	var good;
	good = BinaryOpUGen('==', CheckBadValues.kr(freq, 0, 0), 0);
	SinOsc.ar(freq, 0, 0.1) * good // silence the output if freq is bad
}.play;
)
x.set(\freq, -1.sqrt);

// the UGen method checkBadValues passes through the input for quick testing
{ SinOsc.ar(440, 0, 0.1).checkBadValues }.play
#+END_SRC

::
** CLASS:: CheckBox
redirect:: implClass
summary:: A view that toggles between two states.
categories:: GUI>Views

DESCRIPTION::

A view that toggles between two states when clicked, displaying or hiding a check mark accordingly.

CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::



SUBSECTION:: Data



METHOD:: value
	Stating which of the two states the view is currently in, false meaning unchecked and true meaning checked. Default to false.

	argument::
		A Boolean.

METHOD:: valueAction
	Sets link::#-value:: and triggeres link::#-action::.

	argument::
		A Boolean.

METHOD:: string
	The text displayed next to the check mark.



SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user toggles the state.



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The link::#-value::.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a Boolean.

METHOD:: defaultReceiveDrag
	Sets link::#-valueAction:: to the current drag data.
** class::Class
summary::A Class describes the structure and implementation of a set objects which are its instances.
categories::Core>Kernel, Language>OOP

ClassMethods::
method:: allClasses
returns:: an link::Classes/Array:: of all Classes

InstanceMethods::

method::browse

Open a graphical browser for this Class. Shows methods, arguments, variables, subclasses, and has buttons for navigating to the superclass, source, helpfile, etc.

method::findMethod

Find the Method referred to by name. If not found, return nil.

method::findRespondingMethodFor

As above, but climb the class tree to see if the method is inherited from a superclass. If not found, return nil.

method::dumpAllMethods

Post all instance methods which instances of this class responde too, including inherited ones. code::this.class.dumpAllMethods:: will post all class methods which this class responds to.

method::dumpByteCodes

Dump the byte codes of the named method.

method::dumpClassSubtree

Post the tree of all Classes that inherit from this class.

method::dumpInterface

Post all the methods defined by this Class and their arguments.

method::dumpFullInterface

Post all the class and instance methods that this class responds to (i.e. those defined in this class and those inherited by it).

method::help

Opens the help file for this Class if it exists.

method::helpFilePath

Returns the path of this Class's helpfile as a String.

method::helpFileForMethod

Opens the helpfile for the class in which the responding method is implemented.

code::
#+BEGIN_SRC sclang
Array.helpFileForMethod('select'); // This will open the Collection helpfile
#+END_SRC

::

method::asClass

Return this.

method::asString

Return the name of the class as a String.


subsection:: Accessing

method::name

A Symbol that is the name of the class.

method::nextclass

The next class in a linked list of all classes.

method::superclass

The Class from which this class directly inherits.

method::superclasses

An Array of this class's superclasses, going back to Object.

method::subclasses

An Array of the direct subclasses of this.

method::allSubclasses

An Array of all subclasses of this.

method::methods

An Array of the methods of this class.

method::instVarNames

An Array of the names of the instance variables for this class.

method::classVarNames

An Array of the names of the class variables for this class.

method::iprototype

An Array of the initial values of instance variables.

method::cprototype

An Array of the initial values of class variables.

method::filenameSymbol

A Symbol which is a path to the file which defines the Class.

** class:: Clip
summary:: Clip a signal outside given thresholds.
related:: Classes/Fold, Classes/Wrap
categories::  UGens>Maths


Description::

This differs from the  link::Classes/BinaryOpUGen::  link::Overviews/Methods#clip2#clip2:: in that it
allows one to set both low and high thresholds.


classmethods::

method::ar, kr

argument::in

Signal to be clipped.


argument::lo

Low threshold of clipping. Must be less then hi.


argument::hi

High threshold of clipping. Must be greater then lo.


Examples::

code::
#+BEGIN_SRC sclang

s.boot;

{ Clip.ar(SinOsc.ar(440, 0, 0.2), -0.07, 0.07) }.scope;
#+END_SRC

::

** class:: ClipNoise
summary:: Clip Noise.
related:: Classes/BrownNoise, Classes/GrayNoise, Classes/PinkNoise, Classes/WhiteNoise
categories::  UGens>Generators>Stochastic


Description::

Generates noise whose values are either -1 or 1. This produces
the maximum energy for the least peak to peak amplitude.


classmethods::

method::ar, kr

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang
{ ClipNoise.ar(0.2) }.play;
#+END_SRC

::

** CLASS::Clock
categories::Scheduling>Clocks
summary::abstract superclass for clocks
related::Classes/AppClock, Classes/SystemClock, Classes/TempoClock

DESCRIPTION::
Clock is an abstract class: it only defines an abstract set of methods that
all clocks should implement. See its subclasses: link::Classes/SystemClock::,
link::Classes/TempoClock::, link::Classes/AppClock:: for specific
implementations.

subsection:: Scheduling

A Clock keeps track of time and allows strong::tasks:: to be
strong::scheduled:: for some time in the future (e.g. using
link::Classes/TempoClock#-sched#sched::,
link::Classes/TempoClock#-schedAbs#schedAbs:: or
link::Classes/TempoClock#-play#play:: methods).
A task can be any link::Classes/Object::. When the time at which a task was scheduled is up, the task is emphasis::awoken::, i.e. its
link::Classes/Object#-awake#awake:: method is evaluated. If the value returned by
this method is a number, the task is automatically strong::rescheduled:: for the
time equal to its last scheduled time plus the return value (in
link::Classes/TempoClock#-beats#beats::).

subsection:: Useful Tasks

Objects of different classes may do different things in response to being
scheduled on a clock by having own implementation of the code::awake:: method.
The link::Classes/Object#-awake:: method that all clases inherit simply
calls the same object's link::Classes/Object#-next#next:: method, forwarding the
code::beats:: argument as well as the return value, so subclasses may implement
#+BEGIN_SRC sclang
either one to equivalent effect, as far as clock scheduling is concerned.
footnote:: However, note that the code::next:: method is also involved in the
concept of link::Tutorials/Streams-Patterns-Events1.html#Streams#streams::.::

Examples of useful objects to be scheduled on clocks:
list::
## link::Classes/Function#-awake:: method is implemented so as to call
the function's own link::Classes/Function#-value:: method, effectively running
the code within the function.
## link::Classes/Routine#-awake:: calls own link::Classes/Routine#-next::, in
turn starting or resuming the Routine's Function.
## Some subclasses of link::Classes/Stream:: will have its code::next:: method
do something useful aside from returning a new value in a stream.
#+END_SRC

::

subsection:: Scheduling and Threads

Whenever a task is awaken, its code::awake:: method is called in the context of
the link::Classes/Process#-mainThread#main thread::. Just before that, the main
thread's link::Classes/Thread#-beats#logical time:: is set to the scheduling
time of the awaken task, and its link::Classes/Thread#-clock#clock:: is set to
the scheduling clock. Note however that if the task is a link::Classes/Routine::
 it will then immediately start or resume its Function, setting itself as the
link::Classes/Thread#.thisThread#current thread::.

** class:: CmdPeriod
summary:: register objects to be cleared when Cmd-. is pressed
related:: Classes/ShutDown, Classes/ServerQuit
categories:: Control

description::

CmdPeriod allows you to register objects to perform an action when the user presses Cmd-. These objects must implement a method called strong::-cmdPeriod:: which performs the necessary tasks. (You can add such a method in your custom classes.) Note that since link::Classes/Function:: implements strong::-cmdPeriod:: as a synonym for strong::-value::, it is possible to register any function (and thus any arbitrary code) for evaluation when Cmd-. is pressed.

ClassMethods::

method::add
Registers an object to be cleared when Cmd-. is pressed. This object will stay registered until it is explicitly removed, and will thus respond to additional presses of Cmd-.

method::remove
Removes an object that was previously registered.

method::removeAll
Removes all objects that have been registered.

method::doOnce
Registers an object to be evaluated once, and then unregistered.

method::objects
Get or set the list of objects that are called when CmdPeriod is evaluated.

method::era
The number of times CmdPeriod has been called since startup.

Examples::

code::
#+BEGIN_SRC sclang
(
f = {"foo".postln };
g = {"bar".postln };
CmdPeriod.add(f);
CmdPeriod.add(g);
)

// Now press Cmd-.

CmdPeriod.remove(g);

// Now press Cmd-. Only f executes

CmdPeriod.remove(f); // must explicitly cleanup


// Now press Cmd-.

CmdPeriod.add(g); // one object is added only once.
CmdPeriod.add(g); // one object is added only once.


// Now press Cmd-.

// remove it again.
CmdPeriod.remove(g);


// note that often you want to automatically remove the function once it is evaluated
// instead of

f = { "foo".postln; CmdPeriod.remove(f) };
CmdPeriod.add(f);

// you can write:

CmdPeriod.doOnce { "foo".postln }

// a typical example:
(
w = Window.new("close on cmd-.").front;
CmdPeriod.doOnce { w.close };
)


// in some cases you might need to defer the function by a short amount of time
a = { Synth(\default)};
a.value;
CmdPeriod.add({{a.value}.defer(0.01)});

// remove all
CmdPeriod.removeAll
#+END_SRC

::
** class:: Cocoa
summary:: file paths that utilize OS X Cocoa services
related:: Classes/CocoaDialog
categories:: Platform>OSX

ClassMethods::

private::prGetPathsInDirectory

Examples::

code::
#+BEGIN_SRC sclang
Cocoa.getPathsInDirectory("plugins")

// note: it is better to now use pathMatch (unix compatible). Wild cards like * can be used.

"plugins/*".pathMatch;
"plugins/D*".pathMatch;
"plugins/[D,T]*".pathMatch;

/*
This is a temporary implementation before I (felix) gets around to doing the proper Directory implementation.
It gets all paths in that directory and subdirectories.
maxItems is the size of the array to use, and should be larger than the number of items you might return, else a primitive index error.

all paths are standardized
*/
#+END_SRC

::
** class:: CocoaDialog
summary:: file dialogs that utilize OS X Cocoa services
related:: Classes/Cocoa, Classes/GUI
categories:: Platform>OSX

description::

OSX only. See link::Classes/GUI:: for cross-platform information.

ClassMethods::

private::initClass, prGetPathsDialog, prSavePanel

method::getPaths
Displays an Open File Dialog.

argument::okFunc
A link::Classes/Function:: to be evaluated when OK is pressed. The selected paths are passed as an Array of Strings as the first argument.

argument::cancelFunc
A link::Classes/Function:: to be evaluated if Cancel is pressed.

argument::allowsMultiple
A link::Classes/Boolean:: indicating whether the dialog allows the user to select multiple files. The default is true.

method::savePanel
Displays a Save File Dialog.

argument::okFunc
A link::Classes/Function:: to be evaluated when OK is pressed. The selected path will be passed as a String as the first argument.

argument::cancelFunc
A link::Classes/Function:: to be evaluated if Cancel is pressed.

Examples::

code::
#+BEGIN_SRC sclang
(
CocoaDialog.getPaths({ arg paths;
	paths.do({ arg p;
		p.postln;
	})
},{
	"cancelled".postln;
});
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
CocoaDialog.savePanel({ arg path;
	path.postln;
},{
	"cancelled".postln;
});
)
#+END_SRC

::
** class:: CocoaDocument
summary:: implements Document functionality
related:: Classes/Document
categories:: Platform>OSX

description::

CocoaDocument implements link::Classes/Document:: functionality for the SuperCollider user interface on Mac OSX.

You could instantiate it e.g. by running code::CocoaDocument.new:: but in order to write platform-independent code you should not do this - simply call code::Document.new:: and this instantiates the correct class for your system.

For examples and method descriptions see link::Classes/Document::.

ClassMethods::

private::initClass, prSetDefaultFont, prSetSyntaxColorTheme, prDefaultUsesAutoInOutdent_, prnumberOfOpen, prGetIndexOfListener

method:: wikiBrowse
If set to code::true::, underlining text will create a wiki link.
argument:: value
An instance of link::Classes/Boolean::. Default value is code::true::.

method:: wikiDir
Get/set the default wiki directory. The default is dependent on link::Classes/Document#implementationClass::.
argument:: path
The file system path to the directory. An instance of link::Classes/String::.


method:: postColor
Get / set the listeners pen color.
argument:: col
An instance of link::Classes/Color::.
discussion::
code::
#+BEGIN_SRC sclang
CocoaDocument.postColor; // returns current post color
CocoaDocument.postColor_(Color.red);
CocoaDocument.postColor_(Color.green);
CocoaDocument.postColor_(Color.blue);
CocoaDocument.postColor_(Color.black);
(
r = Routine({
	10.do({
		Document.postColor_(Color.rand);
		"There is no blue without yellow and without orange.".postln;
		0.5.rand.yield;
	});
	CocoaDocument.postColor_(Color.black);
});
)

r.play;
r.stop;
#+END_SRC

::

method:: setTheme
Sets the theme for syntax colorization.
argument:: themeName
A link::Classes/Symbol::, defining the name of the theme that you've put into code::Document.themes::.
discussion::
The Document class has a preset theme called code::'default'::, which is set as follows (default SC colors):
code::
#+BEGIN_SRC sclang
themes = (
	default: (
		classColor: Color(0, 0, 0.75, 1),
		textColor: Color(0, 0, 0, 1),
		stringColor: Color(0.375, 0.375, 0.375, 1),
		commentColor: Color(0.75, 0, 0, 1),
		symbolColor: Color(0, 0.45, 0, 1),
		numberColor: Color(0, 0, 0, 1)
	)
);
#+END_SRC

::
If you want to have your own themes for syntax colorization, you need to put your color set into code::CocoaDocument.themes:: first (preferably in startup.rtf file) and call code::setTheme:: by giving it the name of the theme you've added to "themes" earlier:
code::
#+BEGIN_SRC sclang
//putting a custom color theme into Document.themes
CocoaDocument.themes.put
(\myTheme,
	(
		classColor: Color.new255(53, 74, 187),
		textColor: Color.new255(0, 0, 0),
		stringColor: Color.new255(96, 129, 158),
		commentColor: Color.new255(206, 27, 28),
		symbolColor: Color.new255(57, 154, 20),
		numberColor: Color.new255(157, 80, 65)
	)
);

//and then calling setTheme with the name:
CocoaDocument.setTheme('myTheme');
//to see the current theme:
CocoaDocument.theme;
#+END_SRC

::
You can switch to the default theme anytime by calling:
code::
#+BEGIN_SRC sclang
CocoaDocument.setTheme('default');
#+END_SRC

::
Next time you invoke syntaxColorize, the color theme set by setTheme will be used for syntax colorization. If you want to change the background color for the document window and selected text, in order to make them fit with your syntax colorization theme, see the help for the link::Classes/CocoaDocument#background:: and link::Classes/CocoaDocument#selectedBackground:: methods for Document.


InstanceMethods::

private::prUsesAutoInOutdent_, prIsEditable_, prSetTitle, prGetTitle, prGetFileName, prSetFileName, prGetBounds, prSetBounds, prBalanceParens, prclose, prinsertText, prinitByIndex, prGetLastIndex, propen, prinitByString, prSetBackgroundColor, prGetBackgroundColor, prSetSelectedBackgroundColor, prGetSelectedBackgroundColor, prSelectLine, prSetFont


method:: balanceParens
Starting from the current selection, increase the selection until matching parentheses are selected.
argument:: level
Do this as many times to find ever wider brackets. Set to code::inf:: for outmost.
discussion::
code::
#+BEGIN_SRC sclang
((((
CocoaDocument.current.balanceParens(1);
CocoaDocument.current.balanceParens(3);
CocoaDocument.current.balanceParens(inf);
))))
#+END_SRC

::

method:: background
Get / set the the Document's background color.
argument:: color
An instance of link::Classes/Color::.
discussion::
code::
#+BEGIN_SRC sclang
(
a = Document("background", "'hardly see anything");
a.background_(Color.blue(alpha:0.8)); // notice that alpha controls the window transparency
)
#+END_SRC

::

method:: stringColor
Gets or sets the string color of a specific range of already printed text. Default is the whole document. To set the listener text color for posting, see: link::Classes/Document#postColor::.
argument:: color
An instance of link::Classes/Color::.
argument:: rangeStart
An link::Classes/Integer::. Default is -1.
argument:: rangeSize
An link::Classes/Integer::. Default value is 0
discussion::
code::
#+BEGIN_SRC sclang
// Select the following code in parentheses and execute it
(
Document.current.stringColor_(Color.rand(0.2, 0.8),
	Document.current.selectedRangeLocation + 13,
	16);
)
// Watch me change color
#+END_SRC

::

method:: selectedBackground
Gets or sets the document's background color for selected text. Applies to the whole document instance.
argument:: color
An instance of link::Classes/Color::.
discussion::
code::
#+BEGIN_SRC sclang
Document.current.selectedBackground; // returns default color
(
w = Document.new("Test", "Here is a selected text...");
w.selectedBackground_(Color.new255(120, 180, 110));
w.selectRange(10, 13);
)
#+END_SRC

::

method:: syntaxColorize
Syntax colorize a document.

method:: makeWikiPage
Creates a wiki page.
argument:: wikiWord
An instance of link::Classes/String::. The name of the document.
argument:: extension
An instance of link::Classes/String::. The file extension.
argument:: directory
An instance of link::Classes/String::. The directory in which to save the page.
discussion::
code::
#+BEGIN_SRC sclang
Document.current.makeWikiPage("test1");
#+END_SRC

::

method:: openWikiPage
Opens/creates a wiki page out of the currently selected text.



** class:: CocoaMenuItem
summary:: Abstract superclass of OSX Menu Items
categories:: GUI>Kits>Cocoa
related:: Classes/SCMenuItem, Classes/SCMenuGroup, Classes/SCMenuSeparator

description::
CocoaMenuItem represents a menu item or sub menu in the application menu. This is an abstract class. Generally you will deal with the subclasses SCMenuItem, SCMenuGroup, and SCMenuSeparator, but the convenience method *add (see below) allows one to easily add items to a default 'Library' menu.


classmethods::

method:: clearCustomItems
Clear all custom menu items.

method:: default
Returns the 'Library' menu, creating it if necessary.

method:: add
Add an item to the Library menu. The Library menu will be created automatically if needed.
argument:: names
An link::Classes/Array:: of link::Classes/String::s indicating the menu path to this item.
argument:: action
A link::Classes/Function:: that will be evaluated when this item is selected.


instancemethods::

method:: action
Get or set this item's action. This is a Function that will be evaluated when this item is selected.


method:: state
Get or set this item's state.
argument:: bool
If bool is true a check mark is displayed next to the item.

method:: remove
Remove the receiver and its children (if any).

method:: enabled
Enable or disable this menu item.
argument:: bool
A link::Classes/Boolean:: indicating whether this item should be enabled or disabled.

method:: setShortCut
Set the keyboard shortcut for this item. The Cmd key is assumed.
argument:: string
A link::Classes/String:: indicating the character for this shortcut.
argument:: alt
A link::Classes/Boolean:: indicating whether the alt key is included in this shortcut. Default value is false.
argument:: ctrl
A link::Classes/Boolean:: indicating whether the ctrl key is included in this shortcut. Default value is false.

method:: doAction
Evaluate the receiver's action function.


examples::

code::
#+BEGIN_SRC sclang
// Simple example
g = SCMenuGroup(nil, "stuff", 10);
i = SCMenuItem(g, "foo");
j = SCMenuItem(g, "bar");
j.action = { "bar!!".postln };
k = SCMenuSeparator(g, 1); // add a separator
i.enabled = false;
j.state = true;
j.setShortCut("$", true, true); // Cmd-ctrl-alt-$

// using *add
CocoaMenuItem.add(["hallo", "world"], { "hallo menu".postln });
CocoaMenuItem.add(["hallo", "world", "here"], { "hallo here".postln }); // fails correctly
CocoaMenuItem.add(["mellow", "world", "here"], { "mellow here".postln }); // works.
CocoaMenuItem.add(["hallo", "thought"], { "hallo world".scramble.postln });

CocoaMenuItem.clearCustomItems;
#+END_SRC

::
** class:: CoinGate
summary:: Statistical gate.
categories::  UGens>Generators>Stochastic


Description::

When CoinGate receives a trigger, it tosses a coin
and either passes the trigger or doesn't.


classmethods::

method::ar, kr

argument::prob

Value between 0.0 and 1.0 determines probability of either possibilities.


argument::in
The trigger input.

Examples::

code::
#+BEGIN_SRC sclang

(
a = SynthDef("help-TCoin", { arg out=0, prob=0.5;
	var trig;
	trig = CoinGate.kr(prob, Impulse.kr(10));
	Out.ar(out,
		SinOsc.ar(
			TRand.kr(300.0, 400.0, trig),0,0.2
		)
	)
}).play;
)

a.set(\prob, 1.0);
a.set(\prob, 0.0);
a.set(\prob, 0.1);


(
a = SynthDef("help-TCoin", { arg out=0, prob=0.5;
	var trig;
	trig = Impulse.ar(20, 0, SinOsc.kr(0.5,0,1,1));
	Out.ar(out,
		Mix.fill(3, {Ringz.ar(CoinGate.ar(prob, trig*0.5), #[1,1.5]*Rand(1000, 9000), 0.01)})
	)
}).play;
)

a.set(\prob, 1.0);
a.set(\prob, 0.0);
a.set(\prob, 0.1);
#+END_SRC

::
** CLASS::Collection
summary::Abstract superclass of all collections
related::Classes/List, Classes/Array, Classes/Dictionary, Classes/Bag, Classes/Set, Classes/SortedList
categories::Collections

DESCRIPTION::
Collection is an abstract class. You do not create direct instances of Collection.
There are many types of Collections including link::Classes/List::, link::Classes/Array::, link::Classes/Dictionary::, link::Classes/Bag::, link::Classes/Set::, link::Classes/SortedList::, etc. See link::Overviews/Collections:: for a complete class tree.

CLASSMETHODS::

method::newFrom
Creates a new Collection from another collection. This supports the interface for the method "as".
code::
#+BEGIN_SRC sclang
Array.newFrom(Set[4, 2, 1]);
Set.newFrom(Array[4, 2, 1]);
[1, 2, 3, 4, 3, 2].as(Set); // as(someClass) calls someClass.newFrom(this)
#+END_SRC

::

method::with
Creates a new Collection from the args.
code::
#+BEGIN_SRC sclang
Array.with(4, 2, 1);
#+END_SRC

::

method::fill
Creates a Collection of the given size, the elements of which are determined by evaluation the given function. The function is passed the index as an argument.
code::
#+BEGIN_SRC sclang
Array.fill(4, { arg i; i * 2 });
Bag.fill(14, { arg i; i.rand });
#+END_SRC

::

argument::size
The size of the collection which is returned. If nil, it returns an empty collection. If an array of sizes is given, the resulting collection has the appropriate dimensions (see: link::#*fillND).
::

code::
#+BEGIN_SRC sclang
Array.fill([2, 2, 3], { arg i, j, k;  i * 100 + (j * 10) + k });
#+END_SRC

::

argument::function
The function which is called for each new element - the index is passed in as a first argument. The function be anything that responds to the message "value".

code::
#+BEGIN_SRC sclang
Array.fill(10, { arg i; 2 ** i });
Array.fill(10, Pxrand([0, 1, 2], inf).iter);
Array.fill(10, 7); // an object that doesn't respond with a new value is just repeatedly added.
#+END_SRC

::

method::fill2D
Creates a 2 dimensional Collection of the given sizes. The items are determined by evaluation of the supplied function. The function is passed row and column indexes as arguments. See link::Guides/J-concepts-in-SC::
code::
#+BEGIN_SRC sclang
Array.fill2D(2, 4, 0);
Array.fill2D(3, 4, { arg r, c; r*c+c; });
#+END_SRC

::

method::fill3D
Creates a 3 dimensional Collection of the given sizes. The items are determined by evaluation of the supplied function. The function is passed plane, row and column indexes as arguments. See link::Guides/J-concepts-in-SC::
code::
#+BEGIN_SRC sclang
Array.fill3D(2, 3, 4, { arg p, r, c; p; });
#+END_SRC

::

method::fillND
Creates a N dimensional Collection where N is the size of the array strong::dimensions::. The items are determined by evaluation of the supplied function. The function is passed N number of indexes as arguments. See link::Guides/J-concepts-in-SC::
code::
#+BEGIN_SRC sclang
Array.fillND([4, 4], { arg a, b; a+b; });				// 2D
Array.fillND([4, 4, 4], { arg a, b, c; a+b*c; });		// 3D
Array.fillND([1, 2, 3, 4], { arg a, b, c, d; b+d; });	// 4D
#+END_SRC

::

INSTANCEMETHODS::

subsection::Accessing

method::size
Answers the number of objects contained in the Collection.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].size;
#+END_SRC

::

method::isEmpty
Answer whether the receiver contains no objects.
code::
#+BEGIN_SRC sclang
List[].isEmpty;
#+END_SRC

::


subsection::Adding and Removing

method::add
Add anObject to the receiver.
code::
#+BEGIN_SRC sclang
List[1, 2].add(3);
#+END_SRC

::

method::addAll
Add all items in aCollection to the receiver.
code::
#+BEGIN_SRC sclang
List[1, 2].addAll(List[3, 4]);
#+END_SRC

::

method::remove
Remove anObject from the receiver. Answers the removed object.
code::
#+BEGIN_SRC sclang
(
var a;
a = List[1, 2, 3, 4];
a.remove(3);
a;
)
#+END_SRC

::

method::removeAll
Remove all items in aCollection from the receiver.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].removeAll(List[2, 3]);
#+END_SRC

::
note::that multiple items in the receiver will not necessarily be removed
code::
#+BEGIN_SRC sclang
~closet = [\hat, \hat, \hat, \coat, \coat, \shoe, \shoe];
~closet.removeAll([\hat, \coat, \shoe, \shoe]); // Doesn't empty the closet, just removes what we wanted to
#+END_SRC

::
See link::#-removeEvery:: for a related method that removes all occurrences.
::

method::removeEvery
Remove all occurrences of the items in aCollection from the receiver.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 2, 3, 2, 3, 4].removeEvery(List[2, 3]);
#+END_SRC

::

method::removeAllSuchThat
Remove all items in the receiver for which function answers link::Classes/True::. The function is passed two arguments, the item and an integer index. Answers the objects which have been removed.
code::
#+BEGIN_SRC sclang
(
var a;
a = List[1, 2, 3, 4];
a.removeAllSuchThat({ arg item, i; item < 3 });
a;
)
#+END_SRC

::

method::putEach
Put the values in the corresponding indices given by keys. If one of the two argument arrays is longer then it will wrap.
code::
#+BEGIN_SRC sclang
y = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
y.putEach([4, 7], [\smelly, \head]);
y.putEach([2, 3, 5, 6], \wotsits);
#+END_SRC

::

method::atAll
Return a collection of all the items for the keys.
code::
#+BEGIN_SRC sclang
y = [\a, \b, \c];
y.atAll([0, 2]);
#+END_SRC

::

subsection::Testing

method::includes
Answer whether anObject is contained in the receiver.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].includes(3);
#+END_SRC

::

method::includesAny
Answer whether any item in aCollection is contained in the receiver.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].includesAny(List[4, 5]);
#+END_SRC

::

method::includesAll
Answer whether all items in aCollection are contained in the receiver.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].includesAll(List[4, 5]);
#+END_SRC

::

method::matchItem
Returns link::Classes/True:: if this includes the strong::item::.

subsection::Iteration

method::do
Evaluates strong::function:: for each item in the collection. The function is passed two arguments, the item and an integer index.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].do({ arg item, i; item.postln });
#+END_SRC

::

method::collect
Answer a new collection which consists of the results of strong::function:: evaluated for each item in the collection. The function is passed two arguments, the item and an integer index.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].collect({ arg item, i; item + 10 });
#+END_SRC

::
If you want to control what type of collection is returned, use link::#-collectAs::(function, class).

method::select
Answer a new collection which consists of all items in the receiver for which strong::function:: answers link::Classes/True::. The function is passed two arguments, the item and an integer index.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].select({ arg item, i; item.even });
#+END_SRC

::
If you want to control what type of collection is returned, use link::#-selectAs::(function, class).

method::reject
Answer a new collection which consists of all items in the receiver for which strong::function:: answers link::Classes/False::. The function is passed two arguments, the item and an integer index.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].reject({ arg item, i; item.even });
#+END_SRC

::
If you want to control what type of collection is returned, use link::#-rejectAs::(function, class).

method::detect
Answer the first item in the receiver for which strong::function:: answers link::Classes/True::. The function is passed two arguments, the item and an integer index.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].detect({ arg item, i; item.even });
#+END_SRC

::

method::detectIndex
Similar to link::#-detect:: but returns the index instead of the item itself.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].detectIndex({ arg item, i; item.even });
#+END_SRC

::

method::inject
In functional programming, the operation known as a fold.
inject takes an initial value and a function and combines the elements of the collection by applying the function to the accumulated value and an element from the collection. The strong::function:: takes two arguments and returns the new value. The accumulated value is initialzed to strong::initialValue::.
code::
#+BEGIN_SRC sclang
[1,2,3,4,5].inject(0, _+_); // 15

[1,2,3,4,5].inject(1, _*_); // 120

// same as .collect(_.squared)
[1,2,3,4,5].inject([], {|a,b| a ++ b.squared }); // [ 1, 4, 9, 16, 25 ]
[1,2,3,4,5].inject([], {|a,b| [b] ++ a ++ [b]}); // [ 5, 4, 3, 2, 1, 1, 2, 3, 4, 5 ]
[1,2,3,4,5].inject([], {|a,b| a ++ b ++ a});
[1,2,3,4,5].inject([], {|a,b| a ++ a ++ b});
#+END_SRC

::

method::any
Answer whether strong::function:: answers link::Classes/True:: for any item in the receiver. The function is passed two arguments, the item and an integer index.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].any({ arg item, i; item.even });
#+END_SRC

::

method::every
Answer whether strong::function:: answers link::Classes/True:: for every item in the receiver. The function is passed two arguments, the item and an integer index.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].every({ arg item, i; item.even });
#+END_SRC

::

method::count
Answer the number of items for which strong::function:: answers link::Classes/True::. The function is passed two arguments, the item and an integer index.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].count({ arg item, i; item.even });
#+END_SRC

::

method::occurrencesOf
Answer the number of items in the receiver which are equal to anObject.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 3, 4, 3, 4, 3].occurrencesOf(3);
#+END_SRC

::

method::sum
Answer the sum of the results of strong::function:: evaluated for each item in the receiver. The function is passed two arguments, the item and an integer index.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].sum;
(0..8).sum { |i| 1 / (2 ** i) };
#+END_SRC

::

method::maxItem
Answer the maximum of the results of strong::function:: evaluated for each item in the receiver. The function is passed two arguments, the item and an integer index.
If function is nil, then answer the maximum of all items in the receiver.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].maxItem({ arg item, i; item + 10 });
#+END_SRC

::

method::minItem
Answer the minimum of the results of strong::function:: evaluated for each item in the receiver. The function is passed two arguments, the item and an integer index.
If function is nil, then answer the minimum of all items in the receiver.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].minItem({ arg item, i; item + 10 });
#+END_SRC

::

method::maxIndex
Answer the index of the maximum of the results of strong::function:: evaluated for each item in the receiver. The function is passed two arguments, the item and an integer index.
If function is nil, then answer the maximum of all items in the receiver.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].maxIndex({ arg item, i; item + 10 });
[3.2, 12.2, 13, 0.4].maxIndex;
#+END_SRC

::

method::minIndex
Answer the index of the minimum of the results of strong::function:: evaluated for each item in the receiver. The function is passed two arguments, the item and an integer index.
If function is nil, then answer the minimum of all items in the receiver.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].minIndex({ arg item, i; item + 10 });
List[3.2, 12.2, 13, 0.4].minIndex;
#+END_SRC

::

method::maxSizeAtDepth
Returns the maximum size of all subcollections at a certain depth (dimension)

argument::rank
The depth at which the size of the collection is measured

code::
#+BEGIN_SRC sclang
Set[Set[1, 2, 3], [Set[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(2);
Set[Set[1, 2, 3], [Set[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(1);
Set[Set[1, 2, 3], [Set[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(0);
Set[].maxSizeAtDepth(0);
Set[[]].maxSizeAtDepth(0);
Set[[]].maxSizeAtDepth(1);
#+END_SRC

::

method::maxDepth
Returns the maximum depth of all subcollections.

argument::max
Internally used only.

code::
#+BEGIN_SRC sclang
Set[Set[1, 2, 3], Set[Set[41, 52], 5, 6], 1, 2, 3].maxDepth
#+END_SRC

::

method::iter
Returns a link::Classes/Routine:: that returns the elements one by one.
code::
#+BEGIN_SRC sclang
r = Set[10, 2, -3, -4].iter;
r.next;
r.next;
r.next;
r.next; // nil.
#+END_SRC

::

subsection::Conversion

method::asBag
Answer a link::Classes/Bag:: to which all items in the receiver have been added.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].asBag;
#+END_SRC

::

method::asList
Answer a link::Classes/List:: to which all items in the receiver have been added.
code::
#+BEGIN_SRC sclang
Set[1, 2, 3, 4].asList;
#+END_SRC

::

method::asSet
Answer a link::Classes/Set:: to which all items in the receiver have been added.
code::
#+BEGIN_SRC sclang
List[1, 2, 3, 4].asSet;
#+END_SRC

::

method::asSortedList
Answer a link::Classes/SortedList:: to which all items in the receiver have been added.
code::
#+BEGIN_SRC sclang
List[2, 1, 4, 3].asSortedList;
#+END_SRC

::

method::powerset
Returns all possible combinations of the collection's elements.
code::
#+BEGIN_SRC sclang
Set[1, 2, 3].powerset;

// generate the von neumann ordinals. (warning: only count to four at maximum!)
a = Set[];
a = a.powerset;
a = a.powerset;
a = a.powerset;

u = { |set| set.unify }; // union (count down)
n = { |set| set.powerset }; // powerset (count up)
a = Set[]; // empty set (zero)
n.(n.(a)); // two
u.(n.(n.(a))) == n.(a); // two - one == one
u.(u.(n.(n.(a)))) == u.(n.(a)); // two - two == one - one
#+END_SRC

::

method::flopDict
Takes a collection of dictionaries and returns a single dictionary with arrays of all dictionaries' elements.
If unbubble is link::Classes/True:: (default), and if one element is singular, the array is replaced by this element.
code::
#+BEGIN_SRC sclang
[(degree: 7, x: 4), (degree: 8, x: 5), (degree: -2, dur: 2.5)].flopDict;
[(degree: 7, x: 4), (degree: 8, x: 5), (degree: -2, dur: 2.5)].flopDict(false);
#+END_SRC

::

method::histo
Returns a histogram of the collection by counting the number of values that fall into each slot of size (default: 100) subdivisions between min and max. If there are any values outside this range, it posts a note. If min or max is not given, the smallest (or largest value respectively) is used.
code::
#+BEGIN_SRC sclang
{ 1.0.linrand }.dup(10000).histo(1000).plot;
{ 8.rand }.dup(10000).histo(8).plot(discrete: true);
#+END_SRC

::

subsection::Writing to streams

method::printOn
Print a representation of the collection to a stream.

method::storeOn
Write a compileable representation of the collection to a stream.

method::printItemsOn
Print a comma separated compileable representation of the items in the collection to a stream.

method::storeItemsOn
Write a comma separated compileable representation of the items in the collection to a stream.

subsection::Set specific operations

method::sect
Return the set theoretical intersection of this and strong::that::.
code::
#+BEGIN_SRC sclang
a = [1, 2, 3]; b = [2, 3, 4, 5];
sect(a, b);
#+END_SRC

::

method::union
Return the set theoretical union of this and strong::that::.
code::
#+BEGIN_SRC sclang
a = [1, 2, 3]; b = [2, 3, 4, 5];
union(a, b);
#+END_SRC

::

method::difference
Return the set of all items which are elements of this, but not of strong::that::.
code::
#+BEGIN_SRC sclang
a = [1, 2, 3]; b = [2, 3, 4, 5];
difference(a, b);
#+END_SRC

::

method::symmetricDifference
Return the set of all items which are not elements of both  this and strong::that::.
this -- that
code::
#+BEGIN_SRC sclang
a = [1, 2, 3]; b = [2, 3, 4, 5];
symmetricDifference(a, b);
#+END_SRC

::

method::isSubsetOf
Returns link::Classes/True:: if all elements of this are also elements of strong::that::
code::
#+BEGIN_SRC sclang
a = Set[1, 2, 3, 4];
Set[1, 2].isSubsetOf(a); // true
Set[1, 5].isSubsetOf(a); // false
#+END_SRC

::
** class:: Color
summary:: An object which stores color values
categories:: GUI>Accessories
related:: Classes/Object

description::
An object which stores red, green, blue, and alpha values in instance variables, and provides numerous class and instance methods for creating and manipulating these values.

classmethods::

method:: new
Create a new instance with float values.
argument:: red
An instance of link::Classes/Float:: between 0 and 1.
argument:: green
An instance of link::Classes/Float:: between 0 and 1.
argument:: blue
An instance of link::Classes/Float:: between 0 and 1.
argument:: alpha
An instance of link::Classes/Float:: between 0 and 1.

method:: new255
Create a new instance from 8-bit integer values between 0 and 255.
argument:: red
An instance of link::Classes/Integer:: between 0 and 255.
argument:: green
An link::Classes/Integer:: between 0 and 255.
argument:: blue
An link::Classes/Integer:: between 0 and 255.
argument:: alpha
An link::Classes/Integer:: between 0 and 255.

method:: fromArray
Same as code::Color.new(*array)::.
argument:: array
An instance of link::Classes/Array::. 1-4 values between 0 and 1. See link::#*new::.

method:: fromHexString
Creates a new instance from a hex color string.
argument:: string
A link::Classes/String::.
discussion::
The string should be a 6 character web color, or a 3 character CSS style color. A preceding # is optional.
code::
#+BEGIN_SRC sclang
Color.fromHexString("#FF6600");
#+END_SRC

::

method:: black
Nothing is darker.

method:: white
Nothing is lighter.

method:: clear
Nothing is more clear.

method:: gray
American shades of grey.
argument:: gray
Shades between 0 (black) and 1 (white) as link::Classes/Float::.
argument:: alpha
Transparency of gray between 0 and 1 as link::Classes/Float::.

method:: grey
British shades of grey.
argument:: grey
Shades between 0 (black) and 1 (white) as link::Classes/Float::.
argument:: alpha
Transparency of grey between 0 and 1 as link::Classes/Float::.

method:: red, green, blue, cyan, magenta, yellow
Create a new red, green, blue, cyan, magenta or yellow Color.
argument:: val
An instance of link::Classes/Float:: between 0 and 1, where 1 is the bright, fully saturated color, and 0 is black.
argument:: alpha
Transparency between 0 and 1 as link::Classes/Float::.

method:: rand
A random RGB Color where the colors are randomly chosen between code::lo:: and code::hi::. See link::Classes/Color#new::.
argument:: lo
An instance of link::Classes/Float:: between 0 and 1.
argument:: hi
An instance of link::Classes/Float:: between 0 and 1.

method:: hsv
Maps hsv and alpha values to rgb between 0 and 1.
argument:: hue
link::Classes/Float:: between 0 and 0.999.
argument:: sat
link::Classes/Float:: between 0 and 1.
argument:: val
link::Classes/Float:: between 0 and 1.
argument:: alpha
link::Classes/Float:: between 0 and 1.


instancemethods::
private:: printOn, hash

method:: red, green, blue, alpha
Get/set one of the instance variables, code::red::, code::green::, code::blue::, or code::alpha::.
returns::
An instance of link::Classes/Float:: between 0 and 1.

method:: hexString
Returns a link::Classes/String:: containing a 6 character web color code, preceded by a #.
code::
#+BEGIN_SRC sclang
Color(1.0, 0.4).hexString;
#+END_SRC

::

method:: ==
Binary operator.
code::
#+BEGIN_SRC sclang
// returns true
Color.new255(0, 0, 255, 255) == Color.new(0, 0, 1, 1)
#+END_SRC

::

method:: scaleByAlpha
Returns a Color, where code::red::, code::green::, and code::blue:: are scaled by the code::alpha:: value, and alpha is set to 1.
code::
#+BEGIN_SRC sclang
// returns true:
Color(1, 0.5, 1, 0.5).scaleByAlpha == Color(0.5, 0.25, 0.5, 1)
#+END_SRC

::

method:: blend
Interpolates the code::red::, code::green::, code::blue::, and code::alpha:: values of two Colors, linearly weighting between the first and the second.
argument:: that
A second Color.
argument:: blend
0 means only this, while 1 means only that.

method:: vary
Returns a random variation of a Color.
argument:: val
Varies the RGB values +- this amount.
argument:: lo
Low-clips the RGB variation here.
argument:: hi
High-clips the RGB variation here.
argument:: alphaVal
Varies the alpha value +/- this amount, and clips it between 0 and 1.

method:: complementary
Returns the complementary color.
code::
#+BEGIN_SRC sclang
// returns true:
Color(1, 0.5, 1, 0.5).complementary == Color(0.0, 0.5, 0.0, 0.5)
#+END_SRC

::

method:: multiply
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: divide
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: subtract
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: add
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: symmetricDifference
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: screen
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: lighten
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: darken
argument:: aColor
An instance of Color.
argument:: opacity
A value between 0 and 1. Default value is 1.0.

method:: hueBlend
argument:: aColor
An instance of Color.
argument:: blend
A value between 0 and 1. Default value is 0.

method:: saturationBlend
argument:: aColor
An instance of Color.
argument:: blend
A value between 0 and 1. Default value is 0.

method:: valueBlend
argument:: aColor
An instance of Color.
argument:: blend
A value between 0 and 1. Default value is 0.

method:: asHSV
Returns an array with code::[hue, saturation, value, alpha]::, as values between 0 and 1.

method:: asArray
Returns an array with code::[red, green, blue, alpha]::, as values between 0 and 1.

method:: storeArgs
Returns an array with code::[red, green, blue, alpha]::.

method:: setStroke
For use with link::Classes/Pen::. Sets the code::stroke:: of link::Classes/Pen:: to this.

method:: setFill
For use with link::Classes/Pen::. Sets the code::fill:: of link::Classes/Pen:: to this.

method:: set
For use with link::Classes/Pen::. Sets the code::stroke:: and code::fill:: of link::Classes/Pen:: to this.

method:: round
Round the color.

examples::
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
	// set the Color
	Pen.translate(200, 200);
	30.do{
		Pen.width = 3.0.rand;
		Color.blue(rrand(0.0, 1), rrand(0.0, 0.5)).setStroke;
		Color.red(rrand(0.0, 1), rrand(0.0, 0.5)).setFill;
		Pen.addAnnularWedge(
			0@0,
			rrand(10, 50),
			rrand(51, 100),
			2pi.rand,
			2pi.rand
		);
		Pen.perform([\stroke, \fill].choose);
	}
};
w.refresh;
)
#+END_SRC

::

section:: X-windows colors
code::
#+BEGIN_SRC sclang
'alice blue' -> Color.new255(240, 248, 255),
'AliceBlue' -> Color.new255(240, 248, 255),
'antique white' -> Color.new255(250, 235, 215),
'AntiqueWhite' -> Color.new255(250, 235, 215),
'AntiqueWhite1' -> Color.new255(255, 239, 219),
'AntiqueWhite2' -> Color.new255(238, 223, 204),
'AntiqueWhite3' -> Color.new255(205, 192, 176),
'AntiqueWhite4' -> Color.new255(139, 131, 120),
'aquamarine' -> Color.new255(127, 255, 212),
'aquamarine1' -> Color.new255(127, 255, 212),
'aquamarine2' -> Color.new255(118, 238, 198),
'aquamarine3' -> Color.new255(102, 205, 170),
'aquamarine4' -> Color.new255(69, 139, 116),
'azure' -> Color.new255(240, 255, 255),
'azure1' -> Color.new255(240, 255, 255),
'azure2' -> Color.new255(224, 238, 238),
'azure3' -> Color.new255(193, 205, 205),
'azure4' -> Color.new255(131, 139, 139),
'beige' -> Color.new255(245, 245, 220),
'bisque' -> Color.new255(255, 228, 196),
'bisque1' -> Color.new255(255, 228, 196),
'bisque2' -> Color.new255(238, 213, 183),
'bisque3' -> Color.new255(205, 183, 158),
'bisque4' -> Color.new255(139, 125, 107),
'black' -> Color.new255(0, 0, 0),
'blanched almond' -> Color.new255(255, 235, 205),
'BlanchedAlmond' -> Color.new255(255, 235, 205),
'blue' -> Color.new255(0, 0, 255),
'blue violet' -> Color.new255(138, 43, 226),
'blue1' -> Color.new255(0, 0, 255),
'blue2' -> Color.new255(0, 0, 238),
'blue3' -> Color.new255(0, 0, 205),
'blue4' -> Color.new255(0, 0, 139),
'BlueViolet' -> Color.new255(138, 43, 226),
'brown' -> Color.new255(165, 42, 42),
'brown1' -> Color.new255(255, 64, 64),
'brown2' -> Color.new255(238, 59, 59),
'brown3' -> Color.new255(205, 51, 51),
'brown4' -> Color.new255(139, 35, 35),
'burlywood' -> Color.new255(222, 184, 135),
'burlywood1' -> Color.new255(255, 211, 155),
'burlywood2' -> Color.new255(238, 197, 145),
'burlywood3' -> Color.new255(205, 170, 125),
'burlywood4' -> Color.new255(139, 115, 85),
'cadet blue' -> Color.new255(95, 158, 160),
'CadetBlue' -> Color.new255(95, 158, 160),
'CadetBlue1' -> Color.new255(152, 245, 255),
'CadetBlue2' -> Color.new255(142, 229, 238),
'CadetBlue3' -> Color.new255(122, 197, 205),
'CadetBlue4' -> Color.new255(83, 134, 139),
'chartreuse' -> Color.new255(127, 255, 0),
'chartreuse1' -> Color.new255(127, 255, 0),
'chartreuse2' -> Color.new255(118, 238, 0),
'chartreuse3' -> Color.new255(102, 205, 0),
'chartreuse4' -> Color.new255(69, 139, 0),
'chocolate' -> Color.new255(210, 105, 30),
'chocolate1' -> Color.new255(255, 127, 36),
'chocolate2' -> Color.new255(238, 118, 33),
'chocolate3' -> Color.new255(205, 102, 29),
'chocolate4' -> Color.new255(139, 69, 19),
'coral' -> Color.new255(255, 127, 80),
'coral1' -> Color.new255(255, 114, 86),
'coral2' -> Color.new255(238, 106, 80),
'coral3' -> Color.new255(205, 91, 69),
'coral4' -> Color.new255(139, 62, 47),
'cornflower blue' -> Color.new255(100, 149, 237),
'CornflowerBlue' -> Color.new255(100, 149, 237),
'cornsilk' -> Color.new255(255, 248, 220),
'cornsilk1' -> Color.new255(255, 248, 220),
'cornsilk2' -> Color.new255(238, 232, 205),
'cornsilk3' -> Color.new255(205, 200, 177),
'cornsilk4' -> Color.new255(139, 136, 120),
'cyan' -> Color.new255(0, 255, 255),
'cyan1' -> Color.new255(0, 255, 255),
'cyan2' -> Color.new255(0, 238, 238),
'cyan3' -> Color.new255(0, 205, 205),
'cyan4' -> Color.new255(0, 139, 139),
'dark goldenrod' -> Color.new255(184, 134, 11),
'dark green' -> Color.new255(0, 100, 0),
'dark khaki' -> Color.new255(189, 183, 107),
'dark olive green' -> Color.new255(85, 107, 47),
'dark orange' -> Color.new255(255, 140, 0),
'dark orchid' -> Color.new255(153, 50, 204),
'dark salmon' -> Color.new255(233, 150, 122),
'dark sea green' -> Color.new255(143, 188, 143),
'dark slate blue' -> Color.new255(72, 61, 139),
'dark slate gray' -> Color.new255(47, 79, 79),
'dark slate grey' -> Color.new255(47, 79, 79),
'dark turquoise' -> Color.new255(0, 206, 209),
'dark violet' -> Color.new255(148, 0, 211),
'DarkGoldenrod' -> Color.new255(184, 134, 11),
'DarkGoldenrod1' -> Color.new255(255, 185, 15),
'DarkGoldenrod2' -> Color.new255(238, 173, 14),
'DarkGoldenrod3' -> Color.new255(205, 149, 12),
'DarkGoldenrod4' -> Color.new255(139, 101, 8),
'DarkGreen' -> Color.new255(0, 100, 0),
'DarkKhaki' -> Color.new255(189, 183, 107),
'DarkOliveGreen' -> Color.new255(85, 107, 47),
'DarkOliveGreen1' -> Color.new255(202, 255, 112),
'DarkOliveGreen2' -> Color.new255(188, 238, 104),
'DarkOliveGreen3' -> Color.new255(162, 205, 90),
'DarkOliveGreen4' -> Color.new255(110, 139, 61),
'DarkOrange' -> Color.new255(255, 140, 0),
'DarkOrange1' -> Color.new255(255, 127, 0),
'DarkOrange2' -> Color.new255(238, 118, 0),
'DarkOrange3' -> Color.new255(205, 102, 0),
'DarkOrange4' -> Color.new255(139, 69, 0),
'DarkOrchid' -> Color.new255(153, 50, 204),
'DarkOrchid1' -> Color.new255(191, 62, 255),
'DarkOrchid2' -> Color.new255(178, 58, 238),
'DarkOrchid3' -> Color.new255(154, 50, 205),
'DarkOrchid4' -> Color.new255(104, 34, 139),
'DarkSalmon' -> Color.new255(233, 150, 122),
'DarkSeaGreen' -> Color.new255(143, 188, 143),
'DarkSeaGreen1' -> Color.new255(193, 255, 193),
'DarkSeaGreen2' -> Color.new255(180, 238, 180),
'DarkSeaGreen3' -> Color.new255(155, 205, 155),
'DarkSeaGreen4' -> Color.new255(105, 139, 105),
'DarkSlateBlue' -> Color.new255(72, 61, 139),
'DarkSlateGray' -> Color.new255(47, 79, 79),
'DarkSlateGray1' -> Color.new255(151, 255, 255),
'DarkSlateGray2' -> Color.new255(141, 238, 238),
'DarkSlateGray3' -> Color.new255(121, 205, 205),
'DarkSlateGray4' -> Color.new255(82, 139, 139),
'DarkSlateGrey' -> Color.new255(47, 79, 79),
'DarkTurquoise' -> Color.new255(0, 206, 209),
'DarkViolet' -> Color.new255(148, 0, 211),
'deep pink' -> Color.new255(255, 20, 147),
'deep sky blue' -> Color.new255(0, 191, 255),
'DeepPink' -> Color.new255(255, 20, 147),
'DeepPink1' -> Color.new255(255, 20, 147),
'DeepPink2' -> Color.new255(238, 18, 137),
'DeepPink3' -> Color.new255(205, 16, 118),
'DeepPink4' -> Color.new255(139, 10, 80),
'DeepSkyBlue' -> Color.new255(0, 191, 255),
'DeepSkyBlue1' -> Color.new255(0, 191, 255),
'DeepSkyBlue2' -> Color.new255(0, 178, 238),
'DeepSkyBlue3' -> Color.new255(0, 154, 205),
'DeepSkyBlue4' -> Color.new255(0, 104, 139),
'dim gray' -> Color.new255(105, 105, 105),
'dim grey' -> Color.new255(105, 105, 105),
'DimGray' -> Color.new255(105, 105, 105),
'DimGrey' -> Color.new255(105, 105, 105),
'dodger blue' -> Color.new255(30, 144, 255),
'DodgerBlue' -> Color.new255(30, 144, 255),
'DodgerBlue1' -> Color.new255(30, 144, 255),
'DodgerBlue2' -> Color.new255(28, 134, 238),
'DodgerBlue3' -> Color.new255(24, 116, 205),
'DodgerBlue4' -> Color.new255(16, 78, 139),
'firebrick' -> Color.new255(178, 34, 34),
'firebrick1' -> Color.new255(255, 48, 48),
'firebrick2' -> Color.new255(238, 44, 44),
'firebrick3' -> Color.new255(205, 38, 38),
'firebrick4' -> Color.new255(139, 26, 26),
'floral white' -> Color.new255(255, 250, 240),
'FloralWhite' -> Color.new255(255, 250, 240),
'forest green' -> Color.new255(34, 139, 34),
'ForestGreen' -> Color.new255(34, 139, 34),
'gainsboro' -> Color.new255(220, 220, 220),
'ghost white' -> Color.new255(248, 248, 255),
'GhostWhite' -> Color.new255(248, 248, 255),
'gold' -> Color.new255(255, 215, 0),
'gold1' -> Color.new255(255, 215, 0),
'gold2' -> Color.new255(238, 201, 0),
'gold3' -> Color.new255(205, 173, 0),
'gold4' -> Color.new255(139, 117, 0),
'goldenrod' -> Color.new255(218, 165, 32),
'goldenrod1' -> Color.new255(255, 193, 37),
'goldenrod2' -> Color.new255(238, 180, 34),
'goldenrod3' -> Color.new255(205, 155, 29),
'goldenrod4' -> Color.new255(139, 105, 20),
'gray' -> Color.new255(190, 190, 190),
'gray0' -> Color.new255(0, 0, 0),
'gray1' -> Color.new255(3, 3, 3),
'gray10' -> Color.new255(26, 26, 26),
'gray100' -> Color.new255(255, 255, 255),
'gray11' -> Color.new255(28, 28, 28),
'gray12' -> Color.new255(31, 31, 31),
'gray13' -> Color.new255(33, 33, 33),
'gray14' -> Color.new255(36, 36, 36),
'gray15' -> Color.new255(38, 38, 38),
'gray16' -> Color.new255(41, 41, 41),
'gray17' -> Color.new255(43, 43, 43),
'gray18' -> Color.new255(46, 46, 46),
'gray19' -> Color.new255(48, 48, 48),
'gray2' -> Color.new255(5, 5, 5),
'gray20' -> Color.new255(51, 51, 51),
'gray21' -> Color.new255(54, 54, 54),
'gray22' -> Color.new255(56, 56, 56),
'gray23' -> Color.new255(59, 59, 59),
'gray24' -> Color.new255(61, 61, 61),
'gray25' -> Color.new255(64, 64, 64),
'gray26' -> Color.new255(66, 66, 66),
'gray27' -> Color.new255(69, 69, 69),
'gray28' -> Color.new255(71, 71, 71),
'gray29' -> Color.new255(74, 74, 74),
'gray3' -> Color.new255(8, 8, 8),
'gray30' -> Color.new255(77, 77, 77),
'gray31' -> Color.new255(79, 79, 79),
'gray32' -> Color.new255(82, 82, 82),
'gray33' -> Color.new255(84, 84, 84),
'gray34' -> Color.new255(87, 87, 87),
'gray35' -> Color.new255(89, 89, 89),
'gray36' -> Color.new255(92, 92, 92),
'gray37' -> Color.new255(94, 94, 94),
'gray38' -> Color.new255(97, 97, 97),
'gray39' -> Color.new255(99, 99, 99),
'gray4' -> Color.new255(10, 10, 10),
'gray40' -> Color.new255(102, 102, 102),
'gray41' -> Color.new255(105, 105, 105),
'gray42' -> Color.new255(107, 107, 107),
'gray43' -> Color.new255(110, 110, 110),
'gray44' -> Color.new255(112, 112, 112),
'gray45' -> Color.new255(115, 115, 115),
'gray46' -> Color.new255(117, 117, 117),
'gray47' -> Color.new255(120, 120, 120),
'gray48' -> Color.new255(122, 122, 122),
'gray49' -> Color.new255(125, 125, 125),
'gray5' -> Color.new255(13, 13, 13),
'gray50' -> Color.new255(127, 127, 127),
'gray51' -> Color.new255(130, 130, 130),
'gray52' -> Color.new255(133, 133, 133),
'gray53' -> Color.new255(135, 135, 135),
'gray54' -> Color.new255(138, 138, 138),
'gray55' -> Color.new255(140, 140, 140),
'gray56' -> Color.new255(143, 143, 143),
'gray57' -> Color.new255(145, 145, 145),
'gray58' -> Color.new255(148, 148, 148),
'gray59' -> Color.new255(150, 150, 150),
'gray6' -> Color.new255(15, 15, 15),
'gray60' -> Color.new255(153, 153, 153),
'gray61' -> Color.new255(156, 156, 156),
'gray62' -> Color.new255(158, 158, 158),
'gray63' -> Color.new255(161, 161, 161),
'gray64' -> Color.new255(163, 163, 163),
'gray65' -> Color.new255(166, 166, 166),
'gray66' -> Color.new255(168, 168, 168),
'gray67' -> Color.new255(171, 171, 171),
'gray68' -> Color.new255(173, 173, 173),
'gray69' -> Color.new255(176, 176, 176),
'gray7' -> Color.new255(18, 18, 18),
'gray70' -> Color.new255(179, 179, 179),
'gray71' -> Color.new255(181, 181, 181),
'gray72' -> Color.new255(184, 184, 184),
'gray73' -> Color.new255(186, 186, 186),
'gray74' -> Color.new255(189, 189, 189),
'gray75' -> Color.new255(191, 191, 191),
'gray76' -> Color.new255(194, 194, 194),
'gray77' -> Color.new255(196, 196, 196),
'gray78' -> Color.new255(199, 199, 199),
'gray79' -> Color.new255(201, 201, 201),
'gray8' -> Color.new255(20, 20, 20),
'gray80' -> Color.new255(204, 204, 204),
'gray81' -> Color.new255(207, 207, 207),
'gray82' -> Color.new255(209, 209, 209),
'gray83' -> Color.new255(212, 212, 212),
'gray84' -> Color.new255(214, 214, 214),
'gray85' -> Color.new255(217, 217, 217),
'gray86' -> Color.new255(219, 219, 219),
'gray87' -> Color.new255(222, 222, 222),
'gray88' -> Color.new255(224, 224, 224),
'gray89' -> Color.new255(227, 227, 227),
'gray9' -> Color.new255(23, 23, 23),
'gray90' -> Color.new255(229, 229, 229),
'gray91' -> Color.new255(232, 232, 232),
'gray92' -> Color.new255(235, 235, 235),
'gray93' -> Color.new255(237, 237, 237),
'gray94' -> Color.new255(240, 240, 240),
'gray95' -> Color.new255(242, 242, 242),
'gray96' -> Color.new255(245, 245, 245),
'gray97' -> Color.new255(247, 247, 247),
'gray98' -> Color.new255(250, 250, 250),
'gray99' -> Color.new255(252, 252, 252),
'green' -> Color.new255(0, 255, 0),
'green yellow' -> Color.new255(173, 255, 47),
'green1' -> Color.new255(0, 255, 0),
'green2' -> Color.new255(0, 238, 0),
'green3' -> Color.new255(0, 205, 0),
'green4' -> Color.new255(0, 139, 0),
'GreenYellow' -> Color.new255(173, 255, 47),
'grey' -> Color.new255(190, 190, 190),
'grey0' -> Color.new255(0, 0, 0),
'grey1' -> Color.new255(3, 3, 3),
'grey10' -> Color.new255(26, 26, 26),
'grey100' -> Color.new255(255, 255, 255),
'grey11' -> Color.new255(28, 28, 28),
'grey12' -> Color.new255(31, 31, 31),
'grey13' -> Color.new255(33, 33, 33),
'grey14' -> Color.new255(36, 36, 36),
'grey15' -> Color.new255(38, 38, 38),
'grey16' -> Color.new255(41, 41, 41),
'grey17' -> Color.new255(43, 43, 43),
'grey18' -> Color.new255(46, 46, 46),
'grey19' -> Color.new255(48, 48, 48),
'grey2' -> Color.new255(5, 5, 5),
'grey20' -> Color.new255(51, 51, 51),
'grey21' -> Color.new255(54, 54, 54),
'grey22' -> Color.new255(56, 56, 56),
'grey23' -> Color.new255(59, 59, 59),
'grey24' -> Color.new255(61, 61, 61),
'grey25' -> Color.new255(64, 64, 64),
'grey26' -> Color.new255(66, 66, 66),
'grey27' -> Color.new255(69, 69, 69),
'grey28' -> Color.new255(71, 71, 71),
'grey29' -> Color.new255(74, 74, 74),
'grey3' -> Color.new255(8, 8, 8),
'grey30' -> Color.new255(77, 77, 77),
'grey31' -> Color.new255(79, 79, 79),
'grey32' -> Color.new255(82, 82, 82),
'grey33' -> Color.new255(84, 84, 84),
'grey34' -> Color.new255(87, 87, 87),
'grey35' -> Color.new255(89, 89, 89),
'grey36' -> Color.new255(92, 92, 92),
'grey37' -> Color.new255(94, 94, 94),
'grey38' -> Color.new255(97, 97, 97),
'grey39' -> Color.new255(99, 99, 99),
'grey4' -> Color.new255(10, 10, 10),
'grey40' -> Color.new255(102, 102, 102),
'grey41' -> Color.new255(105, 105, 105),
'grey42' -> Color.new255(107, 107, 107),
'grey43' -> Color.new255(110, 110, 110),
'grey44' -> Color.new255(112, 112, 112),
'grey45' -> Color.new255(115, 115, 115),
'grey46' -> Color.new255(117, 117, 117),
'grey47' -> Color.new255(120, 120, 120),
'grey48' -> Color.new255(122, 122, 122),
'grey49' -> Color.new255(125, 125, 125),
'grey5' -> Color.new255(13, 13, 13),
'grey50' -> Color.new255(127, 127, 127),
'grey51' -> Color.new255(130, 130, 130),
'grey52' -> Color.new255(133, 133, 133),
'grey53' -> Color.new255(135, 135, 135),
'grey54' -> Color.new255(138, 138, 138),
'grey55' -> Color.new255(140, 140, 140),
'grey56' -> Color.new255(143, 143, 143),
'grey57' -> Color.new255(145, 145, 145),
'grey58' -> Color.new255(148, 148, 148),
'grey59' -> Color.new255(150, 150, 150),
'grey6' -> Color.new255(15, 15, 15),
'grey60' -> Color.new255(153, 153, 153),
'grey61' -> Color.new255(156, 156, 156),
'grey62' -> Color.new255(158, 158, 158),
'grey63' -> Color.new255(161, 161, 161),
'grey64' -> Color.new255(163, 163, 163),
'grey65' -> Color.new255(166, 166, 166),
'grey66' -> Color.new255(168, 168, 168),
'grey67' -> Color.new255(171, 171, 171),
'grey68' -> Color.new255(173, 173, 173),
'grey69' -> Color.new255(176, 176, 176),
'grey7' -> Color.new255(18, 18, 18),
'grey70' -> Color.new255(179, 179, 179),
'grey71' -> Color.new255(181, 181, 181),
'grey72' -> Color.new255(184, 184, 184),
'grey73' -> Color.new255(186, 186, 186),
'grey74' -> Color.new255(189, 189, 189),
'grey75' -> Color.new255(191, 191, 191),
'grey76' -> Color.new255(194, 194, 194),
'grey77' -> Color.new255(196, 196, 196),
'grey78' -> Color.new255(199, 199, 199),
'grey79' -> Color.new255(201, 201, 201),
'grey8' -> Color.new255(20, 20, 20),
'grey80' -> Color.new255(204, 204, 204),
'grey81' -> Color.new255(207, 207, 207),
'grey82' -> Color.new255(209, 209, 209),
'grey83' -> Color.new255(212, 212, 212),
'grey84' -> Color.new255(214, 214, 214),
'grey85' -> Color.new255(217, 217, 217),
'grey86' -> Color.new255(219, 219, 219),
'grey87' -> Color.new255(222, 222, 222),
'grey88' -> Color.new255(224, 224, 224),
'grey89' -> Color.new255(227, 227, 227),
'grey9' -> Color.new255(23, 23, 23),
'grey90' -> Color.new255(229, 229, 229),
'grey91' -> Color.new255(232, 232, 232),
'grey92' -> Color.new255(235, 235, 235),
'grey93' -> Color.new255(237, 237, 237),
'grey94' -> Color.new255(240, 240, 240),
'grey95' -> Color.new255(242, 242, 242),
'grey96' -> Color.new255(245, 245, 245),
'grey97' -> Color.new255(247, 247, 247),
'grey98' -> Color.new255(250, 250, 250),
'grey99' -> Color.new255(252, 252, 252),
'honeydew' -> Color.new255(240, 255, 240),
'honeydew1' -> Color.new255(240, 255, 240),
'honeydew2' -> Color.new255(224, 238, 224),
'honeydew3' -> Color.new255(193, 205, 193),
'honeydew4' -> Color.new255(131, 139, 131),
'hot pink' -> Color.new255(255, 105, 180),
'HotPink' -> Color.new255(255, 105, 180),
'HotPink1' -> Color.new255(255, 110, 180),
'HotPink2' -> Color.new255(238, 106, 167),
'HotPink3' -> Color.new255(205, 96, 144),
'HotPink4' -> Color.new255(139, 58, 98),
'indian red' -> Color.new255(205, 92, 92),
'IndianRed' -> Color.new255(205, 92, 92),
'IndianRed1' -> Color.new255(255, 106, 106),
'IndianRed2' -> Color.new255(238, 99, 99),
'IndianRed3' -> Color.new255(205, 85, 85),
'IndianRed4' -> Color.new255(139, 58, 58),
'ivory' -> Color.new255(255, 255, 240),
'ivory1' -> Color.new255(255, 255, 240),
'ivory2' -> Color.new255(238, 238, 224),
'ivory3' -> Color.new255(205, 205, 193),
'ivory4' -> Color.new255(139, 139, 131),
'khaki' -> Color.new255(240, 230, 140),
'khaki1' -> Color.new255(255, 246, 143),
'khaki2' -> Color.new255(238, 230, 133),
'khaki3' -> Color.new255(205, 198, 115),
'khaki4' -> Color.new255(139, 134, 78),
'lavender' -> Color.new255(230, 230, 250),
'lavender blush' -> Color.new255(255, 240, 245),
'LavenderBlush' -> Color.new255(255, 240, 245),
'LavenderBlush1' -> Color.new255(255, 240, 245),
'LavenderBlush2' -> Color.new255(238, 224, 229),
'LavenderBlush3' -> Color.new255(205, 193, 197),
'LavenderBlush4' -> Color.new255(139, 131, 134),
'lawn green' -> Color.new255(124, 252, 0),
'LawnGreen' -> Color.new255(124, 252, 0),
'lemon chiffon' -> Color.new255(255, 250, 205),
'LemonChiffon' -> Color.new255(255, 250, 205),
'LemonChiffon1' -> Color.new255(255, 250, 205),
'LemonChiffon2' -> Color.new255(238, 233, 191),
'LemonChiffon3' -> Color.new255(205, 201, 165),
'LemonChiffon4' -> Color.new255(139, 137, 112),
'light blue' -> Color.new255(173, 216, 230),
'light coral' -> Color.new255(240, 128, 128),
'light cyan' -> Color.new255(224, 255, 255),
'light goldenrod' -> Color.new255(238, 221, 130),
'light goldenrod yellow' -> Color.new255(250, 250, 210),
'light gray' -> Color.new255(211, 211, 211),
'light grey' -> Color.new255(211, 211, 211),
'light pink' -> Color.new255(255, 182, 193),
'light salmon' -> Color.new255(255, 160, 122),
'light sea green' -> Color.new255(32, 178, 170),
'light sky blue' -> Color.new255(135, 206, 250),
'light slate blue' -> Color.new255(132, 112, 255),
'light slate gray' -> Color.new255(119, 136, 153),
'light slate grey' -> Color.new255(119, 136, 153),
'light steel blue' -> Color.new255(176, 196, 222),
'light yellow' -> Color.new255(255, 255, 224),
'LightBlue' -> Color.new255(173, 216, 230),
'LightBlue1' -> Color.new255(191, 239, 255),
'LightBlue2' -> Color.new255(178, 223, 238),
'LightBlue3' -> Color.new255(154, 192, 205),
'LightBlue4' -> Color.new255(104, 131, 139),
'LightCoral' -> Color.new255(240, 128, 128),
'LightCyan' -> Color.new255(224, 255, 255),
'LightCyan1' -> Color.new255(224, 255, 255),
'LightCyan2' -> Color.new255(209, 238, 238),
'LightCyan3' -> Color.new255(180, 205, 205),
'LightCyan4' -> Color.new255(122, 139, 139),
'LightGoldenrod' -> Color.new255(238, 221, 130),
'LightGoldenrod1' -> Color.new255(255, 236, 139),
'LightGoldenrod2' -> Color.new255(238, 220, 130),
'LightGoldenrod3' -> Color.new255(205, 190, 112),
'LightGoldenrod4' -> Color.new255(139, 129, 76),
'LightGoldenrodYellow' -> Color.new255(250, 250, 210),
'LightGray' -> Color.new255(211, 211, 211),
'LightGrey' -> Color.new255(211, 211, 211),
'LightPink' -> Color.new255(255, 182, 193),
'LightPink1' -> Color.new255(255, 174, 185),
'LightPink2' -> Color.new255(238, 162, 173),
'LightPink3' -> Color.new255(205, 140, 149),
'LightPink4' -> Color.new255(139, 95, 101),
'LightSalmon' -> Color.new255(255, 160, 122),
'LightSalmon1' -> Color.new255(255, 160, 122),
'LightSalmon2' -> Color.new255(238, 149, 114),
'LightSalmon3' -> Color.new255(205, 129, 98),
'LightSalmon4' -> Color.new255(139, 87, 66),
'LightSeaGreen' -> Color.new255(32, 178, 170),
'LightSkyBlue' -> Color.new255(135, 206, 250),
'LightSkyBlue1' -> Color.new255(176, 226, 255),
'LightSkyBlue2' -> Color.new255(164, 211, 238),
'LightSkyBlue3' -> Color.new255(141, 182, 205),
'LightSkyBlue4' -> Color.new255(96, 123, 139),
'LightSlateBlue' -> Color.new255(132, 112, 255),
'LightSlateGray' -> Color.new255(119, 136, 153),
'LightSlateGrey' -> Color.new255(119, 136, 153),
'LightSteelBlue' -> Color.new255(176, 196, 222),
'LightSteelBlue1' -> Color.new255(202, 225, 255),
'LightSteelBlue2' -> Color.new255(188, 210, 238),
'LightSteelBlue3' -> Color.new255(162, 181, 205),
'LightSteelBlue4' -> Color.new255(110, 123, 139),
'LightYellow' -> Color.new255(255, 255, 224),
'LightYellow1' -> Color.new255(255, 255, 224),
'LightYellow2' -> Color.new255(238, 238, 209),
'LightYellow3' -> Color.new255(205, 205, 180),
'LightYellow4' -> Color.new255(139, 139, 122),
'lime green' -> Color.new255(50, 205, 50),
'LimeGreen' -> Color.new255(50, 205, 50),
'linen' -> Color.new255(250, 240, 230),
'magenta' -> Color.new255(255, 0, 255),
'magenta1' -> Color.new255(255, 0, 255),
'magenta2' -> Color.new255(238, 0, 238),
'magenta3' -> Color.new255(205, 0, 205),
'magenta4' -> Color.new255(139, 0, 139),
'maroon' -> Color.new255(176, 48, 96),
'maroon1' -> Color.new255(255, 52, 179),
'maroon2' -> Color.new255(238, 48, 167),
'maroon3' -> Color.new255(205, 41, 144),
'maroon4' -> Color.new255(139, 28, 98),
'medium aquamarine' -> Color.new255(102, 205, 170),
'medium blue' -> Color.new255(0, 0, 205),
'medium orchid' -> Color.new255(186, 85, 211),
'medium purple' -> Color.new255(147, 112, 219),
'medium sea green' -> Color.new255(60, 179, 113),
'medium slate blue' -> Color.new255(123, 104, 238),
'medium spring green' -> Color.new255(0, 250, 154),
'medium turquoise' -> Color.new255(72, 209, 204),
'medium violet red' -> Color.new255(199, 21, 133),
'MediumAquamarine' -> Color.new255(102, 205, 170),
'MediumBlue' -> Color.new255(0, 0, 205),
'MediumOrchid' -> Color.new255(186, 85, 211),
'MediumOrchid1' -> Color.new255(224, 102, 255),
'MediumOrchid2' -> Color.new255(209, 95, 238),
'MediumOrchid3' -> Color.new255(180, 82, 205),
'MediumOrchid4' -> Color.new255(122, 55, 139),
'MediumPurple' -> Color.new255(147, 112, 219),
'MediumPurple1' -> Color.new255(171, 130, 255),
'MediumPurple2' -> Color.new255(159, 121, 238),
'MediumPurple3' -> Color.new255(137, 104, 205),
'MediumPurple4' -> Color.new255(93, 71, 139),
'MediumSeaGreen' -> Color.new255(60, 179, 113),
'MediumSlateBlue' -> Color.new255(123, 104, 238),
'MediumSpringGreen' -> Color.new255(0, 250, 154),
'MediumTurquoise' -> Color.new255(72, 209, 204),
'MediumVioletRed' -> Color.new255(199, 21, 133),
'midnight blue' -> Color.new255(25, 25, 112),
'MidnightBlue' -> Color.new255(25, 25, 112),
'mint cream' -> Color.new255(245, 255, 250),
'MintCream' -> Color.new255(245, 255, 250),
'misty rose' -> Color.new255(255, 228, 225),
'MistyRose' -> Color.new255(255, 228, 225),
'MistyRose1' -> Color.new255(255, 228, 225),
'MistyRose2' -> Color.new255(238, 213, 210),
'MistyRose3' -> Color.new255(205, 183, 181),
'MistyRose4' -> Color.new255(139, 125, 123),
'moccasin' -> Color.new255(255, 228, 181),
'navajo white' -> Color.new255(255, 222, 173),
'NavajoWhite' -> Color.new255(255, 222, 173),
'NavajoWhite1' -> Color.new255(255, 222, 173),
'NavajoWhite2' -> Color.new255(238, 207, 161),
'NavajoWhite3' -> Color.new255(205, 179, 139),
'NavajoWhite4' -> Color.new255(139, 121, 94),
'navy' -> Color.new255(0, 0, 128),
'navy blue' -> Color.new255(0, 0, 128),
'NavyBlue' -> Color.new255(0, 0, 128),
'old lace' -> Color.new255(253, 245, 230),
'OldLace' -> Color.new255(253, 245, 230),
'olive drab' -> Color.new255(107, 142, 35),
'OliveDrab' -> Color.new255(107, 142, 35),
'OliveDrab1' -> Color.new255(192, 255, 62),
'OliveDrab2' -> Color.new255(179, 238, 58),
'OliveDrab3' -> Color.new255(154, 205, 50),
'OliveDrab4' -> Color.new255(105, 139, 34),
'orange' -> Color.new255(255, 165, 0),
'orange red' -> Color.new255(255, 69, 0),
'orange1' -> Color.new255(255, 165, 0),
'orange2' -> Color.new255(238, 154, 0),
'orange3' -> Color.new255(205, 133, 0),
'orange4' -> Color.new255(139, 90, 0),
'OrangeRed' -> Color.new255(255, 69, 0),
'OrangeRed1' -> Color.new255(255, 69, 0),
'OrangeRed2' -> Color.new255(238, 64, 0),
'OrangeRed3' -> Color.new255(205, 55, 0),
'OrangeRed4' -> Color.new255(139, 37, 0),
'orchid' -> Color.new255(218, 112, 214),
'orchid1' -> Color.new255(255, 131, 250),
'orchid2' -> Color.new255(238, 122, 233),
'orchid3' -> Color.new255(205, 105, 201),
'orchid4' -> Color.new255(139, 71, 137),
'pale goldenrod' -> Color.new255(238, 232, 170),
'pale green' -> Color.new255(152, 251, 152),
'pale turquoise' -> Color.new255(175, 238, 238),
'pale violet red' -> Color.new255(219, 112, 147),
'PaleGoldenrod' -> Color.new255(238, 232, 170),
'PaleGreen' -> Color.new255(152, 251, 152),
'PaleGreen1' -> Color.new255(154, 255, 154),
'PaleGreen2' -> Color.new255(144, 238, 144),
'PaleGreen3' -> Color.new255(124, 205, 124),
'PaleGreen4' -> Color.new255(84, 139, 84),
'PaleTurquoise' -> Color.new255(175, 238, 238),
'PaleTurquoise1' -> Color.new255(187, 255, 255),
'PaleTurquoise2' -> Color.new255(174, 238, 238),
'PaleTurquoise3' -> Color.new255(150, 205, 205),
'PaleTurquoise4' -> Color.new255(102, 139, 139),
'PaleVioletRed' -> Color.new255(219, 112, 147),
'PaleVioletRed1' -> Color.new255(255, 130, 171),
'PaleVioletRed2' -> Color.new255(238, 121, 159),
'PaleVioletRed3' -> Color.new255(205, 104, 137),
'PaleVioletRed4' -> Color.new255(139, 71, 93),
'papaya whip' -> Color.new255(255, 239, 213),
'PapayaWhip' -> Color.new255(255, 239, 213),
'peach puff' -> Color.new255(255, 218, 185),
'PeachPuff' -> Color.new255(255, 218, 185),
'PeachPuff1' -> Color.new255(255, 218, 185),
'PeachPuff2' -> Color.new255(238, 203, 173),
'PeachPuff3' -> Color.new255(205, 175, 149),
'PeachPuff4' -> Color.new255(139, 119, 101),
'peru' -> Color.new255(205, 133, 63),
'pink' -> Color.new255(255, 192, 203),
'pink1' -> Color.new255(255, 181, 197),
'pink2' -> Color.new255(238, 169, 184),
'pink3' -> Color.new255(205, 145, 158),
'pink4' -> Color.new255(139, 99, 108),
'plum' -> Color.new255(221, 160, 221),
'plum1' -> Color.new255(255, 187, 255),
'plum2' -> Color.new255(238, 174, 238),
'plum3' -> Color.new255(205, 150, 205),
'plum4' -> Color.new255(139, 102, 139),
'powder blue' -> Color.new255(176, 224, 230),
'PowderBlue' -> Color.new255(176, 224, 230),
'purple' -> Color.new255(160, 32, 240),
'purple1' -> Color.new255(155, 48, 255),
'purple2' -> Color.new255(145, 44, 238),
'purple3' -> Color.new255(125, 38, 205),
'purple4' -> Color.new255(85, 26, 139),
'red' -> Color.new255(255, 0, 0),
'red1' -> Color.new255(255, 0, 0),
'red2' -> Color.new255(238, 0, 0),
'red3' -> Color.new255(205, 0, 0),
'red4' -> Color.new255(139, 0, 0),
'rosy brown' -> Color.new255(188, 143, 143),
'RosyBrown' -> Color.new255(188, 143, 143),
'RosyBrown1' -> Color.new255(255, 193, 193),
'RosyBrown2' -> Color.new255(238, 180, 180),
'RosyBrown3' -> Color.new255(205, 155, 155),
'RosyBrown4' -> Color.new255(139, 105, 105),
'royal blue' -> Color.new255(65, 105, 225),
'RoyalBlue' -> Color.new255(65, 105, 225),
'RoyalBlue1' -> Color.new255(72, 118, 255),
'RoyalBlue2' -> Color.new255(67, 110, 238),
'RoyalBlue3' -> Color.new255(58, 95, 205),
'RoyalBlue4' -> Color.new255(39, 64, 139),
'saddle brown' -> Color.new255(139, 69, 19),
'SaddleBrown' -> Color.new255(139, 69, 19),
'salmon' -> Color.new255(250, 128, 114),
'salmon1' -> Color.new255(255, 140, 105),
'salmon2' -> Color.new255(238, 130, 98),
'salmon3' -> Color.new255(205, 112, 84),
'salmon4' -> Color.new255(139, 76, 57),
'sandy brown' -> Color.new255(244, 164, 96),
'SandyBrown' -> Color.new255(244, 164, 96),
'sea green' -> Color.new255(46, 139, 87),
'SeaGreen' -> Color.new255(46, 139, 87),
'SeaGreen1' -> Color.new255(84, 255, 159),
'SeaGreen2' -> Color.new255(78, 238, 148),
'SeaGreen3' -> Color.new255(67, 205, 128),
'SeaGreen4' -> Color.new255(46, 139, 87),
'seashell' -> Color.new255(255, 245, 238),
'seashell1' -> Color.new255(255, 245, 238),
'seashell2' -> Color.new255(238, 229, 222),
'seashell3' -> Color.new255(205, 197, 191),
'seashell4' -> Color.new255(139, 134, 130),
'sienna' -> Color.new255(160, 82, 45),
'sienna1' -> Color.new255(255, 130, 71),
'sienna2' -> Color.new255(238, 121, 66),
'sienna3' -> Color.new255(205, 104, 57),
'sienna4' -> Color.new255(139, 71, 38),
'sky blue' -> Color.new255(135, 206, 235),
'SkyBlue' -> Color.new255(135, 206, 235),
'SkyBlue1' -> Color.new255(135, 206, 255),
'SkyBlue2' -> Color.new255(126, 192, 238),
'SkyBlue3' -> Color.new255(108, 166, 205),
'SkyBlue4' -> Color.new255(74, 112, 139),
'slate blue' -> Color.new255(106, 90, 205),
'slate gray' -> Color.new255(112, 128, 144),
'slate grey' -> Color.new255(112, 128, 144),
'SlateBlue' -> Color.new255(106, 90, 205),
'SlateBlue1' -> Color.new255(131, 111, 255),
'SlateBlue2' -> Color.new255(122, 103, 238),
'SlateBlue3' -> Color.new255(105, 89, 205),
'SlateBlue4' -> Color.new255(71, 60, 139),
'SlateGray' -> Color.new255(112, 128, 144),
'SlateGray1' -> Color.new255(198, 226, 255),
'SlateGray2' -> Color.new255(185, 211, 238),
'SlateGray3' -> Color.new255(159, 182, 205),
'SlateGray4' -> Color.new255(108, 123, 139),
'SlateGrey' -> Color.new255(112, 128, 144),
'snow' -> Color.new255(255, 250, 250),
'snow1' -> Color.new255(255, 250, 250),
'snow2' -> Color.new255(238, 233, 233),
'snow3' -> Color.new255(205, 201, 201),
'snow4' -> Color.new255(139, 137, 137),
'spring green' -> Color.new255(0, 255, 127),
'SpringGreen' -> Color.new255(0, 255, 127),
'SpringGreen1' -> Color.new255(0, 255, 127),
'SpringGreen2' -> Color.new255(0, 238, 118),
'SpringGreen3' -> Color.new255(0, 205, 102),
'SpringGreen4' -> Color.new255(0, 139, 69),
'steel blue' -> Color.new255(70, 130, 180),
'SteelBlue' -> Color.new255(70, 130, 180),
'SteelBlue1' -> Color.new255(99, 184, 255),
'SteelBlue2' -> Color.new255(92, 172, 238),
'SteelBlue3' -> Color.new255(79, 148, 205),
'SteelBlue4' -> Color.new255(54, 100, 139),
'tan' -> Color.new255(210, 180, 140),
'tan1' -> Color.new255(255, 165, 79),
'tan2' -> Color.new255(238, 154, 73),
'tan3' -> Color.new255(205, 133, 63),
'tan4' -> Color.new255(139, 90, 43),
'thistle' -> Color.new255(216, 191, 216),
'thistle1' -> Color.new255(255, 225, 255),
'thistle2' -> Color.new255(238, 210, 238),
'thistle3' -> Color.new255(205, 181, 205),
'thistle4' -> Color.new255(139, 123, 139),
'tomato' -> Color.new255(255, 99, 71),
'tomato1' -> Color.new255(255, 99, 71),
'tomato2' -> Color.new255(238, 92, 66),
'tomato3' -> Color.new255(205, 79, 57),
'tomato4' -> Color.new255(139, 54, 38),
'turquoise' -> Color.new255(64, 224, 208),
'turquoise1' -> Color.new255(0, 245, 255),
'turquoise2' -> Color.new255(0, 229, 238),
'turquoise3' -> Color.new255(0, 197, 205),
'turquoise4' -> Color.new255(0, 134, 139),
'violet' -> Color.new255(238, 130, 238),
'violet red' -> Color.new255(208, 32, 144),
'VioletRed' -> Color.new255(208, 32, 144),
'VioletRed1' -> Color.new255(255, 62, 150),
'VioletRed2' -> Color.new255(238, 58, 140),
'VioletRed3' -> Color.new255(205, 50, 120),
'VioletRed4' -> Color.new255(139, 34, 82),
'wheat' -> Color.new255(245, 222, 179),
'wheat1' -> Color.new255(255, 231, 186),
'wheat2' -> Color.new255(238, 216, 174),
'wheat3' -> Color.new255(205, 186, 150),
'wheat4' -> Color.new255(139, 126, 102),
'white' -> Color.new255(255, 255, 255),
'white smoke' -> Color.new255(245, 245, 245),
'WhiteSmoke' -> Color.new255(245, 245, 245),
'yellow' -> Color.new255(255, 255, 0),
'yellow green' -> Color.new255(154, 205, 50),
'yellow1' -> Color.new255(255, 255, 0),
'yellow2' -> Color.new255(238, 238, 0),
'yellow3' -> Color.new255(205, 205, 0),
'yellow4' -> Color.new255(139, 139, 0),
'YellowGreen' -> Color.new255(154, 205, 50)
#+END_SRC

::
** class:: CombC
summary:: Comb delay line with cubic interpolation.
related:: Classes/CombL, Classes/CombN, Classes/BufCombC
categories::  UGens>Delays


Description::

Comb delay line with cubic interpolation. See also  link::Classes/CombN::
which uses no interpolation, and  link::Classes/CombL::  which uses linear
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. Used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang

// These examples compare the variants, so that you can hear the difference in interpolation

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ CombN.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ CombL.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ CombC.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// with negative feedback:
{ CombN.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ CombL.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ CombC.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

// used as an echo.
{ CombC.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;
#+END_SRC

::

** class:: CombL
summary:: Comb delay line with linear interpolation.
related:: Classes/CombC, Classes/CombN, Classes/BufCombL
categories::  UGens>Delays


Description::

Comb delay line with linear interpolation. See also  link::Classes/CombN::
which uses no interpolation, and  link::Classes/CombC::  which uses cubic
interpolation. Cubic interpolation is more computationally expensive
than linear, but more accurate.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. Used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang

// These examples compare the variants, so that you can hear the difference in interpolation

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ CombN.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ CombL.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ CombC.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// with negative feedback:
{ CombN.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ CombL.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ CombC.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

// used as an echo.
{ CombL.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;
#+END_SRC

::

** class:: CombN
summary:: Comb delay line with no interpolation.
related:: Classes/CombC, Classes/CombL, Classes/BufCombN
categories::  UGens>Delays


Description::

Comb delay line with no interpolation. See also  link::Classes/CombL::
which uses linear interpolation, and  link::Classes/CombC::  which uses
cubic interpolation. Cubic interpolation is more computationally
expensive than linear, but more accurate.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. Used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::decaytime
Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang

// These examples compare the variants, so that you can hear the difference in interpolation

// Comb used as a resonator. The resonant fundamental is equal to
// reciprocal of the delay time.
{ CombN.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ CombL.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

{ CombC.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), 0.2) }.play;

// with negative feedback:
{ CombN.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ CombL.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

{ CombC.ar(WhiteNoise.ar(0.01), 0.01, XLine.kr(0.0001, 0.01, 20), -0.2) }.play;

// used as an echo.
{ CombN.ar(Decay.ar(Dust.ar(1,0.5), 0.2, WhiteNoise.ar), 0.2, 0.2, 3) }.play;
#+END_SRC

::

** class:: Compander
summary:: Compressor, expander, limiter, gate, ducker
categories:: UGens>Dynamics

description::
General purpose (hard-knee) dynamics processor.

classmethods::
method:: ar
argument::in
The signal to be compressed / expanded / gated.

argument::control
The signal whose amplitude determines the gain applied to the input signal. Often the same as in (for standard gating or compression) but should be different for ducking.

argument::thresh
Control signal amplitude threshold, which determines the break point between slopeBelow and slopeAbove. Usually 0..1. The control signal amplitude is calculated using RMS.

argument::slopeBelow
Slope of the amplitude curve below the threshold. If this slope > 1.0, the amplitude will drop off more quickly the softer the control signal gets; when the control signal is close to 0 amplitude, the output should be exactly zero -- hence, noise gating. Values < 1.0 are possible, but it means that a very low-level control signal will cause the input signal to be amplified, which would raise the noise floor.

argument::slopeAbove
Same thing, but above the threshold. Values < 1.0 achieve compression (louder signals are attenuated); > 1.0, you get expansion (louder signals are made even louder). For 3:1 compression, you would use a value of 1/3 here.

argument::clampTime
The amount of time it takes for the amplitude adjustment to kick in fully. This is usually pretty small, not much more than 10 milliseconds (the default value). I often set it as low as 2 milliseconds (0.002).

argument::relaxTime
The amount of time for the amplitude adjustment to be released. Usually a bit longer than clampTime; if both times are too short, you can get some (possibly unwanted) artifacts.

argument::mul

argument::add

discussion::
If any of this is confusing, see http://en.wikipedia.org/wiki/Audio_level_compression

examples::

code::
#+BEGIN_SRC sclang
(
// example signal to process
play({
    var z;
    z = Decay2.ar(
        Impulse.ar(8, 0,LFSaw.kr(0.3, 0, -0.3, 0.3)),
        0.001, 0.3, Mix.ar(Pulse.ar([80,81], 0.3)))
})
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
// noise gate
play({
    var z;
    z = Decay2.ar(
        Impulse.ar(8, 0,LFSaw.kr(0.3, 0, -0.3, 0.3)),
        0.001, 0.3, Mix.ar(Pulse.ar([80,81], 0.3)));
    Compander.ar(z, z,
        thresh: MouseX.kr(0.1, 1),
        slopeBelow: 10,
        slopeAbove: 1,
        clampTime: 0.01,
        relaxTime: 0.01
    );
})
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
// compressor
play({
    var z;
    z = Decay2.ar(
        Impulse.ar(8, 0,LFSaw.kr(0.3, 0, -0.3, 0.3)),
        0.001, 0.3, Mix.ar(Pulse.ar([80,81], 0.3)));
    Compander.ar(z, z,
        thresh: MouseX.kr(0.1, 1),
        slopeBelow: 1,
        slopeAbove: 0.5,
        clampTime: 0.01,
        relaxTime: 0.01
    );
})
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
// limiter
play({
    var z;
    z = Decay2.ar(
        Impulse.ar(8, 0,LFSaw.kr(0.3, 0, -0.3, 0.3)),
        0.001, 0.3, Mix.ar(Pulse.ar([80,81], 0.3)));
    Compander.ar(z, z,
        thresh: MouseX.kr(0.1, 1),
        slopeBelow: 1,
        slopeAbove: 0.1,
        clampTime: 0.01,
        relaxTime: 0.01
    );
})
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
// sustainer
play({
    var z;
    z = Decay2.ar(
        Impulse.ar(8, 0,LFSaw.kr(0.3, 0, -0.3, 0.3)),
        0.001, 0.3, Mix.ar(Pulse.ar([80,81], 0.3)));
    Compander.ar(z, z,
        thresh: MouseX.kr(0.1, 1),
        slopeBelow: 0.1,
        slopeAbove: 1,
        clampTime: 0.01,
        relaxTime: 0.01
    )*0.1;
})
)
#+END_SRC

::
** class:: CompanderD
summary:: Compressor, expander, limiter, gate, ducker.
related:: Classes/Amplitude, Classes/Compander, Classes/Normalizer, Classes/Limiter
categories::  UGens>Dynamics


Description::

CompanderD passes the signal directly to the control input, but
adds a delay to the process input so that the lag in the gain clamping
will not lag the attacks in the input sound.


classmethods::

method::ar

argument::in
The signal to be compressed / expanded / gated.

argument::thresh
Control signal amplitude threshold, which determines the break point between slopeBelow and slopeAbove. Usually 0..1. The control signal amplitude is calculated using RMS.

argument::slopeBelow
Slope of the amplitude curve below the threshold. If this slope > 1.0, the amplitude will drop off more quickly the softer the control signal gets; when the control signal is close to 0 amplitude, the output should be exactly zero -- hence, noise gating. Values < 1.0 are possible, but it means that a very low-level control signal will cause the input signal to be amplified, which would raise the noise floor.

argument::slopeAbove
Same thing, but above the threshold. Values < 1.0 achieve compression (louder signals are attenuated); > 1.0, you get expansion (louder signals are made even louder). For 3:1 compression, you would use a value of 1/3 here.

argument::clampTime
The amount of time it takes for the amplitude adjustment to kick in fully. This is usually pretty small, not much more than 10 milliseconds (the default value). I often set it as low as 2 milliseconds (0.002).

argument::relaxTime
The amount of time for the amplitude adjustment to be released. Usually a bit longer than clampTime; if both times are too short, you can get some (possibly unwanted) artifacts.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Discussion::
If any of this is confusing, see http://en.wikipedia.org/wiki/Audio_level_compression

** CLASS:: Complex
summary:: complex number
categories:: Math
related::Classes/Polar, Classes/SimpleNumber, Classes/Float, Classes/Integer

DESCRIPTION::
A class representing complex numbers.
Note that this is a simplified representation of a complex number, which does not implement the full mathematical notion of a complex number.

CLASSMETHODS::
method:: new
Create a new complex number with the given real and imaginary parts.
argument:: real
the real part
argument:: imag
the imaginary part

returns:: a new instance of Complex.
discussion::
code::
#+BEGIN_SRC sclang
a = Complex(2, 5);
a.real;
a.imag;
#+END_SRC

::

INSTANCEMETHODS::

subsection:: math support
method:: real
The real part of the number.

method:: imag
The imaginary part of the number.

method:: conjugate
the complex conjugate.
discussion::
code::
#+BEGIN_SRC sclang
Complex(2, 9).conjugate
#+END_SRC

::

method:: +
Complex addition.
discussion::
code::
#+BEGIN_SRC sclang
Complex(2, 9) + Complex(-6, 2)
#+END_SRC

::

method:: -
Complex subtraction
discussion::
code::
#+BEGIN_SRC sclang
Complex(2, 9) - Complex(-6, 2)
#+END_SRC

::

method:: *
Complex multiplication
discussion::
code::
#+BEGIN_SRC sclang
Complex(2, 9) * Complex(-6, 2)
#+END_SRC

::

method:: /
Complex division.
discussion::
code::
#+BEGIN_SRC sclang
Complex(2, 9) / Complex(-6, 2)
#+END_SRC

::

method:: exp
Complex exponentiation with base e.
discussion::
code::
#+BEGIN_SRC sclang
exp(Complex(2, 9))
#+END_SRC

::
code::
#+BEGIN_SRC sclang
exp(Complex(0, pi)) == -1 // Euler's formula: true
#+END_SRC

::

method:: squared
Complex self multiplication.
discussion::
code::
#+BEGIN_SRC sclang
squared(Complex(2, 1))
#+END_SRC

::

method:: cubed
complex triple self multiplication.
discussion::
code::
#+BEGIN_SRC sclang
cubed(Complex(2, 1))
#+END_SRC

::

method:: **, pow
Complex exponentiation
discussion::
not implemented for all combinations - some are mathematically ambiguous.
code::
#+BEGIN_SRC sclang
Complex(0, 2) ** 6
#+END_SRC

::
code::
#+BEGIN_SRC sclang
2.3 ** Complex(0, 2)
#+END_SRC

::
code::
#+BEGIN_SRC sclang
Complex(2, 9) ** 1.2 // not defined
#+END_SRC

::


method:: <
the comparison of just the real parts.
discussion::
code::
#+BEGIN_SRC sclang
Complex(2, 9) < Complex(5, 1);
#+END_SRC

::

method:: ==
the comparison assuming that the reals (floats) are fully embedded in the complex numbers
discussion::
code::
#+BEGIN_SRC sclang
Complex(1, 0) == 1;
Complex(1, 5) == Complex(1, 5);
#+END_SRC

::

method:: neg
negation of both parts
discussion::
code::
#+BEGIN_SRC sclang
Complex(2, 9).neg
#+END_SRC

::

method:: abs
the absoulte value of a complex number is its magnitude.
discussion::
code::
#+BEGIN_SRC sclang
Complex(3, 4).abs
#+END_SRC

::

method:: magnitude
distance to the origin.

method:: magnitudeApx

method:: rho
the distance to the origin.

method:: angle, phase, theta
the angle in radians.


subsection:: conversion
method:: asPoint
Convert to a link::Classes/Point::.

method:: asPolar
Convert to a Polar

method:: asInteger
real part as link::Classes/Integer::.

method:: asFloat
real part as link::Classes/Float::.

method:: asComplex
returns this


subsection:: misc
method:: coerce
method:: hash
a hash value
method:: printOn
print this on given stream
method:: performBinaryOpOnSignal
method:: performBinaryOpOnComplex
method:: performBinaryOpOnSimpleNumber
method:: performBinaryOpOnUGen




EXAMPLES::

Basic example:
code::
#+BEGIN_SRC sclang
a = Complex(0, 1);
a * a; // returns Complex(-1, 0);
#+END_SRC

::

Julia set approximation:
code::
#+BEGIN_SRC sclang
f = { |z| z * z + Complex(0.70176, 0.3842) };

(
var n = 80, xs = 400, ys = 400, dx = xs / n, dy = ys / n, zoom = 3, offset = -0.5;
var field = { |x| { |y| Complex(x / n + offset * zoom, y / n + offset * zoom) } ! n } ! n;

w = Window("Julia set", bounds:Rect(200, 200, xs, ys)).front;
w.view.background_(Color.black);
w.drawFunc = {
	n.do { |x|
		n.do { |y|
			var z = field[x][y];
			z = f.(z);
			field[x][y] = z;
			Pen.color = Color.gray(z.rho.linlin(-100, 100, 1, 0));
 			Pen.addRect(
				Rect(x * dx, y * dy, dx, dy)
			);
			Pen.fill
		}
	}
};

fork({ 6.do { w.refresh; 2.wait } }, AppClock)
)
#+END_SRC

::
** class:: CompositeView
redirect:: implClass
summary:: A view that contains other views.
categories:: GUI>Views
related:: Classes/FlowView, Classes/FlowLayout

description::

note::
In Qt GUI, every view can be a parent to other views, so CompositeView redirects to the same class as link::Classes/View:: - you can use the latter equivalently.
::

CompositeView can be used as the parent of other views, while also being a child of a Window or another CompositeView itself. Aside from that it has not special methods of its own.

note::
In Cocoa GUI, this view accepts key actions, but not mouse clicks or drags.
::


classmethods::
private:: key


examples::

subsection:: Coordinate System

Containers use relative coordinates, i.e.  views are placed relative to the upper left corner of the container.
code::
#+BEGIN_SRC sclang
(
w = Window.new;

c = CompositeView(w, Rect(50, 0, 300, 300));
a = Slider2D(c, Rect(0, 0, 100, 100)); // actually displays at (50, 0)
b = Slider2D(c, Rect(100, 100, 100, 100));

c.background = Color.rand;

w.front;
)

c.bounds_(Rect(100, 0, 300, 300)); // contents adust since coords are relative
c.resize_(6); // contents adust since coords are relative
#+END_SRC

::

subsection:: Keydown Bubbling

Key actions "bubble up" to the parent view if a view does not define one itself. In the following example, a and b do not have keyDown actions themselves, so the key event is passed to c, the parent, which defines the key down action. d's parent is the SCTopView, which has no key down action. See also link::Classes/View::.
code::
#+BEGIN_SRC sclang
( //Click on the different views and hit keys on the keyboard.

w = Window.new;

c = CompositeView(w, Rect(0, 0, 200, 200)).background_(Color.grey.alpha_(0.3));

a = Slider2D(c,Rect(0, 0, 100, 100)).background_(Color.rand);
b = Slider2D(c,Rect(100, 100, 100, 100)).background_(Color.rand);

w.front;

c.keyDownAction = {
	"keydown bubbled up to c".postln;
};

// d is on window w, not on composite view c
d = Slider2D(w,Rect(200, 200, 100, 100));
d.background = Color.black;
)
#+END_SRC

::

subsection:: Decorators

A 'decorator' object can be set to handle layout management. All views added to the CompositeView will now be placed by the decorator. Currently the only one existing is link::Classes/FlowLayout::. You can use the ContainerView's addFlowLayout method as a short cut to assigning FlowLayout to decorator.
code::
#+BEGIN_SRC sclang
(
a = Window.new;

b = CompositeView(a,Rect(0, 0, 500, 500));
b.decorator = FlowLayout(b.bounds);
//b.addFlowLayout; // you can also write this for convenience

// adding views to b automatically use the decorator
// no need to use parent.decorator.place
c = Slider2D(b,Rect(0, 0, 100, 100)); // size matters
d = Slider2D(b,Rect(0, 0, 100, 100)); // origin doesn't

a.front;
)
#+END_SRC

::

You can also use an empty composite view nicely as a spacer in link::Classes/VLayoutView::, link::Classes/HLayoutView::, or views that have a link::Classes/FlowLayout:: as their decorator.
code::
#+BEGIN_SRC sclang
(
a = Window.new;
b = CompositeView(a, Rect(0, 0, 500, 500));

b.decorator = FlowLayout(Rect(0, 0, 500, 500));

Slider2D(b,Rect(0, 0, 100, 100)).background_(Color.rand);
CompositeView(b, Rect(0, 0, 70, 100)); // just used for spacing
Slider2D(b,Rect(0, 0, 100, 100)).background_(Color.rand);
Slider2D(b,Rect(0, 0, 100, 100)).background_(Color.rand);

b.decorator.nextLine;

Slider2D(b, Rect(0, 0, 100, 100)).background_(Color.rand);
Slider2D(b, Rect(0, 0, 100, 100)).background_(Color.rand);
CompositeView(b, Rect(0, 0, 70, 100)); // just used for spacing
Slider2D(b,Rect(0,0,100,100)).background_(Color.rand);

a.front;
)
#+END_SRC

::

subsection:: Hiding / Swapping

You can stack CompositeViews on top of each other and use a button show only one of them:
code::
#+BEGIN_SRC sclang
(
var colors = [Color.blue, Color.red, Color.green];
a = Window.new;
q = 3;

b = Button(a, Rect(0, 0, 160, 20));

b.states = Array.fill(q, { arg i;
	[i.asString, Color.white, colors.wrapAt(i)]
});

b.action = { arg butt;
	p.visible = false;
	p = c.at(butt.value);
	p.visible = true;
};

c = Array.fill(q, { arg i;
	b = CompositeView(a, Rect(0, 25, 300, 300));
	b.background = colors[i].alpha_(0.2);
	b.visible = false;
	b;
});

5.do{ arg i; Slider(c[0], Rect(10, i * 30 + 10, 150, 25)).value_(1.0.rand) };
5.do{ arg i; Slider(c[1], Rect(i * 30 + 10, 10, 25, 150)).value_(1.0.rand) };
Slider2D(c[2], Rect(10, 10, 155, 150)).x_(1.0.rand).y_(1.0.rand);

p = c.at(0); // previous
p.visible = true; // show first one

a.front;
)
#+END_SRC

::

subsection:: Nested Example

In this example, the link::Classes/StaticText:: accepts mouse clicks, since container views can't:
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
v = CompositeView.new(w, w.view.bounds.insetBy(10)).background_(Color.rand);
v.decorator = FlowLayout(v.bounds);

l = "SUPERCOLLIDER".scramble;
t = Array.fill(9, {arg i; var n, r, q;
	n = CompositeView.new(v, Rect(20, 20, 121, 121)).background_(Color.rand);
	q = StaticText(n, n.bounds.moveTo(0,0).insetBy(25)).string_(l[i]).align_(\center);
	q.enabled = true;
	q.font = Font("Geneva", 10);
	q.background_(Color.rand);
	q.mouseDownAction = {
		n.background_(Color.rand);
		q.font=q.font.size_(5 + q.font.size + 7 % 60)
	};
});
)
#+END_SRC

::
** CLASS::Condition
categories::Scheduling
summary::Block the execution of a thread

CLASSMETHODS::

method::new
Create a new instance, set the strong::test:: variable.

INSTANCEMETHODS::

method::test
Answer whether the condition will block or not (boolean).

method::wait
Wait until the condition is true and signalled. This only works in a Routine. This method yields a symbol (\hang), so that the clock doesn't reschedule the Routine.
code::
#+BEGIN_SRC sclang
c = Condition(false); fork { 0.5.wait; "started ...".postln; c.wait;  "... and finished.".postln };
c.test = true;
c.signal;
#+END_SRC

::

method::hang
Wait for strong::value:: time, regardless of test. This only works in a Routine. This method yields a symbol (\hang), so that the clock doesn't reschedule the Routine.
code::
#+BEGIN_SRC sclang
c = Condition.new; fork { 0.5.wait; "started ...".postln; c.hang;  "... and finished.".postln };
c.unhang;
#+END_SRC

::

method::signal
If link::#-test:: is true, reschedule blocked threads.

method::unhang
Resume threads.

EXAMPLES::

code::
#+BEGIN_SRC sclang
(
c = Condition.new(false);

Routine {
	1.wait;
	"waited for 1 second".postln;
	1.wait;
	"waited for another second, now waiting for you ... ".postln;
	c.wait;
	"the condition has stopped waiting.".postln;
	1.wait;
	"waited for another second".postln;
	"waiting for you ... ".postln;
		c.test = false;
		c.wait;
	"the condition has stopped waiting.".postln;
	1.wait;
	"the end".postln;
}.play;
)

// continue
(
c.test = true;
c.signal;
)

// a typical use is a routine that can pause under certin conditions:
(
c = Condition.new;
fork { loop { 1.wait; "going".postln; c.wait } };
)
c.test = true; c.signal;
c.test = false;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// the same, using hang

(
c = Condition.new;

Routine {
	1.wait;
	"waited for 1 second".postln;
	1.wait;
	"waited for another second, now waiting for you ... ".postln;
	c.hang;
	"the condition has stopped waiting.".postln;
	1.wait;
	"waited for another second".postln;
	"waiting for you ... ".postln;
	c.hang;
	"the condition has stopped waiting.".postln;
}.play;
)

// continue
c.unhang;
#+END_SRC

::

Waiting for Synths to end (waitForFree) uses a Condition implicitly:
code::
#+BEGIN_SRC sclang
(
SynthDef(\help, {
	var mod = LFNoise2.kr(ExpRand(0.5, 2)) * 0.5;
	var snd =  mod * Blip.ar(Rand(200, 800) * (mod + 1));
	Out.ar(0, snd);
	FreeSelf.kr(mod < 0); // free the synth when amplitude goes below 0.
}).add;
)

(
fork {
	10.do {
		"started a synth".postln;
		Synth(\help).waitForFree;
		"This one ended. Wait a second,  I will start the next one.".postln;
		1.wait;
	};
	"This is it.".postln;
}
);
#+END_SRC

::class:: ContiguousBlockAllocator
summary:: for better handling of dynamic allocation
related:: Classes/Server, Classes/PowerOfTwoAllocator
categories:: Control

description::

A more robust replacement for the default server block allocator, link::Classes/PowerOfTwoAllocator::. May be used in the link::Classes/Server:: class to allocate audio/control bus numbers and buffer numbers.

To configure a server to use ContiguousBlockAllocator, execute the following:
code::
#+BEGIN_SRC sclang
aServer.options.blockAllocClass = ContiguousBlockAllocator;
#+END_SRC

::
Normally you will not need to address the allocators directly. However, ContiguousBlockAllocator adds one feature not present in PowerOfTwoAllocator, namely the emphasis::reserve:: method.

ClassMethods::

method::new
Create a new allocator with emphasis::size:: slots. You may block off the first emphasis::pos:: slots (the server's audioBusAllocator does this to reserve the hardware input and output buses).

InstanceMethods::

private::prReserve, prSplit

method::alloc
Return the starting index of a free block that is emphasis::n:: slots wide. The default is 1 slot.

method::free
Free a previously allocated block starting at emphasis::address::.

method::reserve
Mark a specific range of addresses as used so that the alloc method will not return any addresses within that range.


** class:: Control
summary:: Bring signals and floats into the ugenGraph function of a SynthDef.
related:: Classes/NamedControl, Classes/LagControl, Classes/TrigControl
categories::  UGens>Synth control

Description::

A Control is a UGen that can be set and routed externally to interact with a running Synth.
Typically, Controls are created from the arguments of a SynthDef function.

Generally you do not create Controls yourself. (See Arrays example
below).

The rate may be either .kr (continous control rate signal) or .ir (a
static value, set at the time the synth starts up, and subsequently
unchangeable). For .ar, see link::Classes/AudioControl::

SynthDef creates these when compiling the ugenGraph function. They are
created for you, you use them, and you don't really need to worry about
them if you don't want to.

For a more concise combination of name, default value and lag, see link::Classes/NamedControl::

classmethods::

method::kr, ir

argument::values

default values.


method::names

argument::names

adds control names to the SynthDef.


Examples::

code::
#+BEGIN_SRC sclang
(
SynthDef(\help_Control, { | freq = 200 |

	freq.inspect; // at the time of compiling the def

}).add
);

// synonym:
(
SynthDef(\help_Control, {

	\freq.kr(200).inspect; // at the time of compiling the def

}).add
);
#+END_SRC

::

What is passed into the ugenGraph function is an link::Classes/OutputProxy::, and its source is a Control.

The main explicit use of Control is to allow Arrays to be sent to running Synths:
code::
#+BEGIN_SRC sclang
// a synth def that has 4 partials
(
SynthDef(\help_Control, { arg out=0, i_freq;
	var klank, harm, amp, ring;

	// harmonics
	harm = Control.names([\harm]).ir(Array.series(4, 1, 1).postln);
	// amplitudes
	amp = Control.names([\amp]).ir(Array.fill(4, 0.05));
	// ring times
	ring = Control.names([\ring]).ir(Array.fill(4, 1));

	klank = Klank.ar(`[harm, amp, ring], { ClipNoise.ar(0.01) }.dup, i_freq);

	Out.ar(out, klank);
}).add;
)

a = Synth(\help_Control, [\i_freq, 300, \harm, [1, 3.3, 4.5, 7.8]]);
a.free;
a = Synth(\help_Control, [\i_freq, 300, \harm, [2, 3, 4, 5]]);
a.free;

(
SynthDef(\help_Control_Sines, { arg out=0;
	var sines, control, numsines;
	numsines = 20;
	control = Control.names(\array).kr(Array.rand(numsines, 400.0, 1000.0));
	sines = Mix(SinOsc.ar(control, 0, numsines.reciprocal)) ;
	Out.ar(out, sines ! 2);
}).add
)

b = Synth(\help_Control_Sines);
b.setn(\array, Array.rand(20, 200, 1600));
b.setn(\array, Array.rand(20, 200, 1600));



(
SynthDef(\help_Control_DynKlank, { arg out=0, freq = 440;
	var klank, harm, amp, ring;

	// harmonics
	harm = Control.names(\harm).kr(Array.series(4, 1, 1));
	// amplitudes
	amp = Control.names(\amp).kr(Array.fill(4, 0.05));
	// ring times
	ring = Control.names(\ring).kr(Array.fill(4, 1));
	klank = DynKlank.ar(`[harm, amp, ring], {ClipNoise.ar(0.003)}.dup, freq);
	Out.ar(out, klank);
}).add
)

a = Synth(\help_Control_DynKlank, [\freq, 300]);
b = Synth(\help_Control_DynKlank, [\freq, 400]);


a.setn(\harm,   Array.rand(4, 1.0, 4.7))
a.setn(\amp, Array.rand(4, 0.005, 0.1))
a.setn(\ring, Array.rand(4, 0.005, 1.0))

b.setn(\harm,   Array.rand(4, 1.0, 4.7))
b.setn(\amp, Array.rand(4, 0.005, 0.1))
b.setn(\ring, Array.rand(4, 0.005, 1.0))
#+END_SRC

::

subsection:: Symbols

Inside SynthDefs and UGen functions, symbols can be used to conventiently specify control inputs of different rates and with lags (see: link::Classes/NamedControl::, and link::Classes/Symbol::)

definitionlist::
## code:: \name.kr(val, lag) ::
|| Return a control rate link::Classes/NamedControl:: input with a default value (val), and if supplied, with a lag. If val is an array, the control will be multichannel.
code::
#+BEGIN_SRC sclang
a = { SinOsc.ar(\freq.kr(440, 1.2)) }.play;
a.set(\freq, 330);
a.release;
a = { SinOsc.ar(\freq.kr([440, 460], 1.2)) }.play;
a.setn(\freq, [330, 367]);
a.release;
#+END_SRC

::

## code:: \name.ar(val, lag) ::
|| Return an audio rate link::Classes/NamedControl:: input with a default value (val), and if supplied, with a lag. If val is an array, the control will be multichannel.

## code:: \name.ir(val) ::
|| Return an intitalization rate link::Classes/NamedControl:: input with a default value (val). If val is an array, the control will be multichannel.

## code:: \name.tr(val) ::
|| Return a link::Classes/TrigControl:: input with a default value (val). If val is an array, the control will be multichannel.
code::
#+BEGIN_SRC sclang
a = { Ringz.ar(T2A.ar(\trig.tr), \freq.kr(500, 1), 0.8) }.play;
a.set(\freq, 330, \trig, 1);
a.set(\freq, 830, \trig, 1);
a.release;
#+END_SRC

::
::

** class:: ControlDur
summary:: Duration of one block
categories:: UGens>Info
related:: Classes/ControlRate

description::
Returns the current block duration of the server in seconds. Equivalent to  1 / link::Classes/ControlRate::.

classmethods::
method:: ir

examples::
code::
#+BEGIN_SRC sclang
{ ControlDur.ir.poll }.play;

{ (1/ControlDur.ir).poll }.play;

{ ControlRate.ir.poll }.play;
#+END_SRC

::
** class:: ControlName
summary:: Object to store control information of SynthDef (used internally)
related:: Classes/SynthDesc, Classes/SynthDef
categories:: UGens>Synth control

description::
For an explicit creation of control names see: link::Classes/NamedControl::, link::Classes/Control::

examples::
code::
#+BEGIN_SRC sclang
a = SynthDescLib.global; // the global library of SynthDescs
x = a.synthDescs.at(\default); // get the default SynthDesc
x.controls.do { |ctl| [\name, ctl.name, \defaultValue, ctl.defaultValue].postln };"";
#+END_SRC

::

instancemethods::
private:: printOn

method::name
The name of the control.
returns:: a link::Classes/Symbol::

method::index
The index of the control.
returns:: an link::Classes/Integer::

method::rate
The rate of the control.
returns:: a link::Classes/Symbol:: like code::'audio':: or code::'control'::

method::defaultValue
Default value of this control. Will be an link::Classes/Array:: for multichannel controls.

method::numChannels
The number of channels.
returns:: an link::Classes/Integer::

** class:: ControlRate
summary:: Server control rate.
related:: Classes/RadiansPerSample, Classes/SampleDur, Classes/SampleRate, Classes/SubsampleOffset
categories::  UGens>Info


Description::

Get the current control rate of the server.


classmethods::

method::ir

returns::
The current control rate of the server.

equivalent to 1 / link::Classes/ControlDur::

Examples::
code::
#+BEGIN_SRC sclang
{ ControlRate.ir.poll }.play;
#+END_SRC

::

play a sine tone at control rate
code::
#+BEGIN_SRC sclang
{ SinOsc.ar(ControlRate.ir) * 0.1 }.play;
#+END_SRC

::

** class:: ControlSpec
summary:: numerical input specification
related:: Classes/Warp
categories:: Control, Spec

description::

The original, and most common spec (see link::Classes/Spec::). A ControlSpec is used by GUI sliders and knobs to specify the range and curve of the controls. ControlSpec may be used in many ways to map from linear 0..1 range to your desired range and back.

The most common way to create a ControlSpec is by
code::
#+BEGIN_SRC sclang
anObject.asSpec // the object may be an array or a symbol
#+END_SRC

::

ClassMethods::

private::initClass

method::new

argument::minval
The minimum value of the range.

argument::maxval
The maximium value of the range.

argument::warp
a link::Classes/Warp::, a symbol (e.g. \lin or \exponential: Default value is \lin), or something else that returns a Warp when sent the message .asWarp. A CurveWarp is defined by a number.

argument::step
The smallest possible increment.

argument::default
The default value.

argument::units
The units, e.g. "hz". Used by some gui's as a unit label.

argument::grid

InstanceMethods::

method::map
Maps and constrains a strong::value:: between 0 and 1 to the range between minval and maxval.

method::unmap
Maps and constrains a strong::value:: between minval and maxval to the range between 0 and 1.
code::
#+BEGIN_SRC sclang
g = ControlSpec(0.01, 2000, \exp, 0.1, 220, "Hz");
g.map(0.5); // convert from [0..1] to [0.01..2000]
g.unmap(1000); // convert from [0.01..2000] to [0..1]

// fore and back translation should be close to identical:
g.unmap(g.map(0.5));
#+END_SRC

::

method::clipLo
The lower of maxval and minval.

method::clipHi
The higher of maxval and minval.

method::constrain
Returns code::value.asFloat.clip(clipLo, clipHi).round(step)::.

method::range
Returns code::maxval - minval::.

method::guessNumberStep
Used for EZ GUI classes for guessing a sensible strong::step:: if none is specified.

Examples::

code::
#+BEGIN_SRC sclang
g = ControlSpec(0.01, 2000, \exp, 0.1, 220, "Hz");

// or alternatively

[0.001, 2000, \exp, 0.1, 220, "hz"].asSpec;

// or add it to the ControlSpec.specs IdentityDictionary:

ControlSpec.specs[\myFreq] = ControlSpec(0.01, 2000, \exp, 0.01, 440, units: "Hz");
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// array is used as arguments to ControlSpec.new(minval, maxval, warp, step, default)
[300,3000,\exponential,100].asSpec.dump
Instance of ControlSpec {    (0313FC08, gc=00, fmt=00, flg=00, set=03)
  instance variables [6]
    minval : Integer 300
    maxval : Integer 3000
    warp : Symbol 'exponential'
    step : Integer 100
    default : Integer 300
}

// partially specified ...
[-48,48].asSpec.dump
Instance of ControlSpec {    (0313FF18, gc=00, fmt=00, flg=00, set=03)
  instance variables [6]
    minval : Integer -48
    maxval : Integer 48
    warp : Symbol 'linear'
    step : Float 0
    default : Integer -48
}

// a Symbol
\freq.asSpec.dump
Instance of ControlSpec {    (180F4910, gc=3C, fmt=00, flg=00, set=03)
  instance variables [8]
    minval : Integer 20
    maxval : Integer 20000
    warp : instance of ExponentialWarp (17FEDB30, size=1, set=1)
    step : Integer 0
    default : Integer 440
    units : " Hz"
    clipLo : Integer 20
    clipHi : Integer 20000
}


// nil becomes a default ControlSpec
nil.asSpec.dump
Instance of ControlSpec {    (0313FF18, gc=00, fmt=00, flg=00, set=03)
  instance variables [6]
    minval : Float 0
    maxval : Float 1
    warp : Symbol 'linear'
    step : Float 0
    default : Float 0
}
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// make a frequency spec with an exponential range from 20 to 20000,
// give it a rounding of 30 (Hz)
a = \freq.asSpec;
a.step = 100;

// equivalent:
a = [20, 20000, 'exp', 100, 440].asSpec;
a.dump;

a.constrain(800); // make sure it is in range and round it.
a.constrain(803); // make sure it is in range and round it.

a.map(0.5);
a.map(0.0); // returns min
a.map(1.5); // exceeds the area: clip, returns max

a.unmap(4000);
a.unmap(22.0);
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// like in envelopes, a CurveWarp is created by a number:

a = [0, 1, -4].asSpec;
a.map(0.5);
a.unmap(0.99);
a.map((0..10).normalize).plot;

// look at different distributions:
(
var invals = (0..10).normalize;
(-4..4).do { |curve|
	var a = [0, 1, curve].asSpec;
	a.map(invals).plot;
}
);
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// using spec for sliders:
(
var w, c, d;
w = Window.new("control", Rect(128, 64, 340, 160));
w.front;
c = Slider.new(w, Rect(10, 10, 300, 30));
d = StaticText.new(w, Rect(10, 40, 300, 30));
c.action = {
	d.string = "unmapped value"
	+ c.value.round(0.01)
	+ "......"
	+ "mapped value"
	+ a.map(c.value)
};
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// ControlSpec-map can also be used to map ugens
(
var spec;
spec = [ 100, 18000, \exp].asSpec;
{
	var freq,osc;
	osc = SinOsc.kr(0.1).range(0,1);
	freq = spec.map( osc );

	freq.dump;// BinaryOpUGen

	SinOsc.ar(
		freq.poll
	)
}.play
)
#+END_SRC

::
** class:: Convolution
summary:: Real-time convolver.
related:: Classes/Convolution2, Classes/Convolution2L, Classes/Convolution3
categories::  UGens>FFT, UGens>Convolution


Description::

Strict convolution of two continuously changing inputs. Also see
link::Classes/Convolution2::  for a cheaper CPU cost alternative for the
case of a fixed kernel which can be changed with a trigger message.


See also  link::http://www.dspguide.com/ch18.htm::  by Steven W.
Smith.


classmethods::

method::ar

argument::in

Processing target.


argument::kernel

Processing kernel.


argument::framesize

Size of FFT frame, must be a power of 2.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang
(

	{ var input, kernel;

	input=AudioIn.ar(1);
	kernel= Mix.ar(LFSaw.ar([300,500,800,1000]*MouseX.kr(1.0,2.0),0,1.0));

	//must have power of two framesize
	Out.ar(0,Convolution.ar(input,kernel, 1024, 0.5));
	 }.play;

)

(
//must have power of two framesize- FFT size will be sorted by Convolution to be double this
//maximum is currently a=8192 for FFT of size 16384
a=2048;
s = Server.local;
//kernel buffer
g = Buffer.alloc(s,a,1);
)

(
//random impulse response
g.set(0,1.0);
100.do({arg i; g.set(a.rand, 1.0.rand)});


	{ var input, kernel;

	input=AudioIn.ar(1);
	kernel= PlayBuf.ar(1,g.bufnum,BufRateScale.kr(g.bufnum),1,0,1);

	Out.ar(0,Convolution.ar(input,kernel, 2*a, 0.5));
	 }.play;

)
#+END_SRC

::

** class:: Convolution2
summary:: Real-time fixed kernel convolver.
related:: Classes/Convolution, Classes/Convolution2L, Classes/Convolution3
categories::  UGens>FFT, UGens>Convolution


Description::

Strict convolution with fixed kernel which can be updated using a trigger
signal.


See also  link::http://www.dspguide.com/ch18.htm::  by Steven W.
Smith.


classmethods::

method::ar

argument::in

Processing target.


argument::kernel

Buffer index for the fixed kernel, may be modulated in
combination with the trigger.


argument::trigger

Update the kernel on a change from non-positive to positive
value.


argument::framesize

Size of FFT frame, must be a power of two. Convolution uses twice
this number internally, maximum value you can give this argument
is 2^16 = 65536. Note that it gets progressively more expensive to run for higher powers! 512, 1024,
2048, 4096 standard.

argument::mul

argument::add

Examples::

code::
#+BEGIN_SRC sclang
( // allocate three buffers
b = Buffer.alloc(s,2048);
c = Buffer.alloc(s,2048);
d = Buffer.alloc(s,2048);

b.zero;
c.zero;
d.zero;
)

(
50.do({ |it| c.set(20*it+10, 1.0.rand); });
3.do({ |it| b.set(400*it+100, 1); });
20.do({ |it| d.set(40*it+20, 1); });
)


(
SynthDef( "conv-test", { arg kernel, trig=0;
	var input;

	input=Impulse.ar(1);

	//must have power of two framesize
	Out.ar(0,Convolution2.ar(input,kernel,trig,2048, 0.5));
}).send(s)

)


x = Synth.new("conv-test",[\kernel,b.bufnum]);

// changing the buffer number:
x.set(\kernel,c.bufnum);
x.set(\trig,0);
x.set(\trig,1); // after this trigger, the change will take effect.
x.set(\kernel,d.bufnum);
x.set(\trig,0);
x.set(\trig,1); // after this trigger, the change will take effect.

d.zero;
40.do({ |it| d.set(20*it+10, 1); });// changing the buffers' contents
x.set(\trig,0);
x.set(\trig,1); // after this trigger, the change will take effect.

x.set(\kernel,b.bufnum);
x.set(\trig,0);
x.set(\trig,1); // after this trigger, the change will take effect.


// next example
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
	{ var input, kernel;

	input=AudioIn.ar(1);

	//must have power of two framesize
	Out.ar(0,Convolution2.ar(input,b.bufnum,0,512, 0.5));
	 }.play;

)


// another example
(
//must have power of two framesize- FFT size will be sorted by Convolution2 to be double this
//maximum is currently a=8192 for FFT of size 16384
a=2048;
s = Server.local;
//kernel buffer
g = Buffer.alloc(s,a,1);
)

(
g.set(0,1.0);
100.do({arg i; g.set(a.rand, (i+1).reciprocal)});
)

(
// random impulse response

	{
	var input,inputAmp,threshhold,gate;

input = AudioIn.ar(1);
inputAmp = Amplitude.kr(input);
threshhold = 0.02;	// noise gating threshold
gate = Lag.kr(inputAmp > threshhold, 0.01);

	Out.ar(0,Convolution2.ar(input*gate,g.bufnum,0, a, 0.5));
	 }.play;

)

// one last example
(
b = Buffer.alloc(s, 512, 1);
b.sine1(1.0/[1,2,3,4,5,6], true, true, true);
)

(
	{ var input, kernel;

	input=AudioIn.ar(1);

	//must have power of two framesize
	Out.ar(0,Convolution2.ar(input,b.bufnum,0, 512, 0.5));
	 }.play;

)
#+END_SRC

::

Instead of triggering the kernel update yourself, as in the first example, you can use a UGen trigger signal to do so. In the next example, we use two Convolution2 UGens in order to continuously and smoothly change the impulse response: link::Classes/RecordBuf:: is used to record a random frequency link::Classes/Saw:: oscillator every code::trigPeriod:: seconds.
Right after the recording (trigPeriod gets delayed by the buffer duration link::Classes/BufDur::, using the link::Classes/TDelay:: UGen) the two convolution UGens alternatingly update their kernels (using two triggers convTrigs). At the frequency of the kernel updates a crossfader link::Classes/XFade2:: moves between conv1 and conv2, using a triangle oscillator link::Classes/LFTri:: at half the trigger frequency as a panning input. The result is a constantly shifting spectral colorization of the Dust impulses:

code::
#+BEGIN_SRC sclang
b = Buffer.alloc( s, 2048, 1, _.zeroMsg );
(
	x = { arg i_kernel, density = 100, trigPeriod = 5.0, cutOff = 1000, minFreq = 200, maxFreq = 2000;
		var input, trigFreq, recTrig, irSig, convTrig, convTrigs, bufFrames, conv1, conv2;

		input		= LPF.ar( Dust2.ar( density ), cutOff );
		trigFreq		= trigPeriod.reciprocal;
		recTrig		= Impulse.kr( trigFreq );
		irSig		= Saw.ar( TExpRand.kr( minFreq, maxFreq, recTrig ), 0.4 );
		RecordBuf.ar( irSig, i_kernel, recTrig, loop: 0, trigger: recTrig );
		convTrig		= TDelay.kr( recTrig, BufDur.ir( i_kernel ));
		// split updates across two triggers. Note that [ 1, 0 ] creates
		// a MultiChannel expansion!
		convTrigs		= PulseDivider.kr( convTrig, 2, [ 1, 0 ]);
		bufFrames		= BufFrames.ir( i_kernel );
		// create the two alternatingly updated convolution ugens
		#conv1, conv2	= Convolution2.ar( input, i_kernel, convTrigs, bufFrames );

		XFade2.ar( conv1, conv2, LFTri.kr( trigFreq * 0.5, 1 )) ! 2;
	}.play( s, [ \i_kernel, b ]);
)

x.set( \trigPeriod, 0.1 );	// fast changes
x.set( \trigPeriod, 10.0 );	// slow changes
x.free;	// delete synth
#+END_SRC

::

** class:: Convolution2L
summary:: Real-time convolver with linear interpolation
related:: Classes/Convolution, Classes/Convolution2, Classes/Convolution3, Classes/StereoConvolution2L
categories::  UGens>FFT, UGens>Convolution

Description::
Strict convolution with fixed kernel which can be updated using a trigger signal. There is a linear crossfade between the buffers upon change.

See emphasis:: Steven W Smith, The Scientist and Engineer's Guide to Digital Signal Processing: chapter 18:: -
http://www.dspguide.com/ch18.htm

classmethods::
private:: categories

method::ar

argument::in
processing target

argument::kernel
buffer index for the fixed kernel, may be modulated in combination with the trigger

argument::trigger
update the kernel on a change from <=0 to >0

argument::framesize
size of FFT frame, must be a power of two. Convolution uses twice this number internally, maximum value you can give this argument is 2^16=65536. Note that it gets progressively more expensive to run for higher powers! 512, 1024, 2048, 4096 standard.

argument::crossfade
The number of periods over which a crossfade is made. The default is 1. This must be an integer.

argument::mul

argument::add

Examples::

code::
#+BEGIN_SRC sclang
(// allocate three buffers
b = Buffer.alloc(s, 2048);
c = Buffer.alloc(s, 2048);
d = Buffer.alloc(s, 2048);

b.zero;
c.zero;
d.zero;
)

(
50.do({ |it| c.set(20*it+10, 1.0.rand); });
3.do({ |it| b.set(400*it+100, 1); });
20.do({ |it| d.set(40*it+20, 1); });
)
#+END_SRC

::
code::
#+BEGIN_SRC sclang
(
SynthDef(\conv_test, { arg kernel, t_trig=0;
	var input;

	input=Impulse.ar(1);

	// must have power of two framesize
	Out.ar(0, Convolution2L.ar(input, kernel, t_trig, 2048, 1, 0.5));
}).add
)

x = Synth(\conv_test, [\kernel, b]);

// changing the buffer number:
x.set(\kernel, c);
x.set(\t_trig, 1); // after this trigger, the change will take effect.
x.set(\kernel, d);
x.set(\t_trig, 1); // after this trigger, the change will take effect.

d.zero;
40.do({ |it| d.set(20*it+10, 1); });// changing the buffers' contents
x.set(\t_trig, 1); // after this trigger, the change will take effect.

x.set(\kernel, b);
x.set(\t_trig, 1); // after this trigger, the change will take effect.

x.free;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// longer crossfade
(
SynthDef( \conv_test2, { arg kernel, t_trig=0;
	var input;

	input=Impulse.ar(1);

	// must have power of two framesize
	Out.ar(0, Convolution2L.ar(input, kernel, t_trig, 2048, 5, 0.5));
}).add
)

x = Synth(\conv_test2, [\kernel, b]);

// changing the buffer number:
x.set(\kernel, c);
x.set(\t_trig, 1); // after this trigger, the change will take effect.
x.set(\kernel, d);
x.set(\t_trig, 1); // after this trigger, the change will take effect.

d.zero;
40.do({ |it| d.set(20*it+10, 1); });// changing the buffers' contents
x.set(\t_trig, 1); // after this trigger, the change will take effect.

x.set(\kernel, b);
x.set(\t_trig, 1); // after this trigger, the change will take effect.

x.free;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// next example

b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
	{ var input, kernel;

	input= SoundIn.ar(0);

	// must have power of two framesize
	Convolution2L.ar(input, b, 0, 512, 1, 0.5);
	}.play;

)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// another example

(
// must have power of two framesize- FFT size will be sorted by Convolution2 to be double this
// maximum is currently a=8192 for FFT of size 16384
a=2048;
// kernel buffer
g = Buffer.alloc(s, a, 1);
)

(
g.set(0, 1.0);
100.do({arg i; g.set(a.rand, (i+1).reciprocal)});
)

(
// random impulse response

	{
	var input, inputAmp, threshhold, gate;

	input = SoundIn.ar(0);
	inputAmp = Amplitude.kr(input);
	threshhold = 0.02;	// noise gating threshold
	gate = Lag.kr(inputAmp > threshhold, 0.01);

	Convolution2L.ar(input*gate, g, 0, a, 1, 0.5);
	}.play;

)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// one last example
(
b = Buffer.alloc(s, 512, 1);
b.sine1(1.0/[1, 2, 3, 4, 5, 6], true, true, true);
)

(
	{ var input, kernel;

	input=SoundIn.ar(0);

	// must have power of two framesize
	Convolution2L.ar(input, b, 0, 512, 1, 0.5);
	}.play;

)
#+END_SRC

::

** class:: Convolution3
summary:: Time based convolver.
related:: Classes/Convolution, Classes/Convolution2, Classes/Convolution2L
categories::  UGens>FFT, UGens>Convolution

Description::
Strict convolution with fixed kernel which can be updated using a trigger signal. The convolution is performed in the time domain, which is highly inefficient, and probably only useful for either very short kernel sizes, or for control rate signals.

See link::Classes/Convolution2:: and link::Classes/Convolution2L:: for more efficient convolution UGens.

classmethods::
private:: categories

method::ar, kr

argument::in
processing target

argument::kernel
buffer index for the fixed kernel, may be modulated in combination with the trigger

argument::trigger
update the kernel on a change from <=0 to >0

argument::framesize
size of FFT frame, does not have to be a power of two.

argument:: mul

argument:: add
** class:: Crackle
summary:: Chaotic noise function.
related:: Classes/LatoocarfianN, Classes/Logistic
categories::  UGens>Generators>Stochastic


Description::

A noise generator based on a chaotic function.


classmethods::

method::ar, kr

argument::chaosParam

A parameter of the chaotic function with useful values from
just below 1.0 to just above 2.0. Towards 2.0 the sound crackles.


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang
{ Crackle.ar(1.95, 0.5) }.play;

// modulate chaos parameter
{ Crackle.ar(Line.kr(1.0, 2.0, 3), 0.5, 0.5) }.play;
#+END_SRC

::

** class:: CuspL
summary:: Cusp map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/CuspN

description::
A linear-interpolating sound generator based on the difference equation:

code::
#+BEGIN_SRC sclang
	x[n+1] = a - b * sqrt(abs(x[n]))
#+END_SRC

::
warning:: revise formulae converted to c like code ::

classmethods::

method:: ar
argument::freq
Iteration frequency in Hertz
argument::a
Equation variable
argument::b
Equation variable
argument::xi
Initial value of x

examples::
code::
#+BEGIN_SRC sclang
// vary frequency
{ CuspL.ar(MouseX.kr(20, SampleRate.ir), 1.0, 1.99) * 0.3 }.play(s);

// mouse-controlled params
{ CuspL.ar(SampleRate.ir/4, MouseX.kr(0.9,1.1,1), MouseY.kr(1.8,2,1)) * 0.3 }.play(s);

// as a frequency control
{ SinOsc.ar(CuspL.ar(40, MouseX.kr(0.9,1.1,1), MouseY.kr(1.8,2,1))*800+900)*0.4 }.play(s);
#+END_SRC

::
** class:: CuspN
summary:: Cusp map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/CuspL

description::
A non-interpolating sound generator based on the difference equation:

code::
#+BEGIN_SRC sclang
	x[n+1] = a - b * sqrt(abs(x[n]))
#+END_SRC

::
warning:: revise formulae converted to c like code ::

classmethods::

method:: ar
argument::freq
Iteration frequency in Hertz
argument::a
Equation variable
argument::b
Equation variable
argument::xi
Initial value of x
argument::mul
argument::add

examples::
code::
#+BEGIN_SRC sclang
// vary frequency
{ CuspN.ar(MouseX.kr(20, SampleRate.ir), 1.0, 1.99) * 0.3 }.play(s);

// mouse-controlled params
{ CuspN.ar(SampleRate.ir/4, MouseX.kr(0.9,1.1,1), MouseY.kr(1.8,2,1)) * 0.3 }.play(s);

// as a frequency control
{ SinOsc.ar(CuspN.ar(40, MouseX.kr(0.9,1.1,1), MouseY.kr(1.8,2,1))*800+900)*0.4 }.play(s);
#+END_SRC

::
** class:: DC
summary:: Create a constant amplitude signal
related:: Classes/LeakDC
categories::  UGens>Generators>Single-value

Description::

This UGen simply outputs the initial value you give it.

classmethods::

method::ar, kr

argument::in
constant value to output, cannot be modulated, set at initialisation time

examples::
code::
#+BEGIN_SRC sclang
//won't work (the output is 0.5*0.0), which is why we need the DC UGen!
{0.5}.play

//constantly zero
{DC.ar(0.0) }.play;


//DC offset; will click on start and finish
{DC.ar(0.5) + SinOsc.ar(440,0,0.1) }.play;


//test - note the transient before LeakDC adapts and suppresses the offset
{LeakDC.ar(DC.ar(0.5))}.play;


// show scope
s.scope
#+END_SRC

::

** class:: Date
summary:: an object describing a point in time
categories:: Control


ClassMethods::

method::new
Create a new date with the given properties (all numerical values). These arguments are also the names of instance variables of the date object.

method::getDate
Get current date from system and create a date object from it.
code::
#+BEGIN_SRC sclang
(
var a = Date.getDate;
a.bootSeconds.postln;
a.dayOfWeek.postln;
a
)
#+END_SRC

::

method::localtime
Get current localized time from system and create a date object from it.

method::gmtime
Get current strong::Greenwich Mean Time (GMT):: from system and create a date object from it.

method::seed
Get current date and return a value suitable for seeding a random number generator. See also link::Reference/randomSeed##randomSeed::.
code::
#+BEGIN_SRC sclang
(
var a = Date.seed;
thisThread.randSeed = a;
20.do { [1,0].choose.post }; "".postln;
thisThread.randSeed = a;
25.do { [1,0].choose.post }; "".postln;
)
#+END_SRC

::

InstanceMethods::

method::localtime
Set the receiver's time to current localtime.

method::gmtime
Set the receiver's time to current strong::Greenwich Mean Time (GMT)::.

method::dayStamp
Obtain a string with the year, month and day in the format strong::YYMMDD::.

method::hourStamp
Obtain a string in the format strong::H:M:S::.

method::secStamp
Obtain a string with the seconds.

method::stamp
Obtain a string in the format strong::YYMMDD_HHMMSS::.

method::asSortableString
Obtain a string in an alphabetically sortable standard database format.

method::asctime
Obtain a string in the format WeekdayName MonthName Time Year.

method::asString
Returns asctime.

method::format
Obtain a date string with a given format. The character % is replaced by the appropriate value, which is derived from the letter that follows.
code::
#+BEGIN_SRC sclang
Date.getDate.format("Today is %A. It is around %I o'clock (%p), in %B.");
Date.getDate.format("%Y-%d-%e-%Hh%m");
#+END_SRC

::

discussion::

A list of formats can be found here: http://www.opengroup.org/onlinepubs/009695399/functions/strftime.html


definitionList::

## %a
|| Replaced by the locale's abbreviated weekday name. [ tm_wday]

## %A
|| Replaced by the locale's full weekday name. [ tm_wday]

## %b
|| Replaced by the locale's abbreviated month name. [ tm_mon]

## %B
|| Replaced by the locale's full month name. [ tm_mon]

## %c
|| Replaced by the locale's appropriate date and time representation.

## %C
|| Replaced by the year divided by 100 and truncated to an integer, as a decimal number [00,99]. [ tm_year]

## %d
|| Replaced by the day of the month as a decimal number [01,31]. [ tm_mday]

## %D
|| Equivalent to %m / %d / %y. [ tm_mon, tm_mday, tm_year]

## %e
|| Replaced by the day of the month as a decimal number [1,31]; a single digit is preceded by a space. [ tm_mday]

## %F
|| Equivalent to %Y - %m - %d (the ISO 8601:2000 standard date format). [ tm_year, tm_mon, tm_mday]

## %g
|| Replaced by the last 2 digits of the week-based year (see below) as a decimal number [00,99]. [ tm_year, tm_wday, tm_yday]

## %G
|| Replaced by the week-based year (see below) as a decimal number (for example, 1977). [ tm_year, tm_wday, tm_yday]

## %h
|| Equivalent to %b. [ tm_mon]

## %H
|| Replaced by the hour (24-hour clock) as a decimal number [00,23]. [ tm_hour]

## %I
|| Replaced by the hour (12-hour clock) as a decimal number [01,12]. [ tm_hour]

## %j
|| Replaced by the day of the year as a decimal number [001,366]. [ tm_yday]

## %m
|| Replaced by the month as a decimal number [01,12]. [ tm_mon]

## %M
|| Replaced by the minute as a decimal number [00,59]. [ tm_min]

## %n
|| Replaced by a <newline>.

## %p
|| Replaced by the locale's equivalent of either a.m. or p.m. [ tm_hour]

## %r
|| Replaced by the time in a.m. and p.m. notation;  in the POSIX locale this shall be equivalent to %I :%M :%S%p. [ tm_hour, tm_min, tm_sec]

## %R
|| Replaced by the time in 24-hour notation (%H : %M ). [ tm_hour, tm_min]

## %S
|| Replaced by the second as a decimal number [00,60]. [ tm_sec]

## %t
|| Replaced by a <tab>.

## %T
|| Replaced by the time ( %H : %M : %S ). [ tm_hour, tm_min, tm_sec]

## %u
|| Replaced by the weekday as a decimal number [1,7], with 1 representing Monday. [ tm_wday]

## %U
|| Replaced by the week number of the year as a decimal number [00,53]. The first Sunday of January is the first day of week 1; days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]

## %V
|| Replaced by the week number of the year (Monday as the first day of the week) as a decimal number [01,53]. If the week containing 1 January has four or more days in the new year, then it is considered week 1. Otherwise, it is the last week of the previous year, and the next week is week 1. Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]

## %w
|| Replaced by the weekday as a decimal number [0,6], with 0 representing Sunday. [ tm_wday]

## %W
|| Replaced by the week number of the year as a decimal number [00,53]. The first Monday of January is the first day of week 1; days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]

## %x
|| Replaced by the locale's appropriate date representation.

## %X
|| Replaced by the locale's appropriate time representation.

## %y
|| Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]

## %Y
|| Replaced by the year as a decimal number (for example, 1997). [ tm_year]

## %z
|| Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ), or by no characters if no timezone is determinable. For example, "-0430" means 4 hours 30 minutes behind UTC (west of Greenwich). If tm_isdst is zero, the standard time offset is used. If tm_isdst is greater than zero, the daylight savings time offset is used. If tm_isdst is negative, no characters are returned. [ tm_isdst]

## %Z
|| Replaced by the timezone name or abbreviation, or by no bytes if no timezone information exists. [ tm_isdst]

## %%
|| Replaced by %.
::

If a conversion specification does not correspond to any of the above, the behavior is undefined.
** class:: Dbrown
summary:: Demand rate brownian movement generator.
related:: Classes/Dibrown, Classes/Demand, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::

Dbrown returns numbers in the continuous range between
code::lo::  and  code::hi:: ,
#+BEGIN_SRC sclang
link::Classes/Dibrown::  returns integer values.


The arguments can be a number or any other UGen.


See link::Classes/Pbrown::,  link::Classes/BrownNoise::  for structurally related
equivalents.


classmethods::

method::new

argument::lo

Minimum value.


argument::hi

Maximum value.


argument::step

Maximum step for each new value.


argument::length

Number of values to create. Use code::inf:: for an infinite number.


Examples::

code::

(
{
	var a, freq, trig;
	a = Dbrown(0, 15, 1, inf);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** class:: Dbufrd
summary:: Buffer read demand ugen
categories:: UGens>Buffer, UGens>Demand
related:: Classes/Dbufwr

classmethods::

method:: new
argument:: bufnum
buffer number to read from
argument:: phase
index into the buffer
argument:: loop
when phase exceeds number of frames in buffer, loops when set to 1 (default :1)
discussion::
all inputs can be either demand ugen or any other ugen.

examples::
code::
#+BEGIN_SRC sclang
b = Buffer.alloc(s, 24, 1);
b.setn(0, { exprand(200, 500) } ! b.numFrames);
b.getn(0, b.numFrames, {|x| x.postln })

(
{ var indexPattern;
	indexPattern = Dseq([Dseq([0, 3, 5, 0, 3, 7, 0, 5, 9], 3), Dbrown(0, 23, 1, 5)], inf);
	SinOsc.ar(
		Demand.kr(Dust.kr(10), 0, Dbufrd(b, indexPattern))
	) * 0.1
}.play;
)

// buffer as a time pattern

c = Buffer.alloc(s, 24, 1);
c.setn(0, { [1, 0.5, 0.25].choose } ! c.numFrames);
c.getn(0, c.numFrames, {|x| x.postln })

(
{ var indexPattern;
	indexPattern = Dseq([Dseq([0, 3, 5, 0, 3, 7, 0, 5, 9], 3), Dbrown(0, 23, 1, 5)], inf);
	SinOsc.ar(
		Duty.kr(
			Dbufrd(c, Dseries(0, 1, inf)) * 0.5,
			0,
			Dbufrd(b, indexPattern)
		)
	) * 0.1
}.play;
)

// free buffers

b.free; c.free;
#+END_SRC

::

** class:: Dbufwr
summary:: Buffer write demand ugen
categories:: UGens>Buffer, UGens>Demand
related:: Classes/Dbufrd

classmethods::

method:: new
argument:: input
single channel input
argument:: bufnum
buffer number to write to (single channel buffer)
argument:: phase
index into the buffer
argument:: loop
when phase exceeds number of frames in buffer, loops when set to 1 (default :1)
discussion::
all inputs can be either demand ugen or any other ugen.

examples::
code::
#+BEGIN_SRC sclang
// alloc a single channel buffer
b = Buffer.alloc(s, 24, 1);
b.setn(0, { 210 } ! b.numFrames);

// post some info:
fork { loop { 0.5.wait; b.getn(0, b.numFrames, {|x| x.postln }) } };

// write demand sequence into a buffer
(
{
var read, write, readpos, writepos, writetrig;

	writetrig = Dust.kr(1);
	readpos = Dseries(0, 1, inf);
	writepos = Dseq([Dseries(0, 3, 30), Dseries(0, 1, 30)], inf);

	read = Dbufrd(b, readpos);
	write = Dbufwr(Dseq([Dseries(1, 1, 16), Dwhite(1, 16, 8)], inf) * 60, b, writepos);

	Demand.kr(writetrig, 0, write); // write on trigger

	SinOsc.ar(
		Demand.kr(Impulse.kr(16), 0, read).lag(0.01) * [1, 1.01]
	) * 0.1

}.play;
)

// write into buffer with mouse clicks
(
{
	var val = MouseY.kr(1000, 200, 1); // cursor y pos controls frequency
	var pos = MouseX.kr(0, BufFrames.kr(b) - 1); // cursor x position controls buffer pos
	var write = MouseButton.kr; // button controls write action
	Demand.kr(write, 0, Dbufwr(val, b, pos, 1));
	SinOsc.ar(
		Duty.kr(Dseq([0.5, 0.75, 0.5, 1.0], inf) * 0.2, 0, Dbufrd(b, Dseries(0, 1, inf)))
	) * 0.1
}.play;
)

// write demand sequence into a buffer
b.free; b = Buffer.alloc(s, 2, 1);
fork { loop { 0.5.wait; b.getn(0, b.numFrames, {|x| x.postln }) } };
b.setn(0, [1, 0]);

(
{
var read, write, readpos, writepos, writetrig;

	writetrig = Impulse.kr(2);
	readpos = Dbufrd(b, 1); // first buffer val is position
	writepos = Dbufrd(b, 0); // second buffer val is position
	read = Dbufrd(b, readpos);

	write = Dbufwr(read, b, writepos);

	Demand.kr(writetrig, 0, write); // write on trigger
}.play;
)

// free buffer:
b.free;
#+END_SRC

::

** class:: DebugNodeWatcher
summary:: watches a server address for debug-related messages
related:: Reference/Server-Command-Reference, Classes/Node, Classes/NodeWatcher
categories:: Control, Server>Nodes

description::
Posts when these messages are received from the server:
n_go n_end n_off n_on

For debugging, it can be useful to see every node start and end. It doesn't require registration, reacts to each message.

Examples::

code::
#+BEGIN_SRC sclang
s = Server.default;
s.boot;

d = DebugNodeWatcher(s);
d.start;

y = Group.new;
y.run(false);
y.free;

d.stop;
#+END_SRC

::
** class:: Decay
summary:: Exponential decay
related:: Classes/Decay2
categories:: UGens>Filters>Linear, UGens>Envelopes

Description::

This is essentially the same as  link::Classes/Integrator::  except that
instead of supplying the coefficient directly, it is calculated from a 60
dB decay time. This is the time required for the integrator to lose 99.9%
of its value or -60dB. This is useful for exponential decaying envelopes
triggered by impulses.

classmethods::

method::ar, kr

argument::in
The input signal.

argument::decayTime
60 dB decay time in seconds.

argument::mul

argument::add

Examples::

code::
#+BEGIN_SRC sclang
plot({ Decay.ar(Impulse.ar(1), 0.01) });

// used as an envelope
play({ Decay.ar(Impulse.ar(XLine.kr(1,50,20), 0.25), 0.2, PinkNoise.ar, 0) });
#+END_SRC

::

** class:: Decay2
summary:: Exponential decay
related:: Classes/Decay
categories::  UGens>Filters>Linear, UGens>Envelopes


Description::
link::Classes/Decay::  has a very sharp attack and can produce clicks.
Decay2 rounds off the attack by subtracting one Decay from another.
code:: Decay2.ar(in, attackTime, decayTime):: is equivalent to:
#+BEGIN_SRC sclang

code::
Decay.ar(in, decayTime) - Decay.ar(in, attackTime)
#+END_SRC

::


classmethods::

method::ar, kr

argument::in

The input signal.


argument::attackTime

60 dB attack time in seconds.


argument::decayTime

60 dB decay time in seconds.


argument::mul

argument::add


Examples::

code::
#+BEGIN_SRC sclang
// since attack and decay are a difference of two Decays,
// swapping the values, the envelope turns upside down:
plot({ Decay2.ar(Impulse.ar(1), 0.001, 0.01) })
plot({ Decay2.ar(Impulse.ar(1), 0.01, 0.001) })

// used as an envelope
{ Decay2.ar(Impulse.ar(XLine.kr(1,50,20), 0.25), 0.01, 0.2, FSinOsc.ar(600)) }.play;

// compare the above with Decay used as the envelope
{ Decay.ar(Impulse.ar(XLine.kr(1,50,20), 0.25), 0.2, FSinOsc.ar(600), 0)  }.play;
#+END_SRC

::

** class:: DecodeB2
summary:: 2D Ambisonic B-format decoder.
related:: Classes/BiPanB2, Classes/PanB, Classes/PanB2, Classes/Rotate2
categories::  UGens>Multichannel>Ambisonics


Description::

Decode a two dimensional ambisonic B-format signal to a set of speakers
in a regular polygon. The outputs will be in clockwise order. The
position of the first speaker is either center or left of center.


classmethods::

method::ar, kr

argument::numChans

Number of output speakers. Typically 4 to 8.


argument::w

The B-format signal.


argument::x

The B-format signal.


argument::y

The B-format signal.


argument::orientation

Should be zero if the front is a vertex of the polygon. The first
speaker will be directly in front. Should be 0.5 if the front
bisects a side of the polygon. Then the first speaker will be the
one left of center.

returns::
An array of channels, one for each speaker.

Examples::

code::
#+BEGIN_SRC sclang

(
{
	var w, x, y, p, a, b, c, d;

	p = PinkNoise.ar; // source

	// B-format encode
	#w, x, y = PanB2.ar(p, MouseX.kr(-1,1), 0.1);

	// B-format decode to quad
	#a, b, c, d = DecodeB2.ar(4, w, x, y);

	[a, b, d, c] // reorder to my speaker arrangement: Lf Rf Lr Rr
}.play;
)
#+END_SRC

::

** class:: DegreeToKey
summary:: Convert signal to modal pitch.
categories::  UGens>Conversion


Description::

The input signal value is truncated to an integer value and used as an
index into an octave repeating table of note values. Indices wrap around
the table and shift octaves as they do.


classmethods::

method::ar, kr

argument::bufnum

Index of the buffer which contains the steps for each scale
degree.


argument::in

The input signal.


argument::octave

The number of steps per octave in the scale.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang

(
// modal space
// mouse x controls discrete pitch in dorian mode
var scale, buffer;
scale = FloatArray[0, 2, 3.2, 5, 7, 9, 10]; // dorian scale
buffer = Buffer.alloc(s, scale.size,1, {|b| b.setnMsg(0, scale) });

play({
	var mix;

	mix =

	// lead tone
	SinOsc.ar(
		(
			DegreeToKey.kr(
				buffer.bufnum,
				MouseX.kr(0,15),		// mouse indexes into scale
				12,					// 12 notes per octave
				1,					// mul = 1
				72					// offset by 72 notes
			)
			+ LFNoise1.kr([3,3], 0.04)	// add some low freq stereo detuning
		).midicps,						// convert midi notes to hertz
		0,
		0.1)

	// drone 5ths
	+ RLPF.ar(LFPulse.ar([48,55].midicps, 0.15),
		SinOsc.kr(0.1, 0, 10, 72).midicps, 0.1, 0.1);

	// add some 70's euro-space-rock echo
	CombN.ar(mix, 0.31, 0.31, 2, 1, mix)
})
)
#+END_SRC

::
** class:: DelTapRd
categories:: UGens>Buffer, UGens>Delays
summary:: Tap a delay line from a DelTapWr UGen
related:: Classes/DelTapWr

description::
Tap a delay line from a link::Classes/DelTapWr:: UGen

classmethods::
private:: categories

method:: ar, kr

argument:: buffer
buffer where DelTapWr has written signal.  Max delay time is based on buffer size.
argument:: phase
the current phase of the DelTapWr UGen. This is the output of DelTapWr.
argument:: delTime
A delay time in seconds.
argument:: interp
the kind of interpolation to be used. 1 is none, 2 is linear, 4 is cubic.
argument:: mul
argument:: add

examples::
See link::Classes/DelTapWr#examples:: for examples.

** class:: DelTapWr
categories:: UGens>Buffer, UGens>Delays
summary:: Write to a buffer for a DelTapRd UGen
related:: Classes/DelTapRd

description::
Write to a buffer for a link::Classes/DelTapRd:: UGen

classmethods::
private:: categories

method:: ar, kr
argument:: buffer
the buffer to write signal into. Max delay time is based on buffer size.
argument:: in
the signal to write to the buffer.
returns::
phase - DelTapWr outputs its current sample value for use in the phase argument in DelTapRd

examples::
code::
#+BEGIN_SRC sclang
// a Buffer for the UGens to use, one second at the current sample rate
b = Buffer.alloc(s, s.sampleRate * 1, 1);

// write a signal into a delay, tap it at mutiple times
SynthDef(\test, {arg buffer;
	var src, tapPhase, tap1, tap2, tap3;
	src = WhiteNoise.ar(0.2) * Decay.kr(Dust.kr(3), 0.2);
	tapPhase = DelTapWr.ar(buffer, src);
	#tap1, tap2, tap3 = DelTapRd.ar(buffer, tapPhase,
		[0.2, 0.27, 0.303],  	// tap times
		1,  					// no interp
		[1.0, 0.4, 0.2] 		// muls for each tap
		);
	Out.ar(0, [src + tap2, tap1 + tap3])
	}).send(s);

x = Synth(\test, [\buffer, b]);
x.free;
b.free;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// a Buffer for the UGens to use
b = Buffer.alloc(s, 44100, 1);

// write a signal into a delay, tap it at mutiple times
SynthDef(\write, {arg buffer, cout;
	var src, tapPhase, tap1, tap2, tap3;
	src = WhiteNoise.ar(0.2) * Decay.kr(Dust.kr(3), 0.7);
	tapPhase = DelTapWr.ar(buffer, src);
	Out.kr(cout, tapPhase);
	}).send(s);

SynthDef(\readFilt, {arg buffer, cin;
	var phase, src, filt;
	phase = In.kr(cin);
	src = DelTapRd.ar(buffer, phase, [0.01, 0.2]);
	filt = BPF.ar(src, 880, 0.01) * 10;
	Out.ar(0, filt);
	}).send(s);

c = Bus.control;

x = Synth(\write, [\buffer, b, \cout, c]);
y = Synth(\readFilt, [\buffer, b, \cin, c]);

x.free;
b.free;
#+END_SRC

::

** class:: Delay1
summary:: Single sample delay.
related:: Classes/Delay2
categories::  UGens>Delays


Description::

Delays the input by 1 audio frame or control period.


classmethods::

method::ar, kr

argument::in
Input signal.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

discussion::
For audio-rate signals the delay is 1 audio frame, and for control-rate signals the delay is 1 control period.


Examples::

code::
#+BEGIN_SRC sclang

(
plot({
	var z;
	z = Dust.ar(1000);
	[z, z - Delay1.ar(z)] 	// [ original, subtract delayed from original ]
}))
#+END_SRC

::

** class:: Delay2
summary:: Two sample delay.
related:: Classes/Delay1
categories::  UGens>Delays


Description::

Delays the input by 2 samples.


classmethods::

method::ar, kr

argument::in
Input signal.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang

(
plot({
	var z;
	z = Dust.ar(1000);
	[z, z - Delay2.ar(z)] 	// [ original, subtract delayed from original ]
}))
#+END_SRC

::

** class:: DelayC
summary:: Simple delay line with cubic interpolation.
related:: Classes/DelayL, Classes/DelayN, Classes/BufDelayC
categories::  UGens>Delays


Description::

Simple delay line with cubic interpolation. See also
link::Classes/DelayN::  which uses no interpolation, and
link::Classes/DelayL::  which uses linear interpolation. Cubic
interpolation is more computationally expensive than linear,
but more accurate.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

discussion::
note::
DelayC needs at least 4 samples buffer. Therefore the minimum code::maxdealytime:: and code::delaytime:: must be code::SampleDur.ir * 4::.
::

Examples::
code::
#+BEGIN_SRC sclang
(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
DelayC.ar(z, 0.2, 0.2, 1, z); // input is mixed with delay via the add input
}.play
)

(
// recursive application of delay.
{
z = Decay2.ar(Dust.ar(1, 0.5), 0.01, 0.1, Saw.ar(100 + [0, 1]));
5.do { |i| z = DelayC.ar(RLPF.ar(z, Rand(100, 3000), 0.03), 1, 1 / (2**i), 1, z * 0.5) };
z
}.play
)
#+END_SRC

::

** class:: DelayL
summary:: Simple delay line with linear interpolation.
related:: Classes/DelayC, Classes/DelayN, Classes/BufDelayL
categories::  UGens>Delays


Description::

Simple delay line with linear interpolation. See also
link::Classes/DelayN::  which uses no interpolation, and
link::Classes/DelayC::  which uses cubic interpolation. Cubic
interpolation is more computationally expensive than linear,
but more accurate.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang
(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
DelayL.ar(z, 0.2, 0.2, 1, z); // input is mixed with delay via the add input
}.play
)

(
// recursive application of delay.
{
z = Decay2.ar(Dust.ar(1, 0.5), 0.01, 0.1, Saw.ar(100 + [0, 1]));
5.do { |i| z = DelayL.ar(RLPF.ar(z, Rand(100, 3000), 0.03), 1, 1 / (2**i), 1, z * 0.5) };
z
}.play
)
#+END_SRC

::

** class:: DelayN
summary:: Simple delay line with no interpolation.
related:: Classes/DelayC, Classes/DelayL, Classes/BufDelayN
categories::  UGens>Delays


Description::

Simple delay line with no interpolation. See also
link::Classes/DelayL::  which uses linear interpolation, and
link::Classes/DelayC::  which uses cubic interpolation. Cubic
interpolation is more computationally expensive than linear,
but more accurate.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::maxdelaytime
The maximum delay time in seconds. used to initialize the delay buffer size.

argument::delaytime
Delay time in seconds.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang
(
// Dust randomly triggers Decay to create an exponential
// decay envelope for the WhiteNoise input source
{
z = Decay.ar(Dust.ar(1,0.5), 0.3, WhiteNoise.ar);
DelayN.ar(z, 0.2, 0.2, 1, z); // input is mixed with delay via the add input
}.play
)

(
// recursive application of delay.
{
z = Decay2.ar(Dust.ar(1, 0.5), 0.01, 0.1, Saw.ar(100 + [0, 1]));
5.do { |i| z = DelayN.ar(RLPF.ar(z, Rand(100, 3000), 0.03), 1, 1 / (2**i), 1, z * 0.5) };
z
}.play
)
#+END_SRC

::

** class:: Demand
summary:: Demand results from demand rate UGens.
related:: Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::

When there is a trigger at the trig input, a value is demanded each UGen
in the list and output. The unit generators in the list should be
'demand' rate.

When there is a trigger at the reset input, the demand rate UGens in the
list are reset.

classmethods::
private:: categories

method::ar, kr

argument::trig
Trigger. Can be any signal. A trigger happens when the signal
changes from non-positive to positive.

argument::reset
Trigger. Resets the list of UGens when triggered.

argument::demandUGens
List of demand-rate UGens to get values from. When the shortest stream ends, this ugen will set the link::Classes/Done##'done' flag::.

discussion::
By design, a reset trigger only resets the demand ugens; it does not reset the value at Demand's output. Demand continues to hold its value until the next value is demanded, at which point its output value will be the first expected item in the list.
To jump to the start value upon receipt of a reset trigger, one can add (+) the two triggers together:
code::
#+BEGIN_SRC sclang
(
a = { |t_trig, t_reset|
	var	d = Demand.kr(t_trig + t_reset, t_reset, Dseries(0, 1, inf));
	d.poll(t_trig + t_reset);
	0.0;
}.play
)
a.set(\t_trig, 1); // do this a few times -- the demand value should increase by 1 each time
a.set(\t_reset, 1);	// goes immediately back to 0
#+END_SRC

::

One demand ugen represents a single stream of values, so that embedding the same ugen twice calls this stream twice. To isolate a demand ugen, use a function:
code::
#+BEGIN_SRC sclang
{
var a, b, t = Impulse.kr(2);
a = { Dseq([1, 2, 3, 4, 5], inf) } * 100;
b = a + 1;
Demand.kr(t, 0, [a, b]).poll(t)
}.play
#+END_SRC

::


Examples::

code::
#+BEGIN_SRC sclang

// examples

(
{
	var trig, seq, freq;
	trig = Impulse.kr(24);
	seq = Drand([Dseq((1..5).mirror1, 1), Drand((4..10), 8)], 2000);
	freq = Demand.kr(trig, 0, seq * 100);
	SinOsc.ar(freq + [0,0.7]).cubed.cubed.scaleneg(MouseX.kr(-1,1)) * 0.1;
}.play;
)

(
{
	var trig, seq, freq;
	trig = Impulse.kr(12);
	seq = Drand([Dseq((1..5).mirror1, 1), Drand((4..10), 8)], 2000) * Drand([1,2,4,8],2000);
	freq = Demand.kr(trig, 0, seq * 100);
	SinOsc.ar(freq + [0,0.7]).cubed.cubed.scaleneg(MouseX.kr(-1,1)) * 0.1;
}.play;
)




(
{
	var freq, trig, reset, seq;
	trig = Impulse.kr(10);
	seq = Diwhite(60, 72, inf).midicps;
	freq = Demand.kr(trig, 0, seq);
	SinOsc.ar(freq + [0,0.7]).cubed.cubed * 0.1;
}.play;
)

(
{
	var freq, trig, reset, seq;
	trig = Impulse.kr(10);
	seq = Dseq([72, 75, 79, Drand([82,84,86])], inf).midicps;
	freq = Demand.kr(trig, 0, seq);
	SinOsc.ar(freq + [0,0.7]).cubed.cubed * 0.1;
}.play;
)


(
{
	var freq, trig, reset, seq;
	trig = Impulse.kr(10);
	seq = Dswitch1(
		[
			Diwhite(60, 72, inf),
			Dseq([72, 75, 79, Drand([82,84,86])], inf)
		],
		LFPulse.kr(0.2)
	);
	freq = Demand.kr(trig, 0, seq.midicps);
	SinOsc.ar(freq + [0,0.7]).cubed.cubed * 0.1;
}.play;
)


(
{
	var freq, trig, reset, seq1, seq2;
	trig = Impulse.kr(10);
	seq1 = Drand([72, 75, 79, 82] - 12, inf).midicps;
	seq2 = Dseq([72, 75, 79, Drand([82,84,86])], inf).midicps;
	freq = Demand.kr(trig, 0, [seq1, seq2]);
	SinOsc.ar(freq + [0,0.7]).cubed.cubed * 0.1;
}.play;
)

(
{
	var trig, seq;
	trig = Impulse.kr(8);
	seq = Drand([
		Dseq([4,0,0,1,2,1,0,1]),
		Dseq([4,0,2,0,1,0,1,1]),
		Dseq([4,0,0,2,0,0,1,1]),
		Dseq([4,0,1,2,0,1,2,0]),
		Dseq([4,1,1,1,2,2,3,3]),
		Dseq([4,1,0,1,0,1,0,1])
	], inf);
	trig = Demand.kr(trig, 0, seq * 0.4) * trig;
	{LPF.ar(PinkNoise.ar, 5000)}.dup * Decay.kr(trig, 0.5);
}.play;
)
#+END_SRC

::

** class:: DemandEnvGen
summary:: Demand rate envelope generator
related:: Classes/Demand, Classes/Duty, Classes/TDuty
categories::  UGens>Demand, UGens>Envelopes

Description::
Plays back break point envelope contours (levels, times, shapes) given by demand ugens. The next values are called when the next node is reached.

classmethods::
private:: categories

method::ar, kr

argument::level

A demand UGen or any other UGen returning level values. If this ends, the

code::doneAction::  is evaluated.
#+BEGIN_SRC sclang


argument::dur

A demand UGen or any other UGen returning time values. If this ends, the

code::doneAction::  is evaluated.


argument::shape

A demand UGen or any other UGen: the number given is the shape
number according to link::Classes/Env::.


argument::curve

A demand UGen or any other UGen returning curve values. if shape is 5, this is the
curve factor.

The possible values are:
table::
## 0 || flat segments
## 1 || linear segments, the default
## 2 || natural exponential growth and decay. In this case, the levels must all be nonzero and the have the same sign.
## 3 || sinusoidal S shaped segments.
## 4 || sinusoidal segments shaped like the sides of a Welch window.
## a Float || a curvature value for all segments.
## An Array of Floats || curvature values for each segments.
#+END_SRC

::

argument::gate

If gate is x ≥ 1, the UGen runs.


If gate is 0 > x > 1, the UGen is released at the next
level (doneAction).


If gate is x < 0, the UGen is sampled and held.


argument::reset

If reset crosses from non-positive to positive, the UGen is reset
at the next level. If it is > 1, it is reset immediately.


argument::levelScale

demand ugen returning level scaling values


argument::levelBias

demand ugen returning level offset values


argument::timeScale

demand ugen returning time scaling values


argument::doneAction

A doneAction that is evaluated when level or duration stream
ends. See link::Reference/UGen-doneActions::  for more detail.


Examples::

code::
#+BEGIN_SRC sclang
// frequency envelope with random times
(
	{
		var freq;
		freq = DemandEnvGen.ar(
				Dseq([204, 400, 201, 502, 300, 200], inf),
				Drand([1.01, 0.2, 0.1, 2], inf) * MouseY.kr(0.01, 3, 1),
				7 // cubic interpolation
			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)

// frequency modulation
(
	{
		var freq, list;
		list = { exprand(200, 1000.0) } ! 32;
		freq = DemandEnvGen.ar(
				{ Dseq(list.scramble, inf) } ! 2,
				SampleDur.ir * MouseY.kr(1, 3000, 1),
				5, // curve interpoaltion
				MouseX.kr(-0.01, -4) // curve must be negative for fast interpol.
			);
		SinOsc.ar(freq) * 0.1

	}.play;
)


//  gate
// mouse x on right side of screen toggles gate
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dwhite(300, 1000, inf).round(100),
				0.1,
				5, 0.3, // curve: 0.3
				MouseX.kr > 0.5,
				1
			);
		SinOsc.ar(freq * [1, 1.21]) * 0.1

	}.play;
)

// sample and hold (0.5 > gate > 0)
// mouse x on right side of screen toggles gate
// mouse y scales frequency
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dwhite(300, 1000, inf).round(100),
				0.1,
				5, 0.3,
				MouseX.kr > 0.5 + 0.1
			);
		SinOsc.ar(freq * [1, 1.21]) * 0.1

	}.play;
)

// gate
// mouse x on right side of screen toggles gate
// mouse button does soft reset
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([Dseries(400, 200, 5), 500, 800, 530, 4000, 900], 2),
				Dseq([0.2, 0.1, 0.2, 0.3, 0.1], inf),
				Dseq([1, 0, 0, 6, 1, 1, 0, 2], inf), // shapes
				0,
				MouseX.kr > 0.5, // gate
				MouseButton.kr > 0.5, // reset
				doneAction:0
			);
		SinOsc.ar(freq * [1, 1.001]) * 0.1

	}.play;
)


//  gate
// mouse x on right side of screen toggles sample and hold
// mouse button does hard reset
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([Dseries(400, 200, 5), 500, 800, 530, 4000, 900], 2),
				0.1,
				3, 0,
				MouseX.kr > 0.5 - 0.1, // gate: sample and hold
				MouseButton.kr > 0.5 * 2, // hard reset
				doneAction: 0
			);
		SinOsc.ar(freq * [1, 1.001]) * 0.1

	}.play;
)





// short sequence with doneAction, linear
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([1300, 500, 800, 300, 400], 1),
				0.2,
				1,
				doneAction:2
			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)

// short sequence with doneAction, step
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([1300, 500, 800, 300, 400], 1),
				0.2,
				0,
				doneAction:2
			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)



// a linear ramp
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([300, 800], 1),
				1,
				1
			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)



// random gate:  release. gate low level > 0.
// only end points are kept as release levels
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([500, 800], inf),
				0.03,
				1,0, // linear
				ToggleFF.kr(Dust.kr(5)) + 0.1 // gate


			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)

// random gate: sample and hold. gate low level = 0.
(
	{
		var freq;
		freq = DemandEnvGen.kr(
				Dseq([500, 800, 600], inf),
				0.03,
				1,0, // linear
				ToggleFF.kr(Dust.kr(5)), // gate
				0 // reset

			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)




// lfnoise1
(
	{
			DemandEnvGen.ar(
				Dwhite(-0.1, 0.1, inf),
				SampleDur.ir * MouseY.kr(0.5, 20),
				5,
				-4
			);


	}.play;
)

// lfbrownnoise
(
	{
			DemandEnvGen.ar(
				Dbrown(-0.1, 0.1, 0.1, inf),
				SampleDur.ir * MouseY.kr(1, 100, 1)
			);


	}.play;
)






// hardsyncing a saw
(
	{

			DemandEnvGen.ar(
				Dseq([Dseries(-0.1, 0.01, 20)], inf),
				SampleDur.ir * MouseY.kr(1, 100, 1),
				1, 0,
				K2A.ar(1),
				Impulse.ar(MouseX.kr(1, SampleRate.ir * MouseX.kr(0.002, 1, 1), 1), 0, 1.5)

			)


	}.scope;
)


// softsyncing a saw
(
	{

			DemandEnvGen.ar(
				Dseq([Dseries(-0.1, 0.01, 20)], inf),
				SampleDur.ir * MouseY.kr(1, 100, 1),
				1, 0,
				K2A.ar(1),
				Impulse.ar(MouseX.kr(1, SampleRate.ir * MouseX.kr(0.002, 1, 1), 1)) + [0, 0.3]

			)


	}.scope;
)



// hardsyncing a saw, som random elements
(
	{

			DemandEnvGen.ar(
				Dseq([Dseries(-0.1, 0.01, 20), Dseries(-0.1, 0.01, 20), Dwhite(-0.1, 0.1, 5)], inf),
				SampleDur.ir * MouseY.kr(1, 100, 1),
				3, 0,
				1,
				Impulse.ar(MouseX.kr(1, SampleRate.ir * MouseX.kr(0.002, 1, 1), 1), 0, 1.5)

			)


	}.scope;
)

// softsyncing a saw, som random elements
(
	{

			DemandEnvGen.ar(
				Dseq([Dseries(-0.1, 0.01, 20), Dseries(-0.1, 0.01, 20), Dwhite(-0.1, 0.1, 5)], inf),
				SampleDur.ir * MouseY.kr(1, 100, 1),
				1, 0, // linear interpolation
				1,
				Impulse.ar(MouseX.kr(1, SampleRate.ir * MouseX.kr(0.002, 1, 1), 1))

			)


	}.scope;
)


// multichannel expansion
// mouse x on right side of screen toggles gate
// mouse y controls speed

(
	{
		var freq;
		freq = DemandEnvGen.kr(
				{ Dseq([300, 800, Drand([1000, 460, 300], 1), 400], inf) + 3.0.rand } ! 2,
				MouseY.kr(0.001, 2, 1),
				5, -4,
				MouseX.kr > 0.5
			);
		SinOsc.ar(freq) * 0.1

	}.play;
)
#+END_SRC

::
** class:: DetectIndex
summary:: Search a buffer for a value
categories:: UGens>Buffer

description::
Search a buffer for a value.

classmethods::
method:: ar, kr

argument:: bufnum
index of the buffer
argument:: in
the input signal.
returns::
index

examples::
code::
#+BEGIN_SRC sclang
(
var max = 300;
t = Array.series(max, 0, 1).curdle(0.06).scramble.flat;
b = Buffer(s, t.size, 1);

// alloc and set the values
s.listSendMsg( b.allocMsg( b.setnMsg(0, t) ) );


{
	var index, in, out, f0, fdiff;
	var bufnum = b;
	var input;
	input = MouseX.kr(0, max).round(1); // round to precision
	index = DetectIndex.kr(bufnum, input);
	index.poll;
	SinOsc.ar(index.linexp(0, max, 200, 700)) * 0.1
}.play;
)

b.free;
#+END_SRC

::

** class:: DetectSilence
summary:: When input falls below a threshhold, evaluate doneAction.
categories::  UGens>Synth control, UGens>Analysis>Amplitude


Description::

When input falls below a threshhold, evaluate doneAction. If the input
signal starts with silence at the beginning of the synth's duration, then
DetectSilence will wait indefinitely until the first sound before
starting to monitor for silence.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::amp

When input falls below this, evaluate

code::doneAction:: .
#+BEGIN_SRC sclang


argument::time

The minimum duration for which input must fall below

code::amp::  before this triggers.


argument::doneAction

An integer representing the doneAction. See

link::Reference/UGen-doneActions::  for more detail.

returns::
This UGen outputs 1 if silence is detected, otherwise 0.

Examples::

code::

(
SynthDef("detectSilence-help", { arg out;
	var z;
	z = SinOsc.ar(Rand(400, 700), 0, LFNoise2.kr(8, 0.2).max(0));
	DetectSilence.ar(z, doneAction:2);
	Out.ar(out, z);
}).send(s);
)

s.sendMsg("/s_new", "detectSilence-help", -1);
s.sendMsg("/s_new", "detectSilence-help", -1);
s.sendMsg("/s_new", "detectSilence-help", -1);

(
Task({
	loop({
		s.sendMsg("/s_new", "detectSilence-help", -1);
		[0.5, 1].choose.wait;
	})
}).play;
)
#+END_SRC

::
** class:: Dgeom
summary:: Demand rate geometric series UGen.
related:: Classes/Demand, Classes/Dseries, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::
Demand rate geometric series UGen.

See link::Classes/Pgeom:: for structurally related equivalent.


classmethods::

method::new

argument::start
Start value. Can be a number or any other UGen.


argument::grow
Value by which to grow (x = x[-1] * grow).  Can be a number or
any other UGen.

argument::length
Number of values to create.

discussion::
The arguments can be a number or any other ugen

Examples::

code::
#+BEGIN_SRC sclang

// example

(
{
	var a, freq, trig;
	a = Dgeom(1, 1.2, 15);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

(
{
	var a, freq, trig;
	a = Dgeom(1, 1.2, inf);
	trig = Dust.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** CLASS:: Dialog
redirect:: implClass
summary:: Shows various system dialogs
categories:: GUI>Accessories

DESCRIPTION::
This class allows to show various system dialogs. link::#*openPanel:: will show a dialog for selecting a file to open, and link::#*savePanel:: will show a dialog for selecting or creating a file to save to.


CLASSMETHODS::
PRIVATE:: key

METHOD:: openPanel
	Shows a dialog for selection of an existing file (or multiple files) to open. It does not do anything with the file, instead it just passes the chosen filenames to the given result handler.

	ARGUMENT:: okFunc
		An object to be evaluated when OK is pressed. As argument, either a single filename is passed as a String, or an Array of Strings for multiple selected items is passed, depending on the strong::multipleSelection:: argument.
	ARGUMENT:: cancelFunc
		An object to be evaluated when Cancel is pressed.
	ARGUMENT:: multipleSelection
		A Boolean indicating whether multiple files can be selected.
	DISCUSSION::
	Example:
code::
#+BEGIN_SRC sclang
(
Dialog.openPanel({ arg path;
	path.postln;
},{
	"cancelled".postln;
});
)
#+END_SRC

::

METHOD:: savePanel
	Shows a dialog for selecting or creating a file to save to. It does not do anything with the selected file, and does not create any file; instead it just passes the chosen filename to the given result handler.

	ARGUMENT:: okFunc
		An object to be evaluated when OK is pressed. The chosen filename is passed as a String as argument.
	ARGUMENT:: cancelFunc
		An object to be evaluated when Cancel is pressed.
	DISCUSSION::
	Example:
code::
#+BEGIN_SRC sclang
(
Dialog.savePanel({ arg path;
	path.postln;
},{
	"cancelled".postln;
});
)
#+END_SRC

::

METHOD:: getPaths
	note::Deprecated. Use link::#*openPanel:: instead. ::

	Implements the same functionality as *openPanel, only the last argument is named differently and defaults to true.
** class:: Dibrown
summary:: Demand rate brownian movement generator.
related:: Classes/Dbrown, Classes/Demand, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::
link::Classes/Dbrown::  returns numbers in the continuous range between
code::lo::  and  code::hi:: ,
#+BEGIN_SRC sclang
Dibrown returns integer values.


The arguments can be a number or any other UGen.


See link::Classes/Pbrown::,  link::Classes/BrownNoise::  for structurally related
equivalents.


classmethods::

method::new

argument::lo

Minimum value.


argument::hi

Maximum value.


argument::step

Maximum step for each new value.


argument::length

Number of values to create. Use code::inf:: for an infinite number.


Examples::

code::

(
{
	var a, freq, trig;
	a = Dibrown(0, 15, 1, inf);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** CLASS::Dictionary
summary::associative collection mapping keys to values
related::Classes/Environment, Classes/Event
categories::Collections>Unordered

DESCRIPTION::
A Dictionary is an associative collection mapping keys to values.
Two keys match if they are strong::equal::. (i.e. == returns true.)

The contents of a Dictionary are strong::unordered::. You must not depend on the order of items in a Dictionary.
You must only rely on equality for the keys (e.g. symbols are ok, strings not). For identity matching see: link::Classes/IdentityDictionary::.

CLASSMETHODS::

method::new
Creates a Dictionary with an initial capacity for strong::n:: key value mappings.

method::newFrom
Creates a new Dictionary from another collection.
code::
#+BEGIN_SRC sclang
d= Dictionary.newFrom(List[\a, 1, \b, 2, \c, 4]);
#+END_SRC

::
argument::aCollection
any Object that responds to keysValuesDo (usually a List or an Array).

INSTANCEMETHODS::

subsection::Adding and Removing

method::add
Add strong::anAssociation:: to the Dictionary. If the key value pair already exists in the Dictionary, the key's value will be replaced.
code::
#+BEGIN_SRC sclang
(
d = Dictionary.new;
d.add(\monkey -> 0).postln;
d.add(\robot -> 1).postln;	// Add robot as a key with a value of 1
d.add(\monkey -> 2).postln;	// Replaces the value for the key monkey with 2
)
#+END_SRC

::

method::put
Associate two objects and add them to the Dictionary.
code::
#+BEGIN_SRC sclang
d = Dictionary.new;
d.put("abc", 10);

// using an event:
d = ();
d.put("abc", 10);
#+END_SRC

::
argument::key
key to associate with object. This can be any objects, but is often a link::Classes/Symbol::.
argument::value
an object

method::removeAt
Remove the key and the value associated with it from the Dictionary.
code::
#+BEGIN_SRC sclang
d = (monkey: 99);
d.removeAt(\monkey);
#+END_SRC

::

method::putAll
Add all items of each argument to the dictionary.
code::
#+BEGIN_SRC sclang
d = ();
d.putAll(Dictionary[\hello -> 9, \whello -> "world"], Dictionary["abd" -> 6]);
#+END_SRC

::
argument:: ... dictionaries
any Object that responds to keysValuesDo (usually a Dictionary).

method::putPairs
Add all items to the dictionary, using them as key and value pairwise.
code::
#+BEGIN_SRC sclang
d = ();
d.putPairs([\hello, 10, \whello, "lord", "abc", 7]);
#+END_SRC

::

subsection::Accessing

method::at
Access the value associated with the key.
code::
#+BEGIN_SRC sclang
d = (robot: 99);
d.at(\robot);	// Get the value associated with key
d[\robot];	// different syntax, same behaviour
d.at(\monkey);	// Key doesn't exist: return Nil
#+END_SRC

::

method::atFail
Access the value associated with the key. If the key does not exist, return the result of teletype::function::.

method::keys
Return a link::Classes/Set:: of all keys.
code::
#+BEGIN_SRC sclang
d = (hello: 9, whello: "world");
d.keys;
#+END_SRC

::

method::values
Return a link::Classes/List:: of all values.
code::
#+BEGIN_SRC sclang
d = (hello: 9, whello: "world");
d.values;
#+END_SRC

::

method::atAll
Return an link::Classes/Array:: of all values for the given keys.
code::
#+BEGIN_SRC sclang
d = (hello: 9, whello: "world", z: 99, c: 0.33);
d.atAll([\hello, \z, \hello, \c, \whello]);
#+END_SRC

::

method::getPairs
Return an link::Classes/Array:: with all keys and values pairwise.
code::
#+BEGIN_SRC sclang
d = (hello: 9, whello: 77, z: 99);
d.getPairs;
#+END_SRC

::

method::associationAt
Access the link::Classes/Association:: that has the given key.
code::
#+BEGIN_SRC sclang
d = (robot: 99);
d.associationAt(\robot);	// Get the value associated with key
#+END_SRC

::

method::findKeyForValue
Try to find a given value and return its key.
code::
#+BEGIN_SRC sclang
d = (hello: 1, whello: 1976);
d.findKeyForValue(1);
#+END_SRC

::

method::matchAt
The dictionary's keys are used as conditions against which the arbitrary item is matched. See: link::Reference/matchItem::
note::
if an item matches multiple criteria, the value returned is arbitrary. This is because a dictionary is an unordered collection. It's the user's responsibility to make sure that criteria are mutually exclusive.
::
list::
## If the key is an object, the item will be matched by identity (if key === item, the value will be returned).
## If the key is a collection, the item is matched if it's contained in the collection.
## If the key is a function, the function is evaluated with the item as an argument and the item is matched if the function returns true.
::
code::
#+BEGIN_SRC sclang
(
d = (
	0: \zero,
	\abc: \alpha,
	[1, 2, 3, 5, 8, 13, 21]: \fibonacci,
	{ |x| try { x.even } }: \even // try is needed because argument might not be a number
	);
);

d.matchAt(0)
d.matchAt(1)
d.matchAt(2)	// matches both 'fibonacci' and 'even', either may be returned
d.matchAt(4)
d.matchAt(\abc)
#+END_SRC

::

method::trueAt
Returns link::Classes/True:: if the item at the key is true, otherwise false. This method is also valid in link::Classes/Object::.

method::falseAt
Returns link::Classes/False:: if the item at the key is not true, otherwise true. This method is inherited from link::Classes/Object::.

subsection::Iteration/Enumeration
Most methods for iteration work analogously to Dictionary's superclasses, see e.g. link::Classes/Collection::.

method::do, collect, reject, select
code::
#+BEGIN_SRC sclang
// do, collect, reject, select
d = Dictionary[\a -> "hello", \b -> "robot", \c -> [1, 2, 3]];
d = (a: "hello", b: "robot", c: [1, 2, 3]); // equivalent
d.do { |item, i| [item, i].postln };
d.collect { |item| item + 100 };
d.reject { |item| item.size > 4 };
d.select { |item| item.size > 4 };
#+END_SRC

::

method::keysValuesDo
Iterate over the associations, and evaluate the function for each, passing key and value as argument.
code::
#+BEGIN_SRC sclang
d = (a: "hello", b: "robot", c: [1, 2, 3]);
d.keysValuesDo { |key, value| postln("the key: " ++ key ++ " the value: " ++ value) };
#+END_SRC

::

method::keysValuesChange
Iterate over the associations, and evaluate the function for each, passing key and value as argument. Replace the value with the return value from the function (similar to link::#-collect::, but modifies the dictionary strong::in place::).
code::
#+BEGIN_SRC sclang
d = (a: "hello", b: "robot", c: [1, 2, 3]);
d.keysValuesChange { |key, value| "the key: " ++ key ++ " the value: " ++ value };
d;
#+END_SRC

::

method::keysDo
Iterate over the associations, and evaluate the function for each, passing key as argument.
code::
#+BEGIN_SRC sclang
d = (a: "hello", b: "robot", c: [1, 2, 3]);
d.keysDo { |key| postln("the key: " ++ key) };
#+END_SRC

::

method::associationsDo
Iterate over the associations, and evaluate the function for each.
code::
#+BEGIN_SRC sclang
d = (a: "hello", b: "robot", c: [1, 2, 3]);
d.associationsDo { |assoc| postln("the association: " ++ assoc) };
#+END_SRC

::

method::pairsDo
Iterate over the associations, and evaluate the function for each, passing key and value as argument. Identical to link::#-keysValuesDo::

method::invert
Return a new dictionary with all the values as keys and vice versa.
code::
#+BEGIN_SRC sclang
d = (a: "hello", b: "robot", c: [1, 2, 3]);
d.invert;
#+END_SRC

::

subsection::Other instance methods

method::order
Return an array of keys which corresponds to the order of the values of the dictionary.
code::
#+BEGIN_SRC sclang
d = (a: 5, b: 7, c: 1, d: 0);
d.order;
d.atAll(d.order);	// returns items in order
#+END_SRC

::

method::powerset
Return the set of all subsets: here an array of all sub-dictionaries.
code::
#+BEGIN_SRC sclang
d = (a: 5, b: 7, c: 1, d: 0);
d.powerset;
#+END_SRC

::

method::merge
Combine two dictionaries into a new one by applying a function to each value. If strong::fill:: is true (default: true), values missing from one of them are kept as they are.
code::
#+BEGIN_SRC sclang
d = (a: 5, b: 7, d: 0);
e = (a: 3, b: -3, c: 1);
merge(d, e, { |a, b| a + b });
merge(d, e, { |a, b| a + b }, false);
#+END_SRC

::
argument::that
another dictionary.
argument::func
a link::Classes/Function::.
argument::fill
a link::Classes/Boolean::.

method::blend
Blend two dictionaries into a new one by interpolating each value. If strong::fill:: is true (default: true), values missing from one of them are kept as they are.
code::
#+BEGIN_SRC sclang
d = (a: 5, b: 7, d: 0);
e = (a: 3, b: -3, c: 1);
blend(d, e, 0.3);
blend(d, e, 0.3, false);

d = (a: 500, b: 0.001);
e = (a: 300, b: 0.1);
blend(d, e, 0.3, specs: (a: \freq, b: \rq));
#+END_SRC

::
argument::that
another dictionary.
argument::blend
the blend ratio as a link::Classes/Float:: between 0.0 and 1.0.
argument::fill
a link::Classes/Boolean::.
argument::specs
a dictionary of link::Classes/Spec::s that are applied to each before blending.

method::asSortedArray
Return the values in a sorted array of key value pairs.
code::
#+BEGIN_SRC sclang
d = (a: 5, b: 7, c: 1, d: 0);
d.asSortedArray;
#+END_SRC

::

method::asKeyValuePairs
Return the values in an array of alternating key value pairs.
code::
#+BEGIN_SRC sclang
d = (a: 5, b: 7, c: 1, d: 0);
d.asKeyValuePairs;
#+END_SRC

::

method::embedInStream
If the event is not nil, yields a copy, with all the elements of the receiver. See also link::Classes/Event::.
code::
#+BEGIN_SRC sclang
// write a generator for dictionaries
(
d = (
	a: 5, b: 7, c: 1,
	rout: Routine { |inval|
		inf.do { |i|
			var event = d.copy.put(\count, i);
			inval = event.embedInStream(inval);
		}
	}
);
)

// draw new values
d.rout.((z:999));
d.rout.((z:1, a:0));
d.rout.(());

// sound example
// this also allows to use events or dictionaries in patterns directly:
(
d = (freq: 402, dur: 0.3);
	Pseq([
		d,
		(freq: 300, dur: 0.3),
		d,
		(freq: [400, 770, 800], dur: 1),
		d,
		(freq: 451, dur: 0.33)
	], inf).play;
);

d[\freq] = [900, 1002, 1102];
d[\freq] = [200, 101, 1102];
#+END_SRC

::

SECTION::Overview

subsection::The Difference between Dictionary, IdentityDictionary, Environment, and Event

Often, the subclass link::Classes/Event:: is used as an IdentityDictionary, because there is a syntactical shortcut:
code::
#+BEGIN_SRC sclang
a = (foo: 7);	// return a new Event.
a.put(\foo, 2.718);
a.at(\foo);
a[\foo] = 3.5;	// different syntax for put
#+END_SRC

::

Event, Environment and IdentityDictionary differ mainly insofar from Dictionary as the strong::keys:: are taken to be identical (===) objects (see IdentityDictionary), instead of equal (==) objects. By consequence, the subclasses are also faster for indexing. Apart from this, the subclasses add specific functionality only. Because of its very common usage, the examples often use the shortcut for the subclass Event.
code::
#+BEGIN_SRC sclang
// preliminary identity and equality of strings and symbols
"hello" == "hello";	// true, but
"hello" === "hello";	// false. However:
\hello === \hello;	// true

// compare
Dictionary["hello" -> 0, "hello" -> 1]; // Dictionary[ (hello -> 1) ]
("hello": 0, "hello": 1); // ( "hello": 1, "hello": 0 )

// for symbols as keys, the behaviour is identical:
Dictionary[\hello -> 1, \hello -> 0];
( \hello: 1, \hello: 0 );
#+END_SRC

::


** class:: DiskIn
summary:: Stream in audio from a file.
related:: Classes/PlayBuf, Classes/DiskOut
categories::  UGens>InOut, UGens>Buffer

Description::

Continously play a longer soundfile from disk. This requires a buffer to
be preloaded with one buffer size of sound.


classmethods::
private:: categories

method::ar

argument::numChannels
Number of channels. This must match the number of channels in the buffer.

argument::bufnum
Buffer number
Note:: The Buffer's numFrames must be a power of two and is recommended to be at least 65536 -- preferably 131072 or 262144. Smaller buffer sizes mean more frequent disk access, which can cause glitches. ::

argument:: loop
If set to 1, the soundfile will loop.

Note:: If the buffer has a larger number of frames than the sound file there will be a noticeable gap between the first and the following loop iterations. In that case chose a smaller buffer size or use link::Classes/PlayBuf##PlayBuf:: instead::

discussion::
This UGen will set the link::Classes/Done##'done' flag:: when finished playing.





instancemethods::
private:: init

Examples::

code::
#+BEGIN_SRC sclang
s.boot; // start the server

// examples below will use this synthdef
(
SynthDef("help-Diskin", { arg bufnum = 0;
	Out.ar(0, DiskIn.ar(1, bufnum));
}).send(s)
)
#+END_SRC

::

subsection:: Normal usage (with Buffer; "Object Style")
code::
#+BEGIN_SRC sclang
b = Buffer.cueSoundFile(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 1);

x = { DiskIn.ar(1, b.bufnum) }.play;

b.close;

// again
// note the like named instance method, but different arguments
b.cueSoundFile(Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0);

x.free; b.close; b.free;



// loop it (for better looping use PlayBuf!)
(
p = Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff";
a = SoundFile.new;
a.openRead(p);
d = a.numFrames/s.sampleRate; // get the duration
a.close; // don't forget
b = Buffer.cueSoundFile(s, p, 0, 1);
f = { DiskIn.ar(1, b.bufnum) };
x = f.play;
r = Routine({
	loop({ d.wait; x.free; x = f.play; b.close( b.cueSoundFileMsg(p, 0)) });
}).play; )
r.stop; x.free; b.close; b.free; // you need to do all these to properly cleanup



// cue and play right away
(
SynthDef("help-Diskin", { arg bufnum = 0;
	Out.ar(0, DiskIn.ar(1, bufnum));
}).send(s);
)
(
x = Synth.basicNew("help-Diskin");
m = { arg buf; x.addToHeadMsg(nil, [\bufnum,buf.bufnum])};

b = Buffer.cueSoundFile(s,Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff",0,1, completionMessage: m);

)
#+END_SRC

::

subsection:: OSC Messaging Style
code::
#+BEGIN_SRC sclang
// allocate a disk i/o buffer
s.sendMsg("/b_alloc", 0, 65536, 1);

// open an input file for this buffer, leave it open
s.sendMsg("/b_read", 0, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 65536, 0, 1);

// create a diskin node
s.sendMsg("/s_new", "help-Diskin", x = s.nextNodeID, 1, 1);

s.sendMsg("/b_close", 0); // close the file (very important!)


// again
// don't need to reallocate and Synth is still reading
s.sendMsg("/b_read", 0, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 0, 0, 1);

s.sendMsg("/n_free", x); // stop reading

s.sendMsg("/b_close", 0); // close the file.

s.sendMsg("/b_free", 0); // frees the buffer
#+END_SRC

::

** class:: DiskOut
summary:: Record to a soundfile to disk.
related:: Classes/RecordBuf, Classes/DiskIn
categories::  UGens>InOut, UGens>Buffer

Description::
Record to a soundfile to disk. Uses a link::Classes/Buffer::.

See link::Classes/RecordBuf:: for recording into a buffer in memory.

classmethods::
private:: categories

method::ar

argument::bufnum
The number of the buffer to write to (prepared with /b-write or
Buffer.write)
Note:: The Buffer's numFrames must be a power of two and is recommended to be at least 65536 -- preferably 131072 or 262144. Smaller buffer sizes mean more frequent disk access, which can cause glitches. ::

argument::channelsArray
The Array of channels to write to the file.
Note:: The number of channels in the buffer and the channelsArray must be the same, otherwise DiskOut will fail silently (and not write anything to your file). ::

returns:: The number of frames written to disk.

instancemethods::
private:: checkInputs

Examples::
code::
#+BEGIN_SRC sclang
s.boot; // start the server
(
// something to record
SynthDef("bubbles", {
	var f, zout;
	f = LFSaw.kr(0.4, 0, 24, LFSaw.kr([8,7.23], 0, 3, 80)).midicps; // glissando function
	zout = CombN.ar(SinOsc.ar(f, 0, 0.04), 0.2, 0.2, 4); // echoing sine wave
	Out.ar(0, zout);
}).send(s);

// this will record to the disk
SynthDef("help-Diskout", {arg bufnum;
	DiskOut.ar(bufnum, In.ar(0,2));
}).send(s);

// this will play it back
SynthDef("help-Diskin-2chan", { arg bufnum = 0;
	Out.ar(0, DiskIn.ar(2, bufnum));
}).send(s);
)
#+END_SRC

::

subsection:: Object Style
code::
#+BEGIN_SRC sclang
// start something to record
x = Synth.new("bubbles");

// allocate a disk i/o buffer
b= Buffer.alloc(s, 65536, 2);

// create an output file for this buffer, leave it open
b.write("~/diskouttest.aiff".standardizePath, "aiff", "int16", 0, 0, true);
// create the diskout node; making sure it comes after the source
d = Synth.tail(nil, "help-Diskout", ["bufnum", b]);
// stop recording
d.free;
// stop the bubbles
x.free;
// close the buffer and the soundfile
b.close;
// free the buffer
b.free;

// play it back
(
x = Synth.basicNew("help-Diskin-2chan");
m = { arg buf; x.addToHeadMsg(nil, [\bufnum,buf])};

b = Buffer.cueSoundFile(s,"~/diskouttest.aiff".standardizePath, 0, 2, completionMessage: m);
)
x.free; b.close; b.free; // cleanup
#+END_SRC

::

subsection:: Messaging Style
code::
#+BEGIN_SRC sclang
// The same thing done in Messaging Style (less overhead but without the convienence of objects)
// start something to record
s.sendMsg("/s_new", "bubbles", 2003, 1, 1);

// allocate a disk i/o buffer
s.sendMsg("/b_alloc", 0, 65536, 2); // Buffer number is 0

// create an output file for this buffer, leave it open
s.sendMsg("/b_write", 0, "~/diskouttest.aiff".standardizePath, "aiff", "int16", 0, 0, 1);

// create the diskout node
s.sendMsg("/s_new", "help-Diskout", 2004, 3, 2003, "bufnum", 0);

s.sendMsg("/n_free", 2004); // stop recording
s.sendMsg("/n_free", 2003); // stop the bubbles

s.sendMsg("/b_close", 0); // close the file.
s.sendMsg("/b_free", 0);
#+END_SRC

::

** class:: Diwhite
summary:: Demand rate white noise random generator.
related:: Classes/Dwhite, Classes/Demand, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::
link::Classes/Dwhite::  returns numbers in the continuous range between
code::lo::  and  code::hi:: .
#+BEGIN_SRC sclang
Diwhite returns integer values.


The arguments can be a number or any other UGen.


See link::Classes/Pwhite::,  link::Classes/WhiteNoise::  for structurally related
equivalents.


classmethods::

method::new

argument::lo

Minimum value.


argument::hi

Maximum value.


argument::length

Number of values to create.


Examples::

code::

(
{
	var a, freq, trig;
	a = Diwhite(0, 15, inf);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** class:: Document
redirect:: implementationClass
summary:: An abstract class for editor-specific text document editing classes
categories:: Frontends
related:: Classes/CocoaDocument, Classes/EmacsDocument, Classes/ScelDocument

description::
The Document class represents a text document within the context of your text editing environment. You can use the class to programmatically create, modify, and query these documents. While it is an abstract class, you still use it to create a code::new:: Document. It simply passes on code::new:: to the appropriate document implementation, e.g. link::Classes/CocoaDocument::.

subsection:: Some Important Issues Regarding Document

Different text-editing environments can be used with SuperCollider. Therefore Document is an abstract class, meaning it doesn't provide all the functionality itself, but relies on subclasses to complete the functionality. Calls to code::Document.new:: or code::Document.open:: are actually passed down to the relevant class for the editor you're using, such as link::Classes/CocoaDocument:: (for most Mac users) or link::Classes/ScelDocument:: (containing an link::Classes/EmacsDocument::).

subsection:: Setting the Environment

By default code::envir:: it is set to the current link::Classes/Environment::. However, you can make it use its own link::Classes/Environment:: also. Thus, e.g., if you were to set the link::Classes/Environment:: variable code::~myVar = 12:: in the current link::Classes/Environment::, you can create a new Document window in which that link::Classes/Environment:: variable is not set.




classmethods::

private:: prGetLast, prSetSyntaxColorTheme, prnumberOfOpen, prBasicNew, prGetIndexOfListener, prDefaultUsesAutoInOutdent, initClass

method:: new
argument:: title
An instance of link::Classes/String:: or link::Classes/Symbol::.
argument:: string
An instance of link::Classes/String::. The contents of the document.
argument:: makeListener
Makes this document the listener, i.e. the place where SC-lang posts messages.
argument:: envir
An instance of link::Classes/Environment::. The link::Classes/Environment:: to be used by the interpreter of the document window. By defualt, it is set to the current link::Classes/Environment::.
discussion::
code::
#+BEGIN_SRC sclang
Document.new("this is the title", "this is the text");
#+END_SRC

::

method:: open
Open a document from a path.
argument:: path
The file system path to the document. An instance of link::Classes/String::.
argument:: selectionStart
The beginning of the cursor selection of the file content.
argument:: selectionLength
The length of the cursor selection of the file content.
argument:: envir
An instance of link::Classes/Environment::. The Environment to be used by the interpreter of the document window. By defualt, it is set to the current link::Classes/Environment::.
discussion::
code::
#+BEGIN_SRC sclang
Document.open("README", 292,253); // notice the selected text in the open document
#+END_SRC

::

method:: openDocuments
Returns an Array of all open documents.
code::
#+BEGIN_SRC sclang
d = Document.openDocuments.do{ |doc| doc.name.postln };
#+END_SRC

::

method:: hasEditedDocuments
Returns true if there are edited Documents.

method:: closeAll
warning::
Closes all open Documents, whether edited or not.
::
argument:: leavePostWindowOpen
An instance of link::Classes/Boolean::.

method:: closeAllUnedited
Closes all unedited Documents.
argument:: leavePostWindowOpen
An instance of link::Classes/Boolean::.

method:: current
Gets/sets the current Document.
argument:: value
A Document.
discussion::
code::
#+BEGIN_SRC sclang
Document.current.name.postln; // Prints "Document.html"
#+END_SRC

::

method:: listener
Returns the current Document which is the listener, i.e. the Document where interpreter messages are posted.

method:: allDocuments
Returns all documents.

method:: globalKeyDownAction
Get/set A global action to be performed when a key is pressed.
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: globalKeyUpAction
Get/set A global action to be performed when a key is released.
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: initAction
Get/set A an action to be performed up opening or creating a Document.
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: autoRun
If a document begins with the link::Classes/String::, code::"/*RUN*/"::, then the code following it int he file will be exectued on opening the file, if autorun is set to true.
argument:: value
An instance of link::Classes/Boolean::. Default value is code::true::.

method:: implementationClass
The editor implementation specific class which will handle Documents.
argument:: value
A class for implementing Document, e.g. link::Classes/CocoaDocument::.

subsection:: Path Utilities

Utilities and settings for dealing with documents such as super collider code files. By default the document directory is SuperCollider's application directory.

method:: dir
Get/set the default document directory. The default is dependent on link::Classes/Document#implementationClass::.
argument:: path
The file system path to the directory. An instance of link::Classes/String::.
discussion::
In Main-startUp you can set this to a more practical directory:
code::
#+BEGIN_SRC sclang
Document.dir = "~/Documents/SuperCollider";
#+END_SRC

::

method:: standardizePath
argument:: p
The file system path to the directory. An instance of link::Classes/String::.
discussion::
If it is a relative path, expand it to an absolute path relative to your document directory. Expand tildes in path (your home directory), resolve symbolic links (but not aliases). Also converts from OS9 macintosh path format. See PathName for more complex needs.
code::
#+BEGIN_SRC sclang
Document.standardizePath("~/"); // This will print your home directory

Document.standardizePath(":Patches:newfoots:fastRuckAndTuck");
// Returns: /Volumes/Macintosh HD/Users/cruxxial/Documents/SC3docs/Patches/newfoots/fastRuckAndTuck

Document.standardizePath("~/Documents/SC3docs/Patches/newfoots/fastRuckAndTuck");
// Returns: Patches/newfoots/fastRuckAndTuck

Document.standardizePath("Patches/newfoots/fastRuckAndTuck")
// Returns: Patches/newfoots/fastRuckAndTuck
#+END_SRC

::

method:: abrevPath
Returns a path relative to Document.dir, if the path is inside Document.dir.
argument:: path
The file system path to the directory. An instance of link::Classes/String::.




instancemethods::

private:: prGetBackgroundColor, prGetBounds, prIsEditable, propen, prGetTitle, prinitByString, prGetLastIndex, prSetBackgroundColor, prSetFileName, prUsesAutoInOutdent, prclose, prGetSelectedBackgroundColor, prGetFileName, prSetSelectedBackgroundColor, prSelectLine, prinitByIndex, prAdd, prSetBounds, prinsertText, prSetTitle, initFromPath, initByString

subsection:: General Document Properties

method:: bounds
Get/set the bounds of the document.
argument:: argBounds
An instance of link::Classes/Rect::.

method:: path
Get / set the the Document's path.
argument:: apath
An instance of link::Classes/String::. A files system path.
discussion::
code::
#+BEGIN_SRC sclang
Document.current.path.postln;
#+END_SRC

::

method:: dir
Returns the directory of a Document.
discussion::
code::
#+BEGIN_SRC sclang
Document.current.dir.postln;
#+END_SRC

::

method:: ==
A binary operator.
argument:: doc
An instance of Document.
discussion::
code::
#+BEGIN_SRC sclang
Document.current == Document.listener; // presumaably returns false
#+END_SRC

::

method:: editable
Get / set the the document is editable.
argument:: abool
An instance of link::Classes/Boolean::.

method:: name
Get / set the title (same as link::Classes/Document#title::).
argument:: aname
An instance of link::Classes/String::.
discussion::
code::
#+BEGIN_SRC sclang
Document.current.name.postln;
#+END_SRC

::

method:: title
Get / set the title (same as link::Classes/Document#name::).
argument:: argName
An instance of link::Classes/String::.

method:: alwaysOnTop
Get/set whether a document is always on top.
argument:: boolean
An instance of link::Classes/Boolean::.

method:: promptToSave
Get/set whether a document is prompts to save if it has been changed. Use this with caution.
argument:: bool
An instance of link::Classes/Boolean::.

method:: closed
Returns code::true:: if the document has been closed.

method:: isEdited
Returns code::true:: if the document has been edited.
code::
#+BEGIN_SRC sclang
Document.current.isEdited.postln;
#+END_SRC

::

method:: isFront
Returns code::true:: if the document is in front.

method:: isListener
Returns if the document is the listener.

method:: didBecomeKey
Saves the current link::Classes/Environment::, makes the document current, and performs its link::Classes/Document#toFrontAction::.

method:: didResignKey
Performs the Document's link::Classes/Document#endFrontAction:: and restores the current link::Classes/Environment::.



subsection:: Controlling Document

method:: close
Close a document.
code::
#+BEGIN_SRC sclang
(
Task({
	var doc;
	doc = Document("background", "closing in 2 seconds");
	doc.stringColor_(Color.blue);
	1.wait;
	doc.background_(Color.blue(alpha:0.8));
	1.wait;
	doc.close;
}).play(AppClock);
)
#+END_SRC

::

method:: front
Bring a document to the front.
code::
#+BEGIN_SRC sclang
Document.listener.front;
#+END_SRC

::

method:: unfocusedFront
Bring a document to the front without focusing it.
code::
#+BEGIN_SRC sclang
Document.listener.unfocusedFront;
#+END_SRC

::

method:: onClose
Get/set the action to be performed on closing the document.
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: endFrontAction
Get/set the action to be performed when the document becomes no longer the front document.
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: toFrontAction
Get / set the action to be performed when the document become the front document.
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: mouseDownAction
Get/set the action to be performed on link::Classes/Document#mouseDown::.
note::
The Mac OSX built-in editor does not supports this feature. A mouseDownAction that you supply will be ignored.
::
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::. The arguments passed to the function are: code::x::, code::y::, code::modifiers::, code::buttonNumber::, code::clickCount::, code::clickPos::.


method:: mouseUpAction
Get/set the action to be performed on link::Classes/Document#mouseUp::.
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::. The arguments passed to the function are: code::x::, code::y::, code::modifiers::, code::buttonNumber::, code::clickCount::, code::clickPos::.
discussion::
code::
#+BEGIN_SRC sclang
(

//add a mouse action to this document:
//example: easy button:
//when you click in front of a 17 a SinOsc will start up;
s.waitForBoot({
	Document.current.mouseUpAction_({arg doc;
		var char;
		char = doc.rangeText(doc.selectionStart, 2);
		if(char == "17",{
			{EnvGen.kr(Env.perc, doneAction:2) * SinOsc.ar([600,720,300].choose, 0, 0.5)}.play;
		});
		if(char == "23",{
			{EnvGen.kr(Env.perc, doneAction:2) * PinkNoise.ar(0.2)}.play;
		});
	})
});
)
#+END_SRC

::
Test here and click in front of the numbers: 17 and 23.
code::
#+BEGIN_SRC sclang
Document.current.mouseUpAction = nil; // clear mouseUpActiont
#+END_SRC

::


method:: keyDownAction
Get/set the action to be performed on link::Classes/Document#keyDown::.
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::. The arguments passed to the function are: code::char::, code::modifiers::, code::unicode::, code::keycode::.
discussion::
code::
#+BEGIN_SRC sclang
Document.current.keyDownAction = { arg ...args; args.postln };
// now type some text
Document.current.keyDownAction = nil;
#+END_SRC

::

method:: keyUpAction
Get/set the action to be performed on link::Classes/Document#keyUp::.
argument:: value
An instance of link::Classes/Function:: or link::Classes/FunctionList::. The arguments passed to the function are: code::char::, code::modifiers::, code::unicode::, code::keycode::.
code::
#+BEGIN_SRC sclang
Document.current.keyUpAction = { arg ...args; args.postln };
// now type some text
Document.current.keyUpAction = nil;
#+END_SRC

::

subsection:: Editing Content

method:: selectLine
Select a line of the document by number.
argument:: line
An link::Classes/Integer::.
discussion::
code::
#+BEGIN_SRC sclang
Document.current.selectLine(390);
#+END_SRC

::

method:: selectRange
Select a text range in the string of the document.
argument:: start
The start index.
argument:: length
The length of the selection.
discussion::
code::
#+BEGIN_SRC sclang
(
Document.current.selectRange(Document.current.selectedRangeLocation + 3, 150);
)
#+END_SRC

::

method:: selectionStart
Returns the start of a current selection.
code::
#+BEGIN_SRC sclang
Document.current.selectionStart.postln;
#+END_SRC

::

method:: selectionSize
Returns the size of a current selection.
code::
#+BEGIN_SRC sclang
(
var doc;
doc = Document.current;
doc.selectRange(doc.selectionStart - 40, 10);
doc.selectionSize.postln;
)
#+END_SRC

::


method:: selectedString
Gets/sets the selected string.
argument:: txt
An instance of link::Classes/String::.
discussion::
code::
#+BEGIN_SRC sclang
(
var doc;
doc = Document.current;
doc.selectRange(doc.selectionStart - 40, 10);
doc.selectedString.postln;
)
#+END_SRC

::

method:: currentLine
Returns the current line as a link::Classes/String::.
code::
#+BEGIN_SRC sclang
(
var doc;
doc = Document.current;
doc.selectRange(doc.selectionStart - 40, 10);
doc.currentLine.postln;
)
#+END_SRC

::

method:: getSelectedLines
Returns all full lines from before code::rangestart:: to after code::rangestart + rangesize:: as a link::Classes/String::.
discussion::
code::
#+BEGIN_SRC sclang
(
var doc;
doc = Document.current;
doc.selectRange(doc.selectionStart - 40, 10);
doc.getSelectedLines(doc.selectionStart - 40, 130).postln;
)
#+END_SRC

::


method:: string
Gets or sets the string within a certain range.
argument:: string
A link::Classes/String::.
argument:: rangestart
An link::Classes/Integer::.
argument:: rangesize
An link::Classes/Integer::.
discussion::
code::
#+BEGIN_SRC sclang
// Select the following code in parentheses and execute it
(
Document.current.string_(": test test test test test ",
	Document.current.selectedRangeLocation + 12,
	18);
)
// Watch me change content
#+END_SRC

::

method:: font
Gets or sets the font within a certain range.
argument:: font
An instance of link::Classes/Font::.
argument:: rangestart
An link::Classes/Integer::. Default value is -1. If code::rangestart = -1::, the whole document is selected.
argument:: rangesize
An link::Classes/Integer::. Default value is 0.
discussion::
code::
#+BEGIN_SRC sclang
// Select the following code in parentheses and execute it
(
Document.current.font_(Font("Impact", 14),
	Document.current.selectedRangeLocation + 12,
	18);
)
// Watch me change font
#+END_SRC

::

method:: underlineSelection
Underlines the current selection of a Document.


subsection:: Auto-Completion

note::
OSX version only, currently. See link::Reference/DocumentAutoCompletion::.
::
code::
#+BEGIN_SRC sclang
	*allowAutoComp
	*autoCompAll
	*autoComplete
	*autoCompleteKeyAction
	*openFileAutoComplete (path)
	*openAutoComplete
	autoComplete
#+END_SRC

::

subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.
code::
#+BEGIN_SRC sclang
	*startup
	*numberOfOpen
	mouseUp (x, y, modifiers, buttonNumber, clickCount, clickPos)
	keyDown (character, modifiers, unicode, keycode)
	keyUp (character, modifiers, unicode, keycode)
	getIdentifierCoordFromEnd (endPos)
	dataptr

	Private. Used only internally:
	*newFromIndex (idx)
	*prnumberOfOpen
	*prGetLast
	*prGetIndexOfListener
	*prBasicNew
	prAdd
	prGetLastIndex
	setFont (font, rangeStart, rangeSize)
	setTextColor (color, rangeStart, rangeSize)
	propen (path, selectionStart, selectionLength)
	rangeText (rangestart, rangesize)
	insertTextRange (string, rangestart, rangesize)
	prinitByString (title, str, makeListener)
	prSetBackgroundColor (color)
	prGetBackgroundColor (color)
	prSelectLine (line)
	prIsEditable_ (editable)
	prSetTitle (argName)
	prGetTitle
	prGetFileName
	prSetFileName (apath)
	prGetBounds (argBounds)
	prSetBounds (argBounds)
	prclose
	prinsertText (dataPtr, txt)
	prinitByIndex (idx)
	envir
	envir_ (ev)
	text
	removeUndo
	selectedText
	selectUnderlinedText (clickPos)
	linkAtClickPos (clickPos)
	selectedRangeLocation
	selectedRangeSize
	restoreCurrentEnvironment
	saveCurrentEnvironment
	initByIndex (idx)
	initLast
	initFromPath (path, selectionStart, selectionLength)
	initByString (argTitle, str, makeListener)
#+END_SRC

::





examples::

code::
#+BEGIN_SRC sclang
//unfocusedFront_
(
Document.allDocuments.at(0).unfocusedFront
)


(
var doc;
doc = Document("", "||");
doc.background_(Color.blue(alpha: 1.0.rand));

Task({
	1000.do({
		doc.setFont(rangeSize: [7, 8, 9, 24].choose);
		0.08.wait;
	})
}).play(AppClock);

Task({
	100.do({
		1.01.wait;
		doc.stringColor_([Color.red(alpha: 1.0.rand), Color.green(alpha: 1.0.rand)].choose);
	})
}).play(AppClock);

Task({
	100.do({
		1.01.wait;
		doc.selectedString_(["\"\n#", "||", "-", "--"].choose);
	})
}).play(AppClock);

Task({
	var co, mul;
	co = 0.1;
	mul = 1.02;
	100.do({
		0.16.wait;
		co = co * mul;
		if(co > 0.99, { co = 0.1 });
		doc.background_(Color.blue(alpha: co));
	});
	doc.close;
}).play(AppClock)
)
#+END_SRC

::

A simple implementation of TBT (time based text) http://tbt.dyne.org/?info=download
code::
#+BEGIN_SRC sclang
// record: type some text
(
var time = Main.elapsedTime;
a = List.new;
r = Routine { |char|
loop {
	a = a.add([char, Main.elapsedTime - time]);
	char = 0.yield;
}
};

Document.new("type some text")
	.bounds_(Rect(100,SCWindow.screenBounds.height - 250, 400, 200))
	.keyDownAction = { |doc, key| r.value(key) ; time = Main.elapsedTime};
)

// play back text in time
(
d = Document.new("type some text")
	.bounds_(Rect(550,SCWindow.screenBounds.height-250,400,200));
fork({
	a.do { |pair|
		d.string = d.string ++ pair[0];
		pair[1].wait;
	}
}, AppClock)
)
#+END_SRC

::

Changing the default look of documents can be done with the help of the link::#*initAction:: method. Run the following example once. Afterwards all newly created documents will have a dark grey background. To make this change happen every time you start supercollider, put the code inside your startup.scd file (and optionally wrap it in a code::{}.defer(0.1):: ).
code::
#+BEGIN_SRC sclang
(
Document.listener.background = Color.red;	//a special color for post document
Document.listener.bounds = Rect(1, 461, 620, 567);	//move and resize post document
Document.initAction = {|doc|			//function to run for every new document
	doc.background = Color.grey(0.1, 0.9);
	doc.bounds = Rect(0, 119, 1280, 659);
	doc.selectedBackground = Color(0.4, 0.05, 0.18);
	doc.stringColor = Color.grey(0.9);
};
)
#+END_SRC

::
** class:: Done
summary:: Monitors another UGen to see when it is finished
related:: Classes/FreeSelfWhenDone, Classes/PauseSelfWhenDone, Reference/UGen-doneActions
categories::  UGens>Synth control

Description::

Some UGens set a 'done' flag when they are finished playing. This UGen echoes that flag when it is set to track a particular UGen.

The UGens trackable by Done are:
list::
## link::Classes/PlayBuf::
## link::Classes/RecordBuf::
## link::Classes/Line::
## link::Classes/XLine::
## link::Classes/EnvGen::
## link::Classes/Linen::
## link::Classes/BufRd::
## link::Classes/BufWr::
## link::Classes/Dbufrd::
## link::Classes/Dbufwr::
## link::Classes/DiskIn::
## link::Classes/VDiskIn::
## link::Classes/Demand::
::

classmethods::
private:: categories

method::kr

argument::src

UGen to monitor

examples::
The 'done' flag can be used to trigger other things in the same synth:
code::
#+BEGIN_SRC sclang
(
SynthDef("Done-help", { arg out, t_trig;
	var line, a, b;

	line= Line.kr(1,0,1);

	a= SinOsc.ar(440,0,0.1*line); //sound fading out
	b= WhiteNoise.ar(Done.kr(line)*0.1); //noise starts at end of line

	Out.ar(out, Pan2.ar(a+b));
}).send(s);
)

Synth("Done-help"); //note that this synth doesn't have it's own doneAction, so you'll need to manually deallocate it
#+END_SRC

::
The 'done' flag can be used to trigger a delayed freeing of the current synth, which is not possible by using link::Reference/UGen-doneActions:: :
code::
#+BEGIN_SRC sclang
play {
    var env = Line.kr(1,0,2);
    var sig = PinkNoise.ar(env);
    FreeSelf.kr(TDelay.kr(Done.kr(env),3));
    GVerb.ar(sig,70,7);
}
#+END_SRC

::
** CLASS::DoubleArray
summary::an array whose indexed slots are all of the same type
related::Classes/Int8Array, Classes/Int16Array, Classes/Int32Array, Classes/FloatArray, Classes/SymbolArray
categories::Collections>Ordered

DESCRIPTION::
These classes implement arrays whose indexed slots are all of the same type.
list::
## Int8Array - 8 bit integer
## Int16Array - 16 bit integer
## Int32Array - 32 bit integer
## FloatArray - 32 bit floating point
## DoubleArray - 64 bit floating point
## SymbolArray - symbols
::

INSTANCEMETHODS::

method::readFromStream
** class:: Dpoll
summary:: Print the current output value of a demand rate UGen
categories:: UGens>Demand, UGens>Info

description::
Print the current output value of a demand rate UGen.
WARNING:: Printing values from the Server in intensive for the CPU. Poll should be used for debugging purposes. ::

classmethods::
private:: new1

method:: new
argument:: in
ugen to poll vaues from
argument:: label
a label string
argument:: run
active if 1, inactive if 0. can be a demand ugen (default: 1)
argument:: trigid
discussion::
the print-out is in the form: code:: label: value block offset: offset. ::

structurally related: link::Classes/Poll::

examples::
code::
#+BEGIN_SRC sclang

{ Duty.kr(0.5, 0, Dpoll(Dseries(0, 1, inf) * 2)); 0.0 }.play;

// posts only when cursor is in right half of the screen
{ Duty.kr(0.5, 0, Dpoll(Dseries(0, 1, inf) * 2, run: MouseX.kr > 0.5)); 0.0 }.play;

// label
{ LFPulse.ar(Duty.kr(0.5, 0, Dpoll(Dseries(0, 1, inf) % 10 + 1 * 30, "value"))) * 0.1 }.play;

// block offset:
{ Duty.ar(0.511, 0, Dpoll(Dseries(0, 1, inf) * 2)); 0.0 }.play;

// multichannel expansion:

(
	{
	var x = Duty.kr(0.5, 0,
		Dpoll([Dseries(0, 1, inf), Dgeom(1, 1.1, inf)], ["first", "second"])
	);
	LFPulse.ar(100 + (x * 100)) * 0.1
	}.play
)

{ Duty.kr(0.5, 0, Dpoll(( Dseries(0, 1, inf) + _ ).dup, ("value" + _).dup)); 0.0 }.play;


// the message dpoll(label, run, trigid) is a shorthand:

{ Duty.kr(0.5, 0, Dseries(0, 1, inf).dpoll); 0.0 }.play;
{ Duty.ar(0.5, 0, SinOsc.ar(0.1).dpoll); 0.0 }.play;
#+END_SRC

::

** class:: DragBoth
redirect:: implClass
summary:: A simple drag-and-drop source and receiver
categories:: GUI>Views
related:: Classes/DragSink, Classes/DragSource

DESCRIPTION::

link::Classes/DragSource::, link::Classes/DragSink:: and link::Classes/DragBoth:: are a set of view classes intended as simple-to-use drag-and-drop sources and destinations. They are graphically represented as a simple rectangle, and their specialty is that they emphasis::do not require the Cmd/Ctrl key to be held down to initiate dragging::.

Akin to link::Classes/StaticText:: they can store arbitrary content in the link::Classes/StaticText#-object#-object:: variable, and display it using link::Classes/Object#-asString::. You can set the displayed text separately using link::Classes/StaticText#-string#-string::, and keep it independent of the content if you set link::Classes/StaticText#-setBoth#-setBoth:: to code::false::.

strong::DragBoth::, specifically, strong::accepts any:: dropped data and stores it into the strong::-object:: variable, as well as gives that variable as data strong::for dragging::.

See: link::Classes/View#Drag and drop:: for a general description of the drag and drop mechanism.



CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::

METHOD:: defaultGetDrag
	RETURNS:: The link::Classes/StaticText#-object#-object::.

METHOD:: defaultCanReceiveDrag
	RETURNS:: Allways True.

METHOD:: defaultReceiveDrag
	Sets the link::Classes/StaticText#-object#-object:: to the current drag data.



EXAMPLES::
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
w.addFlowLayout;
// store various kinds of objects in the drag source

// a string source
a = DragBoth(w, Rect(10, 10, 150, 20)).align_(\center).background_(Color.rand);
a.object = "drag us around";

a = DragBoth(w, Rect(10, 10, 150, 20)).align_(\center).background_(Color.rand);
a.object="SUPERCOLLIDER";

8.do{
a = DragBoth(w, Rect(10, 10, 150, 20)).align_(\center).background_(Color.rand);
a.receiveDragHandler = { arg obj; obj.object = View.currentDrag.scramble };
}
)
#+END_SRC

::
** class:: DragSink
redirect:: implClass
summary:: A simple drag-and-drop receiver.
categories:: GUI>Views
related:: Classes/DragBoth, Classes/DragSource

DESCRIPTION::

link::Classes/DragSource::, link::Classes/DragSink:: and link::Classes/DragBoth:: are a set of view classes intended as simple-to-use drag-and-drop sources and destinations. They are graphically represented as a simple rectangle, and their specialty is that they emphasis::do not require the Cmd/Ctrl key to be held down to initiate dragging::.

Akin to link::Classes/StaticText:: they can store arbitrary content in the link::Classes/StaticText#-object#-object:: variable, and display it using link::Classes/Object#-asString::. You can set the displayed text separately using link::Classes/StaticText#-string#-string::, and keep it independent of the content if you set link::Classes/StaticText#-setBoth#-setBoth:: to code::false::.

strong::DragSink::, specifically, strong::accepts any:: dropped data and stores it into the strong::-object:: variable, but allows strong::no dragging::.

See: link::Classes/View#Drag and drop:: for a general description of the drag and drop mechanism.




CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::

METHOD:: defaultCanReceiveDrag
	RETURNS:: Allways True.

METHOD:: defaultReceiveDrag
	Sets the link::Classes/StaticText#-object#-object:: to the current drag data.



EXAMPLES::
code::
#+BEGIN_SRC sclang
(
s.waitForBoot({	// only needed if you are using sound
	w = Window.new.front;

	// store various kinds of objects in the drag source

	// a string source
	a = DragSource(w, Rect(10, 10, 150, 20)).align_(\center);
	a.object = "I am a string source";

	// a Float source
	b = DragSource(w, Rect(10, 40, 150, 20)).align_(\center);
	b.object = 2.234;

	// a Point source
	c = DragSource(w, Rect(10, 70, 150, 20)).align_(\center);
	c.object = Point(20, 30);

	// A sound function source
	// dragLabel_() is used for the label while dragging
	d = DragSource(w, Rect(10, 100, 150, 20)).align_(\center);
	d.object = { Synth(\default) };
	d.dragLabel = " I am a sound function.\n My dragLabel_() is set \n to inform you about that ";

	// A sound function source
	// here the string label is independent of the content type (Function)
	// dragLabel_() is used for the label while dragging
	f = DragSource(w, Rect(10, 130, 150, 20)).align_(\center).setBoth_(false);
	f.object = { { SinOsc.ar(440,0,0.4) }.play };
	f.string = "My label is independent";
	f.dragLabel = " My dragLabel_() says \n I am dragging a sound function ";

	// receive anthing
	g = DragSink(w, Rect(170, 10, 200, 20)).align_(\center);
	g.string = "recieve anything, do nothing";

	// receive only floats
	g = DragSink(w, Rect(170, 40, 200, 20)).align_(\center);
	g.string = "I only like floats";
	g.canReceiveDragHandler = { View.currentDrag.isFloat };

	// receive only numbers and points, and convert them to rects
	h = DragSink(w, Rect(170, 70, 200, 20)).align_(\center);
	h.string = "I convert to Rect";
	h.canReceiveDragHandler = { View.currentDrag.isKindOf(Number) || View.currentDrag.isKindOf(Point) };
	h.receiveDragHandler = { arg v; h.object = View.currentDrag.asRect };

	// receive only functions, and try to play them
	i = DragSink(w, Rect(170, 100, 200, 20)).align_(\center);
	i.string = "I evaluate a (sound) function";
	i.canReceiveDragHandler = { View.currentDrag.isKindOf(Function) };
	i.receiveDragHandler = { arg v;
		i.object = View.currentDrag.value;
		i.string = "click here for silence";
		i.background_(Color.red) };
	i.mouseDownAction_({
		i.object.free;
		i.string = "I evaluate a (sound) function";
		i.background_(Color.clear) });

	StaticText(w, Rect(10, 200, 380, 50))
		.stringColor_(Color.white)
		.string_("Try dragging any item on the left -----> to any item on the right");
});
)
#+END_SRC

::
** class:: DragSource
redirect:: implClass
summary:: A simple drag-and-drop source.
categories:: GUI>Views
related:: Classes/DragSink, Classes/DragBoth

DESCRIPTION::

link::Classes/DragSource::, link::Classes/DragSink:: and link::Classes/DragBoth:: are a set of view classes intended as simple-to-use drag-and-drop sources and destinations. They are graphically represented as a simple rectangle, and their specialty is that they emphasis::do not require the Cmd/Ctrl key to be held down to initiate dragging::.

Akin to link::Classes/StaticText:: they can store arbitrary content in the link::Classes/StaticText#-object#-object:: variable, and display it using link::Classes/Object#-asString::. You can set the displayed text separately using link::Classes/StaticText#-string#-string::, and keep it independent of the content if you set link::Classes/StaticText#-setBoth#-setBoth:: to code::false::.

strong::DragSource::, specifically, gives the strong::-object:: variable as the data strong::for dragging::, but strong::accepts no drop::.

See: link::Classes/View#Drag and drop:: for a general description of the drag and drop mechanism.




CLASSMETHODS::

PRIVATE:: key




INSTANCEMETHODS::

METHOD:: defaultGetDrag
	RETURNS:: The link::Classes/StaticText#-object#-object::.




EXAMPLES::
code::
#+BEGIN_SRC sclang
(
s.waitForBoot({	// only needed if you are using sound
	w = Window.new.front;

	// store various kinds of objects in the drag source

	// a string source
	a = DragSource(w, Rect(10, 10, 150, 20)).align_(\center);
	a.object = "I am a string source";

	// a Float source
	b = DragSource(w, Rect(10, 40, 150, 20)).align_(\center);
	b.object = 2.234;

	// a Point source
	c = DragSource(w, Rect(10, 70, 150, 20)).align_(\center);
	c.object = Point(20, 30);

	// A sound function source
	// dragLabel_() is used for the label while dragging
	d = DragSource(w, Rect(10, 100, 150, 20)).align_(\center);
	d.object = { Synth(\default) };
	d.dragLabel = " I am a sound function.\n My dragLabel_() is set \n to inform you about that ";

	// A sound function source
	// here the string label is independent of the content type (Function)
	// dragLabel_() is used for the label while dragging
	f = DragSource(w, Rect(10, 130, 150, 20)).align_(\center).setBoth_(false);
	f.object = { { SinOsc.ar(440,0,0.4) }.play };
	f.string = "My label is independent";
	f.dragLabel = " My dragLabel_() says \n I am dragging a sound function ";

	// receive anthing
	g = DragSink(w, Rect(170, 10, 200, 20)).align_(\center);
	g.string = "recieve anything, do nothing";

	// receive only floats
	g = DragSink(w, Rect(170, 40, 200, 20)).align_(\center);
	g.string = "I only like floats";
	g.canReceiveDragHandler = { View.currentDrag.isFloat };

	// receive only numbers and points, and convert them to rects
	h = DragSink(w, Rect(170, 70, 200, 20)).align_(\center);
	h.string = "I convert to Rect";
	h.canReceiveDragHandler = { View.currentDrag.isKindOf(Number) || View.currentDrag.isKindOf(Point) };
	h.receiveDragHandler = { arg v; h.object = View.currentDrag.asRect };

	// receive only functions, and try to play them
	i = DragSink(w, Rect(170, 100, 200, 20)).align_(\center);
	i.string = "I evaluate a (sound) function";
	i.canReceiveDragHandler = { View.currentDrag.isKindOf(Function) };
	i.receiveDragHandler = { arg v;
		i.object = View.currentDrag.value;
		i.string = "click here for silence";
		i.background_(Color.red)};
	i.mouseDownAction_({
		i.object.free;
		i.string = "I evaluate a (sound) function";
		i.background_(Color.clear) });

	StaticText(w, Rect(10, 200, 380, 50))
		.stringColor_(Color.white)
		.string_("Try dragging any item on the left -----> to any item on the right");
});
)
#+END_SRC

::
** class:: Drand
summary:: Demand rate random sequence generator.
related:: Classes/Demand, Classes/Dseq, Classes/Dser, Classes/Duty, Classes/Dxrand, Classes/TDuty
categories:: UGens>Demand

Description::
link::Classes/Dxrand::  never plays the same value twice, whereas Drand
chooses any value in the list.


See link::Classes/Prand:: for structurally related equivalent.


classmethods::

method::new

argument::list

An array of values or other UGens.


argument::repeats

Number of values to return.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	var a, freq, trig;
	a = Drand([1, 3, 2, 7, 8], inf);
	trig = Impulse.kr(MouseX.kr(1, 400, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** CLASS:: DrawGrid
summary:: Draws grid lines on a UserView for plotting
categories:: GUI>Accessories
related:: Reference/plot, Classes/GridLines, Classes/Plotter, Classes/UserView

DESCRIPTION::
DrawGrid is used by Plotter to draw the grid lines on a graph.  It can however also be used to draw GridLines on any UserView and could even be used to add grid lines to UserViews behind sliders or in any GUI.

Note that DrawGrid does not hold any reference to the UserView but is meant to have its .draw method called inside of the UserView's drawFunc.  It only needs to know what bounds the grid lines should be drawn within and what the horizontal and vertical GridLines are.


CLASSMETHODS::

METHOD:: new

argument:: bounds
the bounds to draw within.  Multiple DrawGrid may be used to draw grids on a single UserView.

argument:: horzGrid
a GridLines or BlankGridLines or GridLines subclass

argument:: vertGrid
a GridLines or BlankGridLines or GridLines subclass

returns:: a DrawGrid

METHOD:: test
For testing new GridLines objects.
code::
#+BEGIN_SRC sclang
DrawGrid.test( \freq.asSpec.grid, \amp.asSpec.grid );
DrawGrid.test( nil, \degree.asSpec.grid );
#+END_SRC

::

argument:: horzGrid
a GridLines object or subclass

argument:: vertGrid
a GridLines object or subclass

argument:: bounds
default: 500 @ 400

returns:: a DrawGrid


INSTANCEMETHODS::

METHOD:: draw
This draws to the currently active UserView. This method is meant to be called from inside the drawFunc of a UserView.

returns:: nil


METHOD:: horzGrid
set the x gridLines

argument:: g
a GridLines

returns:: self


METHOD:: vertGrid
set the y gridLines

argument:: g
a GridLines

returns:: self


METHOD:: bounds
get or set bounds

argument:: b
a Rect

returns:: a Rect


METHOD:: font
get or set Font

argument:: f
a Font

returns:: a Font

METHOD:: fontColor
get or set font color

argument:: c
a Color

returns:: a Color

METHOD:: gridColors
Set the colors of each of the axis.

argument:: colors
an array of two colors: x,y

returns:: self

METHOD:: opacity
get or set opacity

returns:: float

METHOD:: smoothing
see Pen smoothing

returns:: smoothing

METHOD:: linePattern
see Pen linePattern

returns:: (returnvalue)

METHOD:: init
private

argument:: bounds
argument:: h
argument:: v
returns:: (returnvalue)

METHOD:: x
private
A DrawGridX object that draws the x (horizontal) axis

returns:: a DrawGridX

METHOD:: y
private
A DrawGridY object that draws the y (vertical) axis

returns:: a DrawGridY




METHOD:: copy
safely make a copy of this object and its working members.

returns:: a new DrawGrid

METHOD:: clearCache
private

returns:: self


EXAMPLES::

code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
u = UserView(w,Rect(20,20,300,300));
// the Spec can define its preferred grid system
x =  \freq.asSpec.grid;
y =  \amp.asSpec.grid;
d = DrawGrid(Rect(0,0,500,300), x,y);

u.drawFunc = {
	d.draw
};
)
#+END_SRC

::
** class:: Dreset
summary:: demand rate reset
categories:: UGens>Demand

description::
The reset of a demand ugen can be controlled "from the outside" by the reset input of the link::Classes/Demand:: or link::Classes/Duty:: UGen, which consumes the chain of demands. Dreset allows to reset a subset of the chain internally.

classmethods::
method:: new
argument:: in
a demand UGen, producing values which are passed through
argument:: reset
a demand or any other UGen. When crossing from nonpositive to positive, it resets the first argument.

examples::
code::
#+BEGIN_SRC sclang
(
{
	var a, freq;
	a = Dreset(Dseries(0, 2, inf), Drand([0, 0, 0, 1], inf));
	freq = Duty.kr(1/MouseX.kr(1, 40, 1), 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1
}.play;
)

// reset when mouse button is pressed
(
{
	var a, freq;
	a = Dreset(Dseries(0, 2, inf), MouseButton.kr);
	freq = Duty.kr(1/MouseX.kr(1, 40, 1), 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1
}.play;
)

// audio rate
(
{
	var a, nmax = 90;
	a = { Dreset(Dseries(0, 1, inf), Drand(0 ! nmax ++ 1, inf)) } ! 2;
	Duty.ar(SampleDur.ir, 0, a) * (0.1 / nmax)
}.play;
)
#+END_SRC

::

** class:: Dseq
summary:: Demand rate sequence generator.
related:: Classes/Demand, Classes/Drand, Classes/Dser, Classes/Duty, Classes/Dxrand, Classes/TDuty
categories:: UGens>Demand

Description::

Demand rate sequence generator.


See link::Classes/Pseq:: for structurally related equivalent.


classmethods::

method::new

argument::list

An array of values or other UGens.


argument::repeats

Number of repeats.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	var a, freq, trig;
	a = Dseq([1, 3, 2, 7, 8], 3);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

// audio rate
(
{
	var a, freq, trig;
	a = Dseq({ 10.rand } ! 32, inf);
	trig = Impulse.ar(MouseX.kr(1, 10000, 1));
	freq = Demand.ar(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** class:: Dser
summary:: Demand rate sequence generator.
related:: Classes/Demand, Classes/Drand, Classes/Dseq, Classes/Duty, Classes/Dxrand, Classes/TDuty
categories:: UGens>Demand

Description::

Demand rate sequence generator.

See link::Classes/Pser:: for structurally related equivalent.


classmethods::

method::new

argument::list

An array of values or other UGens.


argument::repeats

Number of values to return.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	var a, freq, trig;
	a = Dser([1, 3, 2, 7, 8], 8);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** class:: Dseries
summary:: Demand rate arithmetic series UGen.
related:: Classes/Demand, Classes/Dgeom, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::

Demand rate arithmetic series UGen.

See link::Classes/Pseries:: for structurally related equivalent.


classmethods::

method::new

argument::start

Start value. Can be a number or any other UGen.


argument::step

Step value. Can be a number or any other UGen.


argument::length

Number of values to create.  Can be a number or any other UGen.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	var a, freq, trig;
	a = Dseries(0, 1, 15);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

(
{
	var a, freq, trig;
	a = Dseries(0, 1, inf);
	trig = Dust.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) % 15 * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** class:: Dshuf
summary:: Demand rate random sequence generator
categories:: UGens>Demand, UGens>Random

classmethods::
method:: new
argument:: list
array of values or other ugens
argument:: length
number of repeats
discussion::
structurally related: link::Classes/Pshuf::

examples::
code::
#+BEGIN_SRC sclang
(
{
	var a, freq, trig;
	a = Dseq([Dshuf([1, 3, 2, 7, 8.5], 3)], inf);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

// audio rate
(
{
	var a, freq, trig;
	a = Dseq([Dshuf({ 10.rand } ! 81, 5)], inf).poll;
	trig = Impulse.ar(MouseX.kr(1, 10000, 1));
	freq = Demand.ar(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

// embedded structures
(
{
	var a, freq, trig;
	a = Dseq([Dshuf([Drand([1, 2, 3], 1), 3, Drand([20, 23, 56], 1), 7, 8.5], 8)], inf);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** class:: Dstutter
summary:: Demand rate input replicator
categories:: UGens>Demand

classmethods::
method:: new
argument:: n
number of repeats (can be a demand ugen)
argument:: in
input ugen
discussion::
structurally related: link::Classes/Pstutter::

examples::
code::
#+BEGIN_SRC sclang
(
{
	var freq, trig;
	var in = Dseq([1, 2, 3], inf);
	var rep = Dstutter(Diwhite(2, 8, inf), in);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, rep).poll(trig) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** class:: Dswitch
summary:: Demand rate generator for embedding different inputs
related:: Classes/Demand, Classes/Dswitch1
categories:: UGens>Demand

description::
Demand rate generator for embedding different inputs.
In difference to Dswitch1, Dswitch embeds all items of
an input demand ugen first before looking up the next index.

classmethods::
method:: new
argument:: array
array of values or other ugens
argument:: index
which of the inputs to return
discussion::
structurally related: link::Classes/Pswitch::

examples::
code::
#+BEGIN_SRC sclang
(
	{
		var d, trig;
		d = Dswitch([
			Dwhite(3, 4, 2),
			Dwhite(0, 1, 2),
			Dseq([1, 1, 1, 0], 2)
		], Dseq([0, 1, 2, 1, 0], 2));

		trig = Impulse.kr(4);

		SinOsc.ar(
			Demand.kr(trig, 0, d).poll(trig)
			* 300 + 400
		)
		* 0.1 ! 2
	}.play;
);

// compare with Dswitch1:

(
	{
		var d, trig;
		d = Dswitch1([
			Dwhite(3, 4, 2),
			Dwhite(0, 1, 2),
			Dseq([1, 1, 1, 0], 2)
		], Dseq([0, 1, 2, 1, 0], 2));

		trig = Impulse.kr(4);

		SinOsc.ar(
			Demand.kr(trig, 0, d).poll(trig)
			* 300 + 400
		)
		* 0.1 ! 2
	}.play;
);
#+END_SRC

::

** class:: Dswitch1
summary:: Demand rate generator for switching between inputs.
related:: Classes/Demand, Classes/Duty, Classes/TDuty, Classes/Dswitch
categories:: UGens>Demand

Description::

Demand rate generator for switching between inputs.

See link::Classes/Pswitch1:: for structurally related equivalent.


classmethods::

method::new

argument::list

Array of values or other UGens.


argument::index

Which of the inputs to return.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	var a, freq, trig;
	a = Dswitch1([1, 3, MouseY.kr(1, 15), 2, Dwhite(0, 3, 2)], MouseX.kr(0, 4));
	trig = Impulse.kr(3);
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)

(
{
	var a, freq, trig;
	a = Dswitch1({ |i| Dseq((0..i*3), inf) } ! 5, MouseX.kr(0, 4));
	trig = Impulse.kr(6);
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** class:: Dust
summary:: Random impulses.
related:: Classes/Dust2
categories::  UGens>Generators>Stochastic


Description::

Generates random impulses from 0 to +1.


classmethods::

method::ar, kr

argument::density
Average number of impulses per second.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang

(
SynthDef("help-Dust", { arg out=0;
	Out.ar(out,
		Dust.ar(200, 0.5)
	)
}).play;
)

(
SynthDef("help-Dust", { arg out=0;
	Out.ar(out,
		Dust.ar(XLine.kr(20000, 2, 10), 0.5)
	)
}).play;
)
#+END_SRC

::

** class:: Dust2
summary:: Random impulses.
related:: Classes/Dust
categories::  UGens>Generators>Stochastic


Description::

Generates random impulses from -1 to +1.


classmethods::

method::ar, kr

argument::density
Average number of impulses per second.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang

(
SynthDef("help-Dust2", { arg out=0;
	Out.ar(out,
		Dust2.ar(200, 0.5)
	)
}).play;
)

(
SynthDef("help-Dust2", { arg out=0;
	Out.ar(out,
		Dust2.ar(XLine.kr(20000, 2, 10), 0.5)
	)
}).play;
)
#+END_SRC

::

** class:: Duty
summary:: Demand results from demand rate UGens.
related:: Classes/Demand, Classes/TDuty
categories::  UGens>Demand


Description::

A value is demanded each UGen in the list and output according to a
stream of duration values. The unit generators in the list should be
'demand' rate.


When there is a trigger at the reset input, the demand rate UGens in the
list and the duration are reset. The reset input may also be a demand
UGen, providing a stream of reset times.


classmethods::

method::ar, kr

argument::dur

Time values. Can be a demand UGen or any signal. The next level
is acquired after duration.


argument::reset

Trigger or reset time values. Resets the list of UGens and the
duration UGen when triggered. The reset input may also be a
demand UGen, providing a stream of reset times.


argument::level

Demand UGen providing the output values.


argument::doneAction

A doneAction that is evaluated when the duration stream ends. See

link::Reference/UGen-doneActions::  for more detail.


Examples::
code::
#+BEGIN_SRC sclang
(
	{
		var freq;
		freq = Duty.kr(
				Drand([0.01, 0.2, 0.4], inf), // demand ugen as durations
				0,
				Dseq([204, 400, 201, 502, 300, 200], inf)
			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)

(
	{
		var freq;
		freq = Duty.kr(
				MouseX.kr(0.001, 2, 1), // control rate ugen as durations
				0,
				Dseq([204, 400, 201, 502, 300, 200], inf)
			);
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)
#+END_SRC

::

Resetting the demand ugens:
code::
#+BEGIN_SRC sclang
(
	{
		var freq;
		freq = Duty.kr(
				Dseq([0.2, 0.3, 0.4, Dseq([1, 1, 1, 2, 1, 2], inf)]) / 2,
				Dust.kr(1), // control rate reset
				Dseq([0, 1, 2, Dseq([1, 2, 3, 4, 5], inf)])
			) * 30 + 250;
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)

(
	{
		var freq;
		freq = Duty.kr(
				Dseq([0.2, 0.3, 0.4, Dseq([1, 1, 1, 2, 1, 2], inf)]) / 2,
				Dseq([1, 2, 4, 5], inf), // demand rate reset
				Dseq([0, 1, 2, Dseq([1, 2, 3, 4, 5], inf)])
			) * 30 + 250;
		SinOsc.ar(freq * [1, 1.01]) * 0.1

	}.play;
)
#+END_SRC

::

Demand ugen as audio oscillator:
code::
#+BEGIN_SRC sclang
(
	{
		var a, n=5, m=64;
		a = {
			var x;
			x = { 0.2.rand2 } ! m;
			x = x ++ ({  Drand({ 0.2.rand2 } ! n) } ! m.rand);
			Dseq(x.scramble, inf)
		} ! n;
		Duty.ar(
				MouseX.kr(1, 125, 1) * SampleDur.ir * [1, 1.02],
				0,
				Dswitch1(a, MouseY.kr(0, n-1))
			)

	}.play;
)
#+END_SRC

::

single sample feedback: a lin cong algorithm:
code::
#+BEGIN_SRC sclang
(
b = Buffer.alloc(s, 1);
{
var x, y, rate, a, c, m;
	rate = MouseX.kr(100, SampleRate.ir);
	a = 1.1;
	c = 0.13;
	m = 1.0;
	x = Dbufrd(b); // read from buffer
	x = x * a + c % m;
	y = Dbufwr(x, b); // write to buffer
	Duty.ar(1 / rate, 0, y) * 0.1;
}.play;
)
#+END_SRC

::

** class:: Dwhite
summary:: Demand rate white noise random generator.
related:: Classes/Diwhite, Classes/Demand, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::

Dwhite returns numbers in the continuous range between
code::lo::  and  code::hi:: .
#+BEGIN_SRC sclang
link::Classes/Diwhite::  returns integer values.


The arguments can be a number or any other UGen.


See link::Classes/Pwhite::,  link::Classes/WhiteNoise::  for structurally related
equivalents.


classmethods::

method::new

argument::lo

Minimum value.


argument::hi

Maximum value.


argument::length

Number of values to create.


Examples::

code::

(
{
	var a, freq, trig;
	a = Dwhite(0, 15, inf);
	trig = Impulse.kr(MouseX.kr(1, 40, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** class:: Dwrand
summary:: Demand rate weighted random sequence generator
categories:: UGens>Demand, UGens>Random
related:: Classes/Demand

classmethods::
method:: new
argument:: list
array of values or other ugens
argument:: weights
array of values (should sum up to 1.0)
argument:: repeats
number of values to return
discussion::
structurally related: link::Classes/Pwrand::, link::Classes/TWindex::, link::Classes/TWChoose::

examples::
code::
#+BEGIN_SRC sclang
(
{
	var a, freq, trig;
	a = Dwrand([0, 1, 2, 7], [0.4, 0.4, 0.1, 0.1], inf).dpoll;
	trig = Impulse.kr(MouseX.kr(1, 400, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** class:: Dxrand
summary:: Demand rate random sequence generator.
related:: Classes/Demand, Classes/Drand, Classes/Dseq, Classes/Dser, Classes/Duty, Classes/TDuty
categories:: UGens>Demand

Description::

Dxrand never plays the same value twice, whereas  link::Classes/Drand::
chooses any value in the list.


See link::Classes/Pxrand:: for structurally related equivalent.


classmethods::

method::new

argument::list

An array of values or other UGens.


argument::repeats

Number of values to return.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	var a, freq, trig;
	a = Dxrand([1, 3, 2, 7, 8], inf);
	trig = Impulse.kr(MouseX.kr(1, 400, 1));
	freq = Demand.kr(trig, 0, a) * 30 + 340;
	SinOsc.ar(freq) * 0.1

}.play;
)
#+END_SRC

::

** class:: DynKlang
categories:: UGens>Generators>Deterministic
summary:: Dynamic sine oscillator bank
related:: Classes/Klang, Classes/DynKlank, Classes/Klank

description::
DynKlang is a bank of sine oscillators. It is less efficient than Klang, as it is basically a wrapper around SinOsc UGens in order to provide a similar interface to link::Classes/Klang::.

Unlike Klang, parameters in code::specificationsArrayRef:: can be changed after it has been started.

classmethods::
private:: categories

method:: ar, kr

argument:: specificationsArrayRef
a Ref to an Array of three Arrays:
definitionlist::
## frequencies || an Array of oscillator frequencies.
## amplitudes || an Array of oscillator amplitudes, or nil. If nil, then amplitudes default to 1.0
## phases || an Array of initial phases, or nil. If nil, then phases default to 0.0
::
argument:: freqscale
a scale factor multiplied by all frequencies at initialization time.
argument:: freqoffset
an offset added to all frequencies at initialization time.

examples::
code::
#+BEGIN_SRC sclang
// frequency modulation
(
play {
	DynKlang.ar(`[
		[800, 1000, 1200] + SinOsc.kr([2, 3, 4.2], 0, [13, 24, 12]),
		[0.3, 0.3, 0.3],
		[pi,pi,pi]
	]
) * 0.1
};
)


// building new synths every 2 seconds
(
{
loop({
	play({
		var mod = SinOsc.kr(Rand(0.1, 0.9), 0, Rand(5, 20));
		Pan2.ar(DynKlang.ar(`[ Array.rand(12, 200.0, 2000.0), 1, mod ]), 1.0.rand)
			* EnvGen.kr(Env.sine(4), 1, 0.02, doneAction: 2);
	});
	2.wait;
})
}.fork;
)


// resetting the frequencies and amplitudes after the synth has been created
(
SynthDef('help-dynKlang', {| freqs=#[220, 440, 880, 1760],
	amps=#[0.35, 0.23, 0.12, 0.05],
	phases=#[1, 1.5, 2, 2.5]|

	Out.ar(0, DynKlang.ar(`[freqs, amps, phases]))
}).add
)

a = Synth('help-dynKlang');

a.setn(\freqs, Array.rand(4, 500, 2000));
a.setn(\amps, Array.rand(4, 0.01, 0.25));
#+END_SRC

::

** class:: DynKlank
summary:: Bank of resonators.
related:: Classes/Klang, Classes/Klank
categories::  UGens>Generators>Deterministic, UGens>Filters>Linear


Description::

DynKlank is a bank of frequency resonators which can be used to simulate
the resonant modes of an object. Each mode is given a ring time, which is
the time for the mode to decay by 60 dB.


Unlike  link::Classes/Klank:: , the frequencies in DynKlank can be
changed after it has been started.


classmethods::

method::ar, kr

argument::specificationsArrayRef
A Ref to an Array of three Arrays: code::[frequencies, amplitudes, ringtimes]::

definitionlist::
## frequencies: || An Array of filter frequencies.
## amplitudes: || An Array of filter amplitudes, or nil. If nil, then amplitudes default to 1.0.
## ring times: || An Array of 60 dB decay times for the filters.
::
All subarrays, if not nil, should have the same length.

argument::input
The excitation input to the resonant filter bank.

argument::freqscale
A scale factor multiplied by all frequencies at initialization time.

argument::freqoffset
An offset added to all frequencies at initialization time.

argument::decayscale
A scale factor multiplied by all ring times at initialization time.

Examples::

code::
#+BEGIN_SRC sclang
s.boot;

{ DynKlank.ar(`[[800, 1071, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play;

{ DynKlank.ar(`[[800, 1071, 1353, 1723], nil, [1, 1, 1, 1]], Dust.ar(8, 0.1)) }.play;

{ DynKlank.ar(`[[800, 1071, 1353, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar(0.007)) }.play;

{ DynKlank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar([0.007,0.007])) }.play;


(
// change freqs and ringtimes with mouse
{	var freqs, ringtimes;
	freqs = [800, 1071, 1153, 1723] * MouseX.kr(0.5, 2, 1);
	ringtimes = [1, 1, 1, 1] * MouseY.kr(0.1, 10, 1);
	DynKlank.ar(`[freqs, nil, ringtimes ], Impulse.ar(2, 0, 0.1))
}.play;
)

(
// set them from outside later:
SynthDef('help-dynKlank', {
	var freqs, ringtimes, signal;
	freqs = Control.names([\freqs]).kr([800, 1071, 1153, 1723]);
	ringtimes = Control.names([\ringtimes]).kr([1, 1, 1, 1]);
	signal = DynKlank.ar(`[freqs, nil, ringtimes ], Impulse.ar(2, 0, 0.1));
	Out.ar(0, signal);
}).add;
)

a = Synth('help-dynKlank');

a.setn(\freqs, Array.rand(4, 500, 2000));
a.setn(\ringtimes, Array.rand(4, 0.2, 4) );

// create multichannel controls directly with literal arrays:
(
SynthDef('help-dynKlank', {|
	freqs (#[100, 200, 300, 400]),
	amps (#[1, 0.3, 0.2, 0.05]),
	rings (#[1, 1, 1, 2])|

	Out.ar(0, DynKlank.ar(`[freqs, amps, rings], WhiteNoise.ar * 0.001))
}).add
)

a = Synth('help-dynKlank');

a.setn(\freqs, Array.rand(4, 500, 2000));
a.setn(\amps, Array.exprand(4, 0.01, 1));

{ Out.kr(102, MouseX.kr(1, 2) * Array.rand(4, 500, 2000)) }.play;
a.mapn(\freqs, 102, 4);
#+END_SRC

::

** class:: EZGui
summary:: An abstract superclass for EZ widget wrappers
categories:: GUI>EZ-GUI
related:: Classes/EZListView, Classes/EZPopUpMenu, Classes/EZSlider, Classes/EZNumber, Classes/EZRanger, Classes/EZKnob

description::
Users will not normally directly create instances of EZGui, but only use it through its subclasses. It provides the basic mechanisms for various EZ widget wrappers. It also provides a standard for EZ GUI Classes, and new EZ Classes should subclass EZGUI to help keep a consistent user interface.


instancemethods::

subsection:: Accessing Instance Variables

method:: view
Returns the enclosing link::Classes/CompositeView::.

method:: bounds
Returns the bounds of the enclosing link::Classes/CompositeView::.

method:: label
Sets/gets it the label. Will add the label view if none was initially created.
argument:: string
An Instance of link::Classes/String::.

method:: window
Returns the window if you used the popUp window function.


subsection:: Accessing GUI options

method:: alwaysOnTop
Makes the popup window always on top, if there is one.
argument:: bool
An Instance of link::Classes/Boolean::. Default is false.

method:: visible
Sets/gets it the component views are visible.
argument:: bool
An Instance of link::Classes/Boolean::. Default is true.

method:: enabled
Sets/gets if the list is enabled.
argument:: bool
An Instance of link::Classes/Boolean::. Default is true.

method:: onClose
Sets/gets the onClose function of either code::view:: or code::window::, depending on whether the EZ view used a popup window.
argument:: func
An Instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: font
argument:: font
An instance of link::Classes/Font::.


subsection:: Subclassing

EZGui provides a standard and basic tools for most EZ classes. If you make a new EZ class, then subclass EZGui, and override the necessary methods. If your class only has a label and a widget, chances are, you need to override nothing, but only need to write the  new and init class methods. See existing subclasses of EZGui for examples of this. You may also want to override the following:

method:: widget
Returns the active widget. Subclasses will typically refer to it or ignore it, e.g.:
code::
#+BEGIN_SRC sclang
MyEZClass{
	myOtherMethods{}
	....
	listView{ ^widget }
}
#+END_SRC

::

method:: action
Gets/sets the action of the EZ class instance.
argument:: func
An Instance of link::Classes/Function:: or link::Classes/FunctionList::.

method:: value
Gets/sets the value of the code::widget::. Does not perform the action.
argument:: val
An integer.

method:: valueAction
Gets/sets the value of the widget. Performs do action.
argument:: val
An integer.

method:: doAction
Performs code::this.action.value(this)::.


subsection:: Internal Utilities

method:: prSubViewBounds
This calculates the bounds of the subviews and the gaps. It returns an array of Rects, which depends on how many subview there are. Subclasses override this if they have more than one widget.

method:: prMakeView
Called by init. Returns code::[view, bounds]::. The container is either the enclosing Container, or a pop up window with a container.

method:: prSetViewParams
Only defined by some subclasses. Sets the code::resize::  and code::align:: of all the views, according to the state of code::layout::.

method:: prMakeMarginGap
Called in the init method of all subclasses. Sets the margin and gap of code::view::. By default, it tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting code::argGap:: overrides these.

** class:: EZKnob
summary:: Wrapper class for label, knob, number box
categories:: GUI>EZ-GUI
related:: Classes/Knob, Classes/NumberBox, Classes/StaticText, Classes/CompositeView, Classes/EZGui

description::
EZKnob is wrapper class which creates an (optional) link::Classes/StaticText::, and a link::Classes/Knob:: plus a link::Classes/NumberBox::. If the parent is nil, then EZKnob will create its own window. See link::Classes/EZGui:: more options.

subsection:: Some Important Issues Regarding NumberBox

warning::
EZKnob replaces the EZKnob Quark, which is now called EZKnobOld.  It is encouraged to update your code. The two classes have different creation methods and approaches, particularly concerning the strong::dimensions:: (now strong::bounds::). To make the conversion process easier,  EZKnobOld has an instance method called convert which will post the equivallent creation code for the new EZKnob.
::

note::
Bounds: Make certain to choose bounds that are large enough to encompass the knob, the number box, and the label (if you use one), otherwise you may get confusing results. See the examples below.
::

classmethods::

method:: new

argument:: parent
The parent view or window. If the parent is nil, then EZKnob will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@20::.  Make certain to choose bounds that are large enough to encompass the knob, the number box, and the label (if you use one), otherwise you may get confusing results. See the examples below.

argument:: label
The label. Default value is nil. If nil, then no link::Classes/StaticText:: is created.

argument:: controlSpec
The link::Classes/ControlSpec:: for scaling the value.  If the code::minVal + maxVal:: of the spec is 0, then code::centered:: will be set to true automatically.

argument:: action
A link::Classes/Function:: called when the value changes. The function is passed the EZKnob instance as its argument.

argument:: initVal
The value to initialize the knob and number box with. If nil, then it uses the link::Classes/ControlSpec::'s default value.

argument:: initAction
A link::Classes/Boolean:: indicating whether the action function should be called when setting the initial value. The default is false.

argument:: labelWidth
Number of pixels width for the label. default is 60. This is only valid for the code::\horz:: layout.

argument:: knobSize
An instance of link::Classes/Point::.  It will adjust itself to maximize the space use of code::width/height::. By default, it uses the maximum availabel height, and adjusts the withd accordingly.

argument:: unitWidth
Number of pixels width for the unit label. Default is 0. If 0, then no unitLabel is created.

argument:: labelHeight
Default is 20.

argument:: layout
code::\vert::, code::vert2::,  code::\line2::, or code::\horz::. default is code::\vert::.
#+BEGIN_SRC sclang

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
code::
(
w=Window.new.front;
g = EZKnob( w,        // parent
            50@90,    // bounds
            " test ", // label
            \freq,    // controlSpec
            { |ez| (ez.value.asString ++" is the value of " ++ ez).postln } // action
);
g.setColors(Color.grey, Color.white)
);

// Simplest version, no parent view, so a window is created
(
	g = EZKnob(label:" test ");
	g.action_({ |ez| (ez.value.asString ++" is the value of " ++ ez).postln });
);
#+END_SRC

::
The contained views can be accessed via the EZKnob instance variables: code::labelView::, code::knobView::, code::numberView::.


instancemethods::

subsection:: Accessing Instance Variables

method:: numberView
Returns:: the code::numberView::

method:: knobView
Returns:: the code::knobView::

method:: labelView
Set/get the code::labelView::

method:: action
A function to be evaluated when the value changes. Te first argument will be the EZKnob.
argument:: arg1
An instance of link::Classes/Function:: or link::Classes/FunctionList::. Default value is code::nil::.

method:: value
The value of the knob

method:: centered
Sets/gets whether the knob is in centered mode. See link::Classes/Knob::.

method:: round
Rounds the values in the number box.

method:: controlSpec
An instance of link::Classes/ControlSpec:: for scaling the values.

method:: value
Gets/sets the list/menu to the index at value. Does not perform the action.
argument:: val
An link::Classes/Integer::.

method:: doAction
Performs the action at the current index and the global action.

method:: set
Set the args after creation. You can only set the label if it was not nil from the beginning.

method:: visible
Sets/gets if the component views are visible.
argument:: bool
An instance of link::Classes/Boolean::. Default is code::true::.

subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: numBackground
An instance of link::Classes/Color::. The code::numColor:: of the number view.
argument:: numStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the number view.
argument:: numNormalColor
An instance of link::Classes/Color::. The code::normalColor:: of the number view.
argument:: numTypingColor
An instance of link::Classes/Color::. The code::typingColor:: of the number view.
argument:: knobColors
An instance of link::Classes/Color::. The code::knobColors:: of the knob view.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the enclosing view.

method:: font
Set the Font used by all the views.
argument:: font
An instance of link::Classes/Font::.

examples::

code::
#+BEGIN_SRC sclang
(	// basic use
	w=Window.new.front;
	g=EZKnob(w, 50@90," test  ", \freq,{|a| a.value.postln});
	g.setColors(Color.grey,Color.white);
);


// lots of knobs on on view
(
w=Window.new.front;
w.view.decorator=FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;

20.do{
	EZKnob(w, 180@24," Freq ", \freq,unitWidth:30,initVal:6000.rand,layout:\horz)
	.setColors(Color.grey,Color.white)
	.font_(Font("Helvetica",11));

};
);

Window.closeAll  // use this to close all the windows

/////////////////////////////////////////////////////////////////
////////// click these parentheses to see all features and layouts

(
m=nil;
m=2@2;		// comment this for no margin

/////////////////
/// Layout \line2

(		// all features, small font
		g=EZKnob(nil, 128@40," freq  ", \freq,unitWidth:20,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,50);
		g.font_(Font("Helvetica",10));
);

(		// no unitView
		g=EZKnob(nil, 118@40," freq  ", \freq,unitWidth:0,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -40);
);
(		// no label, so use window name as label
		g=EZKnob(nil, 118@30, nil, \freq,labelWidth:100, unitWidth:20,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -130);
		g.window.name="Freq";
);

/////////////////
/// Layout \horz


(		// all features
		g=EZKnob(nil, 200@28," freq  ", \freq,unitWidth:30,layout:\horz, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(0,50);
);

(		// no unitView
		g=EZKnob(nil, 160@28," freq  ", \freq,layout:\horz, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(0, -30);
);
(		// no label, so use window name as label
		g=EZKnob(nil, 120@28, nil, \freq ,layout:\horz, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(0, -110);
		g.window.name="Freq";
);



/////////////////
/// Layout \vert

(		// all features
		g=EZKnob(nil, 82@82," freq  ", \freq,unitWidth:18,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.font_(Font("Helvetica", 10));
		g.window.bounds = g.window.bounds.moveBy(220,50);
);

(		// no unitView, with label
		g=EZKnob(nil, 70@90," freq  ", \freq,unitWidth:0,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(220,-90);
);

(		// no label
		g=EZKnob(nil, 120@60,nil, \freq, unitWidth:30,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(220,-230);
		g.window.name="Freq";
);

(		// no lablel, so use window name as label
		g=EZKnob(nil, 120@60,nil, \freq,unitWidth:0,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(220,-340);
		g.window.name="Freq";
);


/////////////////
/// Layout \vert2

(		// all features
		g=EZKnob(nil, 82@82," freq  ", \freq,unitWidth:18,layout:\vert2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.font_(Font("Helvetica", 10));
		g.window.bounds = g.window.bounds.moveBy(350,50);
);

(		// no unitView, with label
		g=EZKnob(nil, 70@90," freq  ", \freq,unitWidth:0,layout:\vert2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(350,-90);
);

(		// no label
		g=EZKnob(nil, 120@60,nil, \freq, unitWidth:30,layout:\vert2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(350,-230);
		g.window.name="Freq";
);

(		// no lablel, so use window name as label
		g=EZKnob(nil, 120@60,nil, \freq,unitWidth:0,layout:\vert2, margin: m);
		g.setColors(Color.grey,Color.white,Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(350,-340);
		g.window.name="Freq";
);


)




///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////


// Sound example
(
// start server
s.waitForBoot({

var w, startButton, noteControl, cutoffControl, resonControl;
var balanceControl, ampControl;
var node, cmdPeriodFunc;

// define a synth
SynthDef("window-test", { arg note = 36, fc = 1000, rq = 0.25, bal=0, amp=0.4, gate = 1;
		var x;
		x = Mix.fill(4, {
			LFSaw.ar((note + {0.1.rand2}.dup).midicps, 0, 0.02)
		});
		x = RLPF.ar(x, fc, rq).softclip;
		x = RLPF.ar(x, fc, rq, amp).softclip;
		x = Balance2.ar(x[0], x[1], bal);
		x = x * EnvGen.kr(Env.cutoff, gate, doneAction: 2);
		Out.ar(0, x);
	}, [0.1, 0.1, 0.1, 0.1, 0.1, 0]
).add;




// make the window
w = Window("another control panel", Rect(20, 400, 230, 250));
w.front; // make window visible and front window.
w.view.decorator = FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;

// add a button to start and stop the sound.
startButton = Button(w, 75 @ 20);
startButton.states = [
	["Start", Color.black, Color.green(0.7)],
	["Stop", Color.white, Color.red(0.7)]
];
startButton.action = {|view|
		if (view.value == 1) {
			// start sound
			node = Synth( "window-test", [
				"note", noteControl.value,
				"fc", cutoffControl.value,
				"rq", resonControl.value,
				"bal", balanceControl.value,
				"amp", ampControl.value.dbamp ]);
		} {
			// set gate to zero to cause envelope to release
			node.release; node = nil;
		};
};

// create controls for all parameters
w.view.decorator.nextLine;
noteControl = EZKnob(w, 220 @ 32, "Note ", ControlSpec(24, 60, \lin, 1, 36, \note),
	{|ez| node.set( "note", ez.value )}, unitWidth:30,layout:\horz)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
cutoffControl = EZKnob(w, 220 @ 32, "Cutoff ", ControlSpec(200, 5000, \exp,0.01,1000,\Hz),
	{|ez| node.set( "fc", ez.value )}, unitWidth:30,layout:\horz)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
resonControl = EZKnob(w, 220 @ 32, "Reson ", ControlSpec(0.1, 0.7,\lin,0.001,0.2,\rq),
	{|ez| node.set( "rq", ez.value )}, unitWidth:30,layout:\horz)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
balanceControl = EZKnob(w, 220 @ 32, "Balance ", \bipolar,
	{|ez| node.set( "bal", ez.value )},  unitWidth:30,layout:\horz)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
ampControl = EZKnob(w, 220 @ 32, "Amp ", \db,
	{|ez| node.set( "amp", ez.value.dbamp )}, -6, unitWidth:30,layout:\horz)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);


// set start button to zero upon a cmd-period
cmdPeriodFunc = { startButton.value = 0; };
CmdPeriod.add(cmdPeriodFunc);

// stop the sound when window closes and remove cmdPeriodFunc.
w.onClose = {
	node.free; node = nil;
	CmdPeriod.remove(cmdPeriodFunc);
};
});
)


//////////////////////////////
// more examples
// these mimick the original  EZKnob layout and colors

(
w = Window("EZKnob", Rect(380,400,300,180)).front;
w.view.decorator = FlowLayout(w.view.bounds);
k = EZKnob(w, 42 @ 74, "Knob", action: { arg knb; knb.value.postln; }, margin:2@2, labelHeight:16);
k.view.background_(Color.grey.alpha_(0.4));
)
k.centered_(true)
k.value=0.5;
k.visible_(false)
k.visible_(true)

k.enabled_(false)
k.value = 0.1
k.enabled
k.enabled_(true)
k.value = 0.25

(
w = Window("EZKnob", Rect(380,400,300,180)).front;
w.view.decorator = FlowLayout(w.view.bounds, gap: 1@1);
StaticText(w, (42 * 4 + 3) @ 16).string_("EZKnob Cluster").background_(Color.blue(0.1,0.1));
w.view.decorator.nextLine;
a = [
		EZKnob(w, 42 @ 74, "knob 1", margin:2@2, labelHeight:16),
		EZKnob(w, 42 @ 74, "knob 2", controlSpec: \freq, margin:2@2, labelHeight:16),
		EZKnob(w, 42 @ 74, "knob 3", controlSpec: \pan, margin:2@2, labelHeight:16).round_(0.001),
		EZKnob(w, 42 @ 74, "knob 4", controlSpec: \rq, margin:2@2, labelHeight:16)
	];
a.do{arg a;a.view.background_(Color.grey.alpha_(0.4))};
)
// a now holds the array of knobs
a
a[0].value
a[3].value_(0.5)
a.collect(_.value );
#+END_SRC

::
** class:: EZListView
summary:: A wrapper class for a label plus a listView with per item actions
categories:: GUI>EZ-GUI
related:: Classes/ListView

description::
EZListView is wrapper class which creates an (optional) label and a listView. It includes per item actions as well as a global action which are both evaluated upon selection of an item. Convenience methods for inserting and deleting list items are also included . If the parent is nil, then EZListView will create its own window. See link::Classes/EZGui:: and link::Classes/EZLists:: for all of the options.

subsection:: Some Important Issues Regarding EZListView

The convenience methods for EZListView require that the items array is an array of associations of labels and functions, not like in ListView, where items is simply an array of strings. If code::label:: is nil, then no staticText is created.

classmethods::

subsection:: Creation / Class Methods

method:: new

argument:: parent
The parent view or window. If the parent is nil, then EZListView will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@200::.

argument:: label
The label. Default value is code::nil::. If code::nil::, then no link::Classes/StaticText:: is created.

argument:: items
Default value is code::nil::. An link::Classes/Array:: of link::Classes/Association::s code:: ['label' -> { arg listObj; value }, ] ::. Or and link::Classes/Array:: link::Classes/Symbol::s (if you are only using code::globalAction::).

argument:: globalAction
A global function to be performed in addition to the item functions code:: { arg listObj; value } ::.

argument:: initVal
Initial value of the List, i.e. the index selected. Default value is 0.

argument:: initAction
An instance of link::Classes/Boolean::. Performs the action at code::initVal:: on creation of the list, plus the code::globalAction::. Default value is code::false::.

argument:: labelWidth
Default value is 80. Not used if layout is code::\vert::.

argument:: labelHeight
Default value is 20. Not used if layout is code::\horz::.

argument:: layout
code::\vert:: or code::\horz::. default is code::\vert::.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
Example:
code::
(
// default with vertical layout
w = Window.new.front;
w.view.decorator = FlowLayout(w.view.bounds);
g = EZListView.new(w,
	230@230,
	"An ListView:",
	[
		\item0 ->{ |a| ("this is item 0 of " ++ a).postln },
		\item1 ->{ |a| ("this is item 1 of " ++ a).postln },
		\item2 ->{ |a| ("this is item 2 of " ++ a).postln },
	],
	globalAction: { |a| ("this is a global action of "++a.asString ).postln },
	initVal: 2,
	initAction: true,
	labelWidth: 120,
	labelHeight: 16,
	layout: \vert,
	gap: 2@2
	);

)

// or a more simple syntax (uses decorator gap settings):
(
w = Window.new.front;
w.view.decorator = FlowLayout(w.view.bounds);
g = EZListView.new(w,200@230, " List:");
g.addItem(\item0, { |a| ("this is item 0 of " ++ a).postln });
g.addItem(\item1, { |a| ("this is item 1 of " ++ a).postln });
g.addItem(\item2, { |a| ("this is item 2 of " ++ a).postln });
g.setColors(Color.grey, Color.white);
)
::

instancemethods::

subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: listBackground
An instance of link::Classes/Color::. The code::background:: of the list view.
argument:: listStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the list view.
argument:: selectedStringColor
An instance of link::Classes/Color::. The code::selectedStringColor:: of the listView.
argument:: hiliteColor
An instance of link::Classes/Color::. The code::hiliteColor:: of the list view.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the list view.

method:: font
Set the link::Classes/Font:: used by all the views.
argument:: font
An instance of link::Classes/Font::.

examples::
Creates its own window if parent is nil:
code::
(
g = EZListView.new(label: " My PopUp List: ");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.setColors(Color.grey,Color.white);
)
::
Layout horizontal:
code::
(
g = EZListView.new(nil,205@180, "Choose One: ", layout:\horz);
10.do{|i| g.addItem("item"++i.asString, {("this is item" ++i.asString). postln})};
g.setColors(Color.grey,Color.white);
)
::
No labelView created, so set the window title:
code::
(
g = EZListView.new(bounds:200@230); // no label
12.do{|i| g.addItem("item"++i.asString, {("this is item" ++i.asString). postln})};
g.view.parent.findWindow.name=" choose item";
)
::
insert item:
code::
(
g = EZListView.new(nil,200@200, "List:");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.addItem(\item4, {"this is item 4". postln});
)

g.insertItem(3, \item3, {"this is item 3". postln});
::
remove item:
code::
(
g = EZListView.new(nil,200@200, "List:");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.addItem(\item4, {"this is item 4". postln});
g.insertItem(3, \item3, {"this is item 3". postln});
)

g.removeItemAt(1);
::
replace item:
code::
(
g = EZListView.new(nil,200@200, "List:");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.addItem(\item3, {"this is item 3". postln});
)

g.replaceItemAt(2, \item2_replaced, {"this is item 2 replaced". postln});
::

** class:: EZLists
summary:: An abstract superclass for EZListView and EZPopUpMenu
categories:: GUI>EZ-GUI
related:: Classes/EZListView, Classes/EZPopUpMenu

description::
Users will not normally directly create instances of EZLists, but only use it through its subclasses. It provides the basic mechanisms for link::Classes/EZListView:: and link::Classes/EZPopUpMenu::.

classmethods::

method:: new

instancemethods::

subsection:: Building and Changing the List

method:: globalAction
Set/get the global function to be performed in addition to the item functions: code:: { arg listObj; value } ::.

method:: items
Set/get an link::Classes/Array:: of Associations including the labels and the item functions: code:: ['label' -> { arg listObj; value }, ] ::.
discussion::
In menus, the OS X graphics system gives special meanings to some characters. See link::Classes/PopUpMenu:: ; Or and link::Classes/Array:: link::Classes/Symbol::s (if you are only using code::globalAction::). link::Classes/Array::s of link::Classes/Symbol::s will get converted into and array of link::Classes/Association::s with and empty link::Classes/Function:: code:: ['label' -> {}, ] ::.

method:: item
Returns:: the item label of the current selection.

method:: itemFunc
Returns:: the item function of the current selection.

method:: addItem
Adds an item.
argument:: name
An instance of link::Classes/String:: or link::Classes/Symbol::. The name of the list/menu item.
argument:: action
An instance of link::Classes/Function::.

method:: insertItem
Inserts a list/menu item at positiion of index.
argument:: index
An link::Classes/Integer::. The index where to insert an item.
argument:: name
An instance of link::Classes/String:: or link::Classes/Symbol::. The name of the list/menu item.
argument:: action
An instance of link::Classes/Function::.

method:: replaceItemAt
Replace a list/menu item at positiion of index.
argument:: index
An link::Classes/Integer::. The index where to insert an item.
argument:: name
An instance of link::Classes/String:: or link::Classes/Symbol::. The name of the list/menu item. Default is the current item label.
argument:: action
An instance of link::Classes/Function::. Default is the current item action.

method:: removeItemAt
Removes a list/menu item at positiion of index.
argument:: index
An link::Classes/Integer::. The index where to remove an item.

method:: remove
Removes both the view, label and the list/menu from the parent view.

subsection:: Accessing Values

method:: value
Gets/sets the list/menu to the index at value. Does not perform the action.
argument:: val
An link::Classes/Integer::.

method:: valueAction
Sets the value and performs the action at the index value and the global action.
argument:: val
An link::Classes/Integer::.

method:: doAction
Performs the action at the current index and the global action.

method:: initViews
Called by init and overriden by all subclasses. This is where the class specific views are built.
** class:: EZNumber
summary:: Wrapper class for label and number box
categories:: GUI>EZ-GUI
related:: Classes/NumberBox

description::
EZNumber is wrapper class which creates an (optional) link::Classes/StaticText::, and a link::Classes/NumberBox::.

subsection:: Some Important Issues Regarding NumberBox
If the parent is code::nil::, then EZNumber will create its own window. See link::Classes/EZGui:: more options.

subsection:: Scrolling and Arrow Keys
EZNumber scrolls by default, using the step size of the link::Classes/ControlSpec::. If the controlSpec's step is set to 0, or is not set, then the the stepping and scrolling will be guessed according to the code::minval:: and code::maxval:: values of the spec on creation of the view.  Unlike the step variable of a regular link::Classes/NumberBox::, code::controlSpec.step:: is also the smallest possible increment for the EZNumber. By default, the shift-key modifier will allow you to step by 100 x code::controlSpec.step::, while the ctrl-key will give you 10x code::controlSpec.step::. Since the alt-key would give you 0.1 of the minimum step, it is disabled by default, but you can change that by setting code::numberView.alt_step:: to any value you like. Accordingly you can customize the other modifiers to fit your needs. See link::Classes/NumberBox::.

classmethods::
method:: new

argument:: parent
The parent view or window. If the parent is nil, then EZNumber will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@20::.

argument:: label
The label. Default value is code::nil::. If code::nil::, then no link::Classes/StaticText:: is created.

argument:: controlSpec
The link::Classes/ControlSpec:: for scaling the value.

argument:: action
A link::Classes/Function:: called when the value changes. The function is passed the EZNumber instance as its argument.

argument:: initVal
The value to initialize the slider and number box with. If code::nil::, then it uses the link::Classes/ControlSpec::'s default value.

argument:: initAction
A link::Classes/Boolean:: indicating whether the action function should be called when setting the initial value. The default is code::false::.

argument:: labelWidth
Number of pixels width for the label. The  default is 60. In the code::\horz:: layout, if you specify the code::numberWidth::, then the code::labelWidth:: is ignored and is set to the code::bounds.width - unitWidth - numberWidth::.

argument:: numberWidth
Number of pixels width for the number box. The  default is 45. In \line2 layout, numberWidth defaults to the bounds.width minus the unitWidth.

argument:: unitWidth
Number of pixels width for the unit label. The default is 0.  If code::unitWidth:: is 0, then no code::unitLabel:: is created. In the code::\line2:: layout, if you specify the code::numberWidth::, then the code::unitWidth:: is ignored and is set to the code::bounds.width - unitWidth - numberWidth::.

argument:: labelHeight
Default is 20;

argument:: layout
code::\line2::, or code::\horz::. The default is code::\horz::; code::\line2:: is a two line version.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
code::
(
w = Window.new.front;
g = EZNumber(w,        // parent
             150@20,   // bounds
             " test ", // label
             \freq,    // controlSpec
             { |ez| (ez.value.asString ++" is the value of " ++ ez).postln }, // action
             330,      // initValue
             true      // initAction
);
g.setColors(Color.grey,Color.white);
);


// Simplest version, no parent view, so a window is created
(
	g = EZNumber(label:" test ", controlSpec: \amp.asSpec.step_(0.01) );
	g.action_({ |ez| (ez.value.asString ++" is the value of " ++ ez).postln });
);
::

The contained views can be accessed via the EZNumber instance variables: code::labelView::, code::numberView::.

instancemethods::

method:: numberView
Returns the numberView

method:: action
A function to be evaluated when the value changes. Te first argument will be the EZNumber.
argument:: arg1
An instance of link::Classes/Function:: or link::Classes/FunctionList::. Default value is nil.

method:: value
The value of the slider

method:: round
Rounds the values in the number box.

method:: controlSpec
An instance of link::Classes/ControlSpec:: for scaling the values.

method:: value
Gets/sets the list/menu to the index at value. Does not perform the action.
argument:: val
An link::Classes/Integer::.

valueAction
Sets the value and performs the action at the index value and the global action.
argument:: val
An link::Classes/Integer::.

method:: doAction
Performs the action at the current index and the global action.

method:: set
Set the args after creation.

method:: enabled
Sets/gets if the list is enabled.
argument:: bool
An instance of link::Classes/Boolean::. Default is code::true::.


subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: numBackground
An instance of link::Classes/Color::. The code::background:: of the number view.
argument:: numStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the number view.
argument:: numNormalColor
An instance of link::Classes/Color::. The code::normalColor:: of the number view.
argument:: numTypingColor
An instance of link::Classes/Color::. The code::typingColor:: of the number view.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the enclosing view.

method:: font
Set the link::Classes/Font:: used by all the views.
argument:: font
An instance of link::Classes/Font::.


examples::
code::
// Simplest version
(		// basic use
		w=Window.new.front;
		g=EZNumber(w, 170@16," test  ", \freq,unitWidth:30, numberWidth:60,layout:\horz);
		g.setColors(Color.grey,Color.white);
);


// lots of numberviews on on view
(
w=Window.new.front;
w.view.decorator=FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;

40.do{
		g=EZNumber(w, 170@16," test  ", \freq,unitWidth:30, numberWidth:60,layout:\horz);
		g.setColors(Color.grey,Color.white, Color.grey(0.8));
};
);


// click these parentheses to see all features and layouts
(

m=nil;
m=2@2;		//comment for no margin

/////////////////
/// Layout \horz

(		// all features
		g=EZNumber(nil, 170@20," freq  ", \freq,unitWidth:30, numberWidth:60,layout:\horz,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,50);
);

(		// no unitView
		g=EZNumber(nil, 170@20," freq  ", \freq,unitWidth:0, numberWidth:60,layout:\horz,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -20);
);

(		// no label, with unit. use window name as label
		g=EZNumber(nil, 120@20,nil, \freq,unitWidth:30, numberWidth:60,layout:\horz,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -90);
		g.window.name="Freq";
);


(		// no units, no label; use window name as label;
		g=EZNumber(nil, 120@20, nil, \freq,unitWidth:0, numberWidth:60,layout:\horz,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -160);
		g.window.name="Freq";
);

/////////////////
/// Layout \line2

(		// all features
		g=EZNumber(nil, 120@42," freq  ", \freq,unitWidth:30, numberWidth:60,layout:\line2,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(100,50);
);

(		// no unitView, with label
		g=EZNumber(nil, 170@42," freq  ", \freq,unitWidth:0, numberWidth:60,layout:\line2,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(100, -50);
);
(		// no unitView, no label; use window name as label
		g=EZNumber(nil, 170@20,nil, \freq,unitWidth:0, numberWidth:60,layout:\line2,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(100,-150);
		g.window.name="Freq";
);


)



// Sound example
(
// start server
s.waitForBoot({

	var w, startButton, noteControl, cutoffControl, resonControl;
	var balanceControl, ampControl;
	var node, cmdPeriodFunc;

	// define a synth
	SynthDef("window-test", { arg note = 36, fc = 1000, rq = 0.25, bal=0, amp=0.4, gate = 1;
			var x;
			x = Mix.fill(4, {
				LFSaw.ar((note + {0.1.rand2}.dup).midicps, 0, 0.02)
			});
			x = RLPF.ar(x, fc, rq).softclip;
			x = RLPF.ar(x, fc, rq, amp).softclip;
			x = Balance2.ar(x[0], x[1], bal);
			x = x * EnvGen.kr(Env.cutoff, gate, doneAction: 2);
			Out.ar(0, x);
		}, [0.1, 0.1, 0.1, 0.1, 0.1, 0]
	).add;



	// make the window
	w = Window("another control panel", Rect(200, 400, 300, 180));
	w.front; // make window visible and front window.
	w.view.decorator = FlowLayout(w.view.bounds);

	w.view.background = Color.rand;

	// add a button to start and stop the sound.
	startButton = Button(w, 75 @ 20);
	startButton.states = [
		["Start", Color.black, Color.green],
		["Stop", Color.white, Color.red]
	];
	startButton.action = {|view|
			if (view.value == 1) {
				// start sound
				node = Synth( "window-test", [
					"note", noteControl.value,
					"fc", cutoffControl.value,
					"rq", resonControl.value,
					"bal", balanceControl.value,
					"amp", ampControl.value.dbamp ]);
			} {
				// set gate to zero to cause envelope to release
				node.release; node = nil;
			};
	};

	// create controls for all parameters
	w.view.decorator.nextLine;
	noteControl = EZNumber(w, 160 @ 20, "Note ", ControlSpec(24, 60, \lin, 1),
		{|ez| node.set( "note", ez.value )}, 36);

	w.view.decorator.nextLine;
	cutoffControl = EZNumber(w, 160 @ 20, "Cutoff ", ControlSpec(200, 5000, \exp),
		{|ez| node.set( "fc", ez.value )}, 1000);

	w.view.decorator.nextLine;
	resonControl = EZNumber(w, 160 @ 20, "Reson", ControlSpec(0.1, 0.7),
		{|ez| node.set( "rq", ez.value )}, 0.2);

	w.view.decorator.nextLine;
	balanceControl = EZNumber(w, 160 @ 20, "Balance ", \bipolar,
		{|ez| node.set( "bal", ez.value )}, 0);

	w.view.decorator.nextLine;
	ampControl = EZNumber(w, 160 @ 20, "Amp ", \db,
		{|ez| node.set( "amp", ez.value.dbamp )}, -6);


	// set start button to zero upon a cmd-period
	cmdPeriodFunc = { startButton.value = 0; };
	CmdPeriod.add(cmdPeriodFunc);

	// stop the sound when window closes and remove cmdPeriodFunc.
	w.onClose = {
		node.free; node = nil;
		CmdPeriod.remove(cmdPeriodFunc);
	};
});
)
::
** class:: EZPopUpMenu
summary:: A wrapper class for a label plus a popUpMenu with per item actions
categories:: GUI>EZ-GUI
related:: Classes/PopUpMenu

description::
EZPopUpMenu is wrapper class which creates an (optional) label and a popUpMenu. It includes per item actions as well as a global action which are both evaluated upon selection of an item. Convenience methods for inserting and deleting menu items are also included . If the parent is nil, then EZPopUpMenu will create its own window.See link::Classes/EZGui:: and link::Classes/EZLists:: for all of the options.

subsection:: Some Important Issues Regarding EZPopUpMenu
The convenience methods for EZPopUpMenu require that the items array is an array of associations of labels and functions, not like in link::Classes/PopUpMenu::, where items is simply an array of strings. If code::label:: is code::nil::, then no staticText is created.

classmethods::
method:: new

argument:: parentView
The parent view or window. If the parent is nil, then EZPopUpMenu will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@22::.

argument:: label
The label. Default value is code::nil::. If code::nil::, then no link::Classes/StaticText:: is created.

argument:: items
Default value is code::nil::. An link::Classes/Array:: of link::Classes/Association::s code:: ['label' -> { arg menuObj; value }, ] ::. Or and link::Classes/Array:: link::Classes/Symbol::s (if you are only using code::globalAction::).

argument:: globalAction
A global function to be performed in addition to the item functions code:: { arg menuObj; value } ::.

argument:: initVal
Initial value of the menu, i.e. the index selected. Default value is 0.

argument:: initAction
An instance of link::Classes/Boolean::. Performs the action at code::initVal:: on creation of the menu, plus the code::globalAction::. Default value is code::false::.

argument:: labelWidth
Default value is 80.

argument:: labelHeight
Default value is 20. Not used if layout is code::\horz::.

argument:: layout
code::\vert:: or code::\horz::. default is code::\horz::.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's code::gap::, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
code::
(
w = Window.new.front;
w.view.decorator = FlowLayout(w.view.bounds);
g = EZPopUpMenu.new(
	w,
	230@22,
	"A PopUpMenu: ",
	[
		\item0 ->{|a| ("this is item 0 of " ++ a).postln},
		\item1 ->{|a| ("this is item 1 of " ++ a).postln},
		\item2 ->{|a| ("this is item 2 of " ++ a).postln},
	],
	globalAction: {|a| ("this is a global action of "++a.asString ).postln},
	initVal: 1,
	initAction: true,
	labelWidth: 120,
	labelHeight: 20,
	layout: \horz,
	gap: 2@2
);
)

// or a more simple syntax:
(
w = Window.new.front;
w.view.decorator = FlowLayout(w.view.bounds);
g = EZPopUpMenu.new(w, 200@22, "Menu: ");
g.addItem(\item0, { |a| ("this is item 0 of " ++ a).postln });
g.addItem(\item1, { |a| ("this is item 1 of " ++ a).postln });
g.addItem(\item2, { |a| ("this is item 2 of " ++ a).postln });
g.value = 0;
)
::

instancemethods::

subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: menuBackground
An instance of link::Classes/Color::. The code::background:: of the menu.
argument:: menuStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the menu.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the list view.

method:: font
Set the link::Classes/Font:: used by all the views.
argument:: font
An instance of link::Classes/Font::.

examples::
code::
// try several examples together
(

// many menus
// inherits the parent's decorator gap

(
w=Window.new("oscillators", Rect(200,500,200,160)).front;
w.view.decorator = FlowLayout(w.view.bounds).gap_(2@2);
5.do{|i|
	g = EZPopUpMenu.new(w,190@22, "Oscillator % : ".format(i+1));
	g.addItem(\off, {"off". postln});
	g.addItem(\sine, {"sine". postln});
	g.addItem(\saw, {"saw". postln});
	g.addItem(\pulse, {"pulse". postln});
	g.setColors(Color.grey,Color.white);
	g.value=0;
};
w.bounds=w.bounds.moveBy(300,60);
);


// Creates its own window if parentView is nil:
(
g = EZPopUpMenu.new(nil,250@22 ," Select : ");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.setColors(Color.grey,Color.white);
g.value=0;

);

// layout vertical:
(
g = EZPopUpMenu.new(nil,200@42, " Choose",layout:\vert);
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.setColors(Color.grey,Color.white);
g.window.bounds=g.window.bounds.moveBy(300,-200);
g.value=0;
);

// No labelView created, so set the window title;
(
g = EZPopUpMenu.new(bounds:180@22); // no label
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.value=0;
g.window.name=" choose item";
g.window.bounds=g.window.bounds.moveBy(0,-200);
);
)
// insertItem;

(
g = EZPopUpMenu.new(nil,200@22, "Menu:");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.addItem(\item4, {"this is item 4". postln});
g.value=0;
);

g.insertItem(3, \item3, {"this is item 3". postln});


// remove Item ;

(
w=Window.new.front;
w.view.decorator = FlowLayout(w.view.bounds);
g = EZPopUpMenu.new(w,200@22, "Menu:");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.addItem(\item4, {"this is item 4". postln});
g.insertItem(3, \item3, {"this is item 3". postln});
g.value=0;
)

g. removeItemAt(0);



// replace item;
(
g = EZPopUpMenu.new(nil,200@22, "List:");
g.addItem(\item0, {"this is item 0". postln});
g.addItem(\item1, {"this is item 1". postln});
g.addItem(\item2, {"this is item 2". postln});
g.addItem(\item3, {"this is item 3". postln});
)

g.replaceItemAt(2, \item2_replaced, {"this is item 2 replaced". postln});
::
** class:: EZRanger
summary:: A wrapper class for a label, a rangeslider, and numberboxes
categories:: GUI>EZ-GUI
related:: Classes/EZGui, Classes/StaticText, Classes/Slider, Classes/NumberBox

description::
EZRanger is wrapper class which creates an (optional) link::Classes/StaticText::, and a link::Classes/Slider:: plus a link::Classes/NumberBox::. If the parent is code::nil::, then EZRanger will create its own window. See link::Classes/EZGui:: more options.

subsection:: Scrolling and Arrow Keys
EZRanger's number boxs scroll by default, using the step size of the link::Classes/ControlSpec::. If the controlSpec's step is set to 0, or is not set, then the the stepping and scrolling will be guessed according to the code::minval:: and code::maxval:: values of the spec on creation of the view.  Unlike the step variable of a regular link::Classes/NumberBox::, code::controlSpec.step:: is also the smallest possible increment for the link::Classes/NumberBox::s.  By default, the shift-key modifier will allow you to step by 100x code::controlSpec.step::, while the ctrl-key will give you 10x code::controlSpec.step::. Since the alt-key would give you 0.1 of the minimum step, it is disabled by default, but you can change that by setting code::numberView.alt_step:: to any value you like. Accordingly you can customize the other modifiers to fit your needs. See link::Classes/NumberBox:: and link::Classes/Slider::. This also effects the arrow keys for the slider.

classmethods::

method:: new

argument:: parent
The parent view or window. If the parent is nil, then EZRanger will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@20::.

argument:: label
The label. Default value is code::nil::. If code::nil::, then no link::Classes/StaticText:: is created.

argument:: controlSpec
The link::Classes/ControlSpec:: for scaling the value.

argument:: action
A link::Classes/Function:: called when the value changes. The function is passed the EZRanger instance as its argument.

argument:: initVal
An inistance of link::Classes/Array:: code::[lo, hi]::. If code::nil::, then it uses the link::Classes/ControlSpec::'s default value.

argument:: initAction
A link::Classes/Boolean:: indicating whether the action function should be called when setting the initial value. The default is code::false::.

argument:: labelWidth
Number of pixels width for the label. default is 60.

argument:: numberWidth
Number of pixels width for the number box. default is 45.

argument:: unitWidth
Number of pixels width for the unit label. The default is 0. If 0, then no code::unitLabel:: is created.

argument:: labelHeight
The default is 20;

argument:: layout
code::\vert::, code::\line2::, or code::\horz::. The default is code::\horz::.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
code::
(
w = Window.new.front;
g = EZRanger(w, 400@16," test  ", \freq, { |v| v.value.postln }, [50,2000], unitWidth:30)
)

// Simplest version, no parent view, so a window is created
(
EZRanger(nil, 400@16," test  ", \freq, { |v| v.value.postln }, [50,2000])
)
::
The contained views can be accessed via the EZRanger instance variables: code::rangeSlider::, code::hiBox::, code::loBox::, code::unitView::, code::labelView::.

instancemethods::

subsection:: Accessing Instance and Class Variables

method:: unitView
The units label. Only appears if code::unitWidth:: was set to > 0.

method:: controlSpec
An instance of ControlSpec for scaling the values.

method:: loBox
The code::lo:: value link::Classes/NumberBox::.

method:: action
Set/get a link::Classes/Function:: or link::Classes/FunctionList:: to be evaluated when the value changes. The first argument will be the EZRanger.

method:: rangeSlider
The link::Classes/RangeSlider:: link::Classes/View::

method:: lo
Set/get the low value.

method::hi
Set/get the high value

method:: hiBox
The hi value link::Classes/NumberBox::.

method:: round
Rounds the values in the number boxes.

subsection:: Doing Some Task (optional)

method:: doAction
Performs the action at the current index and the global action.

method:: value
Gets/sets the code::lo:: and code::hi:: values.
argument:: vals
An instance of link::Classes/Array:: code:: [lo, hi] ::.

method:: valueAction
Sets the value and performs the action at the index value and the global action.
argument:: vals
An instance of link::Classes/Array:: code:: [lo, hi] ::.

subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: sliderColor
An instance of link::Classes/Color::. The slider code::background::.
argument:: numBackground
An instance of link::Classes/Color::. The code::background:: of the number view.
argument:: numStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the number view.
argument:: numNormalColor
An instance of link::Classes/Color::. The code::normalColor:: of the number view.
argument:: numTypingColor
An instance of link::Classes/Color::. The code::typingColor:: of the number view.
argument:: knobColor
An instance of link::Classes/Color::. The code::knobColor:: of the slider view.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the enclosing view.

method:: font
Set the Font used by all the views.
argument:: font
An instance of link::Classes/Font::.


examples::
code::
(	// basic use
	w=Window.new.front;
	g=EZRanger(w, 400@16," test  ", \freq,{|v| v.value.postln},[50,2000],unitWidth:30);
	g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);
);

// lots of range sliders on a view
(
w=Window.new.front;
w.view.decorator=FlowLayout(w.view.bounds);
w.view.decorator.gap=1@1;

20.do{
	g=EZRanger(w, 400@16," test  ", \freq,{|v| v.value.postln},[50.rand,50+20000.rand],unitWidth:30)
	.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,Color.white, Color.white, Color.yellow)
	.font_(Font("Helvetica",11));

};
);

Window.closeAll

/////////////////////////////////////////////////////////////////
////////// click these parentheses to see all features and layouts
(

m=nil;
m=2@2; // comment for no margin


/////////////////
/// Layout \horz

(		// all features, small font
		g=EZRanger(nil, 400@16," freq  ", \freq,
			initVal:[100.rand,200+2000.rand],unitWidth:30, numberWidth:60,layout:\horz, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180,50);
		g.font_(Font("Helvetica",10));
);

(		// no unitView
		g=EZRanger(nil, 400@16," freq  ", \freq,initVal:[100.rand,200+2000.rand],
			unitWidth:0, numberWidth:60,layout:\horz, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180, -20);
		g.font_(Font("Helvetica",10));
);
(		// no label, so use window name as label
		g=EZRanger(nil, 400@16, nil, \freq,initVal:[100.rand,200+2000.rand],
			unitWidth:0, numberWidth:60,layout:\horz, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180, -90);
		g.window.name="Freq";
		g.font_(Font("Helvetica",10));
);

/////////////////
/// Layout \line2

(		// all features
		g=EZRanger(nil, 300@42," freq  ", \freq,initVal:[100.rand,200+2000.rand],
			unitWidth:30, numberWidth:60,layout:\line2, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180,-160);
);

(		// no unitView, with label
		g=EZRanger(nil, 300@42," freq  ", \freq,initVal:[100.rand,200+2000.rand],
			unitWidth:0, numberWidth:60,layout:\line2, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180,-260);
);

(		// no label
		g=EZRanger(nil, 300@42,nil, \freq, initVal:[100.rand,200+2000.rand],
			unitWidth:30, numberWidth:60,layout:\line2, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180,-360);
		g.window.name="Freq";
);

(		// no label, so use window name as label
		g=EZRanger(nil, 150@42,nil, \freq,initVal:[100.rand,200+2000.rand],
			unitWidth:0, numberWidth:60,layout:\line2, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white));
		g.window.bounds = g.window.bounds.moveBy(-180,-460);
		g.window.name="Freq";
);

/////////////////
/// Layout \vert

(		// all features, small font
		g=EZRanger(nil, 45@300," Vol  ", \db.asSpec.step_(0.01),initVal:[-3-15.rand,-2.rand],
			unitWidth:30, numberWidth:60,layout:\vert, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white,\h));
		g.window.bounds = g.window.bounds.moveBy(250,50);
		g.font_(Font("Helvetica",9));
);
(		// no label, small font
		g=EZRanger(nil, 45@300, nil, \db.asSpec.step_(0.01),initVal:[-3-15.rand,-2.rand],
			unitWidth:30, numberWidth:60,layout:\vert, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white,\h));
		g.window.bounds = g.window.bounds.moveBy(310,50);
		g.font_(Font("Helvetica",9));
);
(		// no Units small font
		g=EZRanger(nil, 45@300, " Vol", \db.asSpec.step_(0.01),initVal:[-3-15.rand,-2.rand],
			unitWidth:0, numberWidth:60,layout:\vert, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white,\h));
		g.window.bounds = g.window.bounds.moveBy(370,50);
		g.font_(Font("Helvetica",9));
);
(		// no unitView, no units small font
		g=EZRanger(nil, 45@300, nil, \db.asSpec.step_(0.01),initVal:[-3-15.rand,-2.rand],
			unitWidth:0, numberWidth:60,layout:\vert, margin:2@2);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),
			Color.grey, Color.white, Color.yellow, background:Color.grey(0.7),
				knobColor: HiliteGradient(Color.grey, Color.white,\h));
		g.window.bounds = g.window.bounds.moveBy(430,50);
		g.font_(Font("Helvetica",9));
);

)

/////////////////

////Sound Example


(	// example to explore a synthesis idea:
p = ProxySpace.push(s.boot);

q = q ? ();
q.freqRange = [200, 2000];
q.ampRange = [0.1, 1];
q.ringRange = [0.1, 10];
q.numRange = [3, 30];

q.soundfunc = { |dens=5|
	Splay.ar(
		Array.fill(exprand(q.numRange[0], q.numRange[1]).asInteger, {
			Ringz.ar(
				Dust.ar(dens),
				exprand(q.freqRange[0], q.freqRange[1]),
				exprand(q.ringRange[0], q.ringRange[1]),
				exprand(q.ampRange[0], q.ampRange[1])
			)
		})
	).distort
};
)
~plong.play;

~plong.fadeTime = 3;
~plong = q[\soundfunc];

(
w = Window("cow herd").front;
w.view.decorator_(FlowLayout(w.bounds.copy.moveTo(0, 0)));

Spec.add(\ring, [0.03, 30, \exp]);
Spec.add(\num, [3, 30, \exp, 1]);

EZRanger(w, 390@20, "numRange", \num, { |sl| q.numRange = sl.value; }, labelWidth: 65)
	.round_(1);

EZRanger(w, 390@20, "freqRange", \freq, { |sl| q.freqRange = sl.value; }, q.freqRange, labelWidth: 65)
	.round_(0.1);
EZRanger(w, 390@20, "ringRange", \ring, { |sl| q.ringRange = sl.value; }, q.ringRange, labelWidth: 65)
	.round_(0.0001);
EZRanger(w, 390@20, "ampRange", \amp, { |sl| q.ampRange = sl.value; }, q.ampRange, labelWidth: 65)
	.round_(0.0001);
Button(w, 190@20).states_([[\newSound]]).action_({~plong = q[\soundfunc] });
)
::
** class:: EZScroller
summary:: Show a subset of items on gui elements
categories:: GUI>EZ-GUI

description::
EZScroller is a vertical slider that allows displaying different subsets of a dynamically changing list of objects on a fixed number of views by scrolling.

EZScroller is used JITLib guis like link::Classes/NodeProxyEditor::, link::Classes/ProxyMixer::, link::Classes/TdefAllGui::, and link::Classes/PdefAllGui::.

examples::
code::
(
w = Window.new("EZScroller test", Rect(100, 400,200, 100)).front;
// 5 displays
v = { |i| DragBoth.new(w, Rect(0, i * 20, 100, 20)) }.dup(5);
// 12 items
a = (1..12);

e = EZScroller(w, Rect(100,0,14,100), v.size, a.size, { |sc|
	var startIndex = sc.value.asInteger.postcs;
	v.do { |drag, i| drag.object_( a[ (startIndex) + i] ? ""); };
	e.visible_(sc.numItems > sc.maxItems); // hide when not useful
});
e.doAction;
)
// change list a, update ezscroller
a = (1..4); e.numItems_(a.size); e.doAction;

a = (1..8); e.numItems_(a.size); e.doAction;
::
** class:: EZSlider
summary:: Wrapper class for label, slider, number box
categories:: GUI>EZ-GUI
related:: Classes/Slider, Classes/NumberBox, Classes/StaticText, Classes/CompositeView, Classes/EZGui

description::
EZSlider is wrapper class which creates an (optional) link::Classes/StaticText::, and a link::Classes/Slider:: plus a link::Classes/NumberBox::. If the parent is code::nil::, then EZSlider will create its own window. See link::Classes/EZGui:: more options.

subsection:: Scrolling and Arrow Keys
EZSlider's number box scrolls by default, using the step size of the link::Classes/ControlSpec::. If the controlSpec's step is set to 0, or is not set, then the the stepping and scrolling will be guessed according to the code::minval:: and code::maxval:: values of the spec on creation of the view.  Unlike the step variable of a regular link::Classes/NumberBox::, code::controlSpec.step:: is also the smallest possible increment for the link::Classes/NumberBox::. By default, the shift-key modifier will allow you to step by 100x code::controlSpec.step::, while the ctrl-key will give you 10x code::controlSpec.step::.  Since the alt-key would give you 0.1 of the minimum step, it is disabled by default, but you can change that by setting code::numberView.alt_step:: to any value you like. Accordingly you can customize the other modifiers to fit your needs. See link::Classes/NumberBox:: and link::Classes/Slider::. This also effects the arrow keys for the slider.

classmethods::

subsection:: Creation / Class Methods

method:: new
argument:: parent
The parent view or window. If the parent is code::nil::, then EZSlider will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@20::.

argument:: label
The label. Default value is code::nil::. If code::nil::, then no link::Classes/StaticText:: is created.

argument:: controlSpec
The link::Classes/ControlSpec:: for scaling the value.

argument:: action
A link::Classes/Function:: called when the value changes. The function is passed the EZSlider instance as its argument.

argument:: initVal
The value to initialize the slider and number box with. If code::nil::, then it uses the link::Classes/ControlSpec::'s default value.

argument:: initAction
A link::Classes/Boolean:: indicating whether the action function should be called when setting the initial value. The default is false.

argument:: labelWidth
Number of pixels width for the label. The default is 60.

argument:: numberWidth
Number of pixels width for the number box. The default is 45.

argument:: unitWidth
Number of pixels width for the unit label. The default is 0. If 0, then no unitLabel is created.

argument:: labelHeight
The default is 20;

argument:: layout
code::\vert::, code::\line2::, or code::\horz::. The default is code::\horz::.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
code::
(
w = Window.new.front;
g = EZSlider( w,         // parent
              390@20,    // bounds
              " test ",  // label
              \freq,     // controlSpec
              { |ez| (ez.value.asString ++" is the value of " ++ ez).postln } // action
);
g.setColors(Color.grey,Color.white)
);

// Simplest version, no parent view, so a window is created
(
	g = EZSlider(label:" test ");
	g.action_({ |ez| (ez.value.asString ++" is the value of " ++ ez).postln });
);
::
The contained views can be accessed via the EZSlider instance variables: code::labelView::, code::sliderView::, code::numberView::.

instancemethods::

subsection:: Accessing Instance and Class Variables

method:: numberView
Returns the numberView.

method:: action
A link::Classes/Function:: or link::Classes/FunctionList:: to be evaluated when the value changes. The first argument will be the EZSlider.

method:: value
The value of the slider.

method:: round
Rounds the values in the number box.

method:: controlSpec
An instance of ControlSpec for scaling the values.

method:: value
Gets/sets the list/menu to the index at value. Does not perform the action.
argument:: val
An link::Classes/Integer::.

method:: valueAction
Sets the value and performs the action at the index value and the global action.
argument:: val
An link::Classes/Integer::.

method:: doAction
Performs the action at the current index and the global action.

method:: set
Set the args after creation. You can only set the label if it was not nil from the beginning.

method:: visible
Sets/gets it the component views are visible.
argument:: bool
An instance of link::Classes/Boolean::. Default is code::true::.

subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: sliderBackground
An instance of link::Classes/Color::. The slider code::background::.
argument:: numBackground
An instance of link::Classes/Color::. The code::numColor:: of the number view.
argument:: numStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the number view.
argument:: numNormalColor
An instance of link::Classes/Color::. The code::normalColor:: of the number view.
argument:: numTypingColor
An instance of link::Classes/Color::. The code::typingColor:: of the number view.
argument:: knobColor
An instance of link::Classes/Color::. The code::knobColor:: of the knob view.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the enclosing view.

method:: font
Set the Font used by all the views.
argument:: font
An instance of link::Classes/Font::.

examples::
code::
(	// basic use
	w=Window.new.front;
	g=EZSlider(w, 400@16," test  ", \freq,unitWidth:30, numberWidth:60,layout:\horz);
	g.setColors(Color.grey,Color.white);
);
g.view.enabled=false
// lots of sliders on on view
(
w=Window.new.front;
w.view.decorator=FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;

20.do{
	EZSlider(w, 392@16," Freq ", \freq,unitWidth:30,initVal:6000.rand, numberWidth:60,layout:\horz)
	.setColors(Color.grey,Color.white)
	.font_(Font("Helvetica",11));

};
);

Window.closeAll  // use this to close all the windows

/////////////////////////////////////////////////////////////////
////////// click these parentheses to see all features and layouts

(

m=nil;
//m=2@2;		// uncomment this for margin

/////////////////
/// Layout \horz

(		// all features, small font
		g=EZSlider(nil, 400@14," freq  ", \freq,unitWidth:30, numberWidth:60,layout:\horz, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,50);
		g.font_(Font("Helvetica",10));
);

(		// no unitView
		g=EZSlider(nil, 400@16," freq  ", \freq,unitWidth:0, numberWidth:60,layout:\horz, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -20);
);
(		// no label, so use window name as label
		g=EZSlider(nil, 400@16, nil, \freq,unitWidth:0, numberWidth:60,layout:\horz, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -90);
		g.window.name="Freq";
);

/////////////////
/// Layout \line2

(		// all features
		g=EZSlider(nil, 300@42," freq  ", \freq,unitWidth:30, numberWidth:60,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,-160);
);

(		// no unitView, with label
		g=EZSlider(nil, 300@42," freq  ", \freq,unitWidth:0, numberWidth:60,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,-260);
);

(		// no label
		g=EZSlider(nil, 300@42,nil, \freq, unitWidth:30, numberWidth:60,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,-360);
		g.window.name="Freq";
);

(		// no lablel, so use window name as label
		g=EZSlider(nil, 150@42,nil, \freq,unitWidth:0, numberWidth:60,layout:\line2, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,-460);
		g.window.name="Freq";
);

/////////////////
/// Layout \vert

(		// all features, small font
		g=EZSlider(nil, 45@300," Vol  ", \db.asSpec.step_(0.01),unitWidth:30, numberWidth:60,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(250,50);
		g.font_(Font("Helvetica",10));
);
(		// no label, small font
		g=EZSlider(nil, 45@300, nil, \db.asSpec.step_(0.01),unitWidth:30, numberWidth:60,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(310,50);
		g.font_(Font("Helvetica",10));
);
(		// no Units small font
		g=EZSlider(nil, 45@300, " Vol", \db.asSpec.step_(0.01),unitWidth:0, numberWidth:60,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(370,50);
		g.font_(Font("Helvetica",10));
);
(		// no unitView, no Units small font
		g=EZSlider(nil, 45@300, nil, \db.asSpec.step_(0.01),unitWidth:0, numberWidth:60,layout:\vert, margin: m);
		g.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey,
			Color.white, Color.yellow,nil,nil, Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(430,50);
		g.font_(Font("Helvetica",10));
);

)




///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////


// Sound example
(
// start server
s.waitForBoot({

var w, startButton, noteControl, cutoffControl, resonControl;
var balanceControl, ampControl;
var node, cmdPeriodFunc;

// define a synth
SynthDef("window-test", { arg note = 36, fc = 1000, rq = 0.25, bal=0, amp=0.4, gate = 1;
		var x;
		x = Mix.fill(4, {
			LFSaw.ar((note + {0.1.rand2}.dup).midicps, 0, 0.02)
		});
		x = RLPF.ar(x, fc, rq).softclip;
		x = RLPF.ar(x, fc, rq, amp).softclip;
		x = Balance2.ar(x[0], x[1], bal);
		x = x * EnvGen.kr(Env.cutoff, gate, doneAction: 2);
		Out.ar(0, x);
	}, [0.1, 0.1, 0.1, 0.1, 0.1, 0]
).add;




// make the window
w = Window("another control panel", Rect(20, 400, 440, 180));
w.front; // make window visible and front window.
w.view.decorator = FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;

// add a button to start and stop the sound.
startButton = Button(w, 75 @ 20);
startButton.states = [
	["Start", Color.black, Color.green(0.7)],
	["Stop", Color.white, Color.red(0.7)]
];
startButton.action = {|view|
		if (view.value == 1) {
			// start sound
			node = Synth( "window-test", [
				"note", noteControl.value,
				"fc", cutoffControl.value,
				"rq", resonControl.value,
				"bal", balanceControl.value,
				"amp", ampControl.value.dbamp ]);
		} {
			// set gate to zero to cause envelope to release
			node.release; node = nil;
		};
};

// create controls for all parameters
w.view.decorator.nextLine;
noteControl = EZSlider(w, 430 @ 20, "Note ", ControlSpec(24, 60, \lin, 1, 36, \note),
	{|ez| node.set( "note", ez.value )}, unitWidth:30)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
cutoffControl = EZSlider(w, 430 @ 20, "Cutoff ", ControlSpec(200, 5000, \exp,0.01,1000,\Hz),
	{|ez| node.set( "fc", ez.value )}, unitWidth:30)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
resonControl = EZSlider(w, 430 @ 20, "Reson ", ControlSpec(0.1, 0.7,\lin,0.001,0.2,\rq),
	{|ez| node.set( "rq", ez.value )}, unitWidth:30)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
balanceControl = EZSlider(w, 430 @ 20, "Balance ", \bipolar,
	{|ez| node.set( "bal", ez.value )},  unitWidth:30)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);

w.view.decorator.nextLine;
ampControl = EZSlider(w, 430 @ 20, "Amp ", \db,
	{|ez| node.set( "amp", ez.value.dbamp )}, -6, unitWidth:30)
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);


// set start button to zero upon a cmd-period
cmdPeriodFunc = { startButton.value = 0; };
CmdPeriod.add(cmdPeriodFunc);

// stop the sound when window closes and remove cmdPeriodFunc.
w.onClose = {
	node.free; node = nil;
	CmdPeriod.remove(cmdPeriodFunc);
};
});
)




// a variant of the above example so one can
// add new parameters and more views are created automatically

(
// start server
s.waitForBoot({

var w, startButton, sliders;
var node, cmdPeriodFunc;
var params, specs;

// define a synth
SynthDef("window-test", { arg note = 36, fc = 1000, rq = 0.25, bal = 0, amp=0.4, width=0, gate = 1;
		var x;
		x = Mix.fill(4, {
			VarSaw.ar((note + {0.1.rand2}.dup).midicps, 0, width, 0.02)
		});
		x = RLPF.ar(x, fc, rq).softclip;
		x = RLPF.ar(x, fc, rq, amp).softclip;
		x = Balance2.ar(x[0], x[1], bal);
		x = x * EnvGen.kr(Env.cutoff, gate, 5, doneAction: 2);
		Out.ar(0, x);
	}, [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0]
).add;


params = ["note", "fc", "rq", "bal", "amp", "width"];
specs = [
	ControlSpec(24, 60, \lin, 1, 36, \note),
	ControlSpec(200, 5000, \exp,0.01,1000,\Hz),
	ControlSpec(0.1, 0.7,\lin,0.001,0.2,\rq),
	ControlSpec(-1, 1, \lin, 0, 0, \pan),
	ControlSpec(0.0001, 2, \exp, 0, 0.3, \vol), // db spec acts weird, so use self made one
	ControlSpec(0, 1, \lin, 0, 0.3, \width),
];

// make the window
w = Window("another control panel", Rect(20, 400, 440, 180));
w.front; // make window visible and front window.
w.view.decorator = FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;


// add a button to start and stop the sound.
startButton = Button(w, 75 @ 20);
startButton.states = [
	["Start", Color.black, Color.green(0.7)],
	["Stop", Color.white, Color.red(0.7)]
];
startButton.action = {|view|
		var args;
		if (view.value == 1) {
			// start sound
			params.do { |param, i|
				args = args.add(param);
				args = args.add(sliders[i].value)
			};
			node = Synth("window-test", args.postcs);
		} {
			// set gate to zero to cause envelope to release
			node.release; node = nil;
		};
};

// create controls for all parameters
w.view.decorator.nextLine;
sliders = params.collect { |param, i|
	EZSlider(w, 430 @ 20, param, specs[i], {|ez| node.set( param, ez.value )})
		.setColors(Color.grey,Color.white, Color.grey(0.7),Color.grey, Color.white, Color.yellow);
};
// set start button to zero upon a cmd-period
cmdPeriodFunc = { startButton.value = 0; };
CmdPeriod.add(cmdPeriodFunc);

// stop the sound when window closes and remove cmdPeriodFunc.
w.onClose = {
	node.free; node = nil;
	CmdPeriod.remove(cmdPeriodFunc);
};

})
)
::
** class:: EZText
summary:: Wrapper class for a label, a text field and a value
categories:: GUI>EZ-GUI
related:: Classes/StaticText, Classes/TextField

description::
EZText is a wrapper class which creates an (optional) link::Classes/StaticText::, and a link::Classes/TextField::. The value is displayed as a compileString in the text field for editing.

subsection:: Some Important Issues Regarding EZText
If the parent is code::nil::, then EZText will create its own link::Classes/Window::. See link::Classes/EZGui:: for more options.

classmethods::

subsection:: Creation / Class Methods

method:: new

argument:: parent
The parent view or window. If the parent is nil, then EZText will create its own link::Classes/Window::, and place it conveniently on the screen if the bounds are a link::Classes/Point::. If the bounds are a link::Classes/Rect::, then the link::Classes/Rect:: determines the window bounds.

argument:: bounds
An instance of link::Classes/Rect:: or link::Classes/Point::. Default value is code::160@20::.

argument:: label
The label. Default value is code::nil::. If code::nil::, then no link::Classes/StaticText:: is created.

argument:: action
A link::Classes/Function:: called when the value changes. The function is passed the EZText instance as its argument.

argument:: initVal
The value to initialize the EZText with.

argument:: initAction
A link::Classes/Boolean:: indicating whether the action function should be called when setting the initial value. The default is false.

argument:: labelWidth
Number of pixels width for the label. The default is 60. In the code::\horz:: layout, if you specify the code::textWidth::, then the code::labelWidth:: is ignored and is set to the code::bounds.width - textWidth::.

argument:: textWidth
Number of pixels width for the number box. The default is 45. In code::\vert:: layout, code::textWidth:: defaults to the code::bounds.width::.

argument:: labelHeight
Default is 20.

argument:: layout
code::\vert::, or code::\horz::. The default is code::\horz::; code::\vert:: is a two line version.

argument:: gap
A link::Classes/Point::. By default, the view tries to get its parent's gap, otherwise it defaults to code::2@2::. Setting it overrides these.

argument:: margin
A link::Classes/Point::. This will inset the bounds occupied  by the subviews of view.

discussion::
Example:
code::
(
w = Window("EZText", Rect(300, 300, 260, 60)).front;
g = EZText( w,          // parent
            250@50,     // bounds
            "testing",  // label
            { |ez| (ez.value.asString ++" is the value of " ++ ez).postln }, // action
            [1, 2, 3],  // initValue
            true        // initAction
);
g.setColors(Color.grey,Color.white);
);

// Simplest version, no parent view, so a window is created
(
	g = EZText(label:" test ");
	g.action_({ |ez| (ez.value.asString ++" is the value of " ++ ez).postln });
);

(
	g = EZText(bounds: Rect( 100, 200, 150, 50), label:" test ", layout: \vert);
	g.action_({ |ez| (ez.value.asString ++" is the value of " ++ ez).postln });
);
::
The contained views can be accessed via the EZText instance variables: code::labelView::, code::textField::.

instancemethods::

method:: textField
Returns the textField.

method:: action
A link::Classes/Function:: to be evaluated when the value changes. Typical use is to type in a new value, and interpret it by hitting the evaluation shortcut. The first argument to the function will be the EZText.

method:: value
Gets/sets the value of the ezText. Does not perform the action.
argument:: inval
Any object.

method:: valueAction
Sets the value and performs the action.
argument:: val
Any object.

method:: doAction
Performs the action.

method:: enabled
Sets/gets whether the textfield is enabled.
argument:: bool
An instance of link::Classes/Boolean::. Default is code::true::.


subsection:: Changing Appearance

method:: setColors
argument:: stringBackground
An instance of link::Classes/Color::. The code::background:: of the label and unit views.
argument:: stringColor
An instance of link::Classes/Color::. The code::stringColor:: of the label and unit views.
argument:: textBackground
An instance of link::Classes/Color::. The code::background:: of the textField.
argument:: textStringColor
An instance of link::Classes/Color::. The code::stringColor:: of the textField.
argument:: textNormalColor
An instance of link::Classes/Color::. The code::normalColor:: of the textField.
argument:: textTypingColor
An instance of link::Classes/Color::. The code::typingColor:: of the textField.
argument:: background
An instance of link::Classes/Color::. The code::background:: of the enclosing view.

method:: font
Set the Font used by all the views.
argument:: font
An instance of link::Classes/Font::.

examples::
code::
// Simplest version
(		// basic use
		w=Window("ez", Rect(300, 300, 300, 50)).front;
		g=EZText(w, 290@40," test  ", textWidth: 220,layout:\horz);
		g.setColors(Color.grey,Color.white);
);


// lots of textFields on one window
(
w=Window.new.front;
w.view.decorator=FlowLayout(w.view.bounds);
w.view.decorator.gap=2@2;

40.do{
		g=EZText(w, 170@16," test  ", textWidth: 120,layout:\horz);
		g.setColors(Color.grey, Color.white, Color.grey(0.8));
};
);


// click these parentheses to see three variants
(

m=nil;
m=2@2;		//comment for no margin

/////////////////
/// Layout \horz

(		// with label
		g=EZText(nil, 170@20," freq  ", textWidth:120,layout:\horz,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180,50);
);

(		// no label. use window name as label
		g=EZText(nil, 120@20, layout:\horz,margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(-180, -90);
		g.window.name="Freq";
);

/////////////////
/// Layout \vert

(		// all features
		g=EZText(nil, 120@60," freq  ", textWidth: 120,layout: \vert, margin:m);
		g.setColors(Color.grey,Color.white,background: Color.grey(0.7));
		g.window.bounds = g.window.bounds.moveBy(100,50);
);

)



// Simplest sound example
(
Tdef(\text).set(\note, [0, 2, 7], \dur, { [0.1, 0.2].choose });

w = Window("EZTexts", Rect(200, 400, 304, 120)).front;
w.addFlowLayout;

TdefGui(Tdef(\text), 0, w);
Tdef(\text).envir.keysValuesDo { |k, v|
	EZText(w, Rect(0,0,300,40), k, { |ez|
		Tdef(\text).envir.put(*[k, ez.value].postcs);
	}, v);
};

Tdef(\text, { |ev|
	var mydur;
	loop {
		mydur = ev.dur;
		(note: ev.note, dur: mydur).postln.play;
		mydur.wait;
	}
}).play;
)

// type these or similar functions into dur and note fields and evaluate:

{ [0.1, 0.2, 0.3].choose }
{ [ 0, 2, 7, 10 ].scramble.keep(rrand(0, 4)) }
::
** class:: Env
summary:: Specification for a segmented envelope
related:: Classes/EnvGen, Classes/IEnvGen, Classes/Pseg
categories:: Control, Envelopes

description::
An Env is a specification for a segmented envelope. Envs can be used both server-side, by an link::Classes/EnvGen:: or an link::Classes/IEnvGen:: within a link::Classes/SynthDef::, and clientside, with methods such as link::#-at:: and link::#-asStream::, below.

An Env can have any number of segments which can stop at a particular value or loop several segments when sustaining. It can have several shapes for its segments.

code::
Env.new([0, 1, 0.9, 0], [0.1, 0.5, 1],[-5, 0, -5]).plot;
::

The envelope is conceived as a sequence of emphasis::nodes:: (not to be confused with a synthesis-Node) each of which has three parameters: a target level, a time duration from the previous node, and a shape. The three parameters for each node are kept in separate arrays as explained below.

note::
In some situations we deal with control points or breakpoints. If these control points have associated x positions (say in an envelope GUI, see link::Classes/EnvelopeView::) they must be converted to time differences between points to be used as nodes in a Env object. The methods link::#*xyc:: and link::#*pairs:: can be used to specify an envelope in terms of points.
::

code::
// an envelope in a synth
(
{
	var env = Env([0, 1, 0.5, 1, 0], [0.01, 0.5, 0.02, 0.5]);
	SinOsc.ar(470) * EnvGen.kr(env, doneAction: 2)
}.play
)
// an envelope to control a parameter in a pattern
(
Pbind(
	\note,  Env([0, 12, 6, 13, 0], [1, 5, 2, 10]),
	\dur, 0.1
).play
)
::

ClassMethods::

private::initClass

method::new
Create a new envelope specification.

argument::levels
an array of levels. The first level is the initial value of the envelope. When the envelope is used with an EnvGen, levels can be any UGen (new level values are updated only when the envelope has reached that point).
When the array of levels contains itself an array, the envelope returns a multichannel output (for a discussion, see link::#multichannel expansion::)

argument::times
an array of durations of segments in seconds. There should be one fewer duration than there are levels, but if shorter, the array is extended by wrapping around the given values.

argument::curve
a link::Classes/Symbol::, link::Classes/Float::, or an link::Classes/Array:: of those. Determines the shape of the envelope segments.

The possible values are:
table::
## code::\step:: || || flat segments
## code::\linear:: || code::\lin:: || linear segments, the default
## code::\exponential:: || code::\exp:: || natural exponential growth and decay. In this case, the levels must all be nonzero and have the same sign.
## code::\sine:: || code::\sin:: || sinusoidal S shaped segments.
## code::\welch:: || code::\wel:: || sinusoidal segments shaped like the sides of a Welch window.
## code::\squared::  || code::\sqr:: || squared segment
## code::\cubed:: || code::\cub:: || cubed segment
## a link::Classes/Float:: || || a curvature value for all segments. 0 means linear, positive and negative numbers curve the segment up and down.
## an link::Classes/Array:: of symbols or floats || || curvature values for each segment.
::

argument::releaseNode
an link::Classes/Integer:: or nil. The envelope will sustain at the release node until released.

argument::loopNode
an link::Classes/Integer:: or nil. If not nil the output will loop through those nodes startign at the loop node to the node immediately preceeding the release node, before back to the loop node, and so on. Note that the envelope only transitions to the release node when released. Examples are below. The loop is escaped when a gate signal is sent, when the output transitions to the release node, as described below.

argument::offset
an offset to all time values (only applies in link::Classes/IEnvGen::).

discussion::
code::
(
{
	var env = Env([0.0, 0.5, 0.0, 1.0, 0.9, 0.0], [0.05, 0.1, 0.01, 1.0, 1.5], -4);
	var envgen = EnvGen.ar(env, doneAction: 2);
	SinOsc.ar(
		envgen * 1000 + 440
	) * envgen * 0.1
}.play
);

::



method::newClear
Creates a new envelope specification with strong::numSegments:: for filling in later.
discussion::
This can be useful when passing Env parameters as args to a link::Classes/Synth::. Note that the maximum number of segments is fixed and cannot be changed once embedded in a link::Classes/SynthDef::. Trying to set an Env with more segments than then this may result in other args being unexpectedly set. See link::#newClear:: example below.

subsection::Standard Shape Envelope Creation Methods
The following class methods create some frequently used envelope shapes based on supplied durations.

method::linen
Creates a new envelope specification which has a trapezoidal shape.

argument::attackTime
the duration of the attack portion.

argument::sustainTime
the duration of the sustain portion.

argument::releaseTime
the duration of the release portion.

argument::level
the level of the sustain portion.

argument::curve
the curvature of the envelope.

discussion::
code::

Env.linen(0.1, 0.2, 0.1, 0.6).test.plot;
Env.linen(1, 2, 3, 0.6).test.plot;
Env.linen(1, 2, 3, 0.6, \sine).test.plot;
Env.linen(1, 2, 3, 0.6, \welch).test.plot;
Env.linen(1, 2, 3, 0.6, -3).test.plot;
Env.linen(1, 2, 3, 0.6, -3).test.plot;
Env.linen(1, 2, 3, 0.6, [[\sine, \welch, \lin, \exp]]).plot;
::

method::triangle
Creates a new envelope specification which has a triangle shape.

argument::dur
the duration of the envelope.

argument::level
the peak level of the envelope.

discussion::
code::
Env.triangle(1, 1).test.plot;
::

method::sine
Creates a new envelope specification which has a hanning window shape.

argument::dur
the duration of the envelope.

argument::level
the peak level of the envelope.

discussion::
code::
Env.sine(1, 1).test.plot;
::

method::perc
Creates a new envelope specification which (usually) has a percussive shape.

argument::attackTime
the duration of the attack portion.

argument::releaseTime
the duration of the release portion.

argument::level
the peak level of the envelope.

argument::curve
the curvature of the envelope.

discussion::
code::
Env.perc(0.05, 1, 1, -4).test.plot;
Env.perc(0.001, 1, 1, -4).test.plot;	// sharper attack
Env.perc(0.001, 1, 1, -8).test.plot;	// change curvature
Env.perc(1, 0.01, 1, 4).test.plot;	// reverse envelope
::


method::pairs
Creates a new envelope specification from coordinates / control points

argument::pairs
an array of pairs [[time, level], ...]

argument::curve
the curvature of the envelope.

discussion::
code::
Env.pairs([[0, 1], [2.1, 0.5],  [3, 1.4]], \exp).plot;
Env.pairs([[0, 1], [3, 1.4], [2.1, 0.5], [3, 4]], \exp).plot; // pairs are sorted according to time
Env.pairs({ { 1.0.rand } ! 2 } ! 16, \exp).plot;
::


method::xyc
Creates a new envelope specification from coordinates / control points with curvature.

argument::xyc
an array of triplets [[time, level, curve], ...]

discussion::
code::
Env.xyc([[0, 1, \sin], [2.1, 0.5, \lin],  [3, 1.4, \lin]]).plot;
Env.xyc([[2.1, 0.5, \lin], [0, 1, \sin], [3, 1.4, \lin]]).plot; // pairs are sorted according to time
Env.xyc({ [1.0.rand, 10.0.rand, -4.rand2] } ! 16, \exp).plot;
::


subsection::Sustained Envelope Creation Methods
The following methods create some frequently used envelope shapes which have a sustain segment. They are typically used in SynthDefs in situations where at the time of starting the synth it is not known when it will end. Typical cases are external interfaces, midi input, or quickly varying TempoClock.

code::
(
SynthDef(\env_help, { |out, gate = 1, amp = 0.1, release = 0.1|
	var env = Env.adsr(0.02, release, amp);
	var gen = EnvGen.kr(env, gate, doneAction: 2);
	Out.ar(out, PinkNoise.ar(1 ! 2) * gen)
}).add
);

a = Synth(\env_help);
b = Synth(\env_help, [\release, 2]);
a.set(\gate, 0); // alternatively, you can write a.release;
b.set(\gate, 0);
::



method::adsr
Creates a new envelope specification which is shaped like traditional analog attack-decay-sustain-release (adsr) envelopes.

argument::attackTime
the duration of the attack portion.

argument::decayTime
the duration of the decay portion.

argument::sustainLevel
the level of the sustain portion as a ratio of the peak level.

argument::releaseTime
the duration of the release portion.

argument::peakLevel
the peak level of the envelope.

argument::curve
the curvature of the envelope.

argument::bias
offset

discussion::
code::
Env.adsr(0.02, 0.2, 0.25, 1, 1, -4).test(2).plot;
Env.adsr(0.001, 0.2, 0.25, 1, 1, -4).test(2).plot;
Env.adsr(0.001, 0.2, 0.25, 1, 1, -4).test(0.45).plot;	// release after 0.45 sec
::

method::dadsr
As link::#*adsr:: above, but with its onset delayed by strong::delayTime:: in seconds. The default delay is 0.1.

method::asr
Creates a new envelope specification which is shaped like traditional analog attack-sustain-release (asr) envelopes.

argument::attackTime
the duration of the attack portion.

argument::sustainLevel
the level of the sustain portion as a ratio of the peak level.

argument::releaseTime
the duration of the release portion.

argument::curve
the curvature of the envelope.

discussion::
code::
Env.asr(0.02, 0.5, 1, -4).test(2).plot;
Env.asr(0.001, 0.5, 1, -4).test(2).plot; // sharper attack
Env.asr(0.02, 0.5, 1, 'linear').test(2).plot; // linear segments
::


method::cutoff
Creates a new envelope specification which has no attack segment. It simply sustains at the peak level until released. Useful if you only need a fadeout, and more versatile than link::Classes/Line::.

argument::releaseTime
the duration of the release portion.

argument::level
the peak level of the envelope.

argument::curve
the curvature of the envelope.

discussion::
code::
Env.cutoff(1, 1).test(2).plot;
Env.cutoff(1, 1, 4).test(2).plot;
Env.cutoff(1, 1, \sine).test(2).plot;
::

method::circle
Creates a new envelope specification which cycles through its values. For making a given envelope cyclic, you can use the instance method link::#-circle::

argument::levels
The levels through which the envelope passes.

argument::times
The time between subsequent points in the envelope, which may be a single value (number), or an array of them. If too short, the array is extended. In difference to the *new method, the size of the times array is the same as that of the levels, because it includes the loop time.

argument::curve
The curvature of the envelope, which may be a single value (number or symbol), or an array of them.  If too short, the array is extended. In difference to the *new method, the size of the curve array is the same as that of the levels, because it includes the loop time.


discussion::
code::
{ SinOsc.ar(EnvGen.kr(Env.circle([0, 1, 0], [0.01, 0.5, 0.2])) * 440 + 200) * 0.2 }.play;
{ SinOsc.ar(EnvGen.kr(Env.circle([0, 1, 0, 2, 0, 1, 0], [0.01, 0.3])) * 440 + 200) * 0.2 }.play;
{ SinOsc.ar(EnvGen.kr(Env.circle([0, 1, 0, (2..4), 0, (1..3), 0], [0.01, 0.3])) * 440 + 200).sum * 0.2 }.play; // multichannel expanded levels
::



subsection::Multichannel expansion
If one of the values within either levels, times, or curves is itself an array, the envelope expands to multiple channels wherever appropriate. This means that when such an envelope is passed to an EnvGen, this EnvGen will expand, and when the envelope is queried via the methods link::#-at:: or link::#-asSignal::, it will return an array of values.

code::
(
{
	var env = Env([0.0, 0.5, 0.0, [1.0, 1.25, 1.5], 0.9, 0.0], [0.05, 0.1, 0.01, 1.0, 1.5], -4);
	var envgen = EnvGen.ar(env, doneAction: 2);
	SinOsc.ar(
		envgen * 1000 + 440
	) * envgen * 0.1
}.play
);

(
{
	var env = Env([1, [1, 2, 3], 0.5, 0.5, [3, 2, 1], 2], [1, 1, 0.5, 1], [[\exp, \sin]]);
	env.plot;
	Splay.ar(SinOsc.ar(EnvGen.kr(env) * 400 + 600)) * 0.1
}.play;
);


(
{
	var levels = (1..30);
	var env = Env([1, levels, 0.5, levels / 2.5, 2], [1, 0.15, 1, 0.25, 0.1], \exp);
	Splay.ar(SinOsc.ar(EnvGen.kr(env) * 400 + 600)) * 0.1
}.play;
);


// accessing the envlope by indexing

e = Env([1, [1, 2, 3], 1], [1, 1], \exp);
e.at(0.5);
e.at(1.8);
e.at(2);

e = Env([1, 1, 1], [1, [1, 2, 3]], \exp);
e.at(0.5);
e.at(2);


// multichannel levels

Env([0.1, 1, 0.1], [1, [1, 2, 3]], \exp).plot;
Env([0.1, 1, 0.1], [1, [1, 2, 3]], [\lin, [\lin, \exp, \sin]]).plot;

Env([1, 1, 0.5, 3, 2], [1, 0.5, 1, 0.25], \exp).plot;
Env([0, 1, 0, 2, 0] * [[1, 2, 3]], [1, 0.5, 1, 0.25], \lin).plot;


// multichannel curves

Env([0.01, 5, 1, 0.5] + 1, [1, 0.5, 1, 0.25], [[\lin, \sqr]]).plot;

Env([0.01, 5, 1, 0.5, 0.001] + 1, [1, 0.5, 1, 0.25, 1], [[\lin, \cub, \sin, \cubed, \welch, \step, \exp]]).plot(bounds: Rect(30, 100, 500, 700));

Env([0.01, 5, 1, 0.5, 0.001] + 1, [1, 0.5, 1, 0.25, 1], [(-4..4)]).plot(bounds: Rect(30, 100, 500, 700));
Env([0.01, 5, 1, 0.5] + 1, [1, 0.5, 1, 0.25], [(-4..4)]).plot(bounds: Rect(30, 100, 500, 700));


Env([[0, 0.01], 1, 0], [0.5, 0.5], [[\lin, \exp], \step]).plot;
Env([[0, 0.01], 1, [0, 0.01]], [0.5, 1], [[\lin, \exp]]).plot;

// multichannel times

Env([[2, 1], 0], [[1, 2]], \lin).plot;
Env([0, 1], [1/(1..5)], [(-4..4)]).plot(bounds: Rect(30, 100, 300, 700));
Env([0, 1], [1/(1..5)], \lin).plot(bounds: Rect(30, 100, 300, 700));


// mixed expansions

Env([1, [ 1, 2, 3, 4, 5 ], 0.5, [3, 2, 1], 2], [1, 0.5, 1, 0.25], [[\exp, \lin]]).plot;
Env([1, [ 1, 2, 3, 4, 5 ], 0.5, 4, 2], [1, 0.5, 1, 0.25], \exp).plot;


// expanding control point envelopes

Env.xyc([[2, 0.5, [\lin, \exp]], [0, 1, \lin], [3, 1.4, \lin]]).plot;
Env.xyc({ [1.0.rand, 1.0.rand, {[\lin, \exp, \step].choose} ! 3] } ! 8).plot

Env.xyc([[[2.0, 2.3], 0.5, \lin], [0, 1, \lin], [3, 1.4, \lin]]).plot; // multiple times


::

InstanceMethods::

private::prAsArray


method::ar, kr
Instead of using an link::Classes/EnvGen:: inside a UGen graph, this message does the same implicitly for convenience. Its argument order corresponds to the most common arguments.

argument::doneAction

An integer representing an action to be executed when the env is
finished playing. This can be used to free the enclosing synth,
etc. See link::Reference/UGen-doneActions::  for more detail.

argument::gate

This triggers the envelope and holds it open while > 0. If the
Env is fixed-length (e.g. Env.linen, Env.perc), the gate argument
is used as a simple trigger. If it is an sustaining envelope
(e.g. Env.adsr, Env.asr), the envelope is held open until the
gate becomes 0, at which point is released.

If strong::gate:: < 0, force release with time code:: -1.0 - gate ::. See link::Classes/EnvGen#Forced release:: example.


argument::timeScale

Scales the durations of the segments.

discussion::
code::
{ Blip.ar(50, 200, Env.perc(1, 0.1, 0.2).kr(2)) }.play;
(
{
	Blip.ar(
		Env({ exprand(3, 2000.0) } ! 18, 0.2, \exp).kr,
		200,
		Env({ rrand(0.1, 0.2) } ! 18 ++ 0, 0.2).kr(2))
	}.play;
)
::

method::blend
Blend two envelopes. Returns a new Env. See link::#blend:: example below.

argument::argAnotherEnv
an Env.

argument::argBlendFrac
a number from zero to one.

method::delay
Returns a new Env based on the receiver in which the start value will be held for strong::delay:: number of seconds.

argument::delay
The amount of time to delay the start of the envelope.

discussion::
code::
a = Env.perc(0.05, 1, 1, -4);
b = a.delay(2);
a.test.plot;
b.test.plot;

a = Env([0.5, 1, 0], [1, 1]).plot;
a.delay(1).plot;
::

method::duration
Set the total duration of times, by stretching them.
discussion::
code::
e = Env([0, 1, 0], [1, 2]);
e.duration;
e.duration = 2;
e.duration;
::

method::totalDuration
Get the total duration of the envelope. In multi-channel envelopes, this is the duration of the longest one.
discussion::
code::
e = Env([0, 1, 0], [[1, 2], 2]);
e.duration;
e.totalDuration;
::

method::circle
circle from end to beginning over the time specified, with the curve specified. See also the class method link::#*circle::

discussion::
code::
(
{ SinOsc.ar(
	EnvGen.kr(
		Env([6000, 700, 100], [1, 1], ['exp', 'lin']).circle.postcs)
	) * 0.1
	+ Impulse.ar(1) }.play;
)

(
{ SinOsc.ar(
	EnvGen.kr(
		Env([6000, 700, 100], [1, 1], ['exp', 'lin']).circle(1).postcs,
		MouseX.kr > 0.5)
	) * 0.1
	+ Impulse.ar(1) }.play;
)
::

method::test
Test the envelope on the default link::Classes/Server:: with a link::Classes/SinOsc::.

argument::releaseTime
If this is a sustaining envelope, it will be released after this much time in seconds. The default is 3 seconds.

method::plot
Plot this envelope's shape in a window.

argument::size
The size of the plot. The default is 400.

argument::bounds
the size of the plot window.

argument::minval
the minimum value in the plot. Defaults to the lowest value in the data.

argument::maxval
the maximum value in the plot. Defaults to the highest value in the data.

argument::parent
a window to place the plot in. If nil, one will be created for you.

method::asSignal
Returns a link::Classes/Signal:: of size strong::length:: created by sampling this Env at strong::length:: number of intervals. If the envelope has multiple channels (see link::#multichannel expansion::), this method returns an array of signals.

method::asArray
Converts the Env to an link::Classes/Array:: in a specially ordered format. This allows for Env parameters to be settable arguments in a SynthDef. See example below under link::#newClear::.

method::asMultichannelArray
Converts the Env to an link::Classes/Array:: in a specially ordered format, like link::#asArray::, however it always returns an array of these data sets, corresponding to the number of channels of the envelope.

method::isSustained
Returns true if this is a sustaining envelope, false otherwise.

method::range, exprange
Returns a copy of the Env whose levels have been mapped onto the given linear or exponential range.
discussion::
code::
a = Env.adsr;
a.levels;
a.range(42, 45).levels;
a.exprange(42, 45).levels;

(
// Mapping an Env to an exponential frequency range:
{
	SinOsc.ar(EnvGen.ar(Env.perc(0.01, 0.7).exprange(40, 10000), doneAction: 2)) * 0.2;
}.play
)
::

subsection::Client-side Access and Stream Support
Sustain and loop settings have no effect in the methods below.

method::at
Returns the value of the Env at strong::time::. If the envelope has multiple channels, this method returns an array of levels.

argument::time
A number or an array of numbers to specify a cut in the envelope. If time is an array, it returns the corresponding levels of each time value, and if the envelope has multiple channels, it returns an array of values. A combination of both returns a two-dimensional array.

discussion::
code::
e = Env.triangle(1, 1);
e.at(0.5);
e.at([0.5, 0.7]);

e = Env([1, [1, 2, 3], 1], [1, 1], \exp);
e.at(0.5);
e.at(1.8);
e.at(2);
e.at([0.5, 1.2]);

e = Env([1, 100, 1], [1, [1, 2, 3]], \exp);
e.at(0.5);
e.at(2);
e.at([1, 2, 4]);


::

method::embedInStream
Embeds this Env within an enclosing link::Classes/Stream::. Timing is derived from code::thisThread.beats::.

method::asStream
Creates a Routine and embeds the Env in it. This allows the Env to function as a link::Classes/Stream::.
discussion::
code::
(
{
e = Env.sine.asStream;
5.do({
	e.next.postln;
	0.25.wait;
})}.fork
)
::

Examples::

code::
s.boot; 	//.test below will run a synthesis example
		// to demonstrate the envelope, so the Server must be on

// different shaped segments: .plot graphs the Env
Env.new([0,1, 0.3, 0.8, 0], [2, 3, 1, 4],'linear').test.plot;
Env.new([0.001, 1, 0.3, 0.8, 0.001], [2, 3, 1, 4],'exponential').test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4],\sine).test.plot;
Env.new([0.001, 1, 0.3, 0.8, 0.001],[2,3,1,4],\welch).test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4],'step').test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], -2).test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], 2).test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], [0, 3, -3, -1]).test.plot;
::

If a release node is given, and the gate input of the EnvGen is set to zero, it outputs the nodes after the release node:

code::
// release node is node 1; takes 0.5 seconds to go from 0 to 1,
// sustains at level of 1, then released after three seconds
// (test causes the release after three seconds, given the argument 3),
// taking 2 seconds to finish
Env.new([0,1,0],[0.5,2],'linear',1).test(3).plot

// more complex examples
// release node is node 2; releases after 5 sec
Env.new([0.001,1,0.3,0.8,0.001],[2,3,1,4] * 0.2, 2, 2).test(5).plot;
Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,3,1,2,2,1] * 0.2, 2, 2).test(5).plot;

// early release: goes straight onto the release node after 0.1 seconds
Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,3,1,2,2,1] * 0.2, 2, 2).test(0.1).plot;
::

If a loop node is given, the EnvGen outputs the nodes between the loop node and the release node (not including the release node itself) until it is released:

code::
// release node is node 2, loop node is node 0: so loops around nodes 0 (lvl 1, dur 0.5)
// and 1 (lvl 0.1, dur 0.5) 		//until released after 3.5 seconds
Env.new([0,1,0.1,0],[0.5,0.5,2], 'lin', 2, 0).test(3.5).plot;

// this just sustains at node 0, because there is no other node to loop around!
Env.new([0,1,0],[0.5,2], 'lin', 1, 0).test(3.5).plot;

// more complex example: release node is node 3, loop node is node 1
Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,1,1,2,3,1] * 0.1, 'lin', 3, 1).test(3).plot;
::

note::
The starting level for an envelope segment is always the level you are at right now. For example when the gate is released and you jump to the release segment, the level does not jump to the level at the beginning of the release segment, it changes from whatever the current level is to the goal level of the release segment over the specified duration of the release segment.

There is an extra level at the beginning of the envelope to set the initial level. After that each node is a goal level and a duration, so node zero has duration equal to times[0] and goal level equal to levels[1].

The loop jumps back to the loop node. The endpoint of that segment is the goal level for that segment and the duration of that segment will be the time over which the level changed from the current level to the goal level.
::

subsection::newClear
code::
(
SynthDef(\help_Env_newClear, { |out = 0, gate = 1|
	var env, envctl;
	// make an empty 4 segment envelope
	env = Env.newClear(4);
	// create a control argument array
	envctl = \env.kr(env.asArray);
	Out.ar(out, SinOsc.ar(EnvGen.kr(envctl, gate), 0) * -12.dbamp);
}).add;
)

Synth(\help_Env_newClear, [\env, Env([700,900,900,800], [1,1,1], \exp)]); // 3 segments

// reset then play again:
Synth(\help_Env_newClear, [ \env, Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)]);

// the same written as an event:
(instrument: \help_Env_newClear, env: Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)).play;
::

note:: The above technique currently doesn't work with multichannel expanded envelopes (See: link::#multichannel expansion::)::



subsection::blend
code::
a = Env([0, 0.2, 1, 0.2, 0.2, 0], [0.5, 0.01, 0.01, 0.3, 0.2]);
a.test.plot;

b = Env([0, 0.4, 1, 0.2, 0.5, 0], [0.05, 0.4, [0.01, 0.1], 0.1, 0.4]);
b.test.plot;

(
Task({
	f = (0, 0.2 .. 1);
	f.do { |u|
		blend(a, b, u).test.plot;
		2.wait;
		Window.allWindows.pop.close; // close last opened window
	}
}).play(AppClock);
)

// blend in a SynthDef
(
SynthDef(\help_EnvBlend, { | factor = 0 |
	Out.ar(0, EnvGen.kr(blend(Env.perc, Env.sine, factor), 1.0, doneAction: 2)
		* SinOsc.ar(440,0,0.1)
	)
}).add
);

(
{
	var factors = (0, 0.1..1);
	factors.do {|f| Synth(\help_EnvBlend, [\factor, f.postln]); 1.wait };
}.fork
);
::

** class:: EnvGate
summary:: singleton fade envelope
categories:: Libraries>JITLib>NodeProxy
related:: Classes/EnvGen

description::
Convenience class for an envelope generator combining fadeTime and gate arguments.

ClassMethods::

method::new
Returns an link::Classes/EnvGen::.

argument::i_level
initial level of envelope (if set to 1, it starts open)

argument::gate
a gate input. if nil, EnvGate creates a link::Classes/NamedControl:: named 'gate'

argument::fadeTime
an input for both attack and decay time. if nil, EnvGate creates a link::Classes/NamedControl:: named 'fadeTime' (default time: 0.02)

argument::doneAction
doneAction of the link::Classes/EnvGen::

argument::curve
envelope curve

Examples::

code::
a = { LPF.ar(Saw.ar(200), 600) * EnvGate.new }.play;
a.set(\fadeTime, 2);
a.release;

// the same as:
a.set(\gate, 0);

// several env gates can coexist in one synth def.
(
a = {
	var sound1 = LPF.ar(Saw.ar(80), 600) * EnvGate.new;
	var sound2 = RLPF.ar(Saw.ar(200) * 0.5, 6000 * EnvGate.new + 60, 0.1) * EnvGate.new;
	sound1 + sound2
}.play;
)
a.set(\fadeTime, 5);
a.release;
::
** class:: EnvGen
summary:: Envelope generator
related:: Classes/Linen, Classes/Env
categories::  UGens>Envelopes


Description::

Plays back break point envelopes. The envelopes are instances of the
link::Classes/Env:: class. The envelope and the arguments for  code::levelScale:: ,
code::levelBias:: , and  code::timeScale::
are polled when the EnvGen is triggered and remain constant for the
duration of the envelope.

code::
{ PinkNoise.ar(EnvGen.kr(Env.perc, doneAction: 2)) }.play
::

classmethods::

private::convertEnv

method::ar, kr

argument::envelope

An link::Classes/Env:: instance, or an Array of Controls.
(See link::Classes/Control::  and the example below for how to use
this.)

The envelope is polled when the EnvGen is triggered. The Env inputs can be other UGens.


argument::gate

This triggers the envelope and holds it open while > 0. If the
Env is fixed-length (e.g. Env.linen, Env.perc), the gate argument
is used as a simple trigger. If it is an sustaining envelope
(e.g. Env.adsr, Env.asr), the envelope is held open until the
gate becomes 0, at which point is released.

If strong::gate:: < 0, force release with time code:: -1.0 - gate ::. See link::#Forced release:: below.

argument::levelScale

Scales the levels of the breakpoints.


argument::levelBias

Offsets the levels of the breakpoints.


argument::timeScale

Scales the durations of the segments.


argument::doneAction

An integer representing an action to be executed when the env is
finished playing. This can be used to free the enclosing synth,
etc. See link::Reference/UGen-doneActions::  for more detail.

discussion::
note::
The actual minimum duration of a segment is not zero, but one sample step for audio rate and one block for control rate. This may result in asynchronicity when in two envelopes of different number of levels, the envelope times add up to the same total duration. Similarly, when modulating times, the new time is only updated at the end of the current segment - this may lead to asynchronicity of two envelopes with modulated times.
::

code::

// as amplitude envelope
(
{
	var env = Env([0, 1, 0.5, 1, 0], [0.01, 0.5, 0.02, 0.5]);
	SinOsc.ar(470) * EnvGen.kr(env, doneAction: 2)
}.play
)

// as amplitude and modulation envelope
(
{
	var env = Env([0, 1, 0.5, 0.8, 0, 1.2, 0], [0.01, 0.5, 0.02, 0.5, 0.2, 0.5]);
	var gate = Impulse.kr(MouseX.kr(0.2, 3), 0.5);
	var gen = EnvGen.kr(env, gate);
	SinOsc.ar(270, SinOsc.ar(gen * 473)) * gen * 0.2
}.play
)
// EnvGen multichannel expands when passed a multichannel envelope
(
{ 
	SinOsc.ar(
		EnvGen.kr(
			Env.circle([0, 1, 0, (2..4), 0, LFNoise1.kr(0.1 ! 5) * 10, 0], [0.01, 0.6])
		) 
		* 240 + 300
	).sum * 0.2 
}.play; 
)
::

Examples::

code::
// retriggered envelope by Dust
(
{
	var env = Env([0.0, 0.5, 0.0, 1.0, 0.9, 0.0], [0.05, 0.1, 0.01, 1.0, 1.5], -4);
	var envgen = EnvGen.ar(env, Dust.ar(1));
	SinOsc.ar(
		envgen * 1000 + 440
	) * envgen * 0.1
}.play
);

// two channels
(
{
	var env = Env([0.0, [-0.2, 0.5], 0.0, 1.0, [-0.4, 0.9], 0.0], [0.05, 0.1, 0.01, 1.0, 1.5], -4);
	var envgen = EnvGen.ar(env, Dust.ar([1, 1]));
	SinOsc.ar(
		envgen * 440 + 550
	) * envgen * 0.1
}.play
);

// an envelope in a SynthDef can be used to limit the synth's lifetime (doneAction: 2)

(
SynthDef(\env_help, { | out, gate = 0, freq = 440 |
    var z;
    z = EnvGen.kr(Env.perc, doneAction: 2) * SinOsc.ar(freq, 0, 0.1);
    Out.ar(out, z)
}).add;
)

(
fork {
	10.do {
		Synth(\env_help);
		0.2.rand.wait;
	}
}
)


// turn on
a.set(\gate, 1);

// turn off
a.set(\gate, 0);

// it does not matter to what value the gate is set, as long as it is > 0
a.set(\gate, 2);

a.free;

// using a gated envelope to gate a sound:
(
SynthDef(\env_help, { | out, gate = 0, freq = 440, doneAction = 0 |
    var z = EnvGen.kr(Env.adsr, gate, doneAction: doneAction) * SinOsc.ar(freq, 0, 0.1);
    Out.ar(out, z)
}).add;
)

a = Synth(\env_help);


// turn on
a.set(\gate, 1);

// turn off
a.set(\gate, 0);

// it does not matter to what value the gate is set, as long as it is > 0
a.set(\gate, 2);

a.set(\doneAction, 2, \gate, 0); // set doneAction to two to let the synth free itself

a.free; // alternatively, free it directly.
::

subsection:: Specifying an envelope for each new synth
code::
(
SynthDef(\help_Env_newClear, { |out = 0|
	var env, envctl;
	// make an empty 4 segment envelope
	env = Env.newClear(4);
	// create a control argument array
	envctl = \env.kr(env.asArray);
	Out.ar(out, 
		SinOsc.ar(EnvGen.kr(envctl, \gate.tr), 0, 0.3) // the gate control is a trigger
	); 
}).add;
)

Synth(\help_Env_newClear, [\gate, 1, \env, Env([700,900,900,800], [1,1,1], \exp)]); // 3 segments

// reset then play again:
Synth(\help_Env_newClear, [\gate, 1, \env, Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)]);

// the same written as an event:
(instrument: \help_Env_newClear, gate: 1, env: Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)).play;

::

subsection:: Forced release
If the gate of an EnvGen is set to -1 or below, then the envelope will cutoff immediately.
The time for it to cutoff is the amount less than -1, with -1 being as fast as possible, -1.5 being a cutoff in 0.5 seconds, etc.
The cutoff shape is linear.
code::
(
SynthDef(\stealMe, { |out, gate = 1|
    Out.ar(out, {BrownNoise.ar}.dup * EnvGen.kr(Env.asr, gate, doneAction:2))
}).add;
)

a = Synth(\stealMe);
a.release(3); //  // cutoff in 3 seconds

// this is how the OSC data looks like:
s.sendMsg(\s_new, \stealMe, 1001, 1, 0);
s.sendMsg(\n_set, 1001, \gate, -1.1); // cutoff in 0.1 seconds
::

If the synthDef has an arg named "gate", the convenience method of Node can be used: code::node.release(releaseTime)::
code::
d = { arg gate=1; {BrownNoise.ar}.dup * EnvGen.kr(Env.asr, gate, doneAction:2) }.play;
d.release(3);
::

subsection:: Fast triggering tests
code::
(
{
    EnvGen.kr(
        Env.new([ 0.001, 1, 0.5, 0 ], [ 0.01, 0.3, 1 ], -4, 2, nil),
        Impulse.kr(10)
    ) * SinOsc.ar(440, 0, 0.1)
}.play;
)

(
{
    EnvGen.kr(
        Env.perc( 0.1, 0.0, 0.5, 1, \welch ),
        Impulse.kr(100),
        timeScale: 0.1
    ) * SinOsc.ar(440, 0, 0.3)
}.play;
)
::

subsection:: Modulating the levelScale
code::
// no, it doesn't take a ugen in ...
(
{
    EnvGen.kr(
        Env.asr( 0.1, 1.0, 0.5, \welch ),
        1.0,
        FSinOsc.ar(1.0).range(0.0, 1.0),
        timeScale: 0.1
    ) * SinOsc.ar(440, 0, 0.3)
}.play;
)

// ...but an .ir rate input, a float or an ir rate ugen like Rand would work
(
{
    EnvGen.kr(
        Env.asr( 0.1, 1.0, 0.5, \welch ),
        1.0,
        Rand(0.1, 1.0),
        timeScale: 0.1
    ) * SinOsc.ar(440, 0, 0.3)
}.play;
)
::

subsection::More examples

For more information about the emphasis::control bus mapping:: used in the line code::a = Synth(\sine, [freq: f.asMap]);::, see link::Classes/Node#-map:: and link::Classes/Bus#-asMap::.

code::

// Changing an Env while playing
(
SynthDef(\env, { arg i_outbus=0;
	var env, envctl;
	
	// make a dummy 8 segment envelope
	env = Env.newClear(8);
	
	// create a control argument array
	envctl = \env.kr( env.asArray );
	
	ReplaceOut.kr(i_outbus, EnvGen.kr(envctl, doneAction: 2));
}).add;
)

(
SynthDef(\sine, { |freq = 0|
	Out.ar(0, SinOsc.ar(freq, 0, 0.2));
}).add;
)

f = Bus.control(s, 1);
f.set(800);

// use f's control bus value for frequency
// i.e. *map* the control to read from the bus
a = Synth(\sine, [freq: f.asMap]);

Synth(\env, [i_outbus: f, env: Env([700, 900, 900, 800], [1, 1, 1]*0.4, \exp)]);

Synth(\env, [i_outbus: f, env: Env([1000, 1000, 800, 1000, 900, 1000], [1, 1, 1, 1, 1]*0.3, \step)]);

a.free;
f.free;
::
** class:: EnvelopeView
redirect:: implClass
summary:: A configurable view with nodes and connections
categories:: GUI>Views
related:: Classes/MultiSliderView, Classes/SCEnvelopeEdit

DESCRIPTION::

A view which can graphically display nodes at x/y coordinates, connection lines, cross-connections, node markers, and labels. All of the values for these are stored in arrays. While this view is typically used to make editable envelopes interfaces, it can be used to draw very complex interconnection graphs as well.

You can make the view display an link::Classes/Env:: using link::#-setEnv::. Note however that the view will work on a copy of the data of the Env object, therefore moving the nodes through the view will have no effect on the Env.

You can also define nodes with arrays of x and y values using link::#-value::, and the connections using link::#-connect::.

SUBSECTION:: Appearance

In strong::Qt GUI::, the view supports two strong::display styles::: the default one draws nodes as small dots, with labels next to them, while another style draws nodes as rounded rectangles with labels drawn inside. See link::#-style::.

A strong::label:: for each of the nodes can be set using link::#-strings:: and link::#-setString::.

SUBSECTION:: Interaction

Nodes can be selected and moved using mouse. Shift-clicking a node will add it to the selection.

You can also move selected nodes and change selection using keyboard. In strong::Qt::, pressing the arrow keys will move selected nodes (as long as link::#-step:: is larger than 0). Pressing the left or right arrow keys while holding down Alt will select previous or next node, and holding down Shift will extend selection to the left or to the right. Other GUI kits may differ.

In strong::Qt::, link::#-keepHorizontalOrder:: allows you to enforce the order of nodes in horizontal direction to match their index order. In that case, node movement to the left and to the right will be restricted by the positions of their immediate neighbours. This is especially useful when EnvelopeView is used to display an link::Classes/Env::.

In strong::Qt::, link::#-elasticSelection:: determines whether moving multiple nodes will be blocked altogether if any of the nodes meet an obstacle (the view bounds or a neighbour node), or only those individual nodes will be blocked.

Node selection can also be changed programmatically using link::#-index::, link::#-selectIndex::, and link::#-deselectIndex::. The link::#-index#current:: node can be moved programmatically using link::#-x:: and link::#-y::.

INSTANCEMETHODS::

SUBSECTION:: Data

METHOD:: setEnv
	Sets an link::Classes/Env:: to be displayed by the view. The view will extract data from the Env object to display (times, values and curve types).

	Any nodes existent prior to calling this method will be removed.

	argument::
		An Env.


METHOD:: value
	code::value:: retrieves the node positions, returning an array in the format of the Argument below. code::value_(anArray):: Sets the positions of the nodes, creating them if not existent.

	If there were already existent nodes and their amount is different than the amount of x/y pairs in the argument, nodes will be added or removed (in order of creation reversed) until the amounts match, and then the new values will be applied.

	argument::
		An Array containing two other Arrays, of which one contains the horizontal and the other the vertical position of the new nodes. The values must be between 0 and 1. For example: code:: [[ x1, x2, x3, ... ], [ y1, y2, y3, ... ]] ::

METHOD:: valueAction
	Sets link::#-value:: to the argument and triggers the link::#-action::.

METHOD:: x
	The horizontal position of the emphasis::current:: node.

	argument::
		A Float between 0 and 1.

METHOD:: y
	The vertical position of the emphasis::current:: node.

	argument::
		A Float between 0 and 1.

METHOD:: currentvalue
	Synonym for link::#-y::.

METHOD:: curves
	The shapes of connections between nodes. See below for the valid objects that describe a shape.

	If a single shape is given, it will be applied to all the existing nodes. If an Array of shapes is given, each of its elements will be applied to an existing node, in order of index.

	A connection curve shape applied to a node will determine the shape of the connections originating at that node. If no connections have been created using link::#-connect::, the origin node of a connection is the one with lower index. If there are such connections however, their origin is the node that was passed as the first argument to link::#-connect::.

	argument::
		The valid objects to describe a shape are listed in link::Classes/Env#*new::. The argument can be either a single, or an Array of those values.

METHOD:: strings
	The labels of the nodes.

	note:: In order for the labels to be visible, you might need to ensure that the link::#-strokeColor:: contrasts the link::#-fillColor:: (depending on how the view draws the nodes and the labels).
	::

	argument::
		An Array of Strings.

METHOD:: setString
	Sets the label of the node at the given index.

	note:: In order for the label to be visible, you might need to ensure that the link::#-strokeColor:: contrasts the link::#-fillColor:: (depending on how the view draws the nodes and the labels).::

	argument::
		A String.

METHOD:: setFillColor
	Sets the color used to draw the inside of the node at the given index.

	argument:: index
		An Integer.
	argument:: color
		A Color.

METHOD:: setThumbWidth
	Sets the width of the node at the given index.

    NOTE:: For compatibility with existing code, this will set the link::#-style:: to strong::'rects'::. ::

	argument:: index
		An Integer.
	argument:: width
		An Integer.

METHOD:: setThumbHeight
	Sets the height of the node at the given index.

    NOTE:: For compatibility with existing code, this will set the link::#-style:: to strong::'rects'::. ::

	argument:: index
		An Integer.
	argument:: height
		An Integer.

METHOD:: setThumbSize
	Sets both width and height of the node at the given index to code::size::.

	argument:: index
		An Integer.
	argument:: size
		An Integer.


METHOD:: connect
	Removes any connections created when the link::#-value:: was set, and then creates new ones from the node at index given in the first argument to each of the nodes at indexes given in the second argument.

	argument:: index
		An Integer - the index of the node to become one end of all the new connections.
	argument:: connections
		An Array of Integers - indexes of nodes, each to become the second end to a new connection created.

METHOD:: selection
	note::Only in Qt GUI::
	Returns an array of indexes of all selected nodes.


SUBSECTION:: Appearance

METHOD:: style
    NOTE:: Only available in Qt GUI ::

    One of the following drawing styles:

    list::

    ## strong::'dots':: - nodes are drawn as small dots within a larger circle indicating the area of mouse sensitivity. Labels are drawn next to the dots (see link::#-setString::). This style always draws nodes with emphasis::equal width and height::, and will use the smaller of the node's sizes, if different (it never draws ellipses).

    ## strong::'rects':: - nodes are drawn as rounded rectangles. Labels are drawn within the bounds of the rectangles.
    ::

    NOTE:: For compatibility with existing code, calling any of link::#-thumbWidth::, link::#-thumbHeight::, link::#-setThumbWidth::, or link::#-setThumbHeight:: will automatically switch style to strong::'rects'::. You can still set a different style afterwards.
    ::

    argument::
        One of the symbols: code::\dots:: or code::\rects::. Alternatively, an integer 0 or 1, for each style respectively.

    returns:: An integer 0 or 1.

METHOD:: drawLines
	Whether to draw the connections between the nodes.

	argument::
		A Boolean.

METHOD:: drawRects
	Whether to draw the nodes

	argument::
		A Boolean.


METHOD:: gridOn
	Whether to draw the grid.

	argument::
		A Boolean.

METHOD:: grid
	The resolution of the grid.

	argument::
		A Point of which x and y correspond to grid spacing on the horizontal and the vertical axis, respectively. If one of the two is 0, the grid on that axis will not be drawn.

METHOD:: thumbWidth
    Sets the width of all nodes.

    NOTE:: For compatibility with existing code, this will set the link::#-style:: to strong::'rects'::. ::

	argument::
		An Integer.

METHOD:: thumbHeight
    Sets the height of all nodes.

    NOTE:: For compatibility with existing code, this will set the link::#-style:: to strong::'rects'::. ::

	argument::
		An Integer.

METHOD:: thumbSize
	Sets both link::#-thumbWidth:: and link::#-thumbHeight:: to the argument.

METHOD:: strokeColor
	The color used to draw the connections and the node labels.

	argument::
		A Color.

METHOD:: fillColor
	The default color used to draw the nodes. If the color of a specific node has been set using link::#-setFillColor::, it will take precedence.

	argument::
		A Color.

METHOD:: selectionColor
	The color of a node when it is selected.

	argument::
		A Color.


METHOD:: gridColor
	The color of the grid.

	argument::
		A Color.

METHOD:: colors
	Sets the link::#-strokeColor:: and the link::#-fillColor:: to the arguments, respectively.



SUBSECTION:: Interaction

METHOD:: index
	The index of the emphasis::current:: node, i.e. the node affected by link::#-x:: and link::#-y:: methods.

    In strong::Qt::, this is the selected node with lowest index, or -1 if no selection.

    In strong::Cocoa::, this is the last node selected, or -1 if no selection.

    In strong::SwingOSC::, this is the last node clicked, regardless of selection.

	argument::
		An Integer.

METHOD:: lastIndex
    The last node selected, regardless of the current state of selection.


METHOD:: selectIndex
	Selects the node at given index and makes it the current one, i.e. link::#-currentvalue:: will relate to that node. As a special case, if the argument is -1 all nodes will be deselected.

	argument::
		An Integer.

METHOD:: deselectIndex
	Deselects the node at given index.

	note:: Not available in strong:: Cocoa GUI ::. ::

	argument::
		An Integer.

METHOD:: editable
	Whether any node is editable.

	argument::
		A Boolean.

METHOD:: setEditable
	Sets whether the node at given index is editable. Regardless of this, no node will be editable unless link::#-editable:: is code::true::.

	argument:: index
		An Integer.

	argument:: flag
		A Boolean.

METHOD:: step
	Makes the nodes snap (i.e. quantized) to the nearest multiple of the argument. Unless this is larger than 0, nodes will not be movable using keyboard.

	argument::
		A Float.

METHOD:: keepHorizontalOrder
	note:: Only available in strong::Qt GUI:: ::

	Whether the position of nodes on the horizontal axis shall be restricted by their immediate neighbours (in order of their index).

	Setting this to code::true:: will immediately modify the positions of existing nodes to match the order.

	argument::
		A Boolean.

METHOD:: elasticSelection
	note:: Only available in strong::Qt GUI:: ::

	Whether the relative positions of nodes within the selection can change when the selection is moved using mouse or keyboard, in order to adapt to obstacles (the view bounds or, in case link::#-keepHorizontalOrder:: is code::true::, a neighbour node).

	If this is code::false::, movement of multiple nodes will be blocked altogether when an obstacles is met, otherwise only the individual nodes will be blocked at their obstacles.

	argument::
		A Boolean.


SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user moves a node.

METHOD:: metaAction
	The action object evaluated whenever the user moves a node while the Ctrl key is pressed.

METHOD:: defaultKeyDownAction

    Implements the default behavior on key presses.

    In Qt, the default behavior is defined in the C++ implementation of the view instead of this method. See link::Classes/View#Key and mouse event processing:: for explanation of how to override the behavior.




SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The link::#-value::.

METHOD:: defaultCanReceiveDrag
	returns::
		True for any drag data, but the data should be in the same format as link::#-value::.

METHOD:: defaultReceiveDrag
	If the drag data is of the acceptable form (see link::#-defaultCanReceiveDrag:: above), sets link::#-value:: using that data.



EXAMPLES::

Use as envelope view
code::
(
// use shift-click to keep a node selected
w = Window("envelope", Rect(150 , Window.screenBounds.height - 250, 250, 100)).front;
w.view.decorator = FlowLayout(w.view.bounds);

b = EnvelopeView(w, Rect(0, 0, 230, 80))
	.drawLines_(true)
	.selectionColor_(Color.red)
	.drawRects_(true)
	.resize_(5)
	.step_(0.05)
	.action_({arg b; [b.index, b.value].postln})
	.thumbSize_(5)
	.value_([[0.0, 0.1, 0.5, 1.0],[0.1,1.0,0.8,0.0]]);
w.front;
)

// show grid
b.gridOn_(true);

// show Env
b.setEnv(Env.asr(0.5,1, 0.2));

// make the first point unmoveable
(
b.setEditable(0,false);
)
::

Use shift click to select/unselect the points
code::
(
w = Window("envelope", Rect(150 , Window.screenBounds.height - 250, 400, 150)).front;
w.view.decorator = FlowLayout(w.view.bounds);

b = EnvelopeView(w, Rect(0, 0, 350, 100))
	.thumbSize_(5)
	.drawLines_(true)
	.fillColor_(Color.green)
	.selectionColor_(Color.red)
	.drawRects_(true)
	.value_([(0.0, 0.1 .. 1.0), (0.0, 0.1 .. 1.0)])
	.setEditable(0,false);
)

(
r = Routine({
	var j = 0;
	20.do({ arg i;
		b.selectIndex((b.size - 1).rand.abs);
		0.1.wait;
		b.x_(1.0.rand.abs);
		b.y_(1.0.rand.abs);
	});
	b.selectIndex(-1);
});
AppClock.play(r);
)
::

Show boxes with a string in it:
code::
(
a = Window("text-boxes", Rect(200 , 450, 450, 450));
a.view.decorator = FlowLayout(a.view.bounds);

b = EnvelopeView(a, Rect(0, 0, 440, 440))
	.thumbWidth_(60.0)
	.thumbHeight_(15.0)
	.drawLines_(true)
	.drawRects_(true)
	.selectionColor_(Color.red)
	.value_([[0.1, 0.4, 0.5, 0.3], [0.1, 0.2, 0.9, 0.7]]);
4.do({arg i;
	b.setString(i, ["this", "is", "so much", "fun"].at(i));
	b.setFillColor(i,[Color.yellow, Color.white, Color.green].choose);
});
a.front;
)

(
b.connect(3, [2.0,0.0,1.0]); // the text objects can be connected
b.connect(0,[2.0,3.0,1.0]);
)
::
** class:: EnvirGui
summary:: display the contents of an environment for editing
categories:: Libraries>JITLib>GUI
related:: Classes/EZText, Classes/TdefGui, Classes/PdefGui

description::
EnvirGui displays all keys and values of an environment, so one can change them flexibly. Single number get displayed with an link::Classes/EZSlider::, pairs of numbers with an link::Classes/EZRanger::, and anything else is shown as an link::Classes/EZText:: (a text field).

ClassMethods::

subsection::Creation

method::new
create a new EnvirGui

code::
// simple example
g = EnvirGui.new(nil, 5);				// empty with 5 slots
g.object_((a: 1, b: \werty, freq: [500, 2000]));	// put some things in
g.envir.put(\karl, \otto1);				// one more
g.envir.putAll((b: -12, r: 1, s: 2, t: 3, u: 4, v: 5))

g.object_((x: 2));	// put something else in

g.envir.putAll((b: -12, r: 1, s: 2, t: 3, u: 4, v: 5))

g.envir.removeAt(\b)
g.envir.removeAt(\r)
g.envir.removeAt(\s)
g.envir.removeAt(\t)
g.envir.removeAt(\u)
g.envir.removeAt(\v)

g.parent.close;
::

argument::object
the envir to display

argument::numItems
the number of items to display. If an envir is given, and no num, num is envir.size.

argument::parent
the parent view to display in; if none is given, a new window is created.

argument::bounds
the bounds within which to display; if none is given, bounds are calculated.

argument::makeSkip
flag whether to make a skipjack to manage updates of the envirgui.

argument::options
configuration options

InstanceMethods::

subsection::Instance Variables

method::numItems
how many envir items to display

method::envir
the envir displayed - actually an alias for object.

method::zone
the composite view the envirgui makes for itself

method::valFields
the areas in which the key-value pairs are displayed.

method::widgets
the EZGuis that display the values:
list::
## Single numbers will have an link::Classes/EZSlider::,
## pairs of numbers will be shown as an link::Classes/EZRanger::,
## all other values are shown as compileStrings in an link::Classes/EZText::.
::

method::specs
EZSlider and EZRanger needs specs for their display ranges; if there is a global spec for that key (key.asSpec), it will be used. If not, a spec is generated (see the link::#-getSpec:: method) and kept in these (local) specs.

method::keysRotation
if the size of envir exceeds numItems, the keys displayed can be rotated: e.g. with 10 keys displayed on 5 valFields, keysRotation 0 means show keys (0..4), keysRotation 2 means show keys (2..6), etc.

subsection::Some Methods

method::object
set the environment to show

argument::obj
can be nil, a dictionary, an environment, or an event.

code::
g = EnvirGui((freq: 120, \amp: 0.2, \pan: -0.5), 12, nil, bounds: Rect(20, 400, 220, 100));
g.object_((a: 1, b: [2, 3], c: \symbol, d: [4, 5, 6], f: { "boing".postln }))
::

method::envir
same as object_(obj)

method::name
if in its own window, set the window's name

code::
g.name_("Yoohoo");
::

method::getSpec
For editing, specs for the parameter ranges are needed. These can be set locally in the EnvirGui, or global specs will be looked up. If no local or global specs exist for that parameter name, getSpec makes a usable guess for them.

code::
// inline example
g = EnvirGui.new;
g.getSpec(\freq, 400);		// \freq exists as global spec, so use that
g.object_((freq: 150));

g.getSpec(\iFrek, 500);		// no global spec, so make a new one:
				// exponential from val * 0.05 to val * 20;
g.specs;			// and keep it here
g.envir.put(\iFrek, 500);
::

argument::key
the parameter name for which to find a spec

argument::value
the current value of that param, which may be used for guessing specs.

method::putSpec
add a spec for a given key, or (if it is a global key) override a global spec with a local one:

code::
g.putSpec(\iFrek, [10, 1000, \exp]);
g.putSpec(\freq, [100, 1000, \exp]);
g.object_((freq: 200, iFrek: 20));
::

subsection::Some internal methods

method::setField
set a field by index, with the new key, value;

argument::index
the index

argument::key
a new key

argument::value
the value

argument::sameKey
means the field had the same key already.

method::setByKeys
update the widgets for the current keys

method::clearField
remove the link::Classes/EZGui:: at this index

method::clearFields
remove all unused EZGuis

Examples::

code::
	// Setting envir variables in a Tdef:
(
Tdef(\text).set(\note, [0, 2, 7], \dur, { [0.1, 0.2, 0.4].choose }, \pan, 0, \amp, 0.1);

w = Window("EZTexts", Rect(200, 400, 304, 120)).front;
w.addFlowLayout;

TdefGui(Tdef(\text), 0, parent: w);

e = EnvirGui(Tdef(\text).envir, 4, parent: w);

Tdef(\text, { |ev|
	var mydur;
	loop {
		mydur = ev.dur;
		(note: ev.note, dur: mydur, amp: ev.amp, pan: ev.pan).postln.play;
		mydur.wait;
	}
}).play;
)

	// or equivalently, use the built-in EnvirGui in TdefGui:
TdefGui(Tdef(\text), 4);

Tdef(\text).set(\yuhu, Prand([2, 3, 5, 8, 13], inf), \magic, [\abra, \cadabra]);

Tdef(\text).clear;
::
** CLASS::Environment
related::Classes/Event, Classes/IdentityDictionary
categories::Collections>Unordered
summary:: A dictionary which can serve as a 'name space' for functions

DESCRIPTION::
An Environment is an IdentityDictionary with additional features that allow it to serve as a 'name space' within which functions can be defined and/or evaluated.

CLASSMETHODS::
method::stack
Maintains a stack of Environments accessed by link::#*push:: and link::#*pop::.

method::make
Creates a new Environment and sends make message.

method::use
Creates a new Environment and sends use message.

method::push
Saves link::#.currentEnvironment:: on the stack.

method::pop
Restores link::#.currentEnvironment:: from the stack.

INSTANCEMETHODS::

method::make
Evaluates the function within the environment, returns the environment.

method::use
Evaluates the function within the environment, returns the return value of the function.

method::push
Saves the receiver on the stack.

method::pop
Restores link::#.currentEnvironment:: from the stack.


SECTION::PseudoVariables (global variables)
These are not methods, but global variables.
method:: currentEnvironment
determines environment used by "~" syntax, link::#.valueEnvir::, and link::#.valueArrayEnvir::

method:: topEnvironment
initial value of link::#.currentEnvironment::, can be used for 'global variables'

SECTION::Related Messages

method:: valueEnvir (arg1, arg2...)
evaluates a function, looking up unspecified arguments in link::#.currentEnvironment::

method:: valueArrayEnvir (argArray)
same as link::#.valueEnvir::, but with arguments in an array


SECTION::Overview

subsection::topEnvironment, currentEnvironment, make and use

When SuperCollider starts, it creates an Environment that it stores in the pseudovariables link::#.topEnvironment:: and link::#.currentEnvironment::. The link::#.topEnvironment:: provides a universally accessible collection of named values similar to the link::Classes/Interpreter:: variables a, b, c, ....

The compiler provides a shortcut syntax where ~ is a placeholder for link::#.currentEnvironment::.
This makes the expression code::~myvariable;:: equivalent to code::currentEnvironment.at(\myvariable);:: and the expression code::~myvariable = 888;:: equivalent to code::currentEnvironment.put(\myvariable, 888);::

The messages link::#*make::(function) and link::#*use::(function) replace link::#.currentEnvironment:: with the receiver. The message link::#*make:: is intended to be used when initializing an Environment, so it returns the Environment. The message link::#*use:: is for evaluating a functions within an Environment, so it returns the return value of the function.

For example
code::
(
a = Environment.make({
	~a = 100;
	~b = 200;
	~c = 300;
});
a.postln;
)
::
creates an environment, while
code::
a.use({
	~a + ~b + ~c
}).postln;
::
evaluates the function within that environment.

subsection::valueEnvir and valueArrayEnvir

When Functions are evaluated with link::#.valueEnvir:: and link::#.valueArrayEnvir:: unspecified arguments are looked up in the current Environment.
If the argument is not found in the Environment its default value is used.
code::
(
var f;

// define a function
f = { arg x, y, z; [x, y, z].postln; };

Environment.use({
	~x = 7;
	~y = 8;
	~z = 9;

	f.valueEnvir(1, 2, 3);	// all values supplied
	f.valueEnvir(1, 2);	// z is looked up in the current Environment
	f.valueEnvir(1);	// y and z are looked up in the current Environment
	f.valueEnvir;		// all arguments are looked up in the current Environment
	f.valueEnvir(z: 1);	// x and y are looked up in the current Environment
});
)
::
Now here is how this can be used with an instrument function. Environments allow you to define instruments without having to worry about argument ordering conflicts. Even though the three functions below have the freq, amp and pan args declared in different orders it does not matter, because link::#.valueEnvir:: looks them up in the environment.
code::
s.boot;

(
var orc;
orc = Environment.make {
	~a = { arg freq, amp, pan;
		Pan2.ar(SinOsc.ar(freq), pan, amp);
	};
	~b = { arg amp, pan, freq;
		Pan2.ar(RLPF.ar(Saw.ar(freq), freq * 6, 0.1), pan, amp);
	};
	~c = { arg pan, freq, amp;
		Pan2.ar(Resonz.ar(GrayNoise.ar, freq * 2, 0.1), pan, amp * 2);
	};
	~orc = [~a, ~b, ~c];
};
// 'reverb'
{ var in; in = In.ar(0, 2); CombN.ar(in, 0.2, 0.2, 3, 1, in); }.play(addAction: \addToTail);

{ loop({
	orc.use({
			// set values in the environment
		~freq = exprand(80, 600);
		~amp = 0.1;
		~pan = 1.0.rand2;

			// call a randomly chosen instrument function
			// with values from the environment

		 x = { ~orc.choose.valueEnvir; }.play(fadeTime: 0.2, addAction: \addToHead);
		 0.2.wait;
		 x.release(0.2);
	});
}) }.fork;

)
::

subsection::Environments and asynchronous functions

Local variables declared in functions, and class and instance variables, use lexical scope. That is, the context in which they are understood depends on where the declaration is read during compilation. Asynchronous functions -- any function that will execute outside (later than) the current execution flow -- carry their lexically scoped variables with them.
code::
f = { var a = "got it"; { a.postln }.defer(0.5) };
f.value;
::
Asynchronous functions include any scheduled function, responder function associated with OSCFunc, MIDIFunc, HID or GUI action functions, or actions used in server messaging (such as Buffer.read, Buffer or Bus .get, and so on).

Environment variables have dynamic scope; they are read from whichever environment is current, whether or not it was the current environment when the function was declared. For instance, the following fails because e is no longer the current environment when the deferred function wakes up.
code::
e = (a: "got it", f: { { ~a.postln }.defer(0.5) });
e.use { e.f };
::
link::Classes/Function#inEnvir#Function's inEnvir:: method attaches a function to a specific environment. If no environment is given, the current environment at the time of executing inEnvir is the default.
code::
e = (a: "got it", f: { { ~a.postln }.inEnvir.defer(0.5) });
e.use { e.f };
::

subsection::Using Environments as object prototypes

Environment's strong::know:: variable holds a link::Classes/Boolean:: value controlling whether the Environment may be used as an object prototype or not. If strong::know:: is true, any messages sent to the Environment that it does not already understand will be relayed into items in the Environment. (If false, not-understood messages will produce a standard "does not understand" error message.)

The default for know is false for Environment, and true for link::Classes/Event::.
code::
e = Environment[
	'someVariable' -> 5,
	'printMe' -> { |self, string| string.postln }
];

e.know = true;
::
More typically, Events are used to define such prototypes because the syntax is simpler.
code::
e = (someVariable: 5, printMe: { |self, string| string.postln });
::


An object prototype looks up the method selector in the Environment to decide what to do.

Most objects are simply returned -- the method call behaves like a getter for any other object.
code::
e.someVariable;
// same as
e.at('someVariable');
e['someVariable'];
::
If the selector is a setter, e.g. strong::someVariable_(value):: or strong::someVariable = value::, the new value is put into the Environment.
code::
e.someVariable = 10;
// same as
e.put('someVariable', 10);
::
If the Environment item is a function, it is evaluated as if it were a method definition. The first argument passed into the function is the Environment that holds the function; arguments to the method call follow as the second, third etc. arguments passed into the function.
code::
e.printMe("Oh hai wrldz");
// same as
e['printMe'].value(e, "Oh hai wrldz");
::
The function may access objects in the Environment using the first function argument.
code::
e.mul2 = { |z| z.someVariable * 2 };
e.mul2;
::
Environment variables inside a function will refer to the currently active environment -- not to the Environment being addressed. This is to allow the object prototype to interact with the link::#.currentEnvironment::.
code::
e.mul2 = { |z| ~someVariable * 2 };
// this will throw an error because ~someVariable is nil in the currentEnvironment
e.mul2;
::
If you wish to access objects in the environment using environment variable syntax, 'use' the environment within the function.
code::
e.mul2 = { |z| z.use { ~someVariable * 2 } };
e.mul2;
::

note::
Be careful to avoid method names that are defined in any of the superclasses of environment (or event). Object prototyping works by trapping method selectors that are not already defined as class library methods. Using a generic method selector such as 'stop' or 'reset' will cause the corresponding class library method to respond, and the items in the environment will never be checked.

Assigning a value into an environment using a setter -- strong::name_():: or strong::.name = ...:: -- posts a warning message if the name is already defined in the class library.
code::
e.reset = { "My reset function".postln };

// prints:
WARNING:
'reset' exists a method name, so you can't use it as pseudo-method.

// this does NOT execute the reset function above
// because Object:reset responds
e.reset;
::
::
** class:: EnvironmentRedirect
summary:: base class for environment redirects
categories:: Libraries>JITLib>Environments
related:: Classes/Environment

description::
Environment that redirects access ( strong::put:: ) and assignment ( strong::at:: ).

ClassMethods::

method::new
create new redirect, if envir is given it is used.

subsection:: replacing Environment class methods

EnvironmentRedirect implements some of the interface of link::Classes/Environment::, which it can replace where needed.

method::push, pop, make, use

InstanceMethods::

method::envir
return or replace the source environment

subsection::redirecting objects

Overriding these methods, one can redirect where objects go when they are assigned to the space. This is done for example in link::Classes/LazyEnvir:: and link::Classes/ProxySpace::.

method::at, put, localPut, removeAt

subsection:: replacing Environment instance methods

EnvironmentRedirect implements some of the interface of link::Classes/Environment::, which it can replace where needed.

method::push, pop, make, use, do, clear, keysValuesDo, keysValuesArrayDo, findKeyForValue, sortedKeysValuesDo, choose, know, doesNotUnderstand


section::Networking

EnvironmentRedirect and its subclasses can be used to dispatch assignment over a network. To do this, a dispatch function can be supplied - see Public in strong::JITLibExtensions:: quark.
** class::Error
categories::Core
summary::superclass of all Errors

description::
Error and its subclasses separate different types of error is that can occur in the SuperCollider program into distinct classes, so that they can be reported differently to the user.

Anywhere that an error must be reported to the user and execution must stop, an error object must be created and thrown.
code::
(
var file, path = "betcha-this-file-doesnt-exist.txt";
if((file = File(path, "r")).isOpen) {
	"File is % bytes long.\n".postf(file.length);
	file.close;
} {
	Error("File % could not be opened.".format(path)).throw;
};
)
::

For backward compatibility, code::.die():: creates the error for you.

code::
"Nothing is really wrong; just committing suicide for fun. A Harold and Maude moment.".die;
::

Throwing an error object gives the caller the opportunity to catch, and possibly recover from, the error. See the Exception help file for more information about this.

subsection::Error hierarchy

The following error classes exist in the main library.

list::
## link::Classes/Error::
## link::Classes/DeprecatedError:: : this method is no longer supported.
## link::Classes/MethodError:: : generic error occurring within a method.
## link::Classes/DoesNotUnderstandError:: : the receiver does not understand the method name.
## link::Classes/BinaryOpFailureError:: : a binary operator cannot work with the operand classes.
## link::Classes/ImmutableError:: : attempted to modify an immutable object.
## link::Classes/MustBeBooleanError:: : a test (in if or while) returned a non-Boolean value.
## link::Classes/NotYetImplementedError:: : the method name exists, but isn't implemented yet.
## link::Classes/OutOfContextReturnError:: : a method return by ^ took place outside of a method.
## link::Classes/PrimitiveFailedError:: : an error occurred inside a primitive.
## link::Classes/ShouldNotImplementError:: : you called a method on a class that has no business implementing it.
## link::Classes/SubclassResponsibilityError:: : you called a method on an abstract class.
::

The exact inheritance tree looks like this:
classtree::Error

** CLASS::Event
summary::an environment that represents an action
related::Classes/Pattern
categories::Collections>Unordered, Streams-Patterns-Events>Events

DESCRIPTION::
An Event is an Environment that specifies an action to be taken in response to a link::#-play:: message. The key/value pairs within the Event specify the parameters of that action. Most methods, Event inherits from its superclasses, especially from link::Classes/Dictionary::.

CLASSMETHODS::

private::initClass

subsection::Class variables

method::parentEvents
An IdentityDictionary of useful parent events.
method::partialEvents
An IdentityDictionary of Events that define the default values and functions for different aspects of note generation (timing, volume, pitch, server to use, etc).

subsection::Creation methods

method::new
create an event with initial size strong::n::.
argument::n
Initial size.
argument::proto
May be provided as another event which is used to override keys in the event.
argument::parent
May be provided as another event which is used to provide default keys for the event without modifying it.
argument::know
If strong::know:: is set to link::Classes/True::, the event will respond to appropriate message calls. See link::Classes/Environment:: for more details.

method::default
Returns an empty event with link::#.defaultParentEvent:: as parent.

method::silent
Returns an event that describes a pause of strong::dur:: duration.

method::addEventType
Event types define alternate play functions that are selected by the value of strong::~type::.
argument::type
A name (usually a symbol) for the event type, which can be used to select it

argument::func
A function which optionally takes the server as a first argument

code::
Event.addEventType(\happyEvent, { ("I am so happy to be silent sometimes, says" + ~who).postln; });
Pbind(\type, \happyEvent, \who, Prand(["Alice", "Bob", "Eve"], inf), \dur, Pwhite(0.1, 1.0, inf)).play;

// To a certain degree, it is possible to reuse some of another event type's functionality:
(
Event.addEventType(\happyEvent, { |server|
	~octave = [5, 6, 7]; // always play three octaves
	~detune = 10.0.rand2; // always play a bit out of tune
	~type = \note; // now set type to a different one
	currentEnvironment.play;
});
Pbind(\type, \happyEvent, \degree, Pseq([0, 1, 2, 3, 4, 4, 5, 5, 5, 5, 4, 2, 3, 2, 3, 1], inf), \dur, Pwhite(0.1, 1.0, inf)).play;
);

::


method::makeDefaultSynthDef
This method is called in order to build the default SynthDef, which is stored under the key strong::\default::
code::
SynthDef(\default, { Out.ar(0, Line.kr(0.3, 0, 0.5) * SinOsc.ar(Rand(300, 500.0)) ) }).add; // overwrite default
(freq: 600).play;
Event.makeDefaultSynthDef; // reset default
(freq: 600).play;
::

INSTANCEMETHODS::

method::play
Play the event. This evaluates the function at strong::\play::.
code::
(freq: 800).play;
(play: {  "I rather do something else: ".post; ~x.postln; }, x: 800.rand).play;
::

method::delta
Returns the inter onset time - the time delay until the next event in a sequence. This usually depends on strong::\dur:: and strong::\stretch::, but may be overridden by specifying strong::\delta:: directly.
code::
Pn((dur: 2, freq:8000)).play;
::

method::next
Combines an event given in the argument with the current event. This is used to enable events to be composed.
code::
(a: 6, b: 7).next((c: 100));
::

method::playAndDelta
Used by link::Classes/EventStreamPlayer:: to play Events and obtain a time increment.

method::isRest
Returns strong::true:: if the event will be played as a rest, and strong::false:: otherwise. See link::Classes/Rest:: for a more complete discussion of rests in event patterns.

method::asUGenInput
Calls link::#-asControlInput::.

method::asControlInput
Enables events to represent the server resources they created in an Event.

subsection::Methods that allow Events to provide user control for Synths on Groups

method::synth
Makes the event a control interface to the resultant link::Classes/Synth:: when played.

method::group
Makes the event a control interface to the resultant link::Classes/Group:: when played. This is experimental, does not work consistently yet.

method::stop
Free the link::Classes/Synth:: or link::Classes/Group::.

method::pause
Pause the link::Classes/Synth:: or link::Classes/Group::.

method::resume
Resume the link::Classes/Synth:: or link::Classes/Group::.

method::release
Release the link::Classes/Synth:: or link::Classes/Group::.

method::set
Set a control value in the link::Classes/Synth:: or link::Classes/Group::.
(key1, val1, ....)
code::
a = (note: 2).play;
a.set(\freq, 700);
a.release;
::


SECTION::Basic Usage

Events can be written as a series of key value pairs enclosed in parentheses. Empty parentheses will create an empty event. They may be also used for object prototyping - see link::Classes/Environment:: for more details.

subsection::Event as a name space for keeping objects

Because of this simple syntax, Events are often used as name space for keeping objects:
code::
// using an event to store values
q = (n: 10, x: [1, 2, 3]);
q[\y] = q[\x] * q[\n];	// similar to ~y = ~x * ~n, but in a separate name space
q.y = q.x * q.n;	// shorter way to do the same (pseudo-methods)
q.y;			// [ 100, 200, 300 ]
::

subsection::Event for specifying different things to happen

Event provides a link::#.defaultParentEvent:: that defines a variety of different event types and provides a complete set of default key/value pairs for each type. The type is determined by the value of the key strong::\type:: which defaults to strong::\note::. Note events create synths on the server.
code::
( ).play;			// the default note
(freq: 500, pan: -1) .play;	// 500 Hz, panned left
(play: { ~what.postln }, what: "hello happening").play;	// something else
::
Per default, the play message derives its behaviour from the link::#.defaultParentEvent::, which provides many default values, such as default instrument (\default), note (0), legato (0.8) and so on. Depending on the event type, these may differ completely and need not even represent a sound.

subsection::Events and SynthDefs

The key used to select what synthdef is to be played is strong::\instrument::. In order to use a link::Classes/SynthDef:: with an Event, send it an strong::add:: message. This creates a description of the SynthDef that the event can consult to determine its control names. The values of these names in the event are used when the event is played. (See link::Classes/SynthDesc:: for details.)
code::
(
SynthDef(\pm, { |out=0, freq=440, amp=0.1, pan=0, gate=1, ratio = 1, index = 1, ar = 0.1, dr = 0.1|
	var z;
	z = LPF.ar(
		PMOsc.ar(freq, freq * ratio, Linen.kr(gate, ar,index, dr), 0, 0.3),
		XLine.kr(Rand(4000, 5000), Rand(2500, 3200), 1)
	) * Linen.kr(gate, 0.01, 0.7, dr, 2);
	OffsetOut.ar(out, Pan2.ar(z, pan, amp));
}).add;
);

(instrument: \pm).play;

(instrument: \pm, ratio: 3.42, index: 12, freq: 150, ar: 8, dr: 3, sustain: 10).play;
::

note::
The use of link::Classes/OffsetOut:: in the SynthDef prevents irregularities that can result from the interaction of the timing of a sequence of notes and the control rate of the Server.
::

subsection::Multi-channel Expansion

If a key relevant to the action is assigned an link::Classes/Array::, the action is repeated on each element of the array:
code::
(degree: (0..12)).play;		// a diatonic cluster
::
If several keys are assigned arrays, the action is repeated for each element of the largest array.
Smaller arrays are rotated through repeatedly. Here are some examples:
code::
// every other note of the diatonic cluster: stacked thirds
(degree: (0..12), amp: [0, 0.1]).play;

// every other note of the semitone cluster: a wholetone cluster again
(note: (0..12), amp: [0, 0.1]).play;

// every third note of the semitone cluster: a diminished chord
(note: (0..12), amp: [0, 0, 0.1]).play;

// the same with different sustain times
(note: (0..12), amp: [0, 0, 0.1], sustain:[0.1, 0.3, 1.3, 2.5]).play;

// timingOffset gives a tempo-relative offset time to each synth
(instrument: \pm, ratio: [2.3, 4.5, 1.7], timingOffset: [0, 1.2, 3], sustain: [0.2, 2, 1]).play;
::

In the \note event, all keys multichannel expand apart from: \instrument, \dur, \delta, \strum.

subsection::Arrayed Arguments

It is possible to assign an array to one of a link::Classes/SynthDef::'s control names. For example:
code::
(
SynthDef(\test, { | out = 0, amp = 0.01, freq = #[300,400,400], pan, gate = 1 |
	var audio, env;
	audio = Mix.ar(Pulse.ar(freq, 0.5));	// this is a mixture of three oscillators
	env = Linen.kr(gate, susLevel: amp , doneAction: 2);	// envelope deletes the synt when done
	audio = audio * env;
	OffsetOut.ar(0, audio );
}).add;
)
::
Within an event, arrayed arguments of this sort must be enclosed within an additional array to distinguish them from arguments intended for multi-channel expansion.
code::
// one synth, use enclosing array to prevent multi-channel expansion
(instrument: \test, note: [[0, 2, 4]]).play;

// two synths
(instrument: \test, note: [[0, 2, 4], [6, 8, 10]]).play;
::

subsection::Events and Patterns

Events are closely integrated with the Patterns library. Different patterns can be bound to different keys (or collections of keys) to specify the resultant music. See the help files link::Classes/Pattern:: and link::Classes/Pbind:: and the tutorials link::Tutorials/Streams-Patterns-Events4:: and link::Tutorials/Streams-Patterns-Events5:: for more details on Patterns.

Patterns that return events may be played on a clock: dur specifies the time between two subsequent events.
code::
// Pseq returns one item in the list after the other
(
Pseq([
	(note: 2, sustain: 1, dur: 1.5),
	(note: [5, 7], sustain: 0.5, dur: 0.8),
	(note: [2, 6], sustain: 1, dur: 0.8)
]).play;
)

// Pbind binds parameters to events:
(
Pbind(
	\note, Pseq([2, [5, 7], [2, 6]]),
	\sustain, Pseq([1, 0.5, 1]),
	\dur, Pseq([1.5, 0.8, 0.8])
).play;
)

// per-event timing may be specified:
(
Pbind(
	\note, Pseq([[0, 9], [5, 7], [2, 6]], inf),
	\sustain, Pseq([1, 0.5, 1], inf),
	\dur, Pseq([1.5, 0.8, 0.8], inf),
	\timingOffset, Pseq([[0, 0.3], [0, 0.01]], inf)
).play;
)
::

Here is an example that illustrates some more of the keys defined by the link::#.defaultParentEvent::. Note that it is equivalent to write code::Pbind(\key, val, ...):: and code::Pbind(*[key: val, ...])::.
code::
(
Pbind(*[
	stepsPerOctave:	Pstep(Pseq((2..12).mirror, inf),12),	// 3 - 12 tone e.t. scales
	note:		Pseq((0..12).mirror, inf),		// play full notes up and down
	ctranspose:	Pwhite(-0.2, 0.2),			// detune up to +-20 cents
	detune:		Pwhite(-1.0, 1.0),			// detune up to 1 Hz
	sustain:	Prand([0.2, 0.2, 0.2, 4], inf), 	// notes last 0.2 or 4 seconds
				// 1 in 6 chance waits 0.8 seconds:
	dur:		Prand([0.2, 0.2, 0.2, 0.2, 0.2, 0.8], inf),
	db:		Pstep(Pseq([-15, -25, -20, -25], inf), 0.8)// 4 beat accent structure
]).play;
)
::

subsection::Event's play method

When an Event (or any other link::Classes/Environment::) receives a code::use(function):: message, it sets itself to be currentEnvironment, evaluates the function, and restores the original value of currentEnvironment. This allows the function to access and alter the contents of the event using the following shortcuts:
code::~keyName:: which is equivalent to	code::currentEnvironment.at(keyName):: and
code::~keyName = value:: which is equivalent to code::currentEnvironment.put(keyName, value)::.

We will write code::~keyName:: whenever referring to the value stored at the key keyName in the event.

Here is the definition of Event's play method:
code::
play {
	if (parent.isNil) { parent = defaultParentEvent };
	this.use { ~play.value };
}
::
Thus we can see that the link::#.defaultParentEvent:: is used unless otherwise specified and the function stored in code::~play:: is executed in the context of the Event. It can be replaced in a given event for different behavior:
code::
(a: 6, b: 7, play: { (~a * ~b).postln }).play;
::

subsection::Timing control with Event's delta method

Events also specify timing within a link::Classes/Pattern::. Event's code::delta:: method returns the value of code::~delta:: or, if that is nil, code::~dur * ~stretch::.

Patterns are played by link::Classes/TempoClock::s, which have their own tempo controls. This tempo which can be controlled through code::~tempo:: in the event. Changes to the tempo affect everything else scheduled by the TempoClock, so code::tempo:: provides a global tempo control while code::stretch:: provides a control limited to the one pattern.

subsection::The structure of defaultParentEvent

method::defaultParentEvent
The default event used in most cases. This is a private class variable. See link::#*default::.

The default parent event provides the collection of default values and functions needed for the different uses of an Event. These defaults are defined in partialEvents that specify distinct aspects of default parent Event:
code::
playerEvent	// defines ~play, ~type and ~eventTypes
serverEvent	// server, group, addAction
durEvent	// duration, tempo and articulation
ampEvent	// volume, pan, MIDI velocity
pitchEvent	// pitch specified in many different ways
bufferEvent	// buffers on the server
midiEvent	// defines the sending of midi messages
::

subsection::Useful keys for notes

Using Events is largely a matter of overwriting keys. Here is a list of keys useful for defining notes with their default values, grouped by the partialEvent within which they are defined.

list::

## strong::serverEvent keys:::

The keys in serverEvent provide the values needed to identify the server to be used and where in the tree
of nodes to place the group.
code::
server:		nil,		// if nil, Server.default is used
instrument:	\default,	// this is the name of a SynthDef
group:		1,		// nodeID of group on the server
				// whening adding before or after a node
				// this could be the nodeID of a synth instead of a group
addAction:	0,		// 0, 1, 2, 3 or \addToHead, \addToTail, \addBefore, \addAfter
out:		0,		// usually an output bus number, but depends on the SynthDef
::

## strong::ampEvent keys:::

The ampEvent determines volume. Notice that code::~amp:: is a function that determines its value from code::~db::. The user can choose to specify the amplitude directly by overwriting code::~amp:: or to use a decibel specification by overwriting code::~db::.
code::
amp:		#{ ~db.dbamp },	// the amplitude
db:		-20.0,		// the above described in decibel
pan:		0.0,		// pan position: -1 left 1 right
velocity:	64		// midi velocity
trig:		0.5		// trigger value
::

## strong::durEvent keys:::

The durEvent has keys that determine the timing of a note. Notice that code::~sustain:: is a function that uses code::~legato:: to determine the sustain. Like code::~amp:: this can be overwritten to set the sustain directly.
code::
tempo:			nil,	// changes tempo of a TempoClock
dur:			1.0,	// time until next note (inter-onset time)
stretch:		1.0,	// inverse of tempo control, specific to the Event's stream
legato:			0.8,	// ratio of sustain to duration
sustain:		#{ ~dur * ~legato * ~stretch },
lag:			0.0,	// delay (in seconds) relative to current time position of Stream
timingOffset:		0.0,	// delay (in beats) relative to current time position of Stream
strum:			0.0	// "breaks" a chord. May be negative, playing the chord backward
strumEndsTogether:	false	// if true, the strummed notes end together (with gated synths)
sendGate:		nil  // override: true == always send a gate-release message; false == never send
::

## strong::pitchEvent keys:::

The pitchEvent has the most complex system of functions that provide a variety of useful ways to determine pitch:
code::
freq (->440)		// determines the pitch directly as a frequency in Hertz
midinote (-> 60)	// determines pitch as a fractional MIDI note (69 -> 440)
note (-> 0)		// determines pitch as a scale degree in an ~stepsPerOctave equal tempered scale
degree: 0		// determines pitch as a scale degree within the scale ~scale
::
The event also provides a set of transposition keys:
code::
mtranspose:	0	// modal transposition of degree within a scale
root:		0.0	// transposes root of the scale
gtranspose:	0.0	// gamut transposition within the ~stepsPerOctave equal tempered scale
ctranspose:	0.0	// chromatic transposition within the 12 tone equal tempered scale
harmonic:	1.0	// multiplies the frequency determined by ~midinote, typically to an overtone
detune:		0.0	// directly offsets frequency by adding this value
midiToCps		// a function taking a MIDI note number and turning it into frequency
			// Normally this is _.midicps, but you can override it for non-ET tunings

mtranspose:	0,	// modal transposition of degree
gtranspose:	0.0	// gamut transposition of note within a ~stepsPerOctave e.t. scale
ctranspose:	0.0	// chromatic transposition of midinote within 12 tone e.t. scale

octave:		5.0	// octave offest of note
root:		0.0	// root of the scale
degree:		0	// degree in scale
scale:		#[0, 2, 4, 5, 7, 9, 11]	// diatonic major scale
stepsPerOctave:	12.0	//
detune:		0.0,	// detune in Hertz
harmonic:	1.0	// harmonic ratio
octaveRatio:	2.0	// size of the octave (can be used with the Scale class)
::
The event calculates with these keys to derive parameters needed for the synth:
code::
note: #{	// note is the note in halftone steps from the root
	(~degree + ~mtranspose).degreeToKey(~scale, ~stepsPerOctave);
}
midinote: #{	// midinote is the midinote (continuous intermediate values)
	((~note.value + ~gtranspose + ~root) / ~stepsPerOctave + ~octave) * 12.0;
}
freq: #{
	(~midinote.value + ~ctranspose).midicps * ~harmonic;
}
detunedFreq: #{	// finally sent as "freq" to the synth as a parameter, if given
	~freq.value + ~detune
}
::
::

subsection::Event types

An Event responds to a play message by evaluating code::~play:: in the event, which by default uses the event's type to define the action to be performed. See link::Overviews/Event_types::.
** class:: EventPatternProxy
summary:: event stream reference
categories:: Libraries>JITLib>Patterns
related:: Classes/Pdef

description::
Keeps a reference to a stream that can be replaced while playing. Multiple streams are thus handled without creating dependancies.

ClassMethods::

method::new
create a new instance with a pattern (the source). The pattern should be an emphasis::event pattern:: (see link::Classes/Pdef::)

method::default
a default source, if none is given. the default is a Pbind with resting notes of 1.0 beat duration.

method::defaultQuant
set the default quantization value for the class.

InstanceMethods::

method::source
set the source (a pattern). If a quantization is given, schedule this change to the next beat ( strong::pattern_::(..) is equivalent)

method::clear
set the source to nil and stop playing

method::quant
get or set the quantization value. can be an array [quant, phase, offset, outset]

method::fadeTime
when the synthdefs that are used contain an code::\amp:: control, the patterns are replaced by crossfading the previous with the new over this time (in beats)

method::envir
provide a default event for the Pdef. It is used to filter the incoming stream before it is passed to the source pattern. This is similar to link::Classes/NodeProxy#-nodeMap::. When set for the first time, the pattern is rebuilt.

method::set
set arguments in the default event. If there is none, it is created and the pattern is rebuilt.

subsection::a) using as stream reference

method::embedInStream
just like any pattern, embeds itself in stream

subsection::b) using as EventStreamPlayer

method::play
starts the EventPatternProxy and creates a player. if you want to play multiple instances, use link::#-fork::.

argument::argClock
play on a certain clock.

argument::protoEvent

argument::quant
can be an array of [quant, phase, offset, outset]

argument::doReset
a link::Classes/Boolean::

method::stop
stops the player

method::player
the current player (if the Pdef is simply used in other streams this is code::nil::)

method::pause, resume, reset
perform player method

method::isPlaying
returns true if Pdef is running. if a Pdef is playing and its stream ends, it will schedule a stream for playing as soon as a new one is assigned to it.


Examples::

subsection::a) embedding EventPatternProxy in streams

code::
(
SynthDef("Pdefhelp", { arg out, freq, sustain=1, amp=1, pan;
	var env, u=1;
	env = EnvGen.kr(Env.perc(0.03, sustain), 1, doneAction:2);
	5.do { var d; d = exprand(0.01, 1); u = SinOsc.ar(d * 300, u, rrand(0.1,1.2) * d, 1) };
	Out.ar(out, Pan2.ar(SinOsc.ar(u + 1 * freq, 0, amp * env), pan));

}).add;
)
s.boot;

#a, b, c, m = { EventPatternProxy.new } ! 4;

m.play;
m.source = Pbind(\instrument, \Pdefhelp, \dur, 1, \degree, 16, \legato, 0.1);

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 5, 4, 3]));
b.source = Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[7, 8, 7, 8]));
c.source = Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 1, 2], 2));

x = Pseq([a, b, c], inf).play;


c.source = Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[4, 3, 1, 2]*3));


// infinite loops are scheduled (to ths clock's next beat by default) and released:

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.753, \degree, Pseq(#[0, 5, 4, 3, 2], inf));
a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[0, 5, 4, 3] + 1, 1));
a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 5, 4, 3] - 1, 1));

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[0, 5] - 1, 1));
a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.753, \degree, Pshuf(#[0, 5, 4, 3, 2], inf));

x.stop;
m.stop;

// EventPatternProxy can be used in multiple patterns

(
x = Ppar([
	Pbindf(Pn(a, inf),
		\gtranspose, Pstutter(8, Pseq(#[0, 2, 0, 3],inf))
	),
	Pbindf(Pn(a, inf),
		\gtranspose, Pstutter(8, Pseq(#[7, 4, 0, 3],inf)),
		\dur, 0.6
	),
	Pbindf(Pn(a, inf),
		\degree, Pseq(#[0, 5, 4, 3, 2, 3, 2], 1)
	)
]).play;
)

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.1, \degree, Pseq(#[0, 1, 0, 1, 2], inf));

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.2, \degree, Pseq([0, 4], inf));

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.2, \degree, Pseq([0, 4, Prand([6, 8b],2)], inf));

a.source = Pbind(\instrument, \Pdefhelp, \dur, 0.1, \degree, Pseq(#[0, 1b, 1, 2b, 2, 3, 4b, 4, 5], inf));

a.set(\detune, -50); // set environment
a.set(\detune, 0);

x.stop;
::

subsection::b) playing EventPatternProxy

code::
(
// load a synthdef
s.boot;
SynthDef("gpdef",
	{ arg out=0, freq=440, sustain=0.05, amp=0.1, pan;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain), doneAction:2) * amp;
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;
)


#x, y = {EventPatternProxy.new} ! 2;

x.play; // play them. A silent resting pattern is used.
y.play;


// assign various patterns to it:

x.source = Pbind(\dur, 0.25, \instrument, \gpdef);
x.source = Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6], inf), \instrument, \gpdef);
x.source = Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6]+1, inf), \instrument, \gpdef);
y.source = Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6]-1, inf), \instrument, \gpdef);
y.source = Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b]-2, inf), \instrument, \gpdef);

// using fadeTime:

y.fadeTime = 8.0;
y.source = Pbind(\dur, 0.125, \degree, Pseq([3, 4, 5b, 6]+4.rand, inf), \instrument, \gpdef);
y.source = Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6]-2, inf), \instrument, \gpdef);

(
x.source = Pbind(
		\dur, 1 / 6,
		\degree, Pseq([3, 4, Prand([8, 2, 3, 9, 10],1) - 5, 6]+1, inf),
		\instrument, \gpdef
		)
	);
)
(
x.source = Pbind(
		\dur, 0.25,
		\degree, Pseq([3, 4, Prand([8, 2, 3, 9, 10],1), 6], inf),
		\instrument, \gpdef)
	);
)
x.stop;



// tempo change
TempoClock.default.tempo = 1.3;
y.source = Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5, 6]+1, inf), \instrument, \gpdef);

// drop in ending patterns

x.play;
x.fadeTime = nil;

x.source = Pbind(\dur, 0.25, \degree, Pseq([3, [7,4], 5, 6]-2), \instrument, \gpdef);
x.source = Pbind(\dur, 0.125, \degree, Pseq([3, [7,4], 5, 4]-3), \instrument, \gpdef);
x.source = Pbind(\dur, 0.35, \degree, Pseq([3, [7,4], 5, 4, 3]-3), \instrument, \gpdef);
x.source = Pbind(\dur, 0.25, \degree, Pshuf([3, [7,4], 5, 6]-2), \instrument, \gpdef);



TempoClock.default.tempo = 1.0;
x.stop;
y.stop;
::
** class:: EventStreamPlayer
summary:: two streams combined by a binary operator
related:: Classes/Event, Classes/Pbind
categories:: Streams-Patterns-Events

description::

An EventStreamPlayer is used by link::Classes/Event:: based Patterns.

The EventStreamPlayer holds a stream which returns a series of Events, and a protoEvent. At each call to next, it copies the protoEvent, passes that to the stream, and calls strong::play:: on the link::Classes/Event:: returned.

For more on EventStreamPlayer see link::Tutorials/Streams-Patterns-Events4::

EventStreamPlayer uses the same control methods and status notifications as link::Classes/Task::.

ClassMethods::

method::new
note::
You do not explictly create an EventStreamPlayers, they are created for you when you call link::Classes/Pattern#-play::.
::

InstanceMethods::

private::prStop, prNext

method::play

argument::argClock
(optional) Override the clock assigned in Task.new.

argument::doReset
If true, the task will start over from the beginning. Default is false (task will resume where it was when it was last stopped).

argument::quant
See the link::Classes/Quant:: helpfile.

method::start
Restart the task from the beginning.

method::resume
Resume the task where it left off.

method::pause
Stop playing now.

method::stop
Stop playing now. (Pause and stop have the same implementation.)

method::reset
Set the stream to restart from the beginning the next time it's played.
** class::Exception
categories::Core
summary::root error class

description::
The root of SuperCollider's error handling mechanism.

Exception is an abstract class, defining basic error behavior. This class is not directly used in SuperCollider. Users may create subclasses of Exception to identify specific types of failure conditions.

The built-in exception types are actually subclasses of link::Classes/Error:: -- see its help file for the hierarchy.

subsection::Background: General exception handling

An exception is any event that disrupts the normal execution flow of a program. In practice there is not much distinction between an exception and an error; in SuperCollider, we tend to speak of errors where other object-oriented languages (Java, C++) would use exception consistently.

If a piece of code runs into an unexpected condition, it creates an exception object that holds information about the faulty condition, and then "throws" that object. From there, the interpreter unwinds backward through all the preceding stack frames looking for an exception handler that will "catch" the exception. The exception handler can take an alternate route to resolve the failure and continue normally; if this is not possible, it can re-throw the exception back to the previous stack frame. An exception that never gets caught causes execution to abort. In SuperCollider, this results in the standard error dump (see the Understanding-Errors help file for details); in C++ or Java, the effect is catastrophic, causing the whole program to crash.

subsection::Common syntax in other languages for exception handling is:

code::
try { ...code... }
catch { ...exception handler... }
::

Specific languages may have other variants. The SuperCollider compiler doesn't have room for the "catch" keyword, so the syntax is simpler:

code::
try { ...code... } { ...exception handler... };
::

With "try", "if" the error cannot be handled, you have to re-throw the error explicitly:

code::
try { ...code... } { |error|
	if( test: can I handle the error? ) {
		handle gracefully
	} { error.throw }
};
::

SuperCollider includes a variant, borrowed from Scheme, in which the exception is always fatal, but the preceding code might have allocated some resources that need to be released before reporting the error. For example, you might open a file and do some processing on it that might encounter an error. Good practice is to close the file before the error halt, which you can do this way:

code::
file = File(path, "r");
protect {
	work with the file here, which might cause an error
} {
	file.close;
};
::

With "protect" the second function will execute even if there is no error, and any error will be passed up the chain.

In Java, you can catch specific classes of exception. You can simulate this usage with the following construction:

code::
// Java-style

try {  }
catch { FileNotFoundException e } { console.printLine("File not found: " + e.path) }
catch { EmptyFileException e } { console.printLine("File is empty: " + e.path) };

// SuperCollider-style (hypothetical; these specific exceptions do not exist in the main library

try {  } { |error|
	switch(error.species.name)
		{ 'FileNotFoundException' } { postln("File not found:" + e.path) }
		{ 'EmptyFileException' } { postln("File is empty:" + e.path) }
			// default condition: unhandled exception, rethrow
		{ error.throw }
}
::
Following is an example that recovers from a failed attempt to write into an immutable array, by re-attempting the write on a copy of the array.

code::
(
~inPlaceSub = { |array, find, replace|
	array.do({ |item, i|
		if(item == find) { array[i] = replace };
	});
};

~trySub = { |array, find, replace|
	try {
		~inPlaceSub.(array, find, replace)
	} { |error|
		switch(error.species.name)
			{ 'PrimitiveFailedError' } {
				if(error.what.find("immutable").notNil) {
					"caught ImmutableError".postln;
					~inPlaceSub.(array.copy, find, replace)
				} { "unknown primitive exception".postln; error.throw; }
			}
				// default case: unhandled exception, should die so re-throw error
			{ "unknown exception".postln; error.throw; }
	};
};
)

// pass in a mutable array, OK
~trySub.((0..9), 9, 19);

// pass in a literal array, Immutable exception is caught and handled
~trySub.(#[0, 1, 2, 3, 4, 5], 5, 6);

// pass in a nonsense value, other exception is re-thrown
~trySub.(10, 5, 6);
::
** class:: ExpRand
summary:: Exponential single random number generator.
related:: Classes/IRand, Classes/LinRand, Classes/NRand, Classes/Rand, Classes/TExpRand, Classes/TIRand, Classes/TRand
categories:: UGens>Random

Description::

Generates a single random float value in an exponential distributions
from  code::lo::  to  code::hi:: . It generates
this when the SynthDef first starts playing, and remains fixed for
the duration of the synth's existence.


classmethods::

method::new

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

Examples::

code::

(
SynthDef("help-ExpRand", { arg out=0, n=0;
	Out.ar(out,
		FSinOsc.ar(
			ExpRand(100.0, 8000.0, n),
			0, Line.kr(0.2, 0, 0.01, doneAction:2))
	)
}).send(s);
)

(
Routine({
	inf.do({ arg i;
		Synth.new("help-ExpRand"); 0.05.wait;
	})
}).play;
)

::

** class:: FBSineC
summary:: Feedback sine with chaotic phase indexing
categories:: UGens>Generators>Chaotic
related:: Classes/FBSineN, Classes/FBSineL

description::
A cubic-interpolating sound generator based on the difference equations:

code::
	x[n+1] = sin(im * y[n] + fb * x[n])
	y[n+1] = (a * y[n] + c) % 2pi
::
warning:: revise formulae conversion to c like code. ::

This uses a linear congruential function to drive the phase indexing of a sine wave. For code:: im = 1 ::, code:: fb = 0 ::, and code:: a = 1 :: a normal sinewave results.

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: im
Index multiplier amount
argument:: fb
Feedback amount
argument:: a
Phase multiplier amount
argument:: c
Phase increment amount
argument:: xi
Initial value of x
argument:: yi
Initial value of y

examples::
code::
// default initial params
{ FBSineC.ar(SampleRate.ir/4) * 0.2 }.play(s);
::

code::
// increase feedback
{ FBSineC.ar(SampleRate.ir, 1, Line.kr(0.01, 4, 10), 1, 0.1) * 0.2 }.play(s);
::

code::
// increase phase multiplier
{ FBSineC.ar(SampleRate.ir, 1, 0, XLine.kr(1, 2, 10), 0.1) * 0.2 }.play(s);
::

code::
// modulate frequency and index multiplier
{ FBSineC.ar(LFNoise2.kr(1, 1e4, 1e4), LFNoise2.kr(1,16,17), 1, 1.005, 0.7) * 0.2 }.play(s);
::

code::
// randomly modulate params
(
{ FBSineC.ar(
	LFNoise2.kr(1, 1e4, 1e4),
	LFNoise2.kr(1, 32, 33),
	LFNoise2.kr(1, 0.5),
	LFNoise2.kr(1, 0.05, 1.05),
	LFNoise2.kr(1, 0.3, 0.3)
) * 0.2 }.play(s);
)
::
** class:: FBSineL
summary:: Feedback sine with chaotic phase indexing
categories:: UGens>Generators>Chaotic
related:: Classes/FBSineC, Classes/FBSineN

description::
A linear-interpolating sound generator based on the difference equations:

code::
	x[n+1] = sin(im * y[n] + fb * x[n])
	y[n+1] = (a * y[n] + c) % 2pi
::
warning:: reviser formulae conversion to c like code. ::

This uses a linear congruential function to drive the phase indexing of a sine wave. For code:: im = 1 ::, code:: fb = 0 ::, and code:: a = 1 :: a normal sinewave results.

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: im
Index multiplier amount
argument:: fb
Feedback amount
argument:: a
Phase multiplier amount
argument:: c
Phase increment amount
argument:: xi
Initial value of x
argument:: yi
Initial value of y

examples::
code::
// default initial params
{ FBSineL.ar(SampleRate.ir/4) * 0.2 }.play(s);
::

code::
// increase feedback
{ FBSineL.ar(SampleRate.ir, 1, Line.kr(0.01, 4, 10), 1, 0.1) * 0.2 }.play(s);
::

code::
// increase phase multiplier
{ FBSineL.ar(SampleRate.ir, 1, 0, XLine.kr(1, 2, 10), 0.1) * 0.2 }.play(s);
::

code::
// modulate frequency and index multiplier
{ FBSineL.ar(LFNoise2.kr(1, 1e4, 1e4), LFNoise2.kr(1,16,17), 1, 1.005, 0.7) * 0.2 }.play(s);
::

code::
// randomly modulate params
(
{ FBSineL.ar(
	LFNoise2.kr(1, 1e4, 1e4),
	LFNoise2.kr(1, 32, 33),
	LFNoise2.kr(1, 0.5),
	LFNoise2.kr(1, 0.05, 1.05),
	LFNoise2.kr(1, 0.3, 0.3)
) * 0.2 }.play(s);
)
::
** class:: FBSineN
summary:: Feedback sine with chaotic phase indexing
categories:: UGens>Generators>Chaotic
related:: Classes/FBSineL, Classes/FBSineC

description::
A non-interpolating sound generator based on the difference equations:

code::
	x[n+1] = sin(im * y[n] + fb * x[n])
	y[n+1] = (a * y[n] + c) % 2pi
::
warning:: reviser formulae conversion to c like code. ::

This uses a linear congruential function to drive the phase indexing of a sine wave. For code:: im = 1 ::, code:: fb = 0 ::, and code:: a = 1 :: a normal sinewave results.

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: im
Index multiplier amount
argument:: fb
Feedback amount
argument:: a
Phase multiplier amount
argument:: c
Phase increment amount
argument:: xi
Initial value of x
argument:: yi
Initial value of y
argument:: mul
argument:: add

examples::
code::
// default initial params
{ FBSineN.ar(SampleRate.ir/4) * 0.2 }.play(s);
::

code::
// increase feedback
{ FBSineN.ar(SampleRate.ir, 1, Line.kr(0.01, 4, 10), 1, 0.1) * 0.2 }.play(s);
::

code::
// increase phase multiplier
{ FBSineN.ar(SampleRate.ir, 1, 0, XLine.kr(1, 2, 10), 0.1) * 0.2 }.play(s);
::

code::
// modulate frequency and index multiplier
{ FBSineN.ar(LFNoise2.kr(1, 1e4, 1e4), LFNoise2.kr(1,16,17), 1, 1.005, 0.7) * 0.2 }.play(s);
::

code::
// randomly modulate params
(
{ FBSineN.ar(
	LFNoise2.kr(1, 1e4, 1e4),
	LFNoise2.kr(1, 32, 33),
	LFNoise2.kr(1, 0.5),
	LFNoise2.kr(1, 0.05, 1.05),
	LFNoise2.kr(1, 0.3, 0.3)
) * 0.2 }.play(s);
)
::
** class:: FFT
summary:: Fast Fourier Transform
related:: Classes/IFFT, Guides/FFT-Overview
categories:: UGens>FFT

Description::

The fast fourier transform analyzes the frequency content of a signal, which can be useful for audio analysis or for frequency-domain sound processing (phase vocoder).

classmethods::

method::new

argument::buffer
A buffer to store spectral data. The buffer's size must
correspond to a power of 2. LocalBuf is useful here, because processes should not share data between synths. (Note: most PV UGens operate on this data in place. Use PV_Copy for parallel processing.)

argument::in
The signal to be analyzed. The signal's rate determines the rate at which the input is read.

argument:: hop
The amount of offset from the beginning of one FFT analysis frame to the next, measured in multiples of the analysis frame size. This can range between 1.0 and values close to (but larger than) 0.0, and the default is 0.5 (meaning each frame has a 50% overlap with the preceding/following frames).

argument:: wintype
Defines how the data is windowed:
table::
## -1 || strong::rectangular:: windowing, simple but typically not recommended;
## 0 || (the default) strong::Sine:: windowing, typically recommended for phase-vocoder work;
## 1 || strong::Hann:: windowing, typically recommended for analysis work.
::

argument:: active
A simple control allowing FFT analysis to be active (>0) or inactive (<=0). This is mainly useful for signal analysis processes which are only intended to analyse at specific times rather than continuously

argument:: winsize
The windowed audio frames are usually the same size as the buffer. If you wish the FFT to be zero-padded then you can specify a window size smaller than the actual buffer size (e.g. window size 1024 with buffer size 2048). Both values must still be a power of two. Leave this at its default of zero for no zero-padding.

returns::
The FFT chain

discussion::
Only the first two arguments are required. The remaining arguments allow for custom FFT analyses for specialised situations.

FFT uses a local buffer for holding the buffered audio. The buffer size must be a multiple of the control block size as well as being a power of two.

Note that for phase-vocoder usage, changing the hop or wintype settings from their defaults will typically result in unnatural sound when used in combination with IFFT, due to windowing artifacts. (A hop of 0.25, with Hann windowing, can be a useful combination for phase-vocoder work.)


Examples::

code::
(
{
	var in, chain;
	in = WhiteNoise.ar(0.1);
	chain = FFT(LocalBuf(2048), in);
	IFFT(chain) // inverse FFT
}.play;
)

// hinspecting it, we see that the chain is an FFT:
(
{
	var in, chain;
	in = WhiteNoise.ar(0.1);
	chain = FFT(LocalBuf(2048), in);
	chain.inspect; 
	IFFT(chain) // inverse FFT
}.play;
)

(
{
	var in, chain;
	in = SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08,0,6,6.2).squared, 0, 100, 800));
	chain = FFT(LocalBuf(2048), in);
	IFFT(chain)
}.play;
)

(
{
	var in, chain;
	in = SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08,0,6,6.2).squared, 0, 100,800));
	//in = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagAbove(chain, 310);
	0.5 * IFFT(chain);
}.play;
)

(
{
	var in, chain;
	in = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BrickWall(chain, SinOsc.kr(0.1));
	IFFT(chain)
}.play;
)

(
{
	var in, chain;
	in = WhiteNoise.ar(0.8);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_RandComb(chain, 0.95, Impulse.kr(0.4));
	IFFT(chain)
}.play;
)

(
{
	var in, chain;
	in = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_RectComb(chain, 8, LFTri.kr(0.097,0,0.4,0.5),
		LFTri.kr(0.24,0,-0.5,0.5));
	IFFT(chain)
}.play;
)

(
{
	var in, chain;
	in = SinOsc.ar(LFNoise1.kr(5.2,250,400));
	chain = FFT(LocalBuf(2048), in);
	// moves in and out of freeze
	chain = PV_MagFreeze(chain, SinOsc.kr(0.2) );
	0.5 * IFFT(chain);
}.play;
)


// stereo example:

(
{
	var in, chain;
	in = SinOsc.ar(LFNoise1.kr([5.2, 3.3],250,400));
	chain = FFT({ LocalBuf(2048) } ! 2, in); // we need two buffers for stereo input.
	// moves in and out of freeze
	chain = PV_MagFreeze(chain, SinOsc.kr([0.2, 0.3]) );
	0.5 * IFFT(chain);
}.play;
)

::

** class:: FFTTrigger
summary:: Outputs the necessary signal for FFT chains, without doing an FFT on a signal
categories:: UGens>FFT

classmethods::
private:: categories

method:: new
argument:: buffer
a buffer to condition for FFT use
argument:: hop
the hop size for timing triggers (defaults to 0.5)
argument:: polar
a flag. If 0.0, the buffer will be prepared for complex data, if > 0.0, polar data is set up.

examples::
code::
(
s.boot.doWhenBooted{
	b = Buffer.alloc(s, 512);
};
)
// Reminder: This isn't the intended typical usage! It's OK to do this though.
(
x = {
	var mags, phases, chain, sig;
	// Create simple undulating magnitudes
	mags = {FSinOsc.kr(ExpRand(0.1, 1)).range(0, 1)}.dup(100);
	// Then give them a "rolloff" to make the sound less unpleasant
	mags = mags  * ((1, 0.99 .. 0.01).squared);
	// Let's turn the bins on and off at different rates, I'm *sure* that'll sound interesting
	mags = mags * {LFPulse.kr(2 ** IRand(-3, 5)).range(0, 1)}.dup(100);
	// Let's ignore phase for now
	phases = 0.dup(100);
	chain = FFTTrigger(b, 0.5);
	// Now we can do the packing
	chain = PackFFT(chain, 512, [mags, phases].flop.flatten, 0, 99, 1);
	sig = IFFT(chain);
	Out.ar(0, sig.dup);
}.play(s);
)
x.free;
b.free;
::

** class:: FOS
summary:: First order filter section.
related:: Classes/SOS
categories::  UGens>Filters>Linear


Description::

A standard first order filter section. Filter coefficients are given
directly rather than calculated for you. Formula is equivalent to:

code::
out(i) = (a0 * in(i)) + (a1 * in(i-1)) + (b1 * out(i-1))
::


classmethods::

method::ar, kr

argument::in
Signal input.

argument::a0
See formula above.

argument::a1
See formula above.

argument::b1
See formula above.

argument::mul

argument::add

Examples::

code::

(
// same as OnePole
{	var x;
	x = LFTri.ar(0.4, 0, 0.99);
	FOS.ar(LFSaw.ar(200, 0, 0.2), 1 - x.abs, 0.0, x)
}.play;
)

(
// same as OneZero
{	var x;
	x = LFTri.ar(0.4, 0, 0.99);
	FOS.ar(LFSaw.ar(200, 0, 0.2), 1 - x.abs, x, 0.0)
}.play;
)

(
// same as OnePole, kr
{	var x, ctl;
	x = LFTri.kr(0.2, 0, 0.99);
	ctl = FOS.kr(LFSaw.kr(8, 0, 0.2), 1 - x.abs, 0.0, x);
	LFTri.ar(ctl * 200 + 500);
}.play;
)

::

** class:: FSinOsc
summary:: Fast sine oscillator.
related:: Classes/SinOsc, Classes/SinOscFB
categories::  UGens>Generators>Deterministic

Description::

Very fast sine wave generator (2 PowerPC instructions per output sample!)
implemented using a ringing filter. This generates a much cleaner sine
wave than a table lookup oscillator and is a lot faster. However, the
amplitude of the wave will vary with frequency. Generally the amplitude
will go down as you raise the frequency and go up as you lower the frequency.

warning::
In the current implementation, the amplitude can blow up if the
frequency is modulated by certain alternating signals.
::


classmethods::

method::ar, kr

argument::freq
Frequency in Hertz.

argument::iphase
Initial phase offset.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.


Examples::

code::
{ FSinOsc.ar(800) * 0.2 }.play;

{ FSinOsc.ar(XLine.kr(200, 4000, 1)) * 0.2 }.play;

// loses amplitude towards the end
{ FSinOsc.ar(FSinOsc.ar(XLine.kr(4, 401, 8), 0.0, 200, 800)) * 0.2 }.play;

::

** class::False
categories::Core
summary::false logical value

description::
see link::Classes/Boolean::
** class:: Fdef
summary:: lazy function proxy
categories:: Libraries>JITLib>Patterns
related:: Classes/Pdef, Classes/Tdef, Classes/Pdefn, Classes/Ndef

description::
Placeholder for functions to calculate with.

See also: link::Classes/Maybe:: and the link::Overviews/JITLib:: overview.

ClassMethods::

private::initClass

method::new

argument::key
if no instance exists with this name, create a new one, otherwise return the existing one.

argument::val
If a link::Classes/Function:: is given, replace the old function with the new one.

Examples::

code::
Fdef(\x, { 8 + 9 });

Fdef(\y, Fdef(\x) - 3);

Fdef(\y).value;

Fdef(\x, 3);

Fdef(\y).value;

Fdef(\x, { |x=0| x });


Fdef(\x).value(8);

Fdef(\y).value(8);


z = Fdef(\x) * Fdef(\y) + { 1.0.rand };

z.value;
z.value(400);
::

code::
// sound example
(
s.boot;
SynthDef("gpdef",
	{ arg out=0, freq=440, sustain=0.05, amp=0.1;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain), doneAction:2) * amp;
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

// fork a thread that plays some sounds
(
Fdef(\freq, 440);
Fdef(\dur, 0.2);

fork {
	loop {
		s.sendMsg("/s_new", "gpdef", -1, 1,1, \freq, Fdef(\freq).value);
		Fdef(\dur).value.wait;
	}
};
)

// some modifications

Fdef(\freq, Fdef(\midinote, 60).midicps);
Fdef(\midinote, { [67, 64, 65].choose });
Fdef(\midinote, { [67, 64, 65].choose } + Fdef(\offset));
Fdef(\offset, { 4.rand });
Fdef(\dur, 0.23);
::
** class:: File
summary:: A class for reading and writing files
related:: Classes/FileReader
categories:: Files

description::
A class for reading and writing files. Not sound files.

ClassMethods::

private::prGetcwd, prType

method::new
Create a File instance and open the file. If the open fails, link::Classes/UnixFILE#-isOpen#isOpen:: will return false.

argument::pathName
a link::Classes/String:: containing the path name of the file to open.

argument::mode
a link::Classes/String:: indicating one of the following modes:
definitionList::
## "r" || Opens a file for reading. The file must exist.
## "w" || Creates an empty file for writing. If a file with the same name already exists its content is erased and thefile is treated as a new empty file.
## "a" || Appends to a file. Writing operations append data at the end of the file. The file is created if it does not exist.
## "rb", "wb", "ab" || same as above, but data is binary
## "r+" || Opens a file for update both reading and writing. The file must exist.
## "w+" || Creates an empty file for both reading and writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.
## "a+" || Opens a file for reading and appending. All writing operations are performed at the end of the file, protecting the previous content to be overwritten. You can reposition the internal pointer using the seek method to anywhere in the file for reading, but writing operations will move it back to the end of file. The file is created if it does not exist.
## "rb+", wb+", "ab+" || same as above, but data is binary
::

method::open
same as link::#*new::, but a more intuitive name.

method::getcwd
POSIX standard 'get current working directory'.
code::
// example;
File.getcwd;
::

method::use
open the file, evaluate the function with the file and close it.

subsection:: Filesystem utilities

method::exists
answers if a file exists at that path.
note::
Some filesystems, like the one used by OSX, are case insensitive.
On such systems, this method will return true for "fOo" even if the file is actually named "Foo".
For a workaround, see link::#*existsCaseSensitive:: below.
::
returns:: a link::Classes/Boolean::

method::existsCaseSensitive
Like link::#*exists:: but ensure case sensitivity emphasis:: of the last path component :: on case insensitive filesystems. On case sensitive systems, it falls back to using code::exists::.

note::
This is slower than the normal code::exists:: method, so use it only when really needed.
::

method::systemIsCaseSensitive
answers if the filesystem is case sensitive or not.

method::mkdir
create directory at path, including any missing parent directories.

method::delete
deletes the file at that path. Use only for good, never for evil.

method::realpath
follow symbolic links (and aliases on OSX) and any parent directory references (like "..") and return the true absolute path.
returns:: a link::Classes/String:: or code::nil:: if path did not exist.

method::copy
copy file, symlink or directory. this method will fail if pathNameTo already exists.

symlinks are copied as symlinks (re-created).

method::type
get file type as one of code::\error, \not_found, \regular, \directory, \symlink, \block, \character, \fifo, \socket, \unknown::
returns:: a link::Classes/Symbol::

method::fileSize
get size of file in bytes.
returns:: an link::Classes/Integer::

method::mtime
get last modification time in seconds since the Epoch.
returns:: an link::Classes/Integer::


InstanceMethods::

private::prOpen, prClose

method::open
Open the file. Files are automatically opened upon creation, so this call is only necessary if you are closing and opening the same file object repeatedly.
note::
it is possible when saving files with a standard file dialog to elect to "hide the extension" and save it as RTF. When opening the file you must specify the real filename: "filename.rtf", even though you can't see in file load dialogs or in the Finder.
::

method::close
Close the file.

method::readAllString
Reads the entire file as a link::Classes/String::.

method::readAllStringRTF
Reads the entire file as a link::Classes/String::, stripping RTF formatting.

method::seek
moves the read/write pointer to a given location in the file, where offset is location given in bytes, and origin is the reference of the offset:
definitionList::
## 0 || offset is from the beginning of the file
## 1 || offset is relative to the current position in the file
## 2 || offset is from the end of the file
::

method::pos
sets or returns the current position in the file (in bytes).
when used as a setter, this method is a shortcut for seek(0, value). so setting the pos moves the current file position to a given location from the beginning of the file. the value is clipped so that it lies between 0 inclusively and the file length exclusively.

method::length
returns the current file size in bytes.

Examples::

code::
// write some string to a file:
(
var f, g;
f = File("test","w");
f.write("Does this work?\n is this thing on ?\n");
f.close;
)

// read it again:
(
g = File("test","r");
g.readAllString.postln;
g.close;
)

// try the above with File.use:

File.use("test", "w", { |f| f.write("Doesn't this work?\n is this thing really on ?\n"); });
File.use("test", "r", { |f| f.readAllString.postln });


// more file writing/reading examples:
(
var h, k;
h = File("test2", "wb");
h.inspect;
h.write( FloatArray[1.1, 2.2, 3.3, pi, 3.sqrt] );
h.close;

k = File("test2", "rb");
(k.length div: 4).do({ k.getFloat.postln; });
k.close;
)


(
var f, g;
f = File("test3","w");
100.do({ f.putChar([$a, $b, $c, $d, $e, $\n].choose); });
f.close;

g = File("test3","r");
g.readAllString.postln;
g.close;

g = File("test3","r");
g.getLine(1024).postln;
"*".postln;
g.getLine(1024).postln;
"**".postln;
g.getLine(1024).postln;
"***".postln;
g.getLine(1024).postln;
"****".postln;
g.close;
)

(
//var f, g;
f = File("test3","wb");
f.inspect;
100.do({ f.putFloat(1.0.rand); });

f.inspect;
f.close;

g = File("test3","rb");
100.do({
	g.getFloat.postln;
});
g.inspect;
g.close;
)

(
//var f, g;
f = File("test3","r");
f.inspect;
f.getLine(1024).postln;
f.close;
)
::
** class:: FileReader
summary:: file reader for space-delimited text files
related:: Classes/File
categories:: Files

description::
FileReader reads space-delimited text files into 2D arrays line by line.

For tab delimited files use link::Classes/TabFileReader::. For semi-colon-delimited files use link::Classes/SemiColonFileReader::. For comma-separated files use link::Classes/CSVFileReader::.

Examples::

code::
(
// write a test file:
f = File("FileReaderTest.sc", "w");
f.write(
"Some space delimited items in line 1

and then some more with several blanks     in line 3
"
);
f.close;
)


	// open file, read and put strings into array, close file.
x = FileReader.read("FileReaderTest.sc").postcs;

	// can skip empty lines:
x = FileReader.read("FileReaderTest.sc", true).postcs;

	// can skip blank entries caused by multiple spaces:
x = FileReader.read("FileReaderTest.sc", true, true).postcs;

	// do file open/close by hand if you prefer:
f = File("FileReaderTest.sc", "r"); f.isOpen;
t = FileReader(f, true, true);
t.read;
f.close;

	// take letter "a" as delimiter:
x = FileReader.read("FileReaderTest.sc", true, true, delimiter: $a).postcs;

(
// write a test file with numbers:
f = File("FileReadTestNum.sc", "w");

(1..10).do { |n| f.write(n.asString ++ " "); };
f.close;
)

x = FileReader.read("FileReadTestNum.sc").postcs;
x.collect(_.collect(_.interpret));	// convert to numbers.

	// or do it immediately:
x = FileReader.readInterpret("FileReadTestNum.sc").postcs;

(
// write a test file with several lines of numbers:
f = File("FileReadTestNum.sc", "w");

(1..100).do { |n|
	f.write(n.asString ++ if (n % 10 != 0, " ", Char.nl)); };
f.close;
)


x = FileReader.readInterpret("FileReadTestNum.sc", true, true).postln;
::
** class:: Filter
summary:: Base class for filter UGens
categories:: UGens>Filters

description::

"Filter" is an abstract class - in other words, a class that you do not use directly. Instead, use one of its subclasses. Many common filters inherit from this abstract class, including LPF, HPF, MoogFF, Ringz, Integrator, Median, LeakDC... and many more.

The Filter class also provides a simple way to visualise the frequency-wise effect of applying a filter, see code::scopeResponse:: below.

classmethods::
private:: categories

method:: scopeResponse
Provides a simple way to visualise the frequency-wise effect of applying a filter
discussion::
code::
Stethoscope.defaultServer.boot // boot the server that will be scoped
MoogFF.scopeResponse
HPF.scopeResponse
BRF.scopeResponse
Median.scopeResponse
::

instancemethods::
private:: checkInputs

** class:: FilterPattern
summary:: abstract class that holds a pattern to be modified
related:: Classes/ListPattern
categories:: Streams-Patterns-Events>Patterns>Filter

Examples::

code::
// post subclasses:

FilterPattern.dumpClassSubtree;
::
** class:: Float
summary:: Floating point number
categories:: Math

description::
A 64 bit double precision floating point number. Float inherits most of its behaviour from its superclass.

ClassMethods::

method:: from32Bits
returns:: a new Float from a 32 bit word.

method:: from64Bits
returns:: a new Float from a 64 bit word.

InstanceMethods::

method:: do
iterates a link::Classes/Function:: from code::0:: to code::this-1::. See also: link::Classes/Integer#-do::, link::Classes/Collection#-do::
argument:: function
The function to iterate.

method:: reverseDo
iterates function from this-1 to 0
argument:: function
The function to iterate.

method:: coin
Perform a random test whose probability of success in a range from
zero to one is this and return the result.
returns:: a link::Classes/Boolean::
discussion::
code::
0.2.coin; // 20 % chance for true.
::
See also: link::Guides/Randomness::

method:: isFloat
returns:: code::true:: since this is a Float.

method:: asFloat
returns:: code::this:: since this is a Float.

method:: as32Bits
returns:: an Integer which is the bit pattern of this as a 32bit single precision float

method:: high32Bits
returns:: an Integer which is the bit pattern of high 32 bits of the 64 bit double precision floating point value

method:: low32Bits
returns:: an Integer which is the bit pattern of high 32 bits of the 64 bit double precision floating point value

method:: asStringPrec
Returns a string representation of the number, with the desired precision (i.e. number of significant figures).
discussion::
code::
// example:
pi
pi.asStringPrec(3)
pi.asStringPrec(6)
(pi * 0.0001).asStringPrec(3)
7.4.asStringPrec(5)
7.4.asStringPrec(50)
::

** CLASS::FloatArray
summary::an array whose indexed slots are all of the same type
related::Classes/Int8Array, Classes/Int16Array, Classes/Int32Array, Classes/DoubleArray, Classes/SymbolArray
categories::Collections>Ordered

DESCRIPTION::
These classes implement arrays whose indexed slots are all of the same type.
list::
## Int8Array - 8 bit integer
## Int16Array - 16 bit integer
## Int32Array - 32 bit integer
## FloatArray - 32 bit floating point
## DoubleArray - 64 bit floating point
## SymbolArray - symbols
::

INSTANCEMETHODS::

method::readFromStream
** class:: FlowLayout
summary:: A view decorator which autowraps the view contents
categories:: GUI>Layout
related:: Classes/SCContainerView, Classes/CompositeView

description::
FlowLayout is a decorator which automatically arranges views inside a container view in a row, and starts a new row if there is not enough space left for the next view. link::Classes/Window:: and link::Classes/CompositeView:: both have code::addFlowLayout:: methods which assign FlowLayout to their view decorators and return the decorator.

classmethods::

method:: new
argument:: bounds
An instance of link::Classes/Rect::. Normally set to the code::parent.bounds::.
argument:: margin
An instance of link::Classes/Point::. The horizontal and vertical inner margins, within which the parent's subviews are placed.
argument:: gap
An instance of link::Classes/Point::. The horizontal and vertical layout gap between the subviews.

discussion::
Example:
code::
(
w = Window.new.front;
//change the gaps and margins to see how they work
w.view.decorator = FlowLayout( w.view.bounds, 10@10, 20@5 );
16.do{ Slider2D( w.view,80@80 ).background_( Color.rand ) };
)
::
You can also write:
code::
(
w = Window.new.front;
w.addFlowLayout( 10@10, 20@5 ); // a shortcut method, see SCContainerView
16.do{ Slider2D( w.view,80@80 ).background_( Color.rand ) };
)
::

instancemethods::

subsection:: Accessing Instance Variables

method:: nextLine
Forces the decorator to start a new line:
code::
(
w = Window.new;
q = w.addFlowLayout( 10@10, 20@5 );
Slider2D( w.view,140@140 ).background_( Color.rand );
q.nextLine;
Slider2D( w.view,140@140 ).background_( Color.rand );
w.front;
)
::

method:: indentedRemaining
Returns and instance of link::Classes/Rect::. This is a very useful method which tells you how much space is left in a row, before the next row starts. The height of code::indentedRemaining::, is the full height remaining in the FlowLayout.
code::
(
//normally you will only use the width of indentedRemaining
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,150@150 ).background_( Color.rand );
Slider2D( w.view,150@150 ).background_( Color.rand );
Slider( w.view, d.indentedRemaining.width@150) //fits this view perfectly to the right innerBounds
	.background_( Color.rand );
w.front;
)
::
Compare this with:
code::
( //here the third view is fit to both the right and bottom innerBounds
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,140@140 ).background_( Color.rand );
Slider2D( w.view,140@140 ).background_( Color.rand );
d.nextLine;
Slider2D( w.view, d.indentedRemaining ).background_( Color.rand );
w.front;
)
::

method:: bounds
The outer bounds in which the decorator places the subviews in the parent view.
argument:: b
An instance of link::Classes/Rect::.

method:: innerBounds
Returns the bounds inset by margin.

method:: gap
The horizontal and vertical layout gap between the subviews.
argument:: arg1
An instance of link::Classes/Point::.

method:: margin
The horizontal and vertical inner margins, within which the parent's subviews are placed.
argument:: arg1
An instance of link::Classes/Point::.


subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: left
Get the current left indentation or manually set it.
argument:: arg1
A number.
discussion::
code::
(
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,150@150 ).background_( Color.rand );
d.left_(220); //manually set the new indentation
Slider2D( w.view,150@150 ).background_( Color.rand );
w.front;
)
::

method:: top
Get the current top indentation or manually set it.
argument:: arg1
A number.
discussion::
code::
(
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,150@150 ).background_( Color.rand );
d.top_(50); //manually set the new indentation
Slider2D( w.view,150@150 ).background_( Color.rand );
Slider2D( w.view,150@150 ).background_( Color.rand );
w.front;
)
::

method:: shift
Set the current left and top indentation (see above).

method:: maxHeight
Get/set maximium height of the subviews in the current position.
argument:: arg1
A number.
discussion::
code::
(
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,100@160 ).background_( Color.rand );
Slider2D( w.view,150@150 ).background_( Color.rand );
"first row maxHeight: " ++ d.maxHeight.postln;
Slider2D( w.view,150@150 ).background_( Color.rand );
"second row maxHeight: " ++ d.maxHeight.postln;
w.front;
)
::

method:: maxRight
Get/set maximium right of the subviews in the current position.
argument:: arg1
A number.
discussion::
code::
(
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,100@160 ).background_( Color.rand );
"first row maxRight: " ++ d.maxRight.postln;
Slider2D( w.view,150@150 ).background_( Color.rand );
Slider2D( w.view,150@150 ).background_( Color.rand );
"second row maxRight: " ++ d.maxRight.postln;
w.front;
)
::

method:: currentBounds
Gets a link::Classes/Rect:: with code::bounds.width:: and code::height = top + maxHeight::.
discussion::
code::
(
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 10@5 );
Slider2D( w.view,100@160 ).background_( Color.rand );
d.currentBounds.postln;
Slider2D( w.view,150@150 ).background_( Color.rand );
d.currentBounds.postln;
Slider2D( w.view,150@150 ).background_( Color.rand );
d.currentBounds.postln;
w.front;
)
::

method:: used
Gets a link::Classes/Rect:: with the space actually used.
discussion::
code::
(
w = Window.new;
w.view.decorator = d = FlowLayout.new( w.view.bounds, 10@10, 20@5 );
Slider2D( w.view,100@160 ).background_( Color.rand );
d.used.postln;
Slider2D( w.view,150@150 ).background_( Color.rand );
d.used.postln;
Slider2D( w.view,150@150 ).background_( Color.rand );
d.used.postln;
w.front;
)
::

method:: reset
Resets the layout mechanism to 0,0.

** CLASS:: FlowView
summary:: CompositeView with a FlowLayout as decorator
categories:: GUI>Views
related:: Classes/FlowLayout, Classes/CompositeView

DESCRIPTION::
In the simplest respect this is a lazy contraction of this:
code::
w = GUI.window.new;
w.view.decorator = FlowLayout.new(w.bounds);
w.front;
::

link::Classes/FlowView:: add some features to this setup.
code::
(
f = FlowView.new;

GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));

// the StartRow will be fixed at this point in the children array
f.startRow;

GUI.slider.new(f, Rect(0,0,100,100));
f.startRow;

GUI.slider.new(f, Rect(0,0,100,100));
)
::


CLASSMETHODS::

METHOD:: new

argument:: parent
Parent widget.

argument:: bounds
An instance of link::Classes/Rect::, or a link::Classes/Point:: indicating width@height.

argument:: margin
...
argument:: gap
...
argument:: windowTitle
Title of the window.


INSTANCEMETHODS::

METHOD:: startRow
Start a new row.

METHOD:: indentedRemaining
The maximum space that is left, starting at the current cursor position.
code::
(
f = FlowView.new;

GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));

GUI.slider.new(f, f.indentedRemaining)
	.background = Color.blue(alpha:0.2)
)

(
f = FlowView.new;

GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));

f.startRow; // new row

GUI.slider.new(f, f.indentedRemaining)
	.background = Color.blue(alpha:0.2)
)

(
f = FlowView.new;

GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));

GUI.slider.new(f, f.indentedRemaining)
	.background = Color.blue(alpha:0.2)
)
::

METHOD:: used
The area used so far, rounded up to the nearest rectangle plus margin.
code::
(
w = GUI.window.new;
w.front;
f = FlowView.new(w);
f.background = Color.blue(alpha:0.1);

GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));

f.used.postln;

// overlaid
GUI.compositeView.new(w,f.used)
	.background = Color.red(alpha: 0.1);
)

(
w = GUI.window.new;
w.front;
f = FlowView.new(w);
f.background = Color.blue(alpha:0.1);

GUI.slider.new(f, Rect(0,0,100,100));
GUI.slider.new(f, Rect(0,0,100,100));

f.startRow; // new row

GUI.slider.new(f, Rect(0,0,100,100));

f.used.postln;

// overlaid
GUI.compositeView.new(w,f.used)
	.background = Color.red(alpha: 0.1);
)
::

METHOD:: flow
Insert a sub flow view into the current view.
code::
(
f = FlowView.new;

GUI.slider.new(f, Rect(0,0,100,100));

// flow within a flow
g = f.flow({ arg g;
	ActionButton(g,"a");
	GUI.slider.new(g,Rect(0,0,100,100)).background_(Color.rand);
}).background_(Color.black); // shrinks to fit the contents afterwards
)
::

argument:: func
(describe argument here)

argument:: bounds
(describe argument here)

METHOD:: comp
Insert a sub composite view into the current view.
code::
(
f = FlowView.new;

GUI.slider.new(f, Rect(0,0,100,100));

// sc composite view
g = f.comp({ arg g;
	GUI.slider.new(g, Rect(50,30,50,100)).background_(Color.rand);
	GUI.slider.new(g, Rect(120,30,50,100)).background_(Color.rand);
},Rect(0, 0, 200, 200)).background_(Color.black);

f.startRow;
"Back to flowing".gui(f);
)
::

argument:: func
(describe argument here)

argument:: bounds
(describe argument here)


EXAMPLES::

code::
// note: some of the following examples use ActionButton from the crucialib

// tests
(
FlowView.new.flow({ arg f;
//	b = ActionButton(f,"hi",minWidth:140)
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	b = ActionButton(f,"hi",minWidth:140);
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	b = GUI.slider.new(f,Rect(0,0,100,100));
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	g = f;
	f.flow({ arg f;
		//b = ActionButton(f,"hi",minWidth:140)
	}).background_(Color.white)
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	g = f;
	f.flow({ arg f;
		b = ActionButton(f,"hi",minWidth:140)
	}).background_(Color.white)
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	g = f;
	f.flow({ arg f;
		f.flow({ arg f;
			ActionButton(f,"hello",minWidth:100);
		}).background_(Color.blue);
		b = ActionButton(f,"hi",minWidth:140);
	}).background_(Color.white)
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	g = f;
	f.flow({ arg f;
		f.flow({ arg f;
			ActionButton(f,"hello",minWidth:100);
		}).background_(Color.blue);
		b = ActionButton(f,"hi",minWidth:140);
	}).background_(Color.white)
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
	g = f;
	f.flow({ arg f;
		b = ActionButton(f,"hi",minWidth:140);
		f.flow({ arg f;
			ActionButton(f,"hello",minWidth:100);
		}).background_(Color.blue);
	}).background_(Color.white)
}).background_(Color.grey)
)

(
FlowView.new.flow({ arg f;
	g = f;
	f.flow({ arg f;
		b = GUI.slider.new(f,Rect(0,0,140,20));
		f.flow({ arg f;
			ActionButton(f,"hello",minWidth:100);
		}).background_(Color.blue);
	}).background_(Color.white)
}).background_(Color.grey)
)


(
FlowView.new.flow({ arg f;
		b = GUI.slider.new(f,Rect(0,0,140,20));
		f.flow({ arg f;
			ActionButton(f,"hello",minWidth:100);
		}).background_(Color.blue);
}).background_(Color.grey)
)


(
a = FlowView.new.flow({ arg f;
	g = f;
	w = f.flow({ arg f;
		b = f.flow({ arg f;
			ActionButton(f,"hello",minWidth:100);
		}).background_(Color.blue);
		ActionButton(f,"hi",minWidth:140);
	}).background_(Color.white)
}).background_(Color.grey)

)

b.remove(true);
w.resizeToFit(true,true);


// add something big back in
ActionButton(w,"i'm back",minWidth: 200);
w.resizeToFit(true,true);
// slightly wrong size at the bottom
::
** class:: Fold
summary:: Fold a signal outside given thresholds.
related:: Classes/Clip, Classes/Wrap
categories::  UGens>Maths


Description::

This differs from the  link::Classes/BinaryOpUGen::  link::Overviews/Methods#fold2#fold2:: in that it
allows one to set low and high thresholds.


classmethods::

method::ar, kr

argument::in
Signal to be folded.

argument::lo
Low threshold of folding. Sample values < lo will be folded. must be less then hi.

argument::hi
High threshold of folding. Sample values > hi will be folded. must be greater then lo.


Examples::

code::
s.boot;

{ Fold.ar(SinOsc.ar(440, 0, 0.2), -0.1, 0.1) }.scope;
::

** class:: Font
redirect:: implClass
summary:: A font object
categories:: GUI>Accessories

description::
This is the object you pass to other gui objects to set their font name or size.


classmethods::

private::key

method:: new

note:: The strong::bold::, strong::italic:: and strong::isPointSize:: arguments are only available in Qt GUI.
::

argument:: name
An instance of link::Classes/String::. Must coincide with the name of a font on the system. See link::#*availableFonts::.

argument:: size
An instance of link::Classes/Float::.

argument:: bold
A Boolean.

argument:: italic
A Boolean.

argument:: usePointSize
A Boolean. Whether to regard the strong::size:: argument as point-size - adapting to the screen resolution.

discussion::
Example:
code::
g = Font("Helvetica", 12);
::

method:: availableFonts
returns::
link::Classes/Array:: of the available fonts.

method:: antiAliasing
argument:: flag
An instance of link::Classes/Boolean::. Default value is code::false::.

method:: smoothing
argument:: flag
An instance of link::Classes/Boolean::. Default value is code::false::.

method:: defaultSansFace
returns::
The default sans serif face Font.

method:: defaultSerifFace
returns::
The default serif face Font.

method:: defaultMonoFace
returns::
The default monospace face Font.

method:: default
The global default Font.

In Qt GUI, setting this property is equivalent to code::Font.setDefault(font)::. See link::#*setDefault:: for details.

method:: setDefault
note::Only available in Qt GUI::
Sets the global default font. Properties of the code::font:: argument will be combined with properties of the default system font, and those of individual views.

Optionally, a class can be given, so only views of that class will be affected.

Note that this will immediately affect any existing views.

argument:: font
An instance of Font.

argument:: class
A Class (either QView or one of its subclasses), or code::nil::.

method:: sansSerif
Create a new sans serif face Font.

method:: monospace
Create a new monospace face Font.

method:: serif
Create a new serif face Font.

instancemethods::

method:: name
Gets/sets the name of the font.
argument:: value
An instance of link::Classes/String::.

method:: size
Gets/sets the size of the font.
note:: In Qt GUI, setting this variable is always considered as setting the link::#-pixelSize::, while getting it will return any size set. In other GUI kits, size is always considered as pixel-size anyway. See link::#-hasPointSize:: for distinction.::

argument:: pixelSize
A Float.

method:: hasPointSize
note::Only in Qt GUI::
A Boolean variable indicating whether the link::#-size:: is regarded as pixel-size (precise amount of pixels), or point-size (adapting to screen resolution).
To change this, you need to set the size via link::#-pixelSize:: or link::#-pointSize::.

method:: pixelSize
note::Only in Qt GUI::
Gets or sets the pixel-size of the font. When getting, returns nil if the font has point-size instead. See link::#-hasPointSize:: for distinction.
Argument::
	Any number, but note that floats will be rounded to integer values when setting pixel-size.


method:: pointSize
note::Only in Qt GUI::
Gets or sets the point-size of the font. When getting, returns nil if the font has pixel-size instead. See link::#-hasPointSize:: for distinction.
Argument::
	A Float.

method:: setDefault
Makes this instance of Font the default.

In Qt GUI, this is equivalent to calling link::#*setDefault:: with this Font and the given class as arguments.

In other GUI kits, this is equivalent to setting the link::#*default:: property.

method:: storeArgs
(?)
Returns:: an link::Classes/Array::, code:: [ name, size ] ::.

method:: boldVariant

note:: On the Cocoa GUI it appendes teletype::"-Bold":: to the name. This is only useful for fonts that have bold
variants.
::
returns::
Bold variant of the Font.


examples::

code::
(
w = Window.new.front;
t = StaticText(w, w.view.bounds).align_(\center);
t.string=" SUPERCOLLIDER";
)
t.font = Font("Monaco", 24);


(
var updateFont;
w = Window("Fonts", Rect(150, Window.screenBounds.height - 500, 400, 400)).front;
w.view.decorator = FlowLayout(w.view.bounds);
StaticText.new(w, Rect(5, 0, 30, 20)).string_("Font").align_(\rght);
m = PopUpMenu(w, Rect(40, 0, 250, 20));
m.items = Font.availableFonts;

StaticText.new(w, Rect(290, 0, 28, 20)).string_("Size").align_(\right);
y = PopUpMenu(w, Rect(322, 0, 50, 20));
y.items = ["6","7","8","9","10","12","13","14","18","24","36","48","60","72","96"];

t = TextView(w, Rect(10, 40, 380, 150));
t.string = "\nThe quick drowned fox jumped over the lazy blog. \n\n 0 1 2 3 4 5 6 7 8 9 ";

a = StaticText(w, 200@20).string_("The quick drowned fox").background_(Color.rand).align_(\center);
b = Button(w, 200@20).states_([["The quick drowned fox"]]).background_(Color.rand);
c = PopUpMenu(w, 200@20).items_(["The quick drowned fox"]).background_(Color.rand);

y.action = {
	var font;
	font = Font(m.items[m.value],y.items[y.value].asInteger);
	a.font_(font).refresh;
	b.font_(font).refresh;
	c.font_(font).refresh;
	t.font_(font).refresh;
};

m.action = y.action;

m.valueAction = 3;
y.valueAction = 5;
)


(
var w, f;

w = Window("Fonts", Rect(128, 64, 340, 360));
w.view.decorator = f = FlowLayout(w.view.bounds,Point(4, 4),Point(4, 2));

[
"Helvetica-Bold",
"Helvetica",
"Monaco",
"Arial",
"Gadget",
"MarkerFelt-Thin"
].do({ arg name;
	var v, s, n, spec, p, height = 16;

		v = StaticText(w, Rect(0, 0, 56, height + 2));
		v.font = Font(name, 13);
		v.string = name;

		s = Button(w, Rect(0, 0, 140, height + 2));
		s.font = Font(name, 13);
		s.states = [[name]];

		n = NumberBox(w, Rect(0, 0, 56, height + 2));
		n.font = Font(name, 13);
		n.object = pi;

	f.nextLine;
});

w.front;
)


(
var w, f, i = 0;

w = Window("Fonts", Rect(128, 64, 820, 760));
b = ScrollView(w, w.view.bounds);

b.decorator = f = FlowLayout(b.bounds, Point(4,4), Point(4,2));

Font.availableFonts.do({ arg name;
	var v, s, n, spec, p, height = 16, font;
	font = Font(name,13);

		v = StaticText(b, Rect(0, 0, 56, height + 2));
		v.font = font;
		v.string = name;

		s = Button(b, Rect(0, 0, 140, height + 2));
		s.font = font;
		s.states = [[name]];
		s.action = { font.asCompileString.postln; };

		n = NumberBox(b, Rect(0, 0, 56, height + 2));
		n.font = font;
		n.object = pi;
	if( (i = i + 1) % 3 == 0,{
		f.nextLine;
	});
});

w.front;
)
::
** class:: Formant
summary:: Formant oscillator
categories::  UGens>Generators>Deterministic


Description::

Generates a set of harmonics around a formant frequency at a given
fundamental frequency.


classmethods::

method::ar

argument::fundfreq
Fundamental frequency in Hertz. (control rate)

argument::formfreq
Formant frequency in Hertz. (control rate)

argument::bwfreq
Pulse width frequency in Hertz. Controls the bandwidth of the
formant. (control rate)

Must be greater than or equal to code::fundfreq::.

argument::mul

argument::add

discussion::
The frequency inputs are read at control rate only, so if you use an audio rate UGen as an input, it will only be sampled at the start of each audio synthesis block.


Examples::

code::
// modulate fundamental frequency, formant freq stays constant
{ Formant.ar(XLine.kr(400,1000, 8), 2000, 800, 0.125) }.play

// modulate formant frequency, fundamental freq stays constant
{ Formant.ar(200, XLine.kr(400, 4000, 8), 200, 0.125) }.play

// modulate width frequency, other freqs stay constant
{ Formant.ar(400, 2000, XLine.kr(800, 8000, 8), 0.125) }.play
::
** class:: Formlet
summary:: FOF-like filter.
related:: Classes/RHPF, Classes/RLPF, Classes/Resonz, Classes/Ringz
categories::  UGens>Filters>Linear


Description::

This is a resonant filter whose impulse response is like that of a sine
wave with a  link::Classes/Decay2::  envelope over it. It is possible to
control the attacktime and decaytime.

Formlet is equivalent to:
code::
Ringz(in, freq, decaytime) - Ringz(in, freq, attacktime)
::

The great advantage to this filter over FOF is that there is no limit to
the number of overlapping grains since the grain is just the impulse
response of the filter.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::freq
Resonant frequency in Hertz.

argument::attacktime
60 dB attack time in seconds.

argument::decaytime
60 dB decay time in seconds.

argument::mul

argument::add

discussion::
Note that if attacktime == decaytime then the signal cancels out and if
attacktime > decaytime then the impulse response is inverted.


Examples::

code::
{ Formlet.ar(Impulse.ar(20, 0.5), 1000, 0.01, 0.1) }.play;

{ Formlet.ar(Blip.ar(XLine.kr(10,400,8), 1000, 0.1), 1000, 0.01, 0.1) }.play;

(
// modulating formant frequency
{
	var in;
	in = Blip.ar(SinOsc.kr(5,0,20,300), 1000, 0.1);
	Formlet.ar(in, XLine.kr(1500,700,8), 0.005, 0.04);
}.play;
)

(
// mouse control of frequency and decay time.
{
	var in;
	in = Blip.ar(SinOsc.kr(5,0,20,300), 1000, 0.1);
	Formlet.ar(in,
		MouseY.kr(700,2000,1),
		0.005, MouseX.kr(0.01,0.2,1));
}.play;
)

(
// mouse control of frequency and decay time.
{
	var freq;
	freq = Formlet.kr(
		Dust.kr(10 ! 2),
		MouseY.kr(7,200,1),
		0.005, MouseX.kr(0.1,2,1)
	);
	SinOsc.ar(freq * 200 + [500, 600] - 100) * 0.2
}.play;
)
::

** class::Frame
summary:: Stack Frame
categories:: Core>Kernel


description::
Frames are used to contain the arguments, variables and other information for active Functions.

There are no instance variables or methods.

Since Frames are often created on the stack, it is too dangerous to allow access to them. Dangling pointers could result.

Frame instances are inaccessible to the user.

For error handling routines, the relevant information from a Frame can be transferred into a DebugFrame object which can safely be inspected.

code::
	this.getBackTrace.inspect
::


** class:: Free
summary:: When triggered, frees a node.
related:: Classes/Pause, Classes/FreeSelf
categories::  UGens>Synth control

Description::
When triggered, frees a node.

classmethods::

method::kr

argument::trig
Trigger input

argument::id
Node to be freed.


Examples::

code::
s.boot;

SynthDef("a", { Out.ar(0, SinOsc.ar(800, 0, 0.2)) }).send(s);

SynthDef("b", { arg t_t=0; Out.ar(1, PinkNoise.ar(0.3)); Free.kr(t_t, 1001); }).send(s);

s.sendMsg(\s_new, \a, 1001, 0, 0);

s.sendMsg(\s_new, \b, 1002, 0, 0);

s.sendMsg(\n_set, 1002, \t_t, 1);

s.sendMsg(\s_new, \a, 1001, 0, 0);

s.sendMsg(\n_set, 1002, \t_t, 1);

s.sendMsg(\s_new, \a, 1001, 0, 0);

s.sendMsg(\n_set, 1002, \t_t, 1);
::

** class:: FreeSelf
summary:: When triggered, free enclosing synth.
related:: Classes/PauseSelf, Classes/Free
categories::  UGens>Synth control


Description::
Free enclosing synth when input signal crosses from non-positive to
positive.


classmethods::

method::kr

argument::in

The input signal.


Examples::

code::
(
SynthDef("freeSelf-help", { arg out, t_trig;
	FreeSelf.kr(t_trig);
	Out.ar(out, SinOsc.ar(400,0,0.2));
}).send(s);
)

s.sendMsg("/s_new", "freeSelf-help", 1731);
s.sendMsg("/n_set", 1731, \t_trig, 1);

// a single impulse SynthDef:

(
SynthDef("dirac", { arg out, amp=0.1;
	var u;
	u = Impulse.ar(1);
	FreeSelf.kr(u);
	Out.ar(out, u * amp);
		// multiply by amp after using for release, so amp = 0
		// doesn't cause synth buildup.
}).send(s);
)

(
Task {
	loop({
		fork {
			exprand(34, 156).do {|i|
				i = i + 1;
				s.sendMsg("/s_new", "dirac", -1,0,0, \amp, 1 / i);
				(0.006 * i).wait;
			};
		};
		1.wait;
	})
} .play;
)
::

** class:: FreeSelfWhenDone
summary:: Free the enclosing synth when a UGen is finished
related:: Classes/Done, Classes/PauseSelfWhenDone, Reference/UGen-doneActions
categories::  UGens>Synth control

Description::

Some UGens set a 'done' flag when they are finished playing.
FreeSelfWhenDone will free the enclosing synth when this flag is set to true.

See link::Classes/Done:: for a complete list of these UGens.

Note that many of these UGens have doneActions, which are another way of accomplishing the same thing. See link::Reference/UGen-doneActions:: for more detail.

note:: One must be careful when using binary operations on UGens with done flags, as these will return a link::Classes/BinaryOpUGen::, and thus prevent the done flag from being accessible. See example below. ::

classmethods::
private:: categories

method::kr

argument::src

the UGen to check for done.

examples::
code::
s.boot;

// simple example
(
{ var env;
env = Line.kr(0, 1, 1);
FreeSelfWhenDone.kr(env); // free synth at end of line
SinOsc.ar(200, 0, 0.5) * env
}.play;
)

// the previous example works, because FreeSelfWhenDone operates on the Line
// this version won't work
(
{ var env, output;
env = Line.kr(0, 1, 1);
output = SinOsc.ar(200, 0, 0.5) * env;
output.postln; // output is a BinaryOpUGen, which has no 'done' flag
FreeSelfWhenDone.kr(output); // won't ever be done
output
}.play;
)

// record for four seconds
b = Buffer.alloc(s, 44100 * 4.0, 1);
(
SynthDef("help-RecordBuf",{ arg out=0,bufnum=0;
	var formant, recbuf;
	formant = Formant.ar(XLine.kr(400,1000, 4), 2000, 800, 0.125);
	recbuf = RecordBuf.ar(formant, bufnum, recLevel: Line.kr(1, 1), loop: 0);
	// The RecordBuf doesn't loop, so you can check it for 'done' status
	FreeSelfWhenDone.kr(recbuf);
}).play(s,[\out, 0, \bufnum, b]);
)

// play it back
(
SynthDef("help-RecordBuf play",{ arg out=0,bufnum=0;
	var playbuf;
	playbuf = PlayBuf.ar(1,bufnum);
	FreeSelfWhenDone.kr(playbuf); // frees the synth when the PlayBuf is finished
	Out.ar(out, playbuf);
}).play(s,[\out, 0, \bufnum, b]);
)
::

** class:: FreeVerb
summary:: A reverb
categories:: UGens>Reverbs
related:: Classes/FreeVerb2, Classes/GVerb

description::
Coded from experiments with faust.

classmethods::

method:: ar
argument:: in
input signal.
argument:: mix
dry/wet balance. range 0..1.
argument:: room
room size. rage 0..1.
argument:: damp
Reverb HF damp. range 0..1.
argument:: mul
argument:: add

discussion::
Valid parameter range from 0 to 1. Values outside this range are clipped by the UGen.

examples::
code::
s.boot;

// FreeVerb - 1x1 ugen
(
z = SynthDef(\src, {|mix = 0.25, room = 0.15, damp = 0.5|
	Out.ar(0,
		FreeVerb.ar(
			Decay.ar(Impulse.ar(1), 0.25, LFCub.ar(1200, 0, 0.1)), // mono src
			mix, // mix 0-1
			room, // room 0-1
			damp // damp 0-1 duh
		) ! 2 // fan out...
	);
}).play
)
z.set(\room, 0.7)
z.set(\mix, 0.4)
z.set(\damp, 0.2)

z.free

// it expands as any ugen does
(
z = SynthDef(\src, {|mix = 0.25, room = 0.15, damp = 0.5|
	Out.ar(0,
		FreeVerb.ar(
			Pan2.ar(
				Decay.ar(Impulse.ar(1), 0.25, LFCub.ar(1200, 0, 0.1)),
				LFNoise1.ar(1).range(-1, 1)
			),
			mix,
			room,
			damp
		)
	);
}).play
)
z.set(\room, 0.7)
z.set(\mix, 0.4)
z.set(\damp, 0.2)

z.free
::
** class:: FreeVerb2
summary:: A two-channel reverb
categories:: UGens>Reverbs
related:: Classes/FreeVerb, Classes/GVerb

description::
Coded from experiments with faust.

classmethods::

method:: ar
argument:: in
input signal channel 1.
argument:: in2
input signal channel 2.
argument:: mix
dry/wet balance. range 0..1.
argument:: room
room size. rage 0..1.
argument:: damp
Reverb HF damp. range 0..1.
argument::mul
argument::add

discussion::
Valid parameter range from 0 to 1. Values outside this range are clipped by the UGen.

examples::
code::
s.boot;

// FreeVerb2 - demo synthdef
(
SynthDef(\FreeVerb2x2, {|outbus, mix = 0.25, room = 0.15, damp = 0.5, amp = 1.0|
	var signal;

	signal = In.ar(outbus, 2);

	ReplaceOut.ar(outbus,
		FreeVerb2.ar( // FreeVerb2 - true stereo UGen
			signal[0], // Left channel
			signal[1], // Right Channel
			mix, room, damp, amp)); // same params as FreeVerb 1 chn version

}).add;
)

// 2ch source
(
a = SynthDef(\src2x2, {
	Out.ar(0,
		Decay.ar(Impulse.ar(1), 0.25, LFCub.ar(1200, 0, 0.1)) ! 2 +
		Pan2.ar(
			Decay.ar(Impulse.ar(1, pi), 0.1, WhiteNoise.ar(0.1)),
			LFNoise1.kr(0.5).range(-1, 1)
		)
	)
}).play
)

// kick it in
z = Synth(\FreeVerb2x2, [\outbus, 0], addAction:\addToTail)
// experiment with some settings
z.set(\room, 0.7)
z.set(\mix, 0.33)
z.set(\damp, 0.9)

// silence
[a, z].do(_.free)

// crucial lib example
(
Patch({|mix =0.33, room = 0.25, damp = 0.7, amp = 0.1|
	var signal;

	signal = Decay.ar(Impulse.ar(1), 0.25, LFCub.ar(1200)) ! 2 +
		Pan2.ar(
			Decay.ar(Impulse.ar(1, pi), 0.1, WhiteNoise.ar),
			LFNoise1.kr(0.5).range(-1, 1)
		);

	FreeVerb2.ar(
		signal[0], // Left channel
		signal[1], // Right Channel
		mix, room, damp, amp)

}).gui
)
::
** class:: FreqScope
summary:: Frequency spectrum visualizer
categories:: GUI>Interfaces
related:: Classes/FreqScopeView

description::
FreqScope shows the frequency spectrum of the specified audio bus. The scope will remain active after a command-period. To turn it off you must either click off the 'Power' button or close the window.

Panel commands:
table::
## Power || Turns the scope on and off. This is useful for freezing the signal on the display or for saving CPU.
## BusIn || The audio bus to be analyzed.
## FrqScl || Determines the mapping of frequencies on the x-axis. Can be linear (lin) or logarithmic (log). Logarithmic is equal spacing per musical octave.
## dbCut || Determines the lowest decibel shown on the y-axis.
::

ClassMethods::

method:: new
argument:: width
Default value is 512.
argument:: height
Default value is 300.
argument:: busNum
The number of the audio link::Classes/Bus:: to be monitored.
argument:: scopeColor
An instance of link::Classes/Color::. The drawing color of the scope.
argument:: bgColor
An instance of link::Classes/Color::. The background color of the scope.
discussion::
Example:
code::
s = FreqScope.server.boot;

// create a new analyzer
FreqScope.new(400, 200, 0);

// basic sine
{ SinOsc.ar(2000, 0, 0.25) }.play(s);

// random saw
{ RLPF.ar(Saw.ar(110, 0.2), LFNoise2.kr(1,1e4,1e4), LFNoise2.kr(1, 0.2, 0.22)) }.play(s);

// modulate phase
{ SinOsc.ar(800, SinOsc.ar(XLine.kr(20, 8000, 10), 0, 2pi), 0.25) }.play(s);

// all harmonics
{ Blip.ar(200, Line.kr(1, 100, 10), 0.2) }.play(s);
::

subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: scopeOpen
Returns a link::Classes/Boolean::, whether the scope is open.

InstanceMethods::

subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method::window
Returns the window in which the link::Classes/FreqScopeView:: is placed.

method:: scope
Returns the link::Classes/FreqScopeView::.
** class:: FreqScopeView
redirect:: implClass
summary:: Frequency analysis view
categories:: GUI>Views
related:: Classes/FreqScope

description::
FreqScopeView shows the frequency spectrum of a specified audio bus.

note::

The scope will remain active after a command-period. To turn it off you must use the 'active' method.
Very important: You must run code::kill():: when the parent window is closed to avoid problems. It also frees the buffers that the scope allocated and stops the FFT analysis synth. So:
code::
(
w = Window("My Analyzer", Rect(0, 0, 511, 300));
f = FreqScopeView(w, w.view.bounds);
w.onClose_({ f.kill }); // YOU MUST HAVE THIS
w.front;
)
::

::


classmethods::

method:: new
argument:: parent
The parent view.
argument:: bounds
An instance of link::Classes/Rect::, or a link::Classes/Point:: indicating code::width@height::.
discussion::
Example:
code::
// Start server
s = s.boot;

// Create analyzer in a window
(
w = Window("My Analyzer", Rect(0, 0, 511, 300)); // width should be 511
f = FreqScopeView(w, w.view.bounds);
f.active_(true); // turn it on the first time;

w.onClose_({ f.kill }); // you must have this
w.front;
{ SinOsc.ar([500, 1000], 0, 0.25).mean.dup }.play(s); // start two sine waves
)
::

method:: response
Create a scope in a special frequency-response mode. This uses FFT-based spectral division to estimate the frequency response of some effect, on the assumption that the signal to bus1 is transformed to the signal at bus2 by some linear time-invariant process.
argument:: parent
The parent view.
argument:: bounds
An instance of link::Classes/Rect::, or a link::Classes/Point:: indicating code::width@height::.
argument:: bus1
The bus on which the "pre" signal is found.
argument:: bus2
The bus on which the "post" signal is found.
argument:: freqMode
Linear (0) or log(1) frequency mode. Defaults to 1.
discussion::
Example:
code::
Server.default = s = Stethoscope.defaultServer.boot;

// basic usage. try these. Each one will open a new window
// move the mouse left and right to test response in different ranges
LPF.scopeResponse
HPF.scopeResponse
MoogFF.scopeResponse
BBandPass.scopeResponse
BLowShelf.scopeResponse // by default BLowShelf doesn't mangle much
Resonz.scopeResponse
BRF.scopeResponse
Integrator.scopeResponse
Median.scopeResponse // nonlinear, and therefore interesting

// customize the parameters for more informative scoping
{|in| MoogFF.ar(in, freq: MouseX.kr(10, 10000, 1),
gain:MouseY.kr(4, 0))}.scopeResponse
::

subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: viewClass
Returns link::Classes/SCScope::. See also Subclassing and Internal Methods in link::Classes/SCView::.
warning::Cocoa specific::

method:: initClass
Sets the classvar, code::server = Server.default::.

method:: server
A classvar.

instancemethods::

method:: kill
Very important. This must be run when the parent window is closed to avoid problems. It also frees the buffers that the scope allocated and stops the FFT analysis synth.

method:: active
Turn the scope on or off.
argument:: bool
An instance of link::Classes/Boolean::.

method:: freqMode
argument:: mode
0 = linear, 1 = logarithmic.

method:: inBus
The bus to listen on.
argument:: num
An audio link::Classes/Bus:: number.

method:: dbRange
Get/set the amplitude range.
argument:: db
A link::Classes/Number::.

method:: special
Put the scope into a special mode using a user-specified link::Classes/SynthDef::. Note that only very particular SynthDefs should be used, namely ones that are derived from the code::\freqScope0:: or code::\freqScope1:: SynthDefs. Most users will not need to use this method directly, but it can be used to provide a customised analysis shown in the scope.
argument:: defname
Name of the link::Classes/SynthDef:: you wish to use.
argument:: extraArgs
Extra arguments that you may wish to pass to the synth.


subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: start

method:: eventSeq

method:: cmdPeriod

method:: initFreqScope

method:: sendSynthDefs

method:: allocBuffers

method:: freeBuffers

method:: node

method:: scopebuf

method:: fftbuf

method:: bufSize

examples::

code::
// Start server
s = Server.boot;


// Create analyzer in a window
(
w = Window("My Analyzer", Rect(0, 0, 511, 300)); // width should be 511
f = FreqScopeView(w, w.view.bounds);
f.active_(true); // turn it on the first time;

w.onClose_({ f.kill }); // you must have this
w.front;
{ SinOsc.ar([500, 1000], 0, 0.25).mean.dup }.play(s); // start two sine waves
)

f.freqMode_(1); // change to log scale so we can see them
f.inBus_(1); // look at bus 1
f.dbRange_(200); // expand amplitude range
f.active_(false); // turn scope off (watch CPU)
f.active_(true); // turn it back on

// Now press command-period. The scope is still running.

{ Mix.ar(SinOsc.ar([500, 1200, 3000, 9000, 12000], 0, [0.2, 0.1, 0.05, 0.03, 0.01])) }.play(s); // restart some sines

// Close window and scope is killed.
::
** class:: FreqShift
summary:: Frequency Shifter.
related:: Classes/Hilbert, Classes/HilbertFIR
categories::  UGens>Filters>Nonlinear, UGens>Filters>Pitch


Description::

FreqShift implements single sideband amplitude modulation, also known as
frequency shifting, but not to be confused with pitch shifting. Frequency
shifting moves all the components of a signal by a fixed amount but does
not preserve the original harmonic relationships.


classmethods::

method::ar

argument::in
The input signal.

argument::freq
Amount of shift in cycles per second.

argument::phase
Phase of the frequency shift (0..2pi).

argument::mul

argument::add


Examples::

code::
// shifting a 100Hz tone by 1 Hz rising to 500Hz
{FreqShift.ar(SinOsc.ar(100),XLine.kr(1,500,5),0,[0.1,0.1])}.play(s);

// shifting a complex tone by 1 Hz rising to 500Hz
{FreqShift.ar(Klang.ar(`[[101,303,606,808]]),XLine.kr(1,500,10),0,[0.1,0.1])}.play(s);

// modulating shift and phase
{FreqShift.ar(SinOsc.ar(10),LFNoise2.ar(0.3,1500),SinOsc.ar(500).range(0,2pi),[0.1,0.1])}.play(s);

// the ubiquitous houston example
(
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
{FreqShift.ar(PlayBuf.ar(1,b.bufnum,BufRateScale.kr(b.bufnum),loop:1),LFNoise0.kr(0.45,1000),0,[1,1])}.play(s);
)

// shifting bandpassed noise
{FreqShift.ar(BPF.ar(WhiteNoise.ar(0.2),1000,0.001),LFNoise0.kr(5.5,1000),0,[32,32])}.play(s);
::

subsection:: More Examples
send a SynthDef, run the routine then send a different SynthDef

code::
(// simple detune & pitchmod via FreqShift
SynthDef("frqShift1",{arg frq,detune=1.5;
	var e1,left,right;
	e1 = EnvGen.ar(Env.new([0,0.1,0],[1,2.3]),1,doneAction:2);
	left = SinOsc.ar(frq,0,e1); // original tone
	left = left + FreqShift.ar(left,frq*detune); // shift and add back to original
	right = FreqShift.ar(left,SinOsc.kr(3.23,0,5));
	Out.ar(0, [left,right] * 0.1);
}).add;
)

(// the routine
r = Routine({
	var table,pitch;
	table = [0,2,4,5,7,9,11,12];
	inf.do{
		pitch = (48+(12*2.rand) + table.choose).midicps;
		Synth.grain(\frqShift1, [\frq, pitch]);
		3.wait;
		};
	};
).play;
)

(// shift pulse wave in opposite directions
SynthDef("frqShift1",{arg frq,detune=0.15;
	var e1,snd,left,right;
	e1 = EnvGen.ar(Env.new([0,1,0],[0.02,3.2]),1,doneAction:2);
	snd = Pulse.ar(frq,SinOsc.kr(2.3).range(0.2,0.8),e1); // original tone
	left = FreqShift.ar(snd,XLine.kr(-0.1,-200,2)); // shift and add back to original
	right = FreqShift.ar(snd,XLine.kr(0.1,200,2));
	Out.ar(0, [left,right] * 0.1);
}).add
)

(// FreqShift >> feedback >>> FreqShiftc
SynthDef("frqShift1",{arg frq;
	var e1,snd,snd2,in;
	in = FreqShift.ar(InFeedback.ar(0,1)*3.2,XLine.ar(0.01,frq*1.5,1)); // shift the feedback
	e1 = Env.new([0,0.1,0],[0.02,2.98]);
	snd = SinOsc.ar(frq,0,EnvGen.ar(e1,1,doneAction:2));
	snd2 = FreqShift.ar(snd+in,SinOsc.ar(4.24,0.5,3),0,0.5); // subtle modulating shift
	OffsetOut.ar([0,1], Limiter.ar(snd2+snd * 0.5,1,0.005));
}).add;
)


(// ssllooww columbia tuned shift detune
r.stop; // stop old routine
Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav", bufnum:99);

SynthDef("frqShift1",{arg frq, bufnum;
	var e1,snd,left,right;
	e1 = Env.new([0,1,0],[3,1],-4);
	snd = PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum) * 0.01, loop:1);
	left = FreqShift.ar(snd,frq*2,0,EnvGen.ar(e1,1,doneAction:2)); // subtle shift of the output
	right = FreqShift.ar(snd,frq*3,0,EnvGen.ar(e1,1,doneAction:2));
	Out.ar(0, [left,right] * 3);
}).add;

(// the routine
r = Routine({
	var table,pitch;
	table = [0,2,4,5,7,9,11,12];
	inf.do{
		pitch = (48+(12*2.rand) + table.choose).midicps;
		s.sendMsg("s_new","frqShift1",-1,1,1, "frq", pitch, "bufnum", 99);
		3.wait;
		};
	};
).play;
)
::

** class:: FuncFilterPattern
summary:: Abstract class that filters a pattern using a function
related:: Classes/FilterPattern
categories:: Streams-Patterns-Events>Patterns>Filter

description::
This is an abstract class that filters a pattern using a function. See subclasses below:

classtree::FuncFilterPattern

** class::Function
summary::Implements a function
categories::Core>Kernel

description::
A Function is a reference to a FunctionDef and its defining context Frame. When a FunctionDef is encountered in your code it is pushed on the stack as a Function. A Function can be evaluated by using the 'value' method. See the Functions help file for a basic introduction.

Because it inherits from AbstractFunction, Functions respond to math operations by creating a new Function.

code::
// example
(
var a, b, c;
a = { [100, 200, 300].choose };	// a Function
b = { 10.rand + 1 };	// another Function
c = a + b; 	// c is a Function.
c.value.postln;	// evaluate c and print the result
)
::

See AbstractFunction for function composition examples.

Because Functions are such an important concept, here some examples from related programming languages with functions as first class objects:

code::
// returning the first argument itself:
{ |x| x }.value(1) // SuperCollider
[:x | x ] value: 1 // Smalltalk
((lambda (x) x) 1) // Lisp
::

subsection:: Related Keywords

method:: thisFunction
The global pseudo-variable code::thisFunction:: always evaluates to the current
enclosing Function.

note::
Be aware of link::Reference/Control-Structures#Inline
optimization#inline optimizations:: which will be reflected in the value of
code::thisFunction::.
::

See also: link::Classes/FunctionDef#.thisFunctionDef#thisFunctionDef::


classMethods::

private::new

instancemethods::

subsection::Access

method::def

Get the definition ( FunctionDef ) of the Function.

method::isClosed

returns true if the function is closed, i.e. has no external references and can thus be converted to a compile string safely.

subsection::Evaluation

method::value

Evaluates the FunctionDef referred to by the Function. The Function is passed the args given.

code::
{ |a, b| (a * b).postln }.value(3, 10);
{ arg a, b; (a * b).postln }.value(3, 10); // different way of expressing the same
::

method::valueArray

Evaluates the FunctionDef referred to by the Function. If the last argument is an Array or List, then it is unpacked and appended to the other arguments (if any) to the Function. If the last argument is not an Array or List then this is the same as the 'value' method.

code::
{ |a, b, c| ((a * b) + c).postln }.valueArray([3, 10, 7]);

{ |a, b, c, d| [a, b, c, d].postln }.valueArray([1, 2, 3]);

{ |a, b, c, d| [a, b, c, d].postln }.valueArray(9, [1, 2, 3]);

{ |a, b, c, d| [a, b, c, d].postln }.valueArray(9, 10, [1, 2, 3]);
::

A common syntactic shortcut:

code::
{ |a, b, c| ((a * b) + c).postln }.value(*[3, 10, 7]);
::

method::valueEnvir

As value above. Unsupplied argument names are looked up in the current Environment.

code::
(
Environment.use({
~a = 3;
~b = 10;
{ |a, b| (a * b).postln }.valueEnvir;
});
)
::

method::valueArrayEnvir

Evaluates the FunctionDef referred to by the Function. If the last argument is an Array or List, then it is unpacked and appended to the other arguments (if any) to the Function. If the last argument is not an Array or List then this is the same as the 'value' method. Unsupplied argument names are looked up in the current Environment.


method::valueWithEnvir

Evaluate the function, using arguments from the supplied environment
This is slightly faster than valueEnvir and does not require replacing the currentEnvironment

code::
(
e = Environment.make({ ~a = 3; ~b = 10 });
{ |a, b| (a * b) }.valueWithEnvir(e);
)
::

method::functionPerformList

For Function, this behaves the same as valueArray(arglist). It is used  where Functions and other objects should behave differently to value, such as in the objecr prototyping implementation of Environment.


method::performWithEnvir

code::
a = { |a, b, c| postf("% plus % plus % is %\n", a, b, c, a + b + c); "" };
a.performWithEnvir(\value, (a: 1, c: 3, d: 4, b: 2));
::

argument::selector
A Symbol representing a method selector.
argument::envir
The remaining arguments derived from the environment and passed as arguments to the method named by the selector.

method::performKeyValuePairs

code::
a = { |a, b, c| postf("% plus % plus % is %\n", a, b, c, a + b + c); "" };
a.performKeyValuePairs(\value, [\a, 1, \b, 2, \c, 3, \d, 4]);
::

argument::selector
A Symbol representing a method selector.
argument::pairs
Array or List with key-value pairs.


method::loop

Repeat this function. Useful with Task and Clocks.

code::
t = Task({ { "I'm loopy".postln; 1.wait;}.loop });
t.start;
t.stop;
::

method::defer

Delay the evaluation of this Function by code::delta:: in seconds on AppClock.

This is equivalent to code::AppClock.sched(0, function):: unless code::delta:: is code::nil::. In that case the function is only scheduled if current code is not running on AppClock, otherwise the function is evaluated immediately.

code::
{ "2 seconds have passed.".postln; }.defer(2);

(
{ "chicken".postln }.defer(0); // schedules on the AppClock
{ "egg".postln }.defer // evaluates immediately
)

(
fork { // schedules on a TempoClock
    { "chicken".postln }.defer // schedules on the AppClock
};
{ "egg".postln }.defer // evaluates immediately
)
::

method::dup

Return an Array consisting of the results of n evaluations of this Function.

code::
x = { 4.rand; }.dup(4);
x.postln;
::

method::!

equivalent to dup(n)

code::
x = { 4.rand } ! 4;
x.postln;
::

method::sum

return the sum of n values produced.

code::
{ 4.rand }.sum(8);
::

method::choose

evaluates the function. This makes it polymorphic to SequenceableCollection, Bag and Set.

code::
[{ 100.rand }, [20, 30, 40]].collect(_.choose);
::

method::bench

Returns the amount of time this function takes to evaluate. print is a boolean indicating whether the result is posted. The default is true.

code::
{ 1000000.do({ 1.0.rand }); }.bench;
::

method::fork

Returns a Routine using the receiver as it's function, and plays it in a TempoClock.

code::
{ 4.do({ "Threadin...".postln; 1.wait;}) }.fork;
::

method::forkIfNeeded

If needed, creates a new Routine to evaluate the function in, if the message is called within a routine already, it simply evaluates it.

code::
f = { 4.do({ "Threadin...".postln; 1.wait;}) };
f.forkIfNeeded;
{ "we are now in a routine".postln; 1.wait; f.forkIfNeeded }.fork;
::

method::block

Break from a loop. Calls the receiver with an argument which is a function that returns from the method block. To exit the loop, call .value on the function passed in. You can pass a value to this function and that value will be returned from the block method.

code::
block {|break|
	100.do {|i|
		i.postln;
		if (i == 7) { break.value(999) }
	};
}
::

method::thunk

Return a Thunk, which is an unevaluated value that can be used in calculations

code::
x = thunk { 4.rand };
x.value;
x.value;
::

method::flop

Return a function that, when evaluated with nested arguments, does multichannel expansion by evaluting the receiver function for each channel. A flopped function responds like the "map" function in languages like Lisp.

code::
f = { |a, b| if(a > 0) { a + b } { -inf } }.flop;
f.value([-1, 2, 1, -3.0], [10, 1000]);
f.value(2, 3);
::


method::envirFlop

like flop, but implements an environment argument passing (valueEnvir).
Less efficient in generation than flop, but not a big difference in evaluation.

code::
f = { |a| if(a > 0) { a + 1 } { -inf } }.envirFlop;
e = (a: [20, 40]);
e.use { f.value }
::


method::inEnvir

returns an "environment-safe" function. See Environment for more details.

code::
// prints nil because ~a is read from topEnvironment, not e
e = (a: "got it", f: { { ~a.postln }.defer(0.5) });
e.use { e.f };

// prints "got it" because { ~a.postln } is now bound to the e environment
e = (a: "got it", f: { { ~a.postln }.inEnvir.defer(0.5) });
e.use { e.f };
::


method::case

Function implements a case method which allows for conditional evaluation with multiple cases. Since the receiver represents the first case this can be simply written as pairs of test functions and corresponding functions to be evaluated if true. Unlike Object-switch, this is inlined and is therefore just as efficient as nested if statements.

code::
(
var i, x, z;
z = [0, 1, 1.1, 1.3, 1.5, 2];
i = z.choose;
x = case
	{ i == 1 }   { \no }
	{ i == 1.1 } { \wrong }
	{ i == 1.3 } { \wrong }
	{ i == 1.5 } { \wrong }
	{ i == 2 }   { \wrong }
	{ i == 0 }   { \true };
x.postln;
)
::

method::matchItem

Interface shared with other classes that implements pattern matching. See also: matchItem.
Function.matchItem evaluates the function with the item as argument, expecting a Boolean as reply.

code::
{ |x| x > 5 }.matchItem(6); // true
::

performDegreeToKey(scaleDegree, stepsPerOctave = 12, accidental = 0)

use a function as a conversion from scale degree to note number. See also SequenceableCollection and Scale

code::
// a strange mapping
(
var f = {|degree, stepsPerOctave, acc|
	(1.8 ** (degree % stepsPerOctave) + acc).postln
};
Pbind(
	\scale, f,
	\degree, Pseq([0, 1, 2b, 3s, 4s, 6, 14, [0, 2, 4], [1, 3, 6]], inf)
).play
)
::

subsection::Exception Handling


For the following two methods a return ^ inside of the receiver itself cannot be caught. Returns in methods called by the receiver are OK.


method::try

Executes the receiver. If an exception is thrown the catch function handler is executed with the error as an argument. handler itself can rethrow the error if desired.

method::protect

Executes the receiver. The cleanup function handler is executed with an error as an argument, or nil if there was no error. The error continues to be in effect.

subsection::Audio

method::play

This is probably the simplest way to get audio in SC3. It wraps the Function in a SynthDef (adding an Out ugen if needed), creates and starts a new Synth with it, and returns the Synth object. A Linen is also added to avoid clicks, which is configured to allow the resulting Synth to have its \gate argument set, or to respond to a release message. Args in the function become args in the resulting def.

code::
x = { |freq = 440| SinOsc.ar(freq, 0, 0.3) }.play; // this returns a Synth object;
x.set(\freq, 880); // note you can set the freq argument
x.defName; // the name of the resulting SynthDef (generated automatically in a cycle of 512)
x.release(4); // fadeout over 4 seconds
::

Many of the examples make use of the Function.play syntax.
Note that reusing such code in a SynthDef requires the addition of an Out ugen.

code::
// the following two lines produce equivalent results
{ SinOsc.ar(440, 0, 0.3) }.play(fadeTime: 0.0);
SynthDef(\help_FuncPlay, { Out.ar(0, SinOsc.ar(440, 0, 0.3))}).play;
::

Function.play is often more convienent than SynthDef.play, particularly for short examples and quick testing. The latter does have some additional options, such as lagtimes for controls, etc. Where reuse and maximum flexibility are of greater importance, SynthDef and its various methods are usually the better choice.

argument::target
a Node, Server, or Nil. A Server will be converted to the default group of that server. Nil will be converted to the default group of the default Server.
argument::outbus
the output bus to play the audio out on. This is equivalent to Out.ar(outbus, theoutput). The default is 0.
argument::fadeTime
a fadein time. The default is 0.02 seconds, which is just enough to avoid a click. This will also be the fadeout time for a release if you do not specify.
argument::addAction
see Synth for a list of valid addActions. The default is \addToHead.
argument::args
arguments

method::scope

As play above, and calls Server-scope to open a scope window in which to view the output.

code::
{ FSinOsc.ar(440, 0, 0.3) }.scope(1)
::

argument::numChannels
The number of channels to display in the scope window, starting from outbus. The default is 2.
argument::outbus
The output bus to play the audio out on. This is equivalent to Out.ar(outbus, theoutput). The default is 0.
argument::fadeTime
A fadein time. The default is 0.02 seconds, which is just enough to avoid a click.
argument::bufsize
The size of the buffer for the ScopeView. The default is 4096.
argument::zoom
A zoom value for the scope's X axis. Larger values show more. The default is 1.

method::plot

Calculates duration in seconds worth of the output of this function, and plots it in a GUI window. Unlike play and scope it will not work with explicit Out Ugens, so your function should return a UGen or an Array of them. The plot will be calculated in realtime.

code::
{ SinOsc.ar(440) }.plot(0.01, bounds: Window.screenBounds);

{ {|i| SinOsc.ar(1 + i)}.dup(7) }.plot(1);
::


argument::duration
The duration of the function to plot in seconds. The default is 0.01.
argument::server
The Server on which to calculate the plot. This must be running on your local machine, but does not need to be the internal server. If nil the default server will be used.
argument::bounds
An instance of Rect or Point indicating the bounds of the plot window.
argument::minval
the minimum value in the plot. Defaults to -1.0.
argument::maxval
the maximum value in the plot. Defaults to 1.0.
argument::parent
a window to place the plot in. If nil, one will be created for you.

subsection::Conversion

method::asSynthDef

Returns a SynthDef based on this Function, adding a Linen and an Out ugen if needed.

argument::rates
An Array of rates and lagtimes for the function's arguments (see SynthDef for more details).
argument::prependArgs
arguments
argument::outClass
The class of the output ugen as a symbol. The default is \Out.
argument::fadeTime
a fadein time. The default is 0.
argument::name
the name of the SynthDef

method::asDefName

Performs asSynthDef (see above), sends the resulting def to the local server and returns the SynthDefs name. This is asynchronous.

code::
x = { SinOsc.ar(440, 0, 0.3) }.asDefName; // this must complete first
y = Synth(x);
::

method::asRoutine

Returns a Routine using this as its func argument.

method::r

Returns a Routine using this as its func argument.

code::
a = r { 5.do { |i| i.rand.yield } };
a.nextN(8);
::

method::p

Returns a Prout using this as its func argument.

code::
a = p { 5.do { |i| i.rand.yield } };
x = a.asStream;
x.nextN(8);
::

This is useful for using ListComprehensions in Patterns:

code::
Pbind(\degree, p {:[x, y].postln, x<-(0..10), y<-(0..10), (x + y).isPrime }, \dur, 0.3).play;
::


examples::

subsection::Exception Handling

code::
// no exception handler
value { 8.zorg; \didnt_continue.postln; }

try { 8.zorg } {|error| error.postln; \cleanup.postln; }; \continued.postln;

protect { 8.zorg } {|error| error.postln; }; \didnt_continue.postln;
::

code::
try { 123.postln; 456.throw; 789.postln } {|error| [\catch, error].postln };

try { 123.postln; 789.postln } {|error| [\catch, error].postln };

try { 123.postln; nil.throw; 789.postln } {|error| [\catch, error].postln };

protect { 123.postln; 456.throw; 789.postln } {|error| [\onExit, error].postln };

protect { 123.postln; 789.postln } {|error| [\onExit, error].postln };

(
try {
	protect { 123.postln; 456.throw; 789.postln } {|error| [\onExit, error].postln };
} {|error| [\catch, error].postln };
)

value { 123.postln; 456.throw; 789.postln }

value { 123.postln; Error("what happened?").throw; 789.postln }
::

code::
(
a = [\aaa, \bbb, \ccc, \ddd];
a[1].postln;
a[\x].postln;
a[2].postln;
)

(
try {
	a = [\aaa, \bbb, \ccc, \ddd];
	a[1].postln;
	a[\x].postln;
	a[2].postln;
} {|error| \caught.postln; error.dump }
)

(
try {
	a = [\aaa, \bbb, \ccc, \ddd];
	a[1].postln;
	a[\x].postln;
	a[2].postln;
} {|error| \caught.postln; error.dump; error.throw }
)

(
protect {
	a = [\aaa, \bbb, \ccc, \ddd];
	a[1].postln;
	a[\x].postln;
	a[2].postln;
} {|error| \caught.postln; error.dump }
)
::



** class::FunctionDef
summary:: FunctionDefs contain code which can be executed from a Function.
categories::Core>Kernel

description::

subsection:: Related Keywords

method:: thisFunctionDef
The global pseudo-variable code::thisFunctionDef:: always evaluates to the
current enclosing FunctionDef.

See also: link::Classes/Function#.thisFunction#thisFunction::

instanceMethods::

subsection::Accessing

Even though it is possible to change the values in the various arrays that define the FunctionDef,
you should not do it, unless you like to crash.

method::code

Get the byte code array.

code::
{ |a = 9, b = 10, c| a + b }.def.code;
::

method::sourceCode

Get the source code string.
code::
{ |a = 9, b = 10, c| a + b }.def.sourceCode.postcs;
::

method::context

Get the enclosing FunctionDef or Method.

method::findReferences

return a list of all references to a given symbol.

method::argNames

Get the Array of Symbols of the argument names.

code::
{ |a = 9, b = 10, c| a + b }.def.argNames;
::
method::prototypeFrame

Get the array of default values for argument and temporary variables.

code::
{ |a = 9, b = 10, c| a + b }.def.prototypeFrame;
::
method::varNames

Get the Array of Symbols of the local variable names.

code::
{ |a = 9, b = 10, c| var x = 9; a + b + x }.def.varNames;
::
method::argumentString

Return a string that contains  arguments and their default values for embedding in a string

code::
{ |a = 9, b = 10, c| a + b }.def.argumentString;
::

method::makeEnvirFromArgs

Get the Array of Symbols of the local variable names.

code::
{ |a = 9, b = 10, c| a + b }.def.makeEnvirFromArgs;
::

subsection::Utilities

method::dumpByteCodes

"Disassemble" and post the FunctionDef's byte code instructions to the text window.
** class::FunctionList
summary:: A function that composes multiple functions into one
categories::Core>Kernel

description::

A FunctionList is a function that composes multiple functions into one. This allows allow to deal transparently with several functions as if they were one and to append new functions at a later point. The functions are evaluated in the order they have in the FunctionList's array, which is by default the order in which they have been added to it.

See the link::Reference/Functions:: help file for a basic introduction.

code::
a = FunctionList.new;
fork { loop { 0.7.wait; a.value.postln } };
a.addFunc({ 800.rand });
a.addFunc({ "another".scramble });
::

classMethods::

method::new

create a new instance.
argument:: functions
An array of functions or objects

instanceMethods::

method::array

Set/get the FunctionList's array. New functions can be added to the array directly, e.g.
code::
x = FunctionList(...some functions);
x.array = x.array.insert(2, aFunction);
::

method::addFunc

This message is used to be able to add to an Object, to a Function, or to a FunctionList.
code::nil.addFunc:: returns a function, if only one function is passed in the argument.
code::function.addFunc:: then returns a FunctionList.

method::removeFunc

remove a function from the list.

returns:: the last function when only one function is left, or code::nil:: when the last function was removed.

discussion::
code::addFunc:: and code::removeFunc:: are implemented for link::Classes/Nil::, link::Classes/Object:: and link::Classes/FunctionList::

code::
nil.addFunc(f) // returns f
obj.addFunc(f) // returns FunctionList([obj, f])
nil.removeFunc(f) // returns nil
obj.removeFunc(f) // returns nil, if f === obj, else obj is returned
::

examples::

code::
// example

a = nil;
a = a.addFunc { |x="", y=""| "this % is an % example\n".postf(x, y); 1 };
a.postln;
a = a.addFunc { |x="", y=""| "there is no % that is %\n".postf(x, y); 2 };
a.value;
a.value("text", "extraordinary well written")
a.valueArray(["x", "y"]);
::

code::
// Function:do vs FunctionList:do (same)
a.do { |x| x.value };
{ 4 }.do { |x| x.value.postln }

(
().use {
	~x = "array";
	~y = "ominous";
	a.valueEnvir;
	a.valueEnvir("list");
}
)
::

code::
// removing a function
x = { "removal test".postln };
a.addFunc(x);
a.value;
a = a.removeFunc(x);
a.value;

// mathematics
a = nil;
a = a.addFunc({ 1.0.rand }).addFunc({ [0, 1].choose });
a = a.squared.linexp(0, 1, 1.0, 500);

a.value;
::

code::
// compatibility with function multichannel expansion
a = nil;
a = a.addFunc { |x=0| if(x > 0) { 7 } { 1000.rand } };
a = a.addFunc { |x=0| if(x < 0) { 17 } { -1000.rand } };
a.value

a = a.flop;
a.value
a.value([-1, 1])
::

code::
// typical usage in a Document action
// see also SCView: addAction example.

d = Document.current;
d.keyDownAction = { "You touched the keyboard.".postln };

d.keyDownAction = d.keyDownAction.addFunc {:x, x<-(1..), :: "already % times\n\n".postf(x) };


d.keyDownAction = nil;

// even if you don't know if there is already an action defined
// one can add one.

(
d.keyDownAction = nil;
d.keyDownAction = d.keyDownAction.addFunc {:x, x<-(1..), :: "already % times\n\n".postf(x) };

);

d.keyDownAction = nil;
::



** class:: GUI
summary:: Factory abstraction for all GUI related core classes
categories:: GUI>Kits
related:: Overviews/GUI-Classes, Guides/GUI-Introduction, Classes/ViewRedirect


description::
SuperCollider currently supports three operating system platforms: Macintosh OSX, UNIX (Linux and FreeBSD) and Windows (with some limitations).

Graphical User Interface (GUI) code, for the most part, does not need to worry about which platform is executing the code because of the strong::view redirect:: system. At any time, one and only one strong::GUI kit:: is active. This determines which GUI classes will be used for rendering. These classes, the active views, have prefixes for the GUI kit that created the view object: SCWindow vs. JSCWindow vs. QWindow.

table::
## strong::GUI kit:: || strong::Code to activate:: || strong::Supported platform(s):: || strong::Framework:: || strong::Prefix::
## Cocoa || code::GUI.cocoa:: || Mac OSX only || Cocoa || SC-
## SwingOSC || code::GUI.swing:: || All || Java + Swing || JSC-
## Qt || code::GUI.qt:: || All || Qt || Q-
::

In general, users should not concern themselves with the prefixes. Instead, work with the emphasis::redirect:: classes, which have no prefix: Window, Button, Slider, etc. The redirect class will ask the currently-selected kit which emphasis::implementation class:: should be used.

The GUI kit (CocoaGUI, QtGUI, SwingGUI) maps the generic view names to the implementing classes: code::Window --> SCWindow, QWindow or JSCWindow::. These schemes are in turn used by link::Classes/ViewRedirect:: to provide a simple cross-platform gui syntax. The GUI class provides utilities for switching kits and other cross platform tasks. 

You can get your available schemes (depending on what you installed) with:
code::
GUI.schemes;
::
For a complete list of gui classes and redirects, see link::Overviews/GUI-Classes::.


subsection:: Switching and Referring to GUI Kits

As of this writing, three GUI kits are available through the GUI class: link::Classes/QtGUI:: (Qt framework), link::Classes/CocoaGUI:: (Mac OS X native) and link::Classes/SwingGUI:: (Java). Note that link::Classes/SwingOSC:: is not part of every SuperCollider distribution, so you may have to install it separately.

You can switch the GUI kit by calling one of the following class methods:
code::
GUI.qt;		// use Qt in subsequent GUI creation procedures
GUI.cocoa;	// use cocoa in subsequent GUI creation procedures
GUI.swing;	// use swing in subsequent GUI creation procedures
		// NOTE: If you do not have SwingOSC installed, you get
		// a warning only, and do not switch; so you cannot
		// accidentally disable your gui system.
::

These methods return the new GUI kit implementation. The current implementation can be queried by calling
code::
GUI.current;	// returns the current GUI kit implementation
::

If you want to make a GUI kit specific switch (e.g. in a class), then you should use the following instead, as on non-OSX systems the class CocoaGUI is not in the class library path, and you cannot check for an undefined class:
code::
GUI.id;	// returns the current GUI kit implementation id; this is currently either \cocoa or \swing
::

For persistency, you can store the identifier of the kit implementation and recall the kit through the class method code::fromID:::
code::
x = GUI.cocoa;
y = x.id;		// store the identifier of a kit implementation
y.postln;		// the id could be stored in a preferences file for example
GUI.swing;
// now switch back to the kit implementation with identifier y
GUI.fromID( y );
GUI.current.id.postln;	// --> cocoa
::

The code::*use:: and code::*useID:: methods allow you to temporarily switch the kit, so as to use it only for a dedicated block of statements:
code::
GUI.cocoa;
GUI.useID(\swing, { Array.rand( 1000, 0.0, 1.0 ).plot });
GUI.current.id.postln;	// --> still cocoa
::

You can get a particular kit using the code::*get:: method. You can switch to a particular kit using the code::*set:: method:
code::
x = GUI.get( \swing );	// note: unlike *swing and *cocoa, this does not _switch_ the current kit!
GUI.current.id.postln;	// --> still cocoa
GUI.set( x );			// now we make SwingOSC the current kit
GUI.window.viewPalette;
::

subsection:: Extending GUI Kits

GUI Kits can be extended with custom classes by using their respective code::put:: methods:
code::
GUI.get( \cocoa ).put( \myText, SCStaticText );
GUI.get( \swing ).put( \myText, JSCStaticText );

GUI.cocoa;
GUI.swing;
(
	w = GUI.window.new;
	GUI.myText.new( w, w.view.bounds.insetBy( 20, 20 )).string_( "schoko" ).background_( Color.red );
	w.front;
)
::

If you intend to add extensions from within your own classes upon class library initialization time, the preferred way is to do this in the startup process:
code::
MyGUIExtension {
	*initClass {
		StartUp.add({
			var scheme;

			scheme = GUI.get( \cocoa );
			if( scheme.notNil, {scheme.put( \myText, SCStaticText )});
			scheme = GUI.get( \swing );
			if( scheme.notNil, {scheme.put( \myText, JSCStaticText )});
		});
	}
}
::

classmethods::

subsection:: Methods and Variables for GUI

method:: new

method:: makeGUI

method:: initClass
Sets the code::skin:: to default values on compile.
code::
fontSpecs: ["Helvetica", 10],
fontColor: Color.black,
background: Color(0.8, 0.85, 0.7, 0.5),
foreground: Color.grey(0.95),
onColor: Color(0.5, 1, 0.5),
offColor: Color.clear,
gap: 0@0,
margin: 2@2,
buttonHeight: 16
::

method:: cocoa
Makes Cocoa (Mac OS X GUI) the current scheme and returns it. Subsequent GUI object calls to GUI are delegated to cocoa. Returns the current (cocoa) scheme.

method:: swing
Makes Swing (Java GUI) the current scheme and returns it. Subsequent GUI object calls to GUI are delegated to swing. Returns the current (swing) scheme.

method:: fromID
Changes the current scheme and returns the new scheme.
argument:: id
A link::Classes/Symbol::. The identifier of the scheme to use.


method:: current

Returns the current scheme. This is useful for objects that, upon instantiation, wish to store the then-current scheme, so as to be able to consistently use the same scheme in future method calls.

Note:: the caller shouldn't make any assumptions about the nature (the class) of the returned object, so that the actual implementation (an Event) may change in the future. ::


method:: get
Returns the scheme for a given identifier. Does not switch the current scheme.
argument:: id
A link::Classes/Symbol::. The identifier of the scheme to retrieve, such as returned by calling code::aScheme.id::.

method:: set
Changes the current scheme.
argument:: aScheme
An instance of link::Classes/Symbol::. The scheme to use as current scheme.

method:: use
Executes a function body, temporarily setting the current GUI scheme. This is usefull inside view's action functions in order to make this function use the GUI scheme that was originally used for the view of the action, even if the scheme has been switched meanwhile.
argument:: aScheme
The scheme to use during the function execution.
argument:: func
An Instance of link::Classes/Function::.

method:: useID
Same as code::use:: but using a scheme's id as first argument.
argument:: id
The id of the scheme to use during the function execution.
argument:: func
A body to execute.

method:: add
Registers a new scheme. This is typically called by external libraries in their startup procedure. If a scheme with the same identifier (code::scheme.id::) exists, it is overwritten.
argument:: aScheme
The scheme to add.

method:: doesNotUnderstand
All method calls are mapped to the current scheme, so that for example code::GUI.button:: can be used and is delegated to the button association of the current scheme.
argument:: selector
argument:: ... args

method:: setSkin
argument:: skinName

method:: scheme
A class variable. Returns the current scheme.

method:: schemes
A class variable. Returns an link::Classes/IdentityDictionary:: of registered schemes.

method:: skin
A class variable. Returns the current skin.

method:: skins
A class variable. Returns an link::Classes/IdentityDictionary:: of registered skins.
** class:: GVerb
summary:: A two-channel reverb
categories:: UGens>Reverbs
related:: Classes/FreeVerb, Classes/FreeVerb2

description::
A two-channel reverb link::Classes/UGen::, based on the "GVerb" LADSPA effect by Juhana Sadeharju (kouhia at nic.funet.fi).

subsection:: Known issues
list::
## There is a large CPU spike when the synth is instantiated while all the delay lines are zeroed out.
## Quick changes in roomsize result in zipper noise.
## emphasis::Changing the roomsize does not work properly! Still trying to look for the bug... (-josh)::
::

classmethods::

method:: ar
argument:: in
mono input.
argument:: roomsize
in squared meters.
argument:: revtime
in seconds.
argument:: damping
0 to 1, high frequency rolloff, 0 damps the reverb signal completely, 1 not at all.
argument:: inputbw
0 to 1, same as damping control, but on the input signal.
argument:: spread
a control on the stereo spread and diffusion of the reverb signal.
argument:: drylevel
amount of dry signal.
argument:: earlyreflevel
amount of early reflection level.
argument:: taillevel
amount of tail level.
argument:: maxroomsize
to set the size of the delay lines. Defaults to roomsize + 1.
argument:: mul
argument:: add

examples::
code::
#+BEGIN_SRC sclang


SynthDef(\test, {arg roomsize, revtime, damping, inputbw, spread = 15, drylevel, earlylevel,
		taillevel;
	var a = Resonz.ar(
		Array.fill(4, {Dust.ar(2)}), 1760 * [1, 2, 4, 8], 0.01).sum * 10;
//	var a = SoundIn.ar(0);
//	var a = PlayBuf.ar(1, 0);
	Out.ar(0, GVerb.ar(
		a,
		roomsize,
		revtime,
		damping,
		inputbw,
		spread,
		drylevel.dbamp,
		earlylevel.dbamp,
		taillevel.dbamp,
		roomsize, 0.3) + a)}).add
#+END_SRC

s.boot;
s.scope(2);

// bathroom
a = Synth(\test, [\roomsize, 5, \revtime, 0.6, \damping, 0.62, \inputbw, 0.48, \drylevel -6, \earlylevel, -11, \taillevel, -13]);
a.free;

//living room
a = Synth(\test, [\roomsize, 16, \revtime, 1.24, \damping, 0.10, \inputbw, 0.95, \drylevel -3, \earlylevel, -15, \taillevel, -17]);
a.free;

//church
a = Synth(\test, [\roomsize, 80, \revtime, 4.85, \damping, 0.41, \inputbw, 0.19, \drylevel -3, \earlylevel, -9, \taillevel, -11]);
a.free;

// cathedral
a = Synth(\test, [\roomsize, 243, \revtime, 1, \damping, 0.1, \inputbw, 0.34, \drylevel -3, \earlylevel, -11, \taillevel, -9]);
a.free

// canyon
a = Synth(\test, [\roomsize, 300, \revtime, 103, \damping, 0.43, \inputbw, 0.51, \drylevel -5, \earlylevel, -26, \taillevel, -20]);
a.free;

s.quit;
::
** class:: Gate
summary:: Gate or hold.
related:: Classes/Latch
categories::  UGens>Triggers


Description::

Allows input signal value to pass when gate is positive, otherwise holds last value.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::trig

Gate - can be any signal. The output is held fixed when this is non-positive.


Examples::

code::

s.boot;
// Control rate so as not to whack your speakers with DC
{ Gate.kr(WhiteNoise.kr(1, 0), LFPulse.kr(1.333, 0.5))}.scope(zoom: 20);

::

** class:: GbmanL
summary:: Gingerbreadman map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/GbmanN

description::
A linear-interpolating sound generator based on the difference equations:

code::
	x[n+1] = 1 - y[n] + abs(x[n])
	y[n+1] = x[n]
::
warning:: reviser formulae converted to c like code ::

The behavior of the system is dependent only on its initial conditions and cannot be changed once it's started.

Reference: Devaney, R. L. "The Gingerbreadman." Algorithm 3, 15-16, Jan. 1992.

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: xi
Initial value of x
argument:: yi
Initial value of y

examples::
code::
// default initial params
{ GbmanL.ar(MouseX.kr(20, SampleRate.ir)) * 0.1 }.play(s);

// different initial params
{ GbmanL.ar(MouseX.kr(20, SampleRate.ir), -0.7, -2.7) * 0.1 }.play(s);

// wait for it...
{ GbmanL.ar(MouseX.kr(20, SampleRate.ir), 1.2, 2.0002) * 0.1 }.play(s);

// as a frequency control
{ SinOsc.ar(GbmanL.ar(40)*400+500)*0.4 }.play(s);
::
** class:: GbmanN
summary:: Gingerbreadman map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/GbmanL

description::
A non-interpolating sound generator based on the difference equations:

code::
	x[n+1] = 1 - y[n] + abs(x[n])
	y[n+1] = x[n]
::
warning:: reviser formulae converted to c like code ::

The behavior of the system is only dependent on its initial conditions.

Reference: emphasis:: Devaney, R. L. "The Gingerbreadman." Algorithm 3, 15-16, Jan. 1992. ::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: xi
Initial value of x
argument:: yi
Initial value of y
argument:: mul
argument:: add

examples::
code::
// default initial params
{ GbmanN.ar(MouseX.kr(20, SampleRate.ir)) * 0.1 }.play(s);

// change initial params
{ GbmanN.ar(MouseX.kr(20, SampleRate.ir), -0.7, -2.7) * 0.1 }.play(s);

// wait for it...
{ GbmanN.ar(MouseX.kr(20, SampleRate.ir), 1.2, 2.0002) * 0.1 }.play(s);

// as a frequency control
{ SinOsc.ar(GbmanN.ar(40)*400+500)*0.4 }.play(s);
::
** class:: Gendy1
summary:: Dynamic stochastic synthesis generator.
related:: Classes/Gendy2, Classes/Gendy3
categories::  UGens>Generators>Stochastic


Description::

An implementation of the dynamic stochastic synthesis generator conceived
by Iannis Xenakis and described in  emphasis::Formalized Music (1992, Stuyvesant, NY: Pendragon Press) chapter 9 (pp 246-254) and chapters 13 and 14 (pp 289-322)::.

The BASIC program in the book was written by Marie-Helene Serra so I
think it helpful to credit her too.

The program code has been adapted to avoid infinities in the probability
distribution functions.

The distributions are hard-coded in C but there is an option to have new
amplitude or time breakpoints sampled from a continuous controller input.

subsection:: Technical notes
X's plan as described in chapter 13 allows the 12 segments in the period to be successively modified with each new period.
Yet the period is allowed to vary as the sum of the segment durations, as figure 1 demonstrates.
We can setup some memory of n (conventionally 12) points, or even simply vary successively a single point's ordinate and
duration. There are thus various schemes available to us. In one, fix period T and only move the (ti, Ei) within the period. In another, have a memory of 12 segments but allow continuous modification of the inter point intervals and the amplitudes.
In yet another, just have one point and random walk its amplitude and duration based on the probability distribution.
In this implementation I allow the user to initialise a certain number of memory points which is up to them.
To restrict the period to be unchanging, you must set rate variation to zero (dscale=0).

SuperCollider implementation by Nick Collins.


classmethods::

method::ar, kr

argument::ampdist

Choice of probability distribution for the next perturbation of
the amplitude of a control point.

The distributions are (adapted from the GENDYN program in Formalized Music):

table::
## 0: || LINEAR.
## 1: || CAUCHY.
## 2: || LOGIST.
## 3: || HYPERBCOS.
## 4: || ARCSINE.
## 5: || EXPON.
## 6: || SINUS.
::

Where the sinus (Xenakis' name) is in this implementation taken
as sampling from a third party oscillator. See example below.


argument::durdist

Choice of distribution for the perturbation of the current inter
control point duration.


argument::adparam

A parameter for the shape of the amplitude probability
distribution, requires values in the range 0.0001 to 1 (there are
safety checks in the code so don't worry too much if you want to
modulate!).


argument::ddparam

A parameter for the shape of the duration probability
distribution, requires values in the range 0.0001 to 1.


argument::minfreq

Minimum allowed frequency of oscillation for the Gendy1
oscillator, so gives the largest period the duration is allowed
to take on.


argument::maxfreq

Maximum allowed frequency of oscillation for the Gendy1
oscillator, so gives the smallest period the duration is allowed
to take on.


argument::ampscale

Normally 0.0 to 1.0, multiplier for the distribution's delta
value for amplitude. An ampscale of 1.0 allows the full range
of  -1 to 1 for a change of amplitude.


argument::durscale

Normally 0.0 to 1.0, multiplier for the distribution's delta
value for duration. An ampscale of 1.0 allows the full range of
-1 to 1 for a change of duration.


argument::initCPs

Initialise the number of control points in the memory.
Xenakis specifies 12. There would be this number of control
points per cycle of the oscillator, though the oscillator's
period will constantly change due to the duration distribution.


argument::knum

Current number of utilised control points, allows modulation.

argument::mul

argument::add

discussion::
All parameters can be modulated at control rate except for code::initCPs:: which is used only at initialisation.

Examples::

warning::
if you have lots of CPs and you have fast frequencies, the CPU cost goes up a lot because a new CP move happens every sample!
::

code::
//defaults
{Pan2.ar(Gendy1.ar)}.play

//wandering bass/ powerline
{Pan2.ar(Gendy1.ar(1,1,1.0,1.0,30,100,0.3,0.05,5))}.play

//play me
{Pan2.ar(RLPF.ar(Gendy1.ar(2,3,minfreq:20,maxfreq:MouseX.kr(100,1000),durscale:0.0,initCPs:40),500,0.3,0.2),0.0)}.play

//scream! - careful with your ears for this one!
(
{
    var mx, my;

    mx= MouseX.kr(220,440);
    my= MouseY.kr(0.0,1.0);

    Pan2.ar(Gendy1.ar(2,3,1,1,minfreq:mx, maxfreq:8*mx, ampscale:my, durscale:my, initCPs:7, mul:0.3), 0.0)
}.play
)


//1 CP = random noise effect
{Pan2.ar(Gendy1.ar(initCPs:1))}.play

//2 CPs = suudenly an oscillator (though a fast modulating one here)
{Pan2.ar(Gendy1.ar(initCPs:2))}.play


//used as an LFO
(
{
    Pan2.ar(
        SinOsc.ar(
            Gendy1.kr(2, 4,
                SinOsc.kr(0.1,0,0.49,0.51),
                SinOsc.kr(0.13,0,0.49,0.51),
                3.4, 3.5,
                SinOsc.kr(0.17,0,0.49,0.51),
                SinOsc.kr(0.19,0,0.49,0.51),
                10,10,50, 350),
        0, 0.3),
    0.0)
}.play
)

//wasp
{Pan2.ar(Gendy1.ar(0, 0, SinOsc.kr(0.1, 0, 0.1, 0.9),1.0, 50,1000, 1,0.005, 12, 12, 0.2), 0.0)}.play


//modulate distributions
//change of pitch as distributions change the duration structure and spectrum
{Pan2.ar(Gendy1.ar(MouseX.kr(0,7),MouseY.kr(0,7),mul:0.2), 0.0)}.play


//modulate num of CPs
{Pan2.ar(Gendy1.ar(knum:MouseX.kr(1,13),mul:0.2), 0.0)}.play


(//Gendy into Gendy...with cartoon side effects
{Pan2.ar(Gendy1.ar(
    maxfreq:Gendy1.kr(5,4,0.3, 0.7, 0.1, MouseY.kr(0.1,10), 1.0, 1.0, 5,5, 500, 600),
    knum:MouseX.kr(1,13),mul:0.2), 0.0)
}.play
)

//use SINUS to track any oscillator and take CP positions from it, use adparam and ddparam as the inputs to sample
{Pan2.ar(Gendy1.ar(6,6,LFPulse.kr(100, 0, 0.4, 1.0), SinOsc.kr(30, 0, 0.5),mul:0.2), 0.0)}.play


//try out near the corners especially
(
{Pan2.ar(Gendy1.ar(6,6,LFPulse.kr(MouseX.kr(0,200), 0, 0.4, 1.0),
    SinOsc.kr(MouseY.kr(0,200), 0, 0.5),mul:0.2), 0.0)}.play
)

//texture
(
{
Mix.fill(10,{
var freq;

freq= rrand(130,160.3);
Pan2.ar(SinOsc.ar(Gendy1.ar(6.rand,6.rand,SinOsc.kr(0.1,0,0.49,0.51),
    SinOsc.kr(0.13,0,0.49,0.51),freq ,freq, SinOsc.kr(0.17,0,0.49,0.51),
    SinOsc.kr(0.19,0,0.49,0.51), 12, 12, 200, 400), 0, 0.1), 1.0.rand2)
});
}.play
)

//wahhhhhhhh- try durscale 10.0 and 0.0 too
(
{Pan2.ar(
CombN.ar(
Resonz.ar(
Gendy1.ar(2,3,minfreq:1, maxfreq:MouseX.kr(10,700), durscale:0.1, initCPs:10),
MouseY.kr(50,1000), 0.1)
,0.1,0.1,5, 0.6
)
, 0.0)}.play
)

//overkill
(
{
var n;
n=10;

Mix.fill(n,{
var freq, numcps;

freq= rrand(130,160.3);
numcps= rrand(2,20);
Pan2.ar(Gendy1.ar(6.rand,6.rand,1.0.rand,1.0.rand,freq ,freq, 1.0.rand, 1.0.rand, numcps,
    SinOsc.kr(exprand(0.02,0.2), 0, numcps/2, numcps/2), 0.5/(n.sqrt)), 1.0.rand2)
});
}.play
)

//another traffic moment
(
{
    var n;
    n=10;

    Resonz.ar(
    Mix.fill(n,{
    var freq, numcps;

    freq= rrand(50,560.3);
    numcps= rrand(2,20);
    Pan2.ar(Gendy1.ar(6.rand,6.rand,1.0.rand,1.0.rand,freq ,freq, 1.0.rand, 1.0.rand, numcps,
        SinOsc.kr(exprand(0.02,0.2), 0, numcps/2, numcps/2), 0.5/(n.sqrt)), 1.0.rand2)
    })
    ,MouseX.kr(100,2000), MouseY.kr(0.01,1.0))
    ;
}.play
)

(
{
var n;
n=15;

Out.ar(0,
Resonz.ar(
Mix.fill(n,{
var freq, numcps;

freq= rrand(330,460.3);
numcps= rrand(2,20);
Pan2.ar(Gendy1.ar(6.rand,6.rand,1.0.rand,1.0.rand,freq,MouseX.kr(freq,2*freq), 1.0.rand, 1.0.rand, numcps,
    SinOsc.kr(exprand(0.02,0.2), 0, numcps/2, numcps/2), 0.5/(n.sqrt)), 1.0.rand2)
})
,MouseX.kr(100,2000), MouseY.kr(0.01,1.0))
)

}.play;
)
::

** class:: Gendy2
summary:: Dynamic stochastic synthesis generator.
related:: Classes/Gendy1, Classes/Gendy3
categories::  UGens>Generators>Stochastic


Description::

See  link::Classes/Gendy1::  help file for background. This variant of
GENDYN is closer to that presented in emphasis::Hoffmann, Peter. (2000) The New GENDYN Program. Computer Music Journal 24:2, pp 31-38::.

note::
Random walk is of the amplitude and time delta, not the amp and time
directly. The amplitude step random walk uses a lehmer style number
generator whose parameters are accessible.
::

SuperCollider implementation by Nick Collins

classmethods::

method::ar, kr


argument::ampdist

Choice of probability distribution for the next perturbation of
the amplitude of a control point.

The distributions are (adapted from the GENDYN program in Formalized Music):
table::
## 0: || LINEAR.
## 1: || CAUCHY.
## 2: || LOGIST.
## 3: || HYPERBCOS.
## 4: || ARCSINE.
## 5: || EXPON.
## 6: || SINUS.
::

Where the sinus (Xenakis' name) is in this implementation taken
as sampling from a third party oscillator. See example below.

argument::durdist

Choice of distribution for the perturbation of the current inter
control point duration.

argument::adparam

A parameter for the shape of the amplitude probability
distribution, requires values in the range 0.0001 to 1 (there are
safety checks in the code so don't worry too much if you want to
modulate!).

argument::ddparam

A parameter for the shape of the duration probability
distribution, requires values in the range 0.0001 to 1.


argument::minfreq

Minimum allowed frequency of oscillation for the Gendy1
oscillator, so gives the largest period the duration is allowed
to take on.


argument::maxfreq

Maximum allowed frequency of oscillation for the Gendy1
oscillator, so gives the smallest period the duration is allowed
to take on.


argument::ampscale

Normally 0.0 to 1.0, multiplier for the distribution's delta
value for amplitude. An ampscale of 1.0 allows the full range
of  -1 to 1 for a change of amplitude.


argument::durscale

Normally 0.0 to 1.0, multiplier for the distribution's delta
value for duration. An ampscale of 1.0 allows the full range of
-1 to 1 for a change of duration.


argument::initCPs

Initialise the number of control points in the memory.
Xenakis specifies 12. There would be this number of control
points per cycle of the oscillator, though the oscillator's
period will constantly change due to the duration distribution.


argument::knum

Current number of utilised control points, allows modulation.


argument::a

Parameter for Lehmer random number generator perturbed by
Xenakis as in

code::
((old*a)+c)%1.0
::

argument::c

Parameter for Lehmer random number generator perturbed by
Xenakis.


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

discussion::
All parameters can be modulated at control rate except for code::initCPs:: which is used only at initialisation.


Examples::
warning::
if you have lots of CPs and you have fast frequencies, the CPU cost goes up a lot because a new CP move happens every sample!
::

code::
//LOUD! defaults like a rougher Gendy1
{Pan2.ar(Gendy2.ar)}.play

//advantages of messing with the random number generation- causes periodicities
{Pan2.ar(Gendy2.ar(a:MouseX.kr(0.0,1.0),c:MouseY.kr(0.0,1.0)))}.play

(
{Pan2.ar(
Normalizer.ar(
RLPF.ar(
RLPF.ar(Gendy2.ar(a:SinOsc.kr(0.4,0,0.05,0.05),c:SinOsc.kr(0.3,0,0.1,0.5)),
MouseX.kr(10,10000,'exponential'),0.05),
MouseY.kr(10,10000,'exponential'),0.05)
,0.9)
,Lag.kr(LFNoise0.kr(1),0.5))}.play
)



{Pan2.ar(Gendy2.ar(3,5,1.0,1.0,50,1000,MouseX.kr(0.05,1),MouseY.kr(0.05,1),15, 0.05,0.51,mul:0.5))}.play


//play me
{Pan2.ar(RLPF.ar(Gendy2.ar(1,3,minfreq:20,maxfreq:MouseX.kr(100,1000),durscale:0.0,initCPs:4),500,0.3, 0.2),0.0)}.play


//1 CP = random noise effect
{Pan2.ar(Gendy2.ar(initCPs:1))}.play

//2 CPs = suudenly an oscillator (though a fast modulating one here)
{Pan2.ar(Gendy2.ar(initCPs:2))}.play


//used as an LFO
(
{Pan2.ar(SinOsc.ar(Gendy2.kr(2,1,SinOsc.kr(0.1,0,0.49,0.51),SinOsc.kr(0.13,0,0.49,0.51),
3.4,3.5, SinOsc.kr(0.17,0,0.49,0.51), SinOsc.kr(0.19,0,0.49,0.51),10,10,mul:50, add:350), 0, 0.3), 0.0)}.play
)

//very angry wasp
{Pan2.ar(Gendy2.ar(0, 0, SinOsc.kr(0.1, 0, 0.1, 0.9),1.0, 50,1000, 1,0.005, 12, 12, 0.2,0.2,0.2), 0.0)}.play


//modulate distributions
//change of pitch as distributions change the duration structure and spectrum
{Pan2.ar(Gendy2.ar(MouseX.kr(0,7),MouseY.kr(0,7),mul:0.2), 0.0)}.play


//modulate num of CPs
{Pan2.ar(Gendy2.ar(knum:MouseX.kr(1,13),mul:0.2), 0.0)}.play


(//Gendy1 into Gendy2...with cartoon side effects
{Pan2.ar(Gendy2.ar(maxfreq:Gendy1.kr(5,4,0.3, 0.7, 0.1, MouseY.kr(0.1,10),
    1.0, 1.0, 5,5, 500, 600), knum:MouseX.kr(1,13),mul:0.2), 0.0)}.play
)

//use SINUS to track any oscillator and take CP positions from it, use adparam and ddparam as the inputs to sample
{Pan2.ar(Gendy2.ar(6,6,LFPulse.kr(100, 0, 0.4, 1.0), SinOsc.kr(30, 0, 0.5),mul:0.2), 0.0)}.play


(//try out near the corners especially
{Pan2.ar(Gendy2.ar(6,6,LFPulse.kr(MouseX.kr(0,200), 0, 0.4, 1.0),
    SinOsc.kr(MouseY.kr(0,200), 0, 0.5),mul:0.2), 0.0)}.play
)

//texture- the howling wind?
(
{
    Mix.fill(10,{
    var freq;

    freq= rrand(130,160.3);
    Pan2.ar(SinOsc.ar(Gendy2.ar(6.rand,6.rand,SinOsc.kr(0.1,0,0.49,0.51),SinOsc.kr(0.13,0,0.49,0.51),
        freq ,freq, SinOsc.kr(0.17,0,0.49,0.51), SinOsc.kr(0.19,0,0.49,0.51),
        12, 12, 0.4.rand, 0.4.rand, 200, 400), 0, 0.1), 1.0.rand2)
    });
}.play
)

//CAREFUL! mouse to far right causes explosion of sound
(
{Pan2.ar(
CombN.ar(
Resonz.ar(
Gendy2.ar(2,3,minfreq:1, maxfreq:MouseX.kr(10,700), initCPs:100),
MouseY.kr(50,1000), 0.1)
,0.1,0.1,5, 0.16
)
, 0.0)}.play
)

//storm
(
{
    var n;
    n=15;

    0.5*Mix.fill(n,{
    var freq, numcps;

    freq= rrand(130,160.3);
    numcps= rrand(2,20);
    Pan2.ar(Gendy2.ar(6.rand,6.rand,10.0.rand,10.0.rand,freq,freq*exprand(1.0,2.0),
        10.0.rand, 10.0.rand, numcps, SinOsc.kr(exprand(0.02,0.2), 0, numcps/2, numcps/2),
        10.0.rand, 10.0.rand, 0.5/(n.sqrt)), 1.0.rand2)
    });
}.play
)

//another traffic moment
(
{
    var n;
    n=10;

    Resonz.ar(
    Mix.fill(n,{
    var freq, numcps;

    freq= rrand(50,560.3);
    numcps= rrand(2,20);
    Pan2.ar(Gendy2.ar(6.rand,6.rand,1.0.rand,1.0.rand,freq ,freq,
        1.0.rand, 1.0.rand, numcps, SinOsc.kr(exprand(0.02,0.2), 0,
        numcps/2, numcps/2), 0.5/(n.sqrt)), 1.0.rand2)
    })
    ,MouseX.kr(100,2000), MouseY.kr(0.01,1.0), 0.3)
    ;
    }.play
)
::

** class:: Gendy3
summary:: Dynamic stochastic synthesis generator.
related:: Classes/Gendy1, Classes/Gendy2
categories::  UGens>Generators>Stochastic


Description::

See  link::Classes/Gendy1::  help file for background. This variant of
GENDYN normalises the durations in each period to force oscillation at
the desired pitch. The breakpoints still get perturbed as in
link::Classes/Gendy1:: .

There is some glitching in the oscillator caused by the stochastic
effects - control points as they vary cause big local jumps of amplitude.
Put  code::ampscale::  and  code::durscale::
low to minimise the rate of this.

SuperCollider implementation by Nick Collins

classmethods::

method::ar, kr

argument::ampdist

Choice of probability distribution for the next perturbation of
the amplitude of a control point.

The distributions are (adapted from the GENDYN program in Formalized Music):

table::
## 0: || LINEAR.
## 1: || CAUCHY.
## 2: || LOGIST.
## 3: || HYPERBCOS.
## 4: || ARCSINE.
## 5: || EXPON.
## 6: || SINUS.
::

Where the sinus (Xenakis' name) is in this implementation taken
as sampling from a third party oscillator. See example below.


argument::durdist

Choice of distribution for the perturbation of the current inter
control point duration.


argument::adparam

A parameter for the shape of the amplitude probability
distribution, requires values in the range 0.0001 to 1 (there are
safety checks in the code so don't worry too much if you want to
modulate!).


argument::ddparam

A parameter for the shape of the duration probability
distribution, requires values in the range 0.0001 to 1.


argument::freq

Oscillation frquency.


argument::ampscale

Normally 0.0 to 1.0, multiplier for the distribution's delta
value for amplitude. An ampscale of 1.0 allows the full range
of  -1 to 1 for a change of amplitude.


argument::durscale

Normally 0.0 to 1.0, multiplier for the distribution's delta
value for duration. An ampscale of 1.0 allows the full range of
-1 to 1 for a change of duration.


argument::initCPs

Initialise the number of control points in the memory.
Xenakis specifies 12. There would be this number of control
points per cycle of the oscillator, though the oscillator's
period will constantly change due to the duration distribution.


argument::knum

Current number of utilised control points, allows modulation.

argument::mul

argument::add

discussion::
All parameters can be modulated at control rate except for code::initCPs:: which is used only at initialisation.


Examples::

code::

//LOUD! defaults like a rougher Gendy1
{Pan2.ar(Gendy3.ar(mul:0.5))}.play

{Pan2.ar(Gendy3.ar(freq:MouseX.kr(220,880,'exponential'), durscale:0.01, ampscale:0.02, mul:0.2))}.play

//stochastic waveform distortion- also play me at the same time as the previous example...
{Pan2.ar(Gendy3.ar(1,2,0.3,-0.7,MouseX.kr(55,110,'exponential'),0.03,0.1))}.play


(
{Pan2.ar(
Normalizer.ar(
RLPF.ar(
RLPF.ar(Mix.new(Gendy3.ar(freq:[230, 419, 546, 789])),
MouseX.kr(10,10000,'exponential'),0.05),
MouseY.kr(10,10000,'exponential'),0.05)
,0.9)
,Lag.kr(LFNoise0.kr(1),0.5))}.play
)


//concrete pH?
(
{Pan2.ar(
Mix.new(Gendy3.ar(freq:([1,1.2,1.3,1.76,2.3]*MouseX.kr(3,17,'exponential')),mul:0.2)))}.play
)

//glitch low, mountain high
(
{Pan2.ar(
Mix.new(Gendy3.ar(3,5,1.0,1.0,(Array.fill(5,{LFNoise0.kr(1.3.rand,1,2)})*MouseX.kr(100,378,'exponential')),MouseX.kr(0.01,0.05),MouseY.kr(0.001,0.016),5,mul:0.1)))}.play
)

//play me
{Pan2.ar(RLPF.ar(Gendy3.ar(1,3,freq:MouseX.kr(100,1000), durscale:0.0, ampscale:MouseY.kr(0.0,0.1), initCPs:7, knum: MouseY.kr(7,2)), 500,0.3, 0.2), 0.0)}.play



//used as an LFO
(
{Pan2.ar(SinOsc.ar(Gendy3.kr(2,5,SinOsc.kr(0.1,0,0.49,0.51),SinOsc.kr(0.13,0,0.49,0.51), 0.34, SinOsc.kr(0.17,0,0.49,0.51), SinOsc.kr(0.19,0,0.49,0.51),10,10,mul:50, add:350), 0, 0.3), 0.0)}.play
)

//buzzpipes
{Pan2.ar(Mix.new(Gendy3.ar(0, 0, SinOsc.kr(0.1, 0, 0.1, 0.9),1.0, [100,205,410], 0.011,0.005, 12, 12, 0.12)), 0.0)}.play


//modulate distributions
//change of pitch as distributions change the duration structure and spectrum
{Pan2.ar(Gendy3.ar(MouseX.kr(0,7),MouseY.kr(0,7),mul:0.2), 0.0)}.play


//modulate num of CPs
{Pan2.ar(Gendy3.ar(knum:MouseX.kr(2,13),mul:0.2), 0.0)}.play


//Gendy1 into Gendy2 into Gendy3...with cartoon side effects
(
{Pan2.ar(Gendy3.ar(1,2,freq:Gendy2.ar(maxfreq:Gendy1.kr(5,4,0.3, 0.7, 0.1, MouseY.kr(0.1,10), 1.0, 1.0, 5,5, 25,26),minfreq:24, knum:MouseX.kr(1,13),mul:150, add:200), durscale:0.01, ampscale:0.01, mul:0.1), 0.0)}.play
)

//use SINUS to track any oscillator and take CP positions from it, use adparam and ddparam as the inputs to sample
{Pan2.ar(Gendy3.ar(6,6,LFPulse.kr(LFNoise0.kr(19.0,0.5,0.6), 0, 0.4, 0.5), Gendy1.kr(durscale:0.01,ampscale:0.01), MouseX.kr(10,100),mul:0.2), 0.0)}.play



//wolf tones
(
{
Mix.fill(10,{
var freq;

freq= exprand(130,1160.3);
Pan2.ar(SinOsc.ar(Gendy3.ar(6.rand,6.rand,SinOsc.kr(0.1,0,0.49,0.51),SinOsc.kr(0.13,0,0.49,0.51),freq, SinOsc.kr(0.17,0,0.0049,0.0051), SinOsc.kr(0.19,0,0.0049,0.0051), 12, 12, 200, 400), 0, 0.1), 1.0.rand2)
});
}.play
)

//CAREFUL! mouse to far right causes explosion of sound-
//notice how high frequency and num of CPs affects CPU cost
(
{Pan2.ar(
CombN.ar(
Resonz.ar(
Gendy3.ar(2,3,freq:MouseX.kr(10,700), initCPs:100),
MouseY.kr(50,1000), 0.1)
,0.1,0.1,5, 0.16
)
, 0.0)}.play
)


//storm
(
{
var n;
n=15;

0.5*Mix.fill(n,{
var freq, numcps;

freq= rrand(130,160.3);
numcps= rrand(2,20);
Pan2.ar(Gendy3.ar(6.rand,6.rand,10.0.rand,10.0.rand,freq*exprand(1.0,2.0), 10.0.rand, 10.0.rand, numcps, SinOsc.kr(exprand(0.02,0.2), 0, numcps/2, numcps/2), 0.5/(n.sqrt)), 1.0.rand2)
});
}.play
)



//another glitchy moment
(
{
var n;
n=10;

Resonz.ar(
Mix.fill(n,{
var freq, numcps;

freq= rrand(50,560.3);
numcps= rrand(2,20);
Pan2.ar(Gendy3.ar(6.rand,6.rand,1.0.rand,1.0.rand,freq, 1.0.rand, 1.0.rand, numcps, SinOsc.kr(exprand(0.02,0.2), 0, numcps/2, numcps/2), 0.5/(n.sqrt)), 1.0.rand2)
})
,MouseX.kr(100,2000), MouseY.kr(0.01,1.0), 0.3)
;
}.play
)
::

** class:: GeneralHID
redirect:: implClass
summary:: A uniform class to access HID devices
related:: Classes/HIDDeviceService, Classes/LID, Classes/GeneralHIDDevice, Classes/GeneralHIDSpec
categories:: External Control>HID

description::
GeneralHID is a cross platform wrapper for accessing HID devices. Currently the MacOSX and Linux HID support has been wrapped. Some of the code is inspired by the GUI wrapper.

note::
It is advised to use this class instead of the platform specific classes: link::Classes/HIDDeviceService:: (on MacOSX) and link::Classes/LID:: (on Linux).
::

There are intermediate "bridge" classes link::Classes/MXHID:: (on MacOSX) and link::Classes/GLID:: (on Linux), which should not be used directly, but their names will show up in the output of some of the methods of GeneralHID.

subsection::Some outstanding issues
This class is not completely finished yet. Common slot numbers across platforms are not yet guaranteed. On Windows there is not yet a proper implementation available, but you can use HID Server from http://ixi-software.net/content/backyard.html , which comes with classes which are compatible with GeneralHID.

subsection::Further information
See link::Classes/GeneralHIDDevice:: for a documentation of the methods to access an HID device.
See link::Classes/GeneralHIDSpec:: for a documentation of how to access slots by name, instead of numbers.

ClassMethods::

private::initClass

method::scheme, current
Get the current scheme. With scheme.id and current.id one can get the current scheme ID.

method::buildDeviceList
Look for all connected devices and build a device list. This returns the devicelist as an link::Classes/Array::.

method::deviceList
Returns the device list if it has already been built before.

method::postDevices
Posts a readable list of devices.

method::postDevicesAndProperties
Posts a readable list of devices and their properties.

method::startEventLoop
Start the eventloop with a update rate (or rather update time in seconds).

note::
this is only really needed on MacOSX, but for crossplatform code you should include it in your code.
::

method::stopEventLoop
Stop the eventloop.

method::eventLoopIsRunning
Check status of eventloop.

method::open
Opens the device; the device should be an item got from the device list.

method::findBy
Find a device by its info properties.

argument::vendorID
manufacturer

argument::productID
product identifier as given by manufacturer

argument::locID
identifier for the physical connection to your computer

argument::versionID
a version of the product, as given by the manufacturer

Examples::

code::
// General structure to access a device
// Look for the devices that are attached:
GeneralHID.buildDeviceList;
// Get the list of devices:
d = GeneralHID.deviceList;
// Check which devices have been found:
GeneralHID.postDevices;
// Pick the 6th device and open it and create an instance of it:
a = GeneralHID.open( d[5] )
// Get info on the device:
a.info;
// if you want to automatically find the device when you restart you can use the GeneralHID.findBy method. To get the arguments you should use for this function, you can use:
a.info.findArgs;
// this outputs for my Impact gamepad:
[ 1973, 786, usb-0000:00:1d.0-1/input0, 272 ]
// close the device, as we will reopen it in the next lines
a.close;
// if we know which device we want, we can find it:
b = GeneralHID.findBy( 1973, 786, "usb-0000:00:1d.0-1/input0", 272 );
// if you do not care about the version or the location, you can also do:
b = GeneralHID.findBy( 1973, 786 );
// or if you do not even care about the productID
b = GeneralHID.findBy( 1973 );
// you can then open it by:
a = GeneralHID.open( b )
// Start eventloop:
GeneralHID.startEventLoop
// Get the capabilities of the device in a readable format:
a.caps;
// there are different types of slots:
// button (type 1), has only on/off (1/0) states
// relative (type 2), counts up or down (scrollwheel for example)
// absolute (type 3), continuous value between 0 and 1
// some other may show up on Linux ( Syn (type 0) and Miscellaneous (type 4), but these are generally not very useful).
// See if data is coming in:
a.debug_( true );
// Stop it:
a.debug_( false );
// Debugging can be turned on for each slot individually, if necessary:
//(IBM trackpoint)
a.slots[1].at( 272 ).debug_( true );
// (external mouse on macbook pro)
a.slots[3][1].debug_(true);
(external mouse on ibm thinkpad)
a.slots[2][1].debug_(true);
// Turn it off again: // (IBM trackpoint)
a.slots[1].at( 272 ).debug_( false );
//(external mouse on macbook pro)
a.slots[3][48].debug_(false);
//(external mouse on ibm thinkpad)
a.slots[3][1].debug_(false);

// You can also create a generic gui to see what is coming in:
a.makeGui;

// The current value of a slot can be checked:
a.slots[1].at( 272 ).value;
a.slots[2].at( 1 ).value;
a.slots[3][1].value
//If the slot is an LED, you can set the value:
a.slots[11][0].value = 1;
a.slots[11][0].value = 0;

// Actions can be mapped to each slot individually.
a.slots[1].at( 272 ).action_( { "hello".postln; } );
a.slots[1].at( 273 ).action_( { "hi".postln; } );
a.slots[3].at( 1 ).action_( { "hi".postln; } );
// with an input to the function
a.slots[3].at( 1 ).action_( { |v| "hi, my value is ".post; v.value.postln; } );
a.slots[1].at( 272 ).action_( { |v| "hi, my value is ".post; v.value.postln; } );

// To stop the action, assign it to an empty function.
a.slots[1].at( 272 ).action_( {} );
a.slots[1].at( 273 ).action_( {} );
a.slots[3].at( 1 ).action_( {} );

// you can access slots, by giving them a key:
a.add( \lx, [3,0] );
a[\lx].debug_( true );
// the last item in the output array, now shows the key
a[\lx].debug_( false );
// save the spec for future use:
a.spec.save( "Impact_help" );
// find a spec defined previously for this device:
c = a.findSpec;
// set it:
a.setSpec( c[0] );
// more info on this in the [GeneralHIDSpec] helpfile
// If the server is running you can create a control bus for the HID data to go to, so that a synth can immediately read the data:
s = Server.local.boot;
// To create the bus:
a.slots[1].at( 272 ).createBus( s ); a.slots[2].at( 8 ).createBus( s );

SynthDef( \hidbus_help, { |out=0,amp=0|
	Out.ar( out, SinOsc.ar( 300, 0, 0.01*amp.abs ) );
}).add;
)
x = Synth.new( \hidbus_help );
x.map( \amp, a.slots[2].at( 8 ).bus );
x.free;

( // a nicer version:
SynthDef( \hidbus_help, { |out=0,amp=0,amp2=0|
	Out.ar( out, SinOsc.ar( 300, 0, 0.01*amp.abs.lag( 0.1 ) * amp2.lag(0.01,0.99) ) );
}).add;
)
x = Synth.new( \hidbus_help );
x.map( \amp, a.slots[2].at( 8 ).bus );
x.map( \amp2, a.slots[1].at( 272 ).bus );
x.free;

( // an even nicer version:
SynthDef( \hidbus_help, { |out=0,freqadd=0,amp=0|
	Out.ar( out, SinOsc.ar( 300 + (freqadd.lag(0.2,1)*40), 0, 0.2*amp.lag(0.01,0.99) ) );
}).add;
)
x = Synth.new( \hidbus_help );
x.map( \freqadd, a.slots[2].at( 8 ).bus );
x.map( \amp, a.slots[1].at( 272 ).bus );
x.free;

// To free the bus:
a.slots[1].at( 272 ).freeBus;
a.slots[2].at( 8 ).freeBus;
// Close the device after use:
a.close;
GeneralHID.stopEventLoop
::
** class:: GeneralHIDDevice
summary:: A uniform class to an HID device
related:: Classes/HIDDeviceService, Classes/LID, Classes/GeneralHID, Classes/GeneralHIDSpec
categories:: External Control>HID

description::
GeneralHID is a cross platform wrapper for accessing HID devices. Currently the MacOSX and Linux HID support has been wrapped. Some of the code is inspired by the GUI wrapper.
A GeneralHIDDevice accesses one HID device, such as a mouse, joystick or gamepad. Devices are automatically created when a building the device list with link::Classes/GeneralHID::, so it is not necessary for a user to create a new device.

See link::Classes/GeneralHID:: for a complete explanation and an example of how to access an HID device.

note::
It is advised to use this class instead of the platform specific classes: link::Classes/HIDDeviceService:: (on MacOSX) and link::Classes/LID:: (on Linux)
::

subsection::Some outstanding issues
This class is not completely finished yet. Common slot numbers across platforms are not yet guaranteed. On Windows there is not yet a proper implementation available.

InstanceMethods::

method::isOpen
Checks whether the device is open.

method::info
Display information about the device, such as the name and vendor.

method::caps
Display information about the capabilities of the device in a readable format.

method::slots
Access to the slots of the device. See link::Classes/GeneralHIDSlot::.

method::makeGui
Make a generic gui to see the data coming in on the slots.

method::close
Closes the device.

method::grab
Get exclusive access to the device (linux only). Be careful with this when it is the only keyboard, as you will have no way to get back control.

method::ungrab
Give up exclusive access to the device (linux only).


Examples::

See link::Classes/GeneralHID::. for a complete example of using an HID device.
** class:: GeneralHIDSlot
summary:: A uniform class to a slot of an HID device
related:: Classes/HIDDeviceService, Classes/LID, Classes/GeneralHID, Classes/GeneralHIDSpec
categories:: External Control>HID

description::
GeneralHID is a cross platform wrapper for accessing HID devices. Currently the MacOSX and Linux HID support has been wrapped. Some of the code is inspired by the GUI wrapper.
A GeneralHIDSlot accesses one specific capability of a device, such as a button, an axis or an LED. Its value can be retrieved, an action can be set to be performed when data comes in, and the slot can be mapped to a control bus to use the value directly on the server. Slots are automatically created when a device is opened, so it is not necessary for a user to create a new slot.

See link::Classes/GeneralHID:: for a complete explanation and an example of how to access an HID device.

note::
It is advised to use this class instead of the platform specific classes: link::Classes/HIDDeviceService:: (on MacOSX) and link::Classes/LID:: (on Linux)
::

subsection::Some outstanding issues
This class is not completely finished yet. Common slot numbers across platforms are not yet guaranteed. On Windows there is not yet a proper implementation available.

ClassMethods::

private::initClass

InstanceMethods::

method::debug
Turns on debugging for the slot.

method::value
Get or set the current value of the slot. Setting is only sensible when the slot represents an LED on the device.

method::rawValue
Return the unscaled value of the slot.

method::action
Assign a function to the slot. The function has as an argument the slot.

method::createBus
Create a control bus on the specified server, and map the incoming values to this bus.

method::bus
Returns the bus to which this slot is mapped, if a bus has been created.

method::freeBus
Free the bus on the server.

method::kr
JITLib support. This calls .createBus, and returns an In.kr on the bus for you.

Examples::

See link::Classes/GeneralHID::. for a complete example of using an HID device.
** class:: GeneralHIDSpec
summary:: Create access by names to slots of a GeneralHIDDevice
related:: Classes/HIDDeviceService, Classes/LID, Classes/GeneralHID, Classes/GeneralHIDDevice
categories:: External Control>HID

ClassMethods::

private::initClass

InstanceMethods::

method::add
define a key to a slot

method::at
get the slot

method::value
get or set the slot

method::action
set the action

method::bus
get the bus

method::createBus
create the bus

method::freeBus
free the bus

method:: freeAllBuses
free all buses

Examples::

code::
// Look for the devices that are attached:
GeneralHID.buildDeviceList;

// Get the list of devices:
d = GeneralHID.deviceList;

// Check which devices have been found:
GeneralHID.postDevices;

// Pick the 6th device and open it and create an instance of it:
a = GeneralHID.open( d[5] )

// Get info on the device to see if it is the right one:
a.info;

// Start eventloop:
GeneralHID.startEventLoop

// Get the capabilities of the device in a readable format:
a.caps;

// See if data is coming in:
a.debug_( true );

// make an instance of a spec:
b = GeneralHIDSpec.new( a );

( // defining the spec.
// trick: look at the debug output, by using each input thing on the gamepad and use the first two numbers posted as indexes
// example output of debug: [ 3, 2, 0.49803921568627, nil ]
// as a result of moving the y-axis of the right joystick.
// so we create this slot:
b.add( \ry, [3,2] );

// and so on...
b.add( \lx, [3,0] );
b.add( \ly, [3,1] );
b.add( \rx, [3,5] );

b.add( \b1, [1,288] );
b.add( \b2, [1,289] );
b.add( \b3, [1,290] );
b.add( \b4, [1,291] );
b.add( \b5, [1,292] );
b.add( \b6, [1,293] );
b.add( \b7, [1,294] );
b.add( \b8, [1,295] );

b.add( \b5, [1,292] );
b.add( \b6, [1,293] );
b.add( \b7, [1,294] );
b.add( \b8, [1,295] );

b.add( \cx, [3,16] );
b.add( \cy, [3,17] );

b.add( \bl, [1,296] );
b.add( \br, [1,297] );

b.add( \bj1, [1,298] );
b.add( \bj2, [1,299] );
)

// Stop it:
a.debug_( false );

// look at the map
b.map.postcs;

// store it with a name:
b.save( "Impact" );

// find matching, previously stored specs:
c = b.find;

// load from file:
b.fromFile( "Impact" );

// the loading and storing mechanism works across SC sessions, as they are stored to file, and GeneralHIDSpec loads the device info of all stored specs at startup of the language.

/// A GeneralHIDDevice automatically has a spec, so we can access it even faster:

a.spec;

// to find and set a spec:
a.findSpec;
a.setSpec( "Impact" );

// post the mapping
a.spec.map

// examples of use:
s = Server.local.boot;

// create a bus
b.createBus( \rx, s );
b.createBus( \b1, s );


// simple example:
(
SynthDef( \hidbus_help, { |out=0,amp=0.5|
	Out.ar( out, SinOsc.ar( 300, 0, 0.2*(amp-0.5) ) );
}).add;
)

x = Synth.new( \hidbus_help );
x.map( \amp, b.at( \rx ).bus );
x.free;

( // a nicer version:
SynthDef( \hidbus_help, { |out=0,amp=0.5,amp2=0|
	Out.ar( out, SinOsc.ar( 300, 0, 0.2*(amp-0.5).lag( 0.1 ) * amp2.lag(0.01,0.99) ) );
}).add;
)

x = Synth.new( \hidbus_help );
x.map( \amp, b.at( \rx ).bus );
x.map( \amp2, b.at( \b1 ).bus );
x.free;

( // an even nicer version:
SynthDef( \hidbus_help, { |out=0,freqadd=0,amp=0,fmmul=200|
	Out.ar( out, SinOsc.ar( 300 + (freqadd.lag(0.2,1)*fmmul), 0, 0.2*amp.lag(0.01,0.99) ) );
}).add;
)


// if you want to have buses for all the things defined in the spec, you can use:
b.createAllBuses( s );

(
x = [ Synth.new( \hidbus_help ), Synth.new( \hidbus_help ) ];
x[0].map( \freqadd, b.bus( \ly ) );
x[0].map( \amp, b.bus( \b6 ) );

x[1].map( \freqadd, b.bus( \lx ) );
x[1].map( \amp, b.bus( \b7 ) );

y = [ Synth.new( \hidbus_help, [\fmmul,400] ), Synth.new( \hidbus_help, [\fmmul,400] ) ];
y[0].map( \freqadd, b.bus( \ry ) );
y[0].map( \amp, b.bus( \b5 ) );

y[1].map( \freqadd, b.bus( \rx ) );
y[1].map( \amp, b.bus( \b6 ) );
)

// see what's going on on the server
s.queryAllNodes( true );

// free the synths
y.do{ |it| it.free; }; x.do{ |it| it.free; };



// To free all buses
b.freeAllBuses;

// Close the device after use:

a.close;

GeneralHID.stopEventLoop
::
** class:: Gradient
summary:: A linear color fade between two colors
categories:: GUI>Accessories
related:: Classes/Color, Classes/HiliteGradient

description::

note:: The use of Gradient is strong::not supported yet in Qt GUI::. When Gradient is used in place of Color, the average gradient color will be used instead. ::

classmethods::

method:: new
argument:: color1
An instance of link::Classes/Color::.
argument:: color2
An instance of link::Classes/Color::.
argument:: direction
code::\h:: or code::\v:: for horizontal and vertical respectively. Default value is code::\h::.
argument:: steps
The resolution of the gradient. Default value is 64.

instancemethods::

method:: at
Retrieve the colour at position code::pos::, typically a value between zero and one. code::at(0):: is code::color1::, and code::at(1):: is code::color2::.
argument:: pos

examples::
code::
// basic usage
(
w = Window.new.front;
w.view.background = Gradient(Color.yellow,Color.white);
)

// change direction and resolution
(
w = Window.new.front;
w.view.background = Gradient(Color.red,Color.white,\v, 5);
)

// almost unnoticeable variations can be pleasant
(
w = Window.new.front;
v = CompositeView(w, Rect(50,50,300,300));
c = Color.rand;
d = c.vary(0.15);
v.background = Gradient(c, d, \v);
[c, d].postln
)

(
var w, k, c, d, e, c1, c2, f, g;
w = Window.new.front;
k = Slider2D(w, Rect(50,50,300,300));
f = {
	c = Color.rand;
	d = c.vary(0.5);
	e = d.vary(0.5);
};
g = {
	c1 = d.hueBlend(e, k.y).round(0.01);
	c2 = c.hueBlend(e, k.x).round(0.01);
	k.background = Gradient(c1, c2, \v)
};
f.value; g.value;
k.action = g;
k.mouseUpAction = { [c1, c2].postln };
k.keyDownAction = f; // hit any key for new color
)

// an example using gradient indirectly to update window colour
(
w=Window.new.front;
g = Gradient(Color.red,Color.green);
Task{
	(0, 0.01 .. 1).do{|pos|
		w.view.background = g.at(pos);
		0.01.wait;
	};
}.play(AppClock)
)
::
** class:: GrainBuf
summary:: Granular synthesis with sound stored in a buffer
categories:: UGens>Buffer, UGens>Generators>Granular
related:: Classes/GrainIn, Classes/GrainFM, Classes/GrainSin

classmethods::
private:: categories

method:: ar

argument:: numChannels
the number of channels to output. If 1, mono is returned and pan is ignored.

argument:: trigger
a kr or ar trigger to start a new grain. If ar, grains after the start of the synth are sample accurate.

argument:: dur
size of the grain (in seconds).

argument:: sndbuf
the buffer holding a mono audio signal. If using multi-channel files, use Buffer.readChannel.

argument:: rate
the playback rate of the sampled sound

argument:: pos
the playback position for the grain to start with (0 is beginning, 1 is end of file)

argument:: interp
the interpolation method used for pitchshifting grains:
list::
## 1 = no interpolation
## 2 = linear
## 4 = cubic interpolation (more computationally intensive)
::

argument:: pan
determines where to pan the output.
list::
## If numChannels = 1, no panning is done.
## If numChannels = 2, panning is similar to Pan2.
## If numChannels > 2, pannins is the same as PanAz.
::

argument:: envbufnum
the buffer number containing a singal to use for the grain envelope. -1 uses a built-in Hann envelope.

argument:: maxGrains
the maximum number of overlapping grains that can be used at a given time. This value is set at the UGens init time and can't be modified. Defaults to 512. This can be set lower for more efficient use of memory.

warning:: The above parameter is new (post SC 3.3.1) and has the potential to break code written <= 3.3.1. This parameter is BEFORE the mul slot, and you may need to update code to account for this difference. ::

argument:: mul

argument:: add

discussion:: All args except numChannels and trigger are polled at grain creation time.
instancemethods::
private:: init, argNamesInputsOffset

examples::
code::
s.boot;

(
var winenv;

b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff");
// a custom envelope
winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]);
z = Buffer.sendCollection(s, winenv.discretize, 1);

SynthDef(\buf_grain_test, {arg gate = 1, amp = 1, sndbuf, envbuf;
	var pan, env, freqdev;
	// use mouse x to control panning
	pan = MouseX.kr(-1, 1);
	env = EnvGen.kr(
		Env([0, 1, 0], [1, 1], \sin, 1),
		gate,
		levelScale: amp,
		doneAction: 2);
	Out.ar(0,
		GrainBuf.ar(2, Impulse.kr(10), 0.1, sndbuf, LFNoise1.kr.range(0.5, 2),
			LFNoise2.kr(0.1).range(0, 1), 2, pan, envbuf) * env)
	}).send(s);

)

// use built-in env
x = Synth(\buf_grain_test, [\sndbuf, b, \envbuf, -1])

// switch to the custom env
x.set(\envbuf, z)
x.set(\envbuf, -1);

x.set(\gate, 0);
::

** class:: GrainFM
summary:: Granular synthesis with frequency modulated sine tones
categories:: UGens>Generators>Granular
related:: Classes/GrainIn, Classes/GrainSin, Classes/GrainBuf

classmethods::
private:: categories

method:: ar

argument:: numChannels
the number of channels to output. If 1, mono is returned and pan is ignored.

argument:: trigger
a kr or ar trigger to start a new grain. If ar, grains after the start of the synth are sample accurate.

argument:: dur
size of the grain (in seconds).

argument:: carfreq
the carrier freq of the grain generators internal oscillator

argument:: modfreq
the modulating freq of the grain generators internal oscillator

argument:: index
the index of modulation

argument:: pan
determines where to pan the output.
list::
## If numChannels = 1, no panning is done.
## If numChannels = 2, panning is similar to Pan2.
## If numChannels > 2, pannins is the same as PanAz.
::

argument:: envbufnum
the buffer number containing a singal to use for the grain envelope. -1 uses a built-in Hann envelope.

argument:: maxGrains
the maximum number of overlapping grains that can be used at a given time. This value is set at the UGens init time and can't be modified. Defaults to 512. This can be set lower for more efficient use of memory.

warning:: The above parameter is new (post SC 3.3.1) and has the potential to break code written <= 3.3.1. This parameter is BEFORE the mul slot, and you may need to update code to account for this difference. ::

argument:: mul

argument:: add

discussion:: All args except numChannels and trigger are polled at grain creation time.
instancemethods::
private:: init, argNamesInputsOffset

examples::
code::
s.boot;

(
var winenv;
// a custom envelope
winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]);
z = Buffer.sendCollection(s, winenv.discretize, 1);

SynthDef(\fm_grain_test, {arg gate = 1, amp = 1, envbuf;
	var pan, env, freqdev;
	// use mouse x to control panning
	pan = MouseX.kr(-1, 1);
	// use WhiteNoise and mouse y to control deviation from center pitch
	freqdev = WhiteNoise.kr(MouseY.kr(0, 400));
	env = EnvGen.kr(
		Env([0, 1, 0], [1, 1], \sin, 1),
		gate,
		levelScale: amp,
		doneAction: 2);
	Out.ar(0,
		GrainFM.ar(2, Impulse.kr(10), 0.1, 440 + freqdev, 200, LFNoise1.kr.range(1, 10),
			pan, envbuf) * env)
	}).send(s);

)

// use built-in env
x = Synth(\fm_grain_test, [\envbuf, -1])

// switch to the custom env
x.set(\envbuf, z)
x.set(\envbuf, -1);

x.set(\gate, 0);
::

** class:: GrainIn
summary:: Granulate an input signal
categories:: UGens>Generators>Granular
related:: Classes/GrainSin, Classes/GrainFM, Classes/GrainBuf

classmethods::
private:: categories

method:: ar

argument:: numChannels
the number of channels to output. If 1, mono is returned and pan is ignored.

argument:: trigger
a kr or ar trigger to start a new grain. If ar, grains after the start of the synth are sample accurate.

argument:: dur
size of the grain (in seconds).

argument:: in
the input to granulate

argument:: pan
determines where to pan the output.
list::
## If numChannels = 1, no panning is done.
## If numChannels = 2, panning is similar to Pan2.
## If numChannels > 2, pannins is the same as PanAz.
::

argument:: envbufnum
the buffer number containing a singal to use for the grain envelope. -1 uses a built-in Hann envelope.

argument:: maxGrains
the maximum number of overlapping grains that can be used at a given time. This value is set at the UGens init time and can't be modified. Defaults to 512. This can be set lower for more efficient use of memory.

warning:: The above parameter is new (post SC 3.3.1) and has the potential to break code written <= 3.3.1. This parameter is BEFORE the mul slot, and you may need to update code to account for this difference. ::

argument:: mul

argument:: add

discussion:: All args except numChannels and trigger are polled at grain creation time.
instancemethods::
private:: init, argNamesInputsOffset

Examples::
code::
s.boot;

(
var winenv;
// a custom envelope
winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]);
z = Buffer.sendCollection(s, winenv.discretize, 1);

SynthDef(\in_grain_test, {arg gate = 1, amp = 1, envbuf;
	var pan, env;
	// use mouse x to control panning
	pan = MouseX.kr(-1, 1);
	env = EnvGen.kr(
		Env([0, 1, 0], [1, 1], \sin, 1),
		gate,
		levelScale: amp,
		doneAction: 2);
	Out.ar(0,
		GrainIn.ar(2, Impulse.kr(32), 1, PinkNoise.ar * 0.05, pan, envbuf) * env)
	}).send(s);

)

// use built-in env
x = Synth(\in_grain_test, [\envbuf, -1])

// switch to the custom env
x.set(\envbuf, z)
x.set(\envbuf, -1);

x.set(\gate, 0);
::

** class:: GrainSin
summary:: Granular synthesis with sine tones
categories:: UGens>Generators>Granular
related:: Classes/GrainIn, Classes/GrainFM, Classes/GrainBuf

classmethods::
private:: categories

method:: ar

argument:: numChannels
the number of channels to output. If 1, mono is returned and pan is ignored.

argument:: trigger
a kr or ar trigger to start a new grain. If ar, grains after the start of the synth are sample accurate.

argument:: dur
size of the grain (in seconds).

argument:: freq
the input to granulate

argument:: pan
determines where to pan the output.
list::
## If numChannels = 1, no panning is done.
## If numChannels = 2, panning is similar to Pan2.
## If numChannels > 2, pannins is the same as PanAz.
::

argument:: envbufnum
the buffer number containing a singal to use for the grain envelope. -1 uses a built-in Hann envelope.

argument:: maxGrains
the maximum number of overlapping grains that can be used at a given time. This value is set at the UGens init time and can't be modified. Defaults to 512. This can be set lower for more efficient use of memory.

warning:: The above parameter is new (post SC 3.3.1) and has the potential to break code written <= 3.3.1. This parameter is BEFORE the mul slot, and you may need to update code to account for this difference. ::

argument:: mul

argument:: add

discussion:: All args except numChannels and trigger are polled at grain creation time.

instancemethods::
private:: init, argNamesInputsOffset

Examples::
code::

s.boot;

(
var winenv;
// a custom envelope
winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]);
z = Buffer.sendCollection(s, winenv.discretize, 1);

SynthDef(\sin_grain_test, {arg gate = 1, amp = 1, envbuf;
	var pan, env, freqdev;
	// use mouse x to control panning
	pan = MouseX.kr(-1, 1);
	// use WhiteNoise and mouse y to control deviation from center pitch
	freqdev = WhiteNoise.kr(MouseY.kr(0, 400));
	env = EnvGen.kr(
		Env([0, 1, 0], [1, 1], \sin, 1),
		gate,
		levelScale: amp,
		doneAction: 2);
	Out.ar(0,
		GrainSin.ar(2, Impulse.kr(10), 0.1, 440 + freqdev, pan, envbuf) * env)
	}).send(s);

)
s.scope
// use built-in env
x = Synth(\sin_grain_test, [\envbuf, -1])

// switch to the custom env
x.set(\envbuf, z)
x.set(\envbuf, -1);

x.set(\gate, 0);
::

** class:: GrayNoise
summary:: Gray Noise.
related:: Classes/BrownNoise, Classes/ClipNoise, Classes/PinkNoise, Classes/WhiteNoise
categories::  UGens>Generators>Stochastic


Description::

Generates noise which results from flipping random bits in a word.
This type of noise has a high RMS level relative to its peak to peak
level. The spectrum is emphasized towards lower frequencies.


classmethods::

method::ar, kr

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

(
SynthDef("help-GrayNoise", { arg out=0;
	Out.ar(out,
		GrayNoise.ar(0.1)
	)
}).play;
)

::

** CLASS:: GridLayout
summary:: A layout that organizes views in a grid
categories:: GUI>Layout
related:: Classes/HLayout, Classes/VLayout, Classes/StackLayout, Guides/GUI-Layout-Management
redirect:: implClass

DESCRIPTION::

note:: GridLayout is only implemented in strong::Qt GUI:: ::

GridLayout distributes its space into a strong::grid of rows and columns::, where each item can occupy strong::one or more cells::.

You can construct the layout in two ways using link::#*rows:: and link::#*columns::. In the former constructor you pass arrays of items by rows, and in the latter by columns. Items can also be added later using link::#-add:: and link::#-addSpanning::. To remove an item, simply use link::Classes/View#-remove:: for views, or link::Classes/QObject#-destroy:: for views or layouts.

It is possible to add more than one view into the same cell. The last added view will be the top-most. However, it is most probably more convenient to use a link::Classes/StackLayout:: for that purpose.

The layout manages the grid size automatically: you can add an item at any row and cell number. When items are added or removed, the grid will re-adjust according to the last occupied row and column.

subsection:: Fine tuning

Each item can be assigned an strong::alignment:: either at layout link::#*rows#construction:: or later using link::#-setAlignment::. An item will then get at most its default size, if available (see: link::Classes/View#-sizeHint::), and will be aligned within its cell according to the specified alignment.

Each row or column can be assigned a strong::stretch factor:: using link::#-setRowStretch:: and link::#-setColumnStretch::. Rows or columns that would otherwise get equal space are then distributed according to the relative proportions of their stretch factors.

Each row or column can also be assigned a strong::minimum:: size using link::#-setMinRowHeight:: and link::#-setMinColumnWidth::, to override the size contraints imposed by the contained views.

In addition to adjusting the spacing between cells using link::Classes/QLayout#-spacing:: you can control the spacing between rows and between columns separately using link::#-hSpacing:: and link::#-vSpacing::.

subsection:: Leaving empty space

You can leave any cell empty by not placing any item into it, or at link::#*rows#construction:: using code::nil:: instead of a view or another layout. Note though that the empty cells will always be regarded as freely stretchable and will not impose any constraints on space distribution.



CLASSMETHODS::

PRIVATE:: key
PRIVATE:: qtClass

METHOD:: rows

    Creates a GridLayout and fills each row with an array of items given as arguments.

    argument:: ... rows

    Each argument is an Array of items to form a consecutive row. An item can be a strong::view::, another strong::layout::, or strong::nil:: for an empty cell.

    discussion::

    You can make an item span more than one cell by wrapping it into an Array, followed by pairs of (\rows, number) and/or (\columns, number). You can also assign an alignment to an item by following it with a pair of (\align, alignment). \rows, \columns, and \align can be abbreviated with \r, \c, and \a, respectively. For possible alignment values see link::Reference/gui_alignments::.

    The simplified syntax for placing key-value pairs into an array comes handy (see link::Reference/Syntax-Shortcuts#Creating Arrays with key-value pairs::, and the example below).

    Example:
Code::
(
w=Window().layout_( GridLayout.rows(
    [Slider2D(), Slider2D(), [Slider(), rows:2]],
    [Slider2D(), Slider2D()],
    [[Slider().orientation_(\horizontal), columns:2]]
)).front;
)
::

METHOD:: columns

    Creates a GridLayout and fills each column with an array of items given as arguments.

    argument:: ... cols

    Each argument is an Array of items to form a consecutive column. An item can be a strong::view::, another strong::layout::, or strong::nil:: for an empty cell.

    discussion::

    To make an item span several cells, or assign an alignment to it, the same instructions as for link::#*rows:: apply.



INSTANCEMETHODS::

METHOD:: add

    Adds an item into the cell at specified row and column.

    argument:: item
    The item can be a strong::view:: or another strong::layout::.

    argument:: row
    The row index.

    argument:: column
    The column index.

    argument:: align
    A symbol denoting the alignment, or nil. See link::Reference/gui_alignments:: for possible values.

METHOD:: addSpanning

    Adds an item into the grid so as to occupy several cells.

    argument:: item
    The item can be a strong::view:: or another strong::layout::.

    argument:: row
    The row index.

    argument:: column
    The column index.

    argument:: rowSpan
    The amount of cells to occupy in vertical direction.

    argument:: columnSpan
    The amount of cells to occpy in horizontal direction.

    argument:: align
    A symbol denoting the alignment, or nil. See link::Reference/gui_alignments:: for possible values.

METHOD:: hSpacing

    The spacing between columns, in Integer amount of pixels.

METHOD:: vSpacing

    The spacing between rows, in Integer amount of pixels.

METHOD:: setRowStretch

    Sets the stretch factor of a row. By default rows have a stretch factor of 0. If a larger factor is assigned to a row, rows will get their space redistributed according to the relative proportions of their factors.

    argument:: row
    The index of a row.

    argument:: factor
    An Integer.

METHOD:: setColumnStretch

    Sets the stretch factor of a column. By default columns have a stretch factor of 0. If a larger factor is assigned to a column, columns will get their space redistributed according to the relative proportions of their factors.

    argument:: column
    The index of a column.

    argument:: factor
    An Integer.

METHOD:: setAlignment

    Sets the alignment of an item managed by the layout.

    argument:: item
    A view or a layout managed by this layout, or a Point of which x denotes the column index and y the row index of an item.

    argument:: align
    A symbol denoting the alignment. See link::Reference/gui_alignments:: for possible values.

METHOD:: minRowHeight

    Gets the minimum height assigned to a row.

    argument:: row
    The index of a row.

METHOD:: setMinRowHeight

    Sets the minimum height of row.

    argument:: row
    The index of a row.

    argument:: height
    An Integer amount of pixels.

METHOD:: minColumnWidth

    Gets the minimum width assigned to a column.

    argument:: column
    The index of a column.

METHOD:: setMinColumnWidth

    Sets the minimum width of a column.

    argument:: column
    The index of a column.

    argument:: width
    An Integer amount of pixels.
** CLASS:: GridLines
summary:: given a spec and the actual data's min and max values, calculates the ideal spacing and labelling of grid lines for plotting
categories:: GUI>Accessories
related:: Reference/plot, Classes/Plotter, Classes/DrawGrid

DESCRIPTION::
GridLines is a strategy object that implements a general strategy for finding a suitable min max range for graphing and suitable intervals for grid lines and labelling.

The object that does the actual drawing on a view is DrawGrid.

A GridLines object uses a ControlSpec to define the minimum and maximum possible values.  Given a data set's actual mininum and maximum values, the GridLines object can choose a logical range for graphing that encompasses the data that will be plotted.  

Future development work will add subclasses of GridLines that can bind more tightly with the data they are representing.  For instance a FreqGridLines (not yet impemented) could apply stronger lines to octave divisions.  A DegreeGridLines could be used to draw pitch degree gridlines behind a frequency plot.

Spec has a .grid variable that points to its preferred GridLines object that should be used for graphing.

code::
\freq.asSpec.grid
::

This default implementation does not know anything about the data is displaying:

code::
DrawGrid.test( nil, \midinote.asSpec.grid );
::

A MidinoteGrid could be written that labels these correctly, shows octaves and individual notes depending on the current zoom.

Note that the GridLines does not know which axis it is to be used on and could also be used in polar plots or in 3D rendering.

CLASSMETHODS::

METHOD:: new

argument:: spec
The ControlSpec that defines the mininum and maximum values, warn and step.

returns:: a GridLines


INSTANCEMETHODS::

METHOD:: spec
get/set the spec

returns:: a ControlSpec

METHOD:: asGrid
return self.  nil.asGrid would return a BlankGridLines which is a subclass of GridLines.  So when plotting if you specify a grid of nil then you will get no lines at all.

returns:: self

METHOD:: niceNum
Based on: http://books.google.de/books?id=fvA7zLEFWZgC&pg=PA61&lpg=PA61
This rounds a value to a logical nice number.  It is mostly used to support internal calculation, though it may be useful for other applications.

argument:: val
The value.

argument:: round
Boolean. Rounding uses a specific algorithm.  This is not simple rounding to an integer value.

returns:: the nice number

METHOD:: ideals
for internal use

argument:: min
(describe argument here)

argument:: max
(describe argument here)

argument:: ntick
(describe argument here)

returns:: (returnvalue)

METHOD:: looseRange
Returns the logical minimum and maximum that will contain the data.

argument:: min
minimum value

argument:: max
maximum value.

argument:: ntick
the number of lines you would like (which usually varies by how much screen space you have and what you consider cluttered)

returns:: [ideal min, ideal max]

METHOD:: getParams
Specifically for use by DrawGrid. This returns a dictionary filled with:
'lines': an array of values where lines should be drawn
'labels': [value, formatted label] for each line 

argument:: valueMin
minimum value of the data to be plotted

argument:: valueMax
maximum value of the data to be plotted

argument:: pixelMin
If numTicks is nil: used to guess the ideal numTicks based on the graph size.

argument:: pixelMax
If numTicks is nil: used to guess the ideal numTicks based on the graph size.

argument:: numTicks
Explicit number of ticks you would like to see on the graph.

returns:: A dictionary

METHOD:: formatLabel
Round the value and append the spec's units

argument:: val
The value

argument:: numDecimalPlaces
Number of decimal places

returns:: a string


** class:: Group
summary:: Client-side representation of a group node on the server
categories:: Server>Nodes, Server>Abstractions

description::
A Group is the client-side representation of a group node on the server, which is a collection of other nodes organized as a linked list.
The Nodes within a Group may be controlled together, and may be both link::Classes/Synth::s and other Groups.
Groups are thus useful for controlling a number of nodes at once, and when used as targets can be very helpful in controlling order of execution. (See link::Guides/Order-of-execution:: for more details on this topic).

For more on the crucial distinction between client objects and server nodes, see link::Guides/ClientVsServer::. For information on creating nodes without using objects, see link::Guides/NodeMessaging::.

N.B. Group is a subclass of Node, and thus many of its most useful and important methods are documented in the link::Classes/Node:: help file. Please refer to it for more information.

subsection:: RootNode and the default group

When a Server is booted there is a top level group with an ID of zero that defines the root of the tree. This is represented by a subclass of Group: link::Classes/RootNode::.
If the Server was booted from within SCLang (as opposed to from the command line) then a default_group with an ID of 1 will be automatically created. This group is the default enclosing group for all Nodes, i.e. it's what you get if you don't specify.
In general you should create new Nodes within the default group of a Server rather than in its RootNode.
See link::Classes/Server::, link::Reference/default_group:: and link::Classes/RootNode:: for more detail.

subsection:: Bundling

Some of the methods below have two versions: a regular one which sends its corresponding message to the server immediately, and one which returns the message in an link::Classes/Array:: so that it can be added to a bundle.
It is also possible to capture the messages generated by the regular methods using Server's automated bundling capabilities. See link::Classes/Server:: and link::Guides/Bundled-Messages:: for more detail.

classmethods::
private:: creationCmd

subsection:: Creation with Immediate Instantiation on the Server

method:: new
Create and return a Group.

argument:: target
A target for this Group. If target is not a Group or Synth, it will be converted as follows: If it is a Server, it will be converted to the default_group of that server. If it is nil, to the default_group of the default Server.
argument:: addAction
one of the following Symbols:
table::
## \addToHead || (the default) add at the head of the group specified by target
## \addToTail || add at the tail of the group specified by target
## \addAfter || add immediately after target in its server's node order
## \addBefore || add immediately before target in its server's node order
## \addReplace || replace target and take its place in its server's node order
::
Note: A Synth is not a valid target for \addToHead and \addToTail.
discussion::
code::
s.boot;
g = Group.new; // add a Group at the head of the default Server's default group
h = Group.new(g, \addAfter);
s.queryAllNodes; // note the Group within the default group (ID 1)
g.free; h.free;
::

subsection:: Convenience methods for add actions
The following convenience methods correspond to the add actions above:

method:: after
Create and return a Group and add it immediately after aNode.

method:: before
Create and return a Group and add it immediately before aNode.

method:: head
Create and return a Group. If aGroup is a Group add it at the head of that group. If it is a Server, add it at the head of the default_group of that server. If it is nil, add it at the head of the default_group of the default Server.

method:: tail
Create and return a Group. If aGroup is a Group add it at the tail of that group. If it is a Server, add it at the tail of the default_group of that server. If it is nil, add it at the tail of the default_group of the default Server.

method:: replace
Create and return a Group and use it to replace nodeToReplace, taking its place in its server's node order.

subsection:: Creation without Instantiation on the Server

For use in message bundles it is also possible to create a Group object in the client app without immediately creating a group node on the server. Once done one can call methods which create messages to add to a bundle, which when sent to the server will instantiate the group or perform other operations. (See strong::Control::, below.)

method:: basicNew
Create and return a Group object without creating a group node on the server. (This method is inherited from Node and is documented here only for convenience.)
argument:: server
An optional instance of Server. If nil this will default to the default Server.
argument:: nodeID
An optional node ID number. If not supplied one will be generated by the Server's NodeIDAllocator. Normally you should not need to supply an ID.
discussion::
code::
s.boot;
g = Group.basicNew(s); // Create without sending
s.sendBundle(nil, g.newMsg;); // Now send a message; create at the head of s' default group
s.queryAllNodes;
g.free;
::

After creation, use instance methods code::newMsg, addToHeadMsg, addToTailMsg, addBeforeMsg, addAfterMsg, addReplaceMsg:: to instantiate this synth on the server. See link::#instancemethods#Instance Methods:: below.


instancemethods::

subsection:: Creation without Instantiation on the Server
Use class method code::basicNew:: to create a Synth without instantiating it on the server. Then use the following instance methods:

method:: newMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group. If target is nil, it will default to the default_group of the Server specified in *basicNew when this Group was created. The default addAction is \addToHead. (See *new above for details of addActions.

method:: addToHeadMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group. If aGroup is a Group it will be added at the head of that group. If it is nil, it will be added at the head of the default_group of this Group's server (as specified when *basicNew was called).

method:: addToTailMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group. If aGroup is a Group it will be added at the tail of that group. If it is nil, it will be added at the tail of the default_group of this Group's server (as specified when *basicNew was called).

method:: addBeforeMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group, immediately before aNode.

method:: addAfterMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group, immediately after aNode.

method:: addReplaceMsg
Returns a message of the type g_new which can be bundled. When sent to the server this message will instantiate this group, replacing nodeToReplace in the server's node order.

subsection:: Control and Introspection

For further methods of controlling Groups (set, map, etc.), see the link::Classes/Node:: help file.

method:: moveNodeToHead, moveNodeToHeadMsg
Move aNode to the head of this group

method:: moveNodeToTail, moveNodeToTailMsg
Move aNode to the tail of this group

method:: freeAll, freeAllMsg
Free all the nodes in this group, but do not free this group itself.

method:: deepFree, deepFreeMsg
Free all Synths in the group, and all Synths in any enclosed groups, but do not free this group or any of its enclosed groups.

method:: dumpTree
Post a representation of this group's node subtree. (Sends a message of the type g_dumpTree.) If code::postControls:: is true, then the current Control (arg) values for any synths contained in this group will be posted as well. The default is false.

method:: queryTree
note:: not working yet ::
Queries the server for a message describing this group's node subtree. (Sends a message of the type g_queryTree.) This reply is passed to the action function as an argument. See g_queryTree in Server-Command-Reference or the example below for information on how the reply is structured.


Examples::
code::
(
s = Server.default; // just to be sure
s.boot;
)

(
SynthDef("help-Group-moto-rev", { arg out=0,freq=100,ffreq=120;
	var x;
	x = RLPF.ar(LFPulse.ar(SinOsc.kr(0.2, 0, 10, freq), [0,0.1], 0.1),
		ffreq, 0.1).clip2(0.4);
	Out.ar(out, x);
}).add;


SynthDef("help-Group-wah", { arg out, rate = 1.5, cfreq = 1400, mfreq = 1200, rq=0.1;
	var zin, zout, q;

	zin = In.ar(out, 2);
	cfreq = Lag3.kr(cfreq, 0.1);
	mfreq = Lag3.kr(mfreq, 0.1);
	q   = Ramp.kr(rq, 0.1);
	zout = RLPF.ar(zin, LFNoise1.kr(rate, mfreq, cfreq), q, 10).distort
		* 0.15;

	// replace the incoming bus with the effected version
	ReplaceOut.ar( out , zout );

}).add;
)

g = Group.new;

(
l = Array.fill(3,{
	// random freq for each synth, added to g at the head
	Synth("help-Group-moto-rev",["out",0,"freq",rrand(10,120)],g,\addToHead);
});
)

// set all controls that match "ffreq" in all nodes in g to 90
g.set("ffreq",300);

g.set("freq",80);

// since we stored the Synths in an Array, we can also control them individually
(
r = Routine({
	inf.do({
		l.do({ arg node;
			node.set("freq",rrand(10,120));
			1.0.wait;
		});
	})
});

r.play;
)

// g is in a group too. Since we didn't specify it's the default group (ID 1) of the default Server
g.group.inspect;

// asking a wah to go order-of-execution after g, in the same group as g.
x = Synth.after(g,"help-Group-wah",["out",0]);

// now dump my tree to confirm
g.dumpTree;

x.free;

// free all nodes in g, but not g itself
g.freeAll;

// don't forget the Routine is still running...
r.stop;

// oh, and set l to nil so the Synths and Array can be garbage collected
l = nil;

// and i'm still on the server, its just my children that were freed
g.query;

// don't need the individual synth objects this time
(
3.do({
	// random freq for each synth, added to g at the head
	Synth("help-Group-moto-rev",["out",0,"freq",rrand(10,1200)],g,\addToHead);
});
)

// now query my tree and post a graph of it (duplicates dumpTree)
// msg format is ['/g_querytree.reply', node1-ID, numChildren, defName, child1-ID, numChildren, ...]
//(
//g.queryTree({|msg|
//	var i = 1, tabs = 0, dumpFunc;
//	("NODE TREE Group" + msg[1]).postln;
//	if(msg[2] > 0, {
//		dumpFunc = {|numChildren|
//			tabs = tabs + 1;
//			numChildren.do({
//				i = i + 3;
//				tabs.do({ "   ".post });
//				msg[i].post;
//				(" " ++ msg[i + 2]).postln;
//				if(msg[i + 1] > 0, { dumpFunc.value(msg[i + 1]) });
//			});
//			tabs = tabs - 1;
//		};
//		dumpFunc.value(msg[2]);
//	});
//});
//)

// kill me and my children
g.free;

// see, I'm gone
g.query;
::

** class:: HIDDevice
summary:: stores information about a device and holds an array of HIDElements
related:: Classes/HIDDeviceService, Classes/LID, Classes/GeneralHID
categories:: External Control>HID

description::

Helper class for link::Classes/HIDDeviceService::.

A HIDDevice's information consists out of:
the manufacturer, the product, the usage, the vendorID, the productID and the locID.
The last three are used to identify the device. The vendorID and the productID are static for each device, the locID depends on the (usb) port the device is connected to.

InstanceMethods::

private::prAddElement
** class:: HIDDeviceElement
summary:: stores information about a device
related:: Classes/HIDDeviceService, Classes/HIDDevice, Classes/LID, Classes/GeneralHID
categories:: External Control>HID

description::

Helper class for link::Classes/HIDDeviceService::.

A HIDDeviceElement's information consists out of:
the type, the usage, the cookie, the minimum and the maximum value.
The cookie is a number that can be used to identify an element of a device.
** class:: HIDDeviceService
summary:: provides access to Human Interface Devices like joysticks and gamepads
related:: Classes/LID, Classes/GeneralHID, Classes/HIDDevice
categories:: External Control>HID

description::
It is advised to use link::Classes/GeneralHID:: instead, which wraps the HIDDeviceService functionality, and produces crossplatform compatible code.

This service was mainly designed to use gamepads as control input. The name is derived from the mac osx specifications.

The HIDDeviceService handles all the primitive calls. link::Classes/HIDDevice:: only stores information about a device and holds an array of HIDElements, which store information about the controllers of the device.

A link::Classes/HIDDevice::'s information consists out of:
the manufacturer, the product, the usage, the vendorID, the productID and the locID.
The last three are used to identify the device. The vendorID and the productID are static for each device, the locID depends on the (usb) port the device is connected to.

A link::Classes/HIDDeviceElement::'s information consists out of:
the type, the usage, the cookie, the minimum and the maximum value.
The cookie is a number that can be used to identify an element of a device.

ClassMethods::

private::initClass, prbuildDeviceList, prbuildElementList, prGetElementListSize, prreleaseDeviceList, pr_runEventLoop, pr_stopEventLoop, prHidAction, prReadError

method::buildDeviceList
It is also possible to search for devices in other usage pages (look in the class file). The default is: page: GenericDesktop usage: Joystick. If a nil is passed in all devices are listed.

method::deviceSpecs
You can add to the classvar deviceSpecs the specs of your device. The key used has to be the product name derived from the device info. Here is a collection of specs:
code::
//wingman
(
HIDDeviceService.deviceSpecs.put('WingMan Action Pad',
	IdentityDictionary[
		\a -> 0, \b-> 1, \c-> 2,
		\x-> 3, \y-> 4, \z-> 5,
		\l-> 6, //front left
		\r-> 7, //front right
		\s-> 8,
		\mode-> 9,
		\xx-> 10,
		\yy-> 11,
		\slider-> 12,
		\hat-> 13
	]);
)
//cyborg
(
HIDDeviceService.deviceSpecs.put(\cyborg,  //not the right product name yet, so this doesn't work.
	IdentityDictionary[
		\trig -> 0, \a-> 1, \b -> 2, \c -> 3,
		\f1-> 4, \f2-> 5, \f3-> 6, \f4 -> 7,
		\l -> 8, \r -> 9, // arrow buttons
		\hu -> 10, \hl -> 11, \hr -> 12, \hd -> 13, // hat positions
		\x -> 14, \y -> 15, \z -> 16, // axes
		\slider-> 17,
		\hat-> 18
	]);
)
::

Examples::

There are two ways of getting values from the device: One is to poll a value, the other one is to start an eventloop that pushes every new value into the language and calls an action (like link::Classes/MIDIIn::).
To set up an eventloop follow these steps:
numberedList::
## initialize the service by calling:
code::
HIDDeviceService.buildDeviceList;
::
## now the information about the devices can be found:
code::
(
HIDDeviceService.devices.do({arg dev;
	[dev.manufacturer, dev.product, dev.vendorID, dev.productID, dev.locID].postln;
	dev.elements.do({arg ele;
		[ele.type, ele.usage, ele.cookie, ele.min, ele.max].postln;
	});
});
)
::
## the device needs to be queued, that means that the eventloop actually uses this device to push values.
code::
HIDDeviceService.devices.at(0).queueDevice;
::
## set an action that is called by the incoming events. In addition to the value the events also deliver the productID, the vendorID and the locID of the device and the cookie of the element.
code::
(
HIDDeviceService.action_({arg productID, vendorID, locID, cookie, val;
	[productID, vendorID, locID, cookie, val].postln;
});
)
::
## start the eventloop:
code::
HIDDeviceService.runEventLoop;
::
## stop the eventloop:
code::
HIDDeviceService.stopEventLoop;
::
::
** CLASS:: HLayout
summary:: A layout that distributes views in a horizontal line
categories:: GUI>Layout
related:: Classes/VLayout, Classes/GridLayout, Classes/StackLayout, Guides/GUI-Layout-Management
redirect:: implClass

DESCRIPTION::
See documentation of superclass link::Classes/QLineLayout:: for details.

CLASSMETHODS::

PRIVATE:: key
PRIVATE:: layoutClass
** class:: HLayoutView
redirect:: implClass
summary:: A container view that arranges its children horizontally
categories:: GUI>Views
related:: Classes/VLayoutView, Classes/CompositeView

DESCRIPTION::

note::
In Qt GUI, this class has been rendered strong::obsolete:: by a special set of layout classes; they are easier to use and more flexible. See link::Classes/HLayout:: for an equivalent to this class, and link::Guides/GUI-Layout-Management:: for a general description of the Qt layout system.
::

HLayoutView can be a parent to other views, and it automatically arranges its child views in horizontal order, expanding their height to its own bounds. Only the width of the children is relevant.

When arranging its children, HLayoutView takes the values of their 'minWidth' and 'maxWidth' properties into account. This is useful when a child's link::Classes/View#-resize#resize:: mode is set to 2, 5, or 8. See link::#examples:: below.

HLayoutView inherits some useful formatting methods from its superclasses.

note::
HLayoutView is designed mainly for grouping and placing widgets. While you can set it to accept key presses, it does not accept mouse clicks or drags.
::

CLASSMETHODS::
PRIVATE:: key

EXAMPLES::

Child view height fills the HLayoutView automatically:

code::
(
q = 10;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));

Array.fill(q,{ arg i;
    Slider(h,Rect(0,0,20,75)).value_(i / q)
});
h.background_(Color.rand);

w.front
)
::

Stretching the layout view; Slider height fills the View automatically:

code::
(
q = 8;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));
h.background = Color.rand;
h.resize = 5; // elastic

Array.fill(q,{ arg i;
    var s;
    s = Slider(h,Rect(0,0,20,75)).background_(Color.grey.alpha_(0.4));
    s.value = i / q;
    s
});
StaticText(h, Rect(0,0,105,20)).background_(Color.rand).string_(" Some Example\n Text");
w.front
)
::

Stretching the layout view and the contents; if all the contents are elastic, the widths of the contents are perfectly divided up. In this example, the StaticText is not elastic in order to preserve its width:

code::
(
q = 10;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));
h.resize = 5; // elastic
h.background = Color.rand;

Array.fill(q,{ arg i;
    var s;
    s = Slider(h,Rect(0,0,20,75));
    s.resize = 5; // elastic
    s.value = i / q;
    s
});
StaticText(h, Rect(0,0,105,20)).background_(Color.rand).string_(" Some Example\n Text");

w.front
)
::

Setting minWidth on contents; beware that if the layout view width is smaller than the combined width of all the contents, things might disappear when you try to handle them with the mouse:

code::
(
q = 5;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));
h.background = Color.rand;
h.resize = 5; // elastic

Array.fill(q,{ arg i;
    var s;
    s = Slider(h,Rect(0,0,20,75));
    s.value = i / 5;
    if(i < 2,{
        s.resize = 5; // some elastic
        s.setProperty(\minWidth,20);
    },{
        s.resize = 1; // some not elastic
    });
    s
});
StaticText(h, Rect(0,0,105,20)).background_(Color.rand).string_(" Some Example\n Text");

w.front
)
::

code::
(
q = 5;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));
h.resize = 5; // elastic
h.background = Color.rand;
Array.fill(q,{ arg i;
    var s;
    s = Slider(h,Rect(0,0,20,75));
    s.value = i / 5;
    s.resize = 5;
    s.setProperty(\minWidth,20);
    s.setProperty(\maxWidth,40);
    s
});

w.front
)
::

Text flows:

code::
(
q = 5;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));
h.resize = 5; // elastic

Array.fill(q,{ arg i;
    var s;
    s =     StaticText(h,120@20).string_("Some short text which wraps around");

    s.resize = 5;
    s.setProperty(\minWidth,10);
    s.setProperty(\maxWidth,120);

    // not working
    s.setProperty(\maxHeight,10);
    s.setProperty(\minHeight,10);

    s.background = Color.white;
    s
});

w.front
)
::

Spacing:

code::
(
q = 10;
w = Window.new;

h = HLayoutView(w,Rect(0,0,300,300));
h.setProperty(\spacing,0);

Array.fill(q,{
    Slider(h,Rect(0,0,20,75))
});

w.front
)
::
** class:: HPF
summary:: 2nd order Butterworth highpass filter.
related:: Classes/BPF, Classes/BRF, Classes/LPF
categories::  UGens>Filters>Linear


Description::
A second order high pass filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Cutoff frequency in Hertz.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
{ HPF.ar(Saw.ar(200,0.1), FSinOsc.kr(XLine.kr(0.7,300,20),0,3600,4000), 5) }.play;

(
{ 	var ctl = HPF.kr(LFSaw.kr(5), SinOsc.kr(XLine.kr(0.07,30,20), 0, 35, 40)) ;
	SinOsc.ar(ctl * 200 + 500);
}.play;
)

(
{ 	var ctl = HPF.kr(LFSaw.kr(5,0.1), MouseX.kr(2, 200, 1));
	SinOsc.ar(ctl * 200 + 400) * 0.1;
}.play;
)
::

** class:: HPZ1
summary:: Two point difference filter
related:: Classes/LPZ1, Classes/HPZ2
categories::  UGens>Filters>Linear


Description::

A special case fixed filter. Implements the formula:

code::
out(i) = 0.5 * (in(i) - in(i-1))
::

Which is a two point differentiator.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
// Compare:

{ WhiteNoise.ar(0.25) }.play;

{ HPZ1.ar(WhiteNoise.ar(0.25)) }.play;

// HPZ1 is useful to detect changes in a signal:
// see also HPZ2
(
{
	var changingSignal = LFNoise0.ar(1000);
	var hpz1 = HPZ1.ar(changingSignal);
	[hpz1, hpz1 > 0, hpz1.abs > 0]
}.plot
);
::

** class:: HPZ2
summary:: Two zero fixed midcut.
related:: Classes/BPZ2, Classes/BRZ2, Classes/LPZ2, Classes/HPZ1
categories::  UGens>Filters>Linear


Description::

A special case fixed filter. Implements the formula:

code::
out(i) = 0.25 * (in(i) - (2 * in(i - 1)) + in(i - 2)).
::


classmethods::

method::ar, kr

argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
// Compare:

{ WhiteNoise.ar(0.25) }.play;

{ HPZ2.ar(WhiteNoise.ar(0.25)) }.play;

// HPZ2 is useful to detect changes in a signal:
// see also HPZ1
(
{
	var changingSignal = LFNoise0.ar(1000);
	var hpz1 = HPZ2.ar(changingSignal);
	[hpz1, hpz1 > 0]
}.plot
);
::

** CLASS::Harmonics
summary:: Convenient factory for filling buffers with harmonics on the server
categories:: Collections, Server, UGens>Buffer

DESCRIPTION::
Harmonics objects are convenient factories for creating Arrays that are used to fill buffers using the b_gen sine fill commands on the server.

CLASSMETHODS::

method::new
Create a new Harmonics array of size. Nothing is filled in for you, until instance methods are applied.
code::
a = Harmonics.new(16);	// just returns an instance of Harmonics with size
::

INSTANCEMETHODS::

method::ramp
code::
a.ramp(1.0, 1.0);	// returns a harmonic series

b = Buffer.alloc(s, 512, 1);
// harmonic series for freqs, ramp down for amps
b.sine2(a.ramp(1.0, 1.0).postln, a.ramp(0.5, -0.025).postln, true, true, true);
(
z = SynthDef("help-Osc",{ arg out=0,bufnum=0;
	Out.ar(out,
		Osc.ar(bufnum, 200, 0, 0.5)
	)
});
)
y = z.play(s,[\out, 0, \bufnum, b]);
y.free;
::

method::decay
Implements the formula: 1 / ((i+1) ** k)
code::
a.decay(1.0);

b.sine2(a.ramp(1.0, 1.0).postln, a.decay(1.0).postln, true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
y.free;
::

method::geom
Implements the formula: 1 / (i ** k)
code::
a.geom(1.2);

b.sine2(a.ramp(1.0, 1.0).postln, a.geom(1.2).postln, true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
y.free;
::

method::formant
Create a formant like structure.
code::
a.formant(6, 3);

b.sine2(a.formant(12, 3).postln, a.geom(1.2), true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
y.free;
::

method::teeth
code::
a.teeth(6, 3);

b.sine2(a.teeth(2, 3).postln, a.geom(1.2), true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
b.sine2(a.teeth(4, 1).postln, a.geom(1.2), true, true, true);
b.sine2(a.teeth(1, 3).postln, a.geom(1.2), true, true, true);
b.sine2(a.teeth(2, 3).postln, a.geom(1.2), true, true, true);
y.free;
::

method::cutoff
Returns 1.0 to the nth place, fills the rest with 0.0
code::
a.cutoff(3);

b.sine2(a.ramp(1.0, 1.0), a.cutoff(3), true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
b.sine2(a.ramp(1.0, 1.0), a.cutoff(3), true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.cutoff(5), true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.cutoff(1), true, true, true);
y.free;
::

method::shelf
code::
a.shelf(0, 6, 1, 0);

b.sine2(a.ramp(1.0, 1.0), a.shelf(0, 6, 1, 0).postln , true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
b.sine2(a.ramp(1.0, 1.0), a.shelf(0, 11, 1, 0).postln , true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.shelf(2, 6, 1, 0).postln , true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.shelf(6, 8, 1, 0).postln , true, true, true);
y.free;
::

method::sine
code::
a.sine(8, 0, 1, 0);

b.sine2(a.ramp(1.0, 1.0), a.sine(8, 0, 1, 0).postln , true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
b.sine2(a.ramp(1.0, 1.0), a.sine(4, 0, 1, 0).postln , true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.sine(2.2, 0.5pi, 0.4, 0.2).postln , true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.sine(pi, 0.25pi, 0.5, 0).postln , true, true, true);
y.free;
::

method::pulse
code::
a.pulse(8, 0, 2, 1, 0);

b.sine2(a.ramp(1.0, 1.0), a.pulse(8, 0, 2, 1, 0).postln , true, true, true);
y = z.play(s,[\out, 0, \bufnum, b]);
b.sine2(a.ramp(1.0, 1.0), a.pulse(8, 0, 2, 1, 0).postln , true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.pulse(4, 0, 2, 0.4, 0.2).postln , true, true, true);
b.sine2(a.ramp(1.0, 1.0), a.pulse(7, 0.5pi, 3, 0.5, 0.1).postln , true, true, true);
y.free;
::

method:: rand, exprand, linrand
method:: rand2
method:: coin

** class:: Hasher
summary:: Randomized value.
categories::  UGens>Filters>Nonlinear, UGens>Random


Description::

Returns a unique output value from zero to one for each input value
according to a hash function. The same input value will always produce
the same output value. The input need not be from 0 to 1.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ Hasher.ar(Line.ar(0,1,1), 0.2) }.play;

(
{
	SinOsc.ar(
		Hasher.kr(MouseX.kr(0,10).round(1), 300, 500)
	) * 0.1
}.play;
)

(
{
	SinOsc.ar(
		Hasher.kr(MouseX.kr(0,10).round(1) + 0.0001, 300, 500)
	) * 0.1
}.play;
)

(
{
	SinOsc.ar(
		Hasher.kr(MouseX.kr(0,10), 300, 500)
	) * 0.1
}.play;
)
::
** class:: HelpBrowser
categories:: HelpSystem, GUI>Interfaces
related:: Classes/SCDoc
summary:: Browse the SuperCollider help documentation

description::

HelpBrowser is the GUI help browser that lets you browse the documentation of SuperCollider. It is coupled with SCDoc to allow on-the-fly rendering of HTML help files.

classmethods::
private:: getOldWrapUrl, initClass

method:: instance
The singleton HelpBrowser instance.

method:: new
Create a new HelpBrowser instance with given home URL.

method:: defaultHomeUrl
Get or set the default home URL.

method:: openNewWindows
Get or set the default for "open in new windows" toggle.

method:: goTo
Go to url with singleton instance or a new window, depending on the code::openNewWindows:: setting.

method:: openHelpFor
Open the relevant help page for given text in the singleton HelpBrowser instance.

method:: openSearchPage
Open the help search page with given text in the singleton HelpBrowser instance.

method:: openBrowsePage
Open the category browser page in the singleton HelpBrowser instance.

argument:: category
An optional String to start at specified category, like "UGens>Filters"

method:: openHelpForMethod
Open help for specified method.
argument:: method
a link::Classes/Method::

instancemethods::
private:: init, openTextFile, startAnim, stopAnim

method:: homeUrl
Get or set the home URL.

method:: window
The GUI window for this HelpBrowser.
discussion::
Mainly useful for when you need to show the browser:
code::
HelpBrowser.instance.window.front;
::

method:: goTo
Go to specific URL. If the URL points to a file under link::Classes/SCDoc#*helpTargetDir:: it will be rendered on demand if needed.

method:: goHome
Go to the home URL.

method:: goBack
Go back.

method:: goForward
Go forward.

** class:: HenonC
summary:: Henon map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/HenonN, Classes/HenonL

description::
A cubic-interpolating sound generator based on the difference equation:

code::
	x[n+2] = 1 - a * pow(x[n+1], 2) + b * x[n]
::
warning:: revise formulae converted to c like code. ::

This equation was discovered by French astronomer Michel Hénon while studying the orbits of stars in globular clusters.

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: x0
Initial value of x
argument:: x1
Second value of x

examples::
code::
// default initial params
{ HenonC.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);

// mouse-control of params
{ HenonC.ar(SampleRate.ir/4, MouseX.kr(1,1.4), MouseY.kr(0,0.3)) * 0.2 }.play(s);

// randomly modulate params
(
{ HenonC.ar(
	SampleRate.ir/8,
	LFNoise2.kr(1, 0.2, 1.2),
	LFNoise2.kr(1, 0.15, 0.15)
) * 0.2 }.play(s);
)

// as a frequency control
{ SinOsc.ar(HenonC.ar(40, MouseX.kr(1,1.4), MouseY.kr(0,0.3))*800+900)*0.4 }.play(s);
::
** class:: HenonL
summary:: Henon map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/HenonC, Classes/HenonN

description::
A linear-interpolating sound generator based on the difference equation:

code::
	x[n+2] = 1 - a * pow(x[n+1], 2) + b * x[n]
::
warning:: revise formulae converted to c like code. ::

This equation was discovered by French astronomer Michel Hénon while studying the orbits of stars in globular clusters.

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: x0
Initial value of x
argument:: x1
Second value of x

examples::
code::
// default initial params
{ HenonL.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);

// mouse-control of params
{ HenonL.ar(SampleRate.ir/4, MouseX.kr(1,1.4), MouseY.kr(0,0.3)) * 0.2 }.play(s);

// randomly modulate params
(
{ HenonL.ar(
	SampleRate.ir/8,
	LFNoise2.kr(1, 0.2, 1.2),
	LFNoise2.kr(1, 0.15, 0.15)
) * 0.2 }.play(s);
)

// as a frequency control
{ SinOsc.ar(HenonL.ar(40, MouseX.kr(1,1.4), MouseY.kr(0,0.3))*800+900)*0.4 }.play(s);
::
** class:: HenonN
summary:: Henon map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/HenonL, Classes/HenonC

description::
A non-interpolating sound generator based on the difference equation:

code::
	x[n+2] = 1 - a * pow(x[n+1], 2) + b * x[n]
::
warning:: revise formulae converted to c like code. ::

This equation was discovered by French astronomer Michel Hénon while studying the orbits of stars in globular clusters.

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: x0
Initial value of x
argument:: x1
Second value of x
argument::mul
argument::add

examples::
code::
// default initial params
{ HenonN.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);

// mouse-control of params
{ HenonN.ar(SampleRate.ir/4, MouseX.kr(1,1.4), MouseY.kr(0,0.3)) * 0.2 }.play(s);

// randomly modulate params
(
{ HenonN.ar(
	SampleRate.ir/8,
	LFNoise2.kr(1, 0.2, 1.2),
	LFNoise2.kr(1, 0.15, 0.15)
) * 0.2 }.play(s);
)

// as a frequency control
{ SinOsc.ar(HenonN.ar(40, MouseX.kr(1,1.4), MouseY.kr(0,0.3))*800+900)*0.4 }.play(s);
::
** class:: Hilbert
summary:: Applies the Hilbert transform to an input signal.
related:: Classes/HilbertFIR, Classes/FreqShift
categories::  UGens>Filters>Nonlinear


Description::

Returns two channels with the original signal and a copy of that signal that has been shifted in phase by 90 degrees (0.5 pi radians). Hilbert outputs two channels containing the input signal and the transformed signal. Due to the method used, distortion occurs in the upper octave of the frequency spectrum (See HilbertFIR for an FFT implementation that avoids this, but introduces a signigicant delay).


classmethods::

method::ar

argument::in

The input signal to transform.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
s = s.boot;
s.scope;
a = {Hilbert.ar(SinOsc.ar(100)) * -20.dbamp}.play;
a.release;
::
** class:: HilbertFIR
summary:: Applies the Hilbert transform to an input signal.
related:: Classes/Hilbert, Classes/FreqShift
categories::  UGens>Filters>Nonlinear


Description::

Returns two channels with the original signal and a copy of that signal that has been shifted in phase by 90 degrees (0.5 pi radians). HilbertFIR outputs two channels containing the input signal and the transformed signal. HilbertFIR uses FFTs and a 90 degree phase shift to transform the signal, and results in a delay equal to the size of the buffer used for the FFT divided by the sample rate. The Hilbert UGen has less delay, but distorts in the upper octace of the frequency spectrum.


classmethods::

method::ar

argument::in

The input signal to transform.


argument::buffer

A Buffer to be used for the inter FFT processing. Best results with a size of 1024 or 2048. 1024 gives an acceptable result (though a little choppy), 2048 is much smoother but creates more delay.


code::
s = s.boot;
s.scope;
a = { HilbertFIR.ar(SinOsc.ar(100) * -20.dbamp, LocalBuf(2048) }.play;
a.release;
::
** class:: HiliteGradient
summary:: A linear color fade between an outside and an inside color
categories:: GUI>Accessories
related:: Classes/Color, Classes/Gradient

description::
A linear color fade between an outside and an inside color.

note:: The use of HiliteGradient is strong::not supported yet in Qt GUI::. When HiliteGradient is used in place of Color, the average gradient color will be used instead. ::

classmethods::

method:: new
argument:: color1
An instance of Color.
argument:: color2
An instance of Color.
argument:: direction
code::\h:: or code::\v:: for horizontal and vertical respectively. Default value is code::\v::.
argument:: steps
The resolution of the gradient. Default value is 64.
argument:: frac
The center of the gradient. Default value is 0.33, i.e. off center toward the top on a vertical gradient.

examples::
code::
// basic usage
(
w = Window.new.front;
v = CompositeView(w, Rect(50, 50, 200, 50));
v.background = HiliteGradient(Color.gray, Color.white);
)

// change direction and resolution
(
w = Window.new.front;
w.view.background = HiliteGradient(Color.red, Color.white, \h, 12, 0.5);
)

// almost unnoticeable variations can be pleasant
(
w = Window.new.front;
v = CompositeView(w, Rect(50,50,300,300));
c = Color.rand;
d = c.vary(0.15);
v.background = HiliteGradient(c, d, \v);
[c, d].postln
)

(
var w, k, c, d, e, c1, c2, f, g;
w = Window.new.front;
k = Slider2D(w, Rect(50, 50, 300, 300));
f = {
	c = Color.rand;
	d = c.vary(0.5);
	e = d.vary(0.5);
};
g = {
	c1 = d.hueBlend(e, k.y).round(0.01);
	c2 = c.hueBlend(e, k.x).round(0.01);
	k.background = HiliteGradient(c1, c2, \v)
};
f.value; g.value;
k.action = g;
k.mouseUpAction = { [c1, c2].postln };
k.keyDownAction = f; // hit any key for new color
)
::
** class:: History
summary:: keeps a history of interpreted lines of code
related:: Classes/Archive
categories:: Streams-Patterns-Events

description::

History keeps track of all code lines that are being executed, in order to forward them to other players, to easily reuse earlier versions, or to store and reproduce a performance. Since it records everything that is interpreted, there is only one privileged instance of History - code::History.current::.
(adc 2006/7)

ClassMethods::

private::initClass

method::start
start adding interpreted code to (current) history.

method::end
end adding interpreted code to (current) history.

method::clear
remove all items from (current) history.

method::enter
add an entry by hand.

method::document
post the history in a new document (as story).

method::drop
drop the newest n lines from history. if n is negative, drop the oldest n lines.

method::keep
keep only the newest n lines from history. if n is negative, keep the oldest n lines.

method::saveCS
store history as one compileString.

method::loadCS
load a history from (compilestring) file.

method::saveStory
store in a file, in historical order as individual code snippets.

method::loadStory
read history into current, from a file in story format.

method::play
play back current history from start to end line, per default verbose.

method::stop
stop current history playback.

method::rewrite
Write a properly formatted code file from a history.

argument::path
The filename is the original name with "_rewritten." appended.

argument::open
If open is true (default: true), open a text window with the string.

Examples::

code::
History.clear.end;		// clear to start over
History.start; 			// starts recording, opens log file

				// execute these lines one by one
1 + 2;
p = ProxySpace.push(s.boot);
~a = {Dust.ar([1,1] * 30 ) * 0.3 }; //
~a.play;
~a.end;

History.end;		// NOTE: change of interface! History.end ends logging now.


History.document; // create a document with all the changes

History.showLogFile; //

g = History.makeWin(0@20); // make a gui window, put it where you like
g = History.makeWin(0@20, 5); // lines to see in textview

History.play;			// posts lines by default;

History.play(verbose: false);	// just do it, no posting;

	// continue recording
History.start;

10 + 200;			// enter 5 more lines
p.push;
~b = { |freq=500| LFDNoise3.ar(freq.dup(2)) * 0.2 };
~b.play;
~b.set(\freq, 1000);
~b.end(2);

History.end;


	// save current history to a file.
History.saveCS("~/Desktop/TestHist.scd");
h = History.new.loadCS("~/Desktop/TestHist.scd");
h.lines.printcsAll; "";

	// under the hood: History.someCommand goes to History.current:

	// History.current is where new codelines always go.
h = History.current;
h.lines.printcsAll; "";
h.lineShorts.printcsAll; "";	// lineshorts are for gui display

History.enter("2 + 2");		// make a simple entry by hand.
h.lines.printcsAll; "";

		// one can edit a history:

History.drop(-1); // drop the oldest memory
History.drop(1); // drop the newest memory

h.keep(9); 		h.lines.printAll; "";
h.drop(3); 		h.lines.printAll; "";
h.removeLast;		h.lines.printAll;"";
h.removeAt([3, 4]);	h.lines.printAll;"";


// more examples
History.clear.start;

1 + 2;			// code lines get stored

(nil + 2).postln;	// error lines are ignored

	// comment-only line is kept, empty lines not:

	// save and load as text files


History.saveCS; // save as compilestring for reloading.
			// save with name, in forward time order.
History.saveCS("~/Desktop/testHist.scd", forward: true);
			// load back in from file
h = History.new.loadCS("~/Desktop/testHist.scd", forward: true);
h.lines.postcs; "";

	// save as human-readable/hand-playable story
History.saveStory		// write all to time-stamped file in historical order
History.saveStory("~/Desktop/myTestStory.scd");	// ... with given filename.
History.loadStory("~/Desktop/myTestStory.scd");	// load from story format file

Document.open("~/Desktop/myTestStory.scd");	// the story file is human-readable.


	// Various Internals
	// make a new instance of History by hand:
h = History([[0, \me, "1+2"], [1.234, \me, "q = q ? ();"], [3, \me, "\"History\".speak"]]);
h.lines.printcsAll; "";
h.lineShorts.printcsAll; "";

h.play;	// play it
h.stop;


	// string formatting utils
h.storyString;
History.formatTime(1234.56);
History.unformatTime("0:20:34.56");
(
History.prettyString("
/* removes line returns at start and end of code strings ... */

").postcs;
)	// convert a line to a short string of n characters for gui display
History.shorten(h.lines.first.postcs, 60).postcs;


	// in networked setups, one may turn off local recording and rely on remote recording:
History.recordLocally
History.localOff
History.recordLocally
History.localOn
History.recordLocally


	// by default, history always logs here (and makes the folder if not there yet):
History.logFolder;
History.showLogFolder;
History.logPath;
History.showLogFile;	// current logfile...
	// todo: optionally, one should be able to turn logging off?

	// filtering lines, to get subsets of all lines by key and/or searchstring:

	// get indices for specific keys
h = History([[0, \me, "a=1+2"], [1, \me, "3+5"], [1.234, \you, "q = q ? ();"], [3, \her, "\"Herstory ==== \".speak"]]);
h.keys;
h.matchKeys(\me);
h.matchKeys(\you);
h.matchKeys(\her);
h.matchKeys; 		// nil if no test
h.matchKeys(\all); 	// all keys match
h.matchKeys([\me, \her])
h.matchKeys(\isidor)	// empty array if no line found

h.matchString("Herst");
h.matchString("q");
h.matchString("1+");
h.matchString("herStory", false); // ignoreCase is false by default
h.matchString("herStory", true); // ignoreCase

h.indicesFor([\me, \her], "=");	// indices for line written by \me or \her AND containing "=";

	// searching is only an interface/access feature,
	// so please read on at HistoryGui help ...
h.makeWin;

HistoryGui.help;
::
** CLASS:: HistoryGui
summary:: A gui for History objects
categories:: GUI>Interfaces
related:: Classes/History

DESCRIPTION::
The gui elements in detail:
DEFINITIONLIST::
## button start || stops and starts History emphasis::if:: code::gui.history:: is current.
## popUp sameDoc/newDoc || switches whether the code::postDoc:: method posts to old post-doc window or new.
## button closeAll || closes all documents called "History repeats".
## button closeOld || closes only those created from this gui, except the latest.

## button X/- || turns filtering on/off.
## popup \all || selects which key to search for (only useful if networked)
## textview || allows for typing in search string.

## listview || shows either all code::lineShorts::, or the filtered code::lineShorts::; selecting them in listview makes them come appear in post-doc window.
::


EXAMPLES::

code::
(
h = History.new.lines_([
	[0, \me, "1+2"],
	[1, \me, "3+5"], [1.234, \you, "q = q ? ();"],
	[3, \her, "\"Herstory\".speak"]
]);
g = h.makeWin;
g.findDoc;
g.postDoc(2);
)

h.document;
// how filtering works:
g.filters.postcs;
g.filterOff;
g.filterOn;
g.filtering;
g.setKeyFilter(\all);
g.setKeyFilter(\me);
g.setStrFilter("");
g.setStrFilter("3");

// internal state cached in gui:
g.filteredIndices;
g.filteredShorts;

// to do: execute line on special key in listview;
// window following?
::
** class:: IEnvGen
summary:: Envelope generator for polling values from an Env
categories:: UGens>Envelopes
related:: Classes/Env

description::
Envelope generator for polling values from an envelope. IEnvGen plays back break point envelopes from the code::index:: point. The envelopes are instances of the link::Classes/Env:: class.

classmethods::
private:: categories, new1

method:: ar, kr

argument:: envelope
an instance of Env (this is static for the life of the UGen)
argument:: index
a point to access within the Env
argument:: mul
argument:: add

instancemethods::
private:: init, argNamesInputsOffset, convertEnv

examples::

code::
(
{
	var env =  Env([0, 0.6, 0.3, 1.0, 0], [0.1, 0.02, 0.4, 1.1], [\lin, \exp, -6, \sin]);
	var envgen = IEnvGen.kr(env, MouseX.kr(0, env.times.sum));
	env.plot;
	SinOsc.ar(envgen * 500 + 440)
}.play;
)

// index with an SinOsc ... mouse controls amplitude of SinOsc
// use offset so negative values of SinOsc will map into the Env
(
{
	var sin = SinOsc.ar(440, 0, MouseX.kr(0, 1));
	// use offset so negative values of SinOsc will map into the Env
	var env = Env([-1, -0.7, 0.7, 1], [ 0.8666, 0.2666, 0.8668 ], \lin, -1.0);
	IEnvGen.ar(env, sin) * 0.1
}.play;
)

// index with Amplitude of input, control freq of SinOsc (uses SoundIn)
(
{
	var point = Amplitude.ar(SoundIn.ar(0), 0.01, 0.2);
	// use offset so negative values of SinOsc will map into the Env
	var env = Env.xyc([[0, 330, \exp], [0.5, 440, \exp], [1.0, 1760]]);
	SinOsc.ar(IEnvGen.kr(env, point)) * 0.2
}.play;
)

::

** class:: IFFT
summary:: Inverse Fast Fourier Transform
related:: Classes/FFT, Guides/FFT-Overview
categories::  UGens>FFT


Description::
The inverse fast fourier transform converts from frequency content to a
signal.

The fast fourier transform analyzes the frequency content of a signal. The IFFT UGen converts this emphasis::frequency-domain:: information back into emphasis::time-domain:: audio data. Most often this is used as the end of a process which begins with link::Classes/FFT::, followed by frequency-domain processing using PV (phase-vocoder) UGens, followed by IFFT.

classmethods::

method::new, ar, kr
returns a time domain signal from converting the FFT frequency domain signal chain. The *new method is equivalent to the *ar message returns an audio rate signal.

argument::buffer

The FFT "chain" signal coming originally from an FFT UGen, perhaps via other PV UGens.

argument:: wintype
Defines how the data is windowed:
table::
## -1 || strong::rectangular:: windowing, simple but typically not recommended;
## 0 || (the default) strong::Sine:: windowing, typically recommended for phase-vocoder work;
## 1 || strong::Hann:: windowing, typically recommended for analysis work.
::

argument:: winsize
Can be used to account for zero-padding, in the same way as the link::Classes/FFT:: UGen.

returns::
The emphasis::time-domain:: audio signal.

discussion::
The IFFT UGen converts the FFT data in-place (in the original FFT buffer) and overlap-adds the result to produce a continuous signal at its output.

Examples::

code::

// without any modification, convert FFT chain (frequency domain signal) back to audio (time domain signal)
{
	var in, chain;
	in = WhiteNoise.ar(0.01);
	chain = FFT(LocalBuf(2048), in);
	IFFT.ar(chain) // inverse FFT
	);
}.play;

::

** class:: IODesc
summary:: Description of SynthDesc input or output
categories:: Server>Nodes
related:: Classes/SynthDesc

description::
IODesc describes an input or output of a SynthDesc, as returned by link::Classes/SynthDesc#-outputs:: and link::Classes/SynthDesc#-inputs::

classmethods::
private:: new

instancemethods::
private:: printOn

method:: rate
A link::Classes/Symbol:: for the rate.

method:: numberOfChannels
The number of channels.

method:: startingChannel
This can either be a link::Classes/String::, a link::Classes/Float:: or an link::Classes/UGen::.
table::
## String || The name of the control that provides the bus index
## Float || A hard-coded bus index
## UGen || The UGen providing the bus index
::

method:: type
The class of the input/output ugen, like link::Classes/In::, link::Classes/Out::, link::Classes/ReplaceOut::, etc.

** class:: IRand
summary:: Single integer random number generator.
related:: Classes/ExpRand, Classes/LinRand, Classes/NRand, Classes/Rand, Classes/TExpRand, Classes/TIRand, Classes/TRand
categories:: UGens>Random

Description::

Generates a single random integer value in uniform distribution from
code::lo::  to  code::hi:: . It generates
this when the SynthDef first starts playing, and remains fixed for
the duration of the synth's existence.


classmethods::

method::new

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

Examples::

code::
(
SynthDef("help-IRand", {
	Out.ar(
		IRand(0, 1), //play on random channel between 0 and 1
		FSinOsc.ar(500,
			0, Line.kr(0.2, 0, 0.1, doneAction:2))
	)
}).send(s);
)

(
Routine({
	16.do({
		Synth.new("help-IRand"); 0.5.wait;
	})
}).play;
)
::

** CLASS::IdentityBag
summary::A Bag according to identity
categories::Collections>Unordered

DESCRIPTION::
An IdentityBag is an unordered collection of objects. In some languages it is referred to as a counted set. A Bag keeps track of the number of times objects are inserted and requires that objects be removed the same number of times. There is only one instance of an object in a Bag even if the object has been added to the Bag multiple times (test is for strong::identity::).

The contents of a IdentityBag are unordered. You must not depend on the order of items in a set.

INSTANCEMETHODS::

private::setDictionary

subsection::Adding and Removing

method::add
Add anObject to the Bag. A Bag may contain multiple entries of the same object.
code::
IdentityBag[1, 2, 3].add(4);
IdentityBag[1, 2, 3].add(3);
IdentityBag["abc", "def", "ghi"].add("jkl");
IdentityBag["abc", "def", "ghi"].add("def");
::

method::remove
Remove anObject from the IdentityBag.
code::
IdentityBag[1, 2, 3].remove(3);
::

method::contents
Returns the dictionary that stores the objects in pairs (obj -> numberOfObjects)
code::
IdentityBag[\a, \b, \c, \c].contents;
::

subsection::Iteration

method::do
Evaluates function for each item in the IdentityBag.
The function is passed two arguments, the item and an integer index.
code::
IdentityBag[1, 2, 3, 300].do({ arg item, i; item.postln });
::

section::Difference between Bag and IdentityBag
code::
// the two strings are equal, but not identical
"something" == "something"; // true
"something" === "something" // false

a = Bag.new;
a.add("something");
a.add("something");
a.contents; // only one object in the bag really

a = IdentityBag.new;
a.add("something");
a.add("something");
a.contents; // two objects in the bag
::
** CLASS::IdentityDictionary
summary::associative collection mapping keys to values
related::Classes/Environment, Classes/Event
categories::Collections>Unordered

DESCRIPTION::
An IdentityDictionary is an associative collection mapping keys to values.
Keys match only if they are strong::identical objects::. (i.e. === returns true.)

(In Dictionary, keys match if they are equal valued. This makes IdentityDictionary faster than link::Classes/Dictionary::)

The contents of a Dictionary are strong::unordered::. You must not depend on the order of items in a Dictionary.

Often, the subclass Event is used as an IdentityDictionary, because there is a syntactical shortcut:
code::
a = (); // return a new Event.
a.put(\foo, 2.718);
a.at(\foo);
::

CLASSMETHODS::

method::new
The link::#-parent:: and link::#-proto:: instance variables allow additional IdentityDictionary's to provide default values. The precedence order for determining the value of a key is the IdentityDictionary, its prototype, its parent.

When the instance variable link::#-know:: is link::Classes/True::, the IdentityDictionary responds to unknown messages by looking up the selector and evaluating the result with the dictionary as an argument. For example:
code::
a = IdentityDictionary(know: true);
a.put(\foo, { | x | ("the argument is:" + x).postln });
a.foo;
::

INSTANCEMETHODS::

method::putGet
Sets key to newValue, returns the previous value of key.

subsection::Accessing Instance Variables

method::proto, parent, know

subsection::IdentityDictionary reimplements the following methods of Dictionary

method::at, put, includesKey, findKeyForValue, scanFor

subsection::The following three methods provide support for Quant

method::nextTimeOnGrid, asQuant, timingOffset


EXAMPLES::

IdentityDictionary is often used to assign names to instances of a particular class. For example, the proxy classes ( link::Classes/Pdef::, link::Classes/Pdefn::, link::Classes/Tdef::, link::Classes/Ndef:: ), and link::Classes/NodeWatcher:: all have class variables named all implemented as IdentityDictionaries.
** CLASS::IdentitySet
summary::a set according to identity
related::Classes/List, Classes/Dictionary
categories::Collections>Unordered

DESCRIPTION::
An IdentitySet is a collection of objects, no two of which are the same object (aka. "identical").
Most of its methods are inherited (see link::Classes/Collection:: and link::Classes/Set:: classes).
The contents of an IdentitySet are unordered. You must not depend on the order of items in an IdentitySet.
For an ordered set, see link::Classes/OrderedIdentitySet::.

IdentitySets are faster than Sets because testing for identity is much faster than testing for equality. Different classes may implement equality in different ways, but identity can be determined just by comparing the object addresses. This allows some methods of IdentitySet to be implemented
by fast primitives.

INSTANCEMETHODS::

subsection::Adding and Removing

method::add
Add anObject to the IdentitySet. An object which is equal to an object already in the IdentitySet will not be added.
code::
IdentitySet[1, 2, 3].add(4);
IdentitySet[1, 2, 3].add(3);
// the two strings are equal but not identical
IdentitySet["abc", "def", "ghi"].add("def");
// symbols are guaranteed to be identical if they are equal
IdentitySet['abc', 'def', 'ghi'].add('def');
IdentitySet['abc', 'def', 'ghi'].add('jkl');
::

method::remove
Remove anObject from the IdentitySet.
code::
IdentitySet[1, 2, 3].remove(3);
::

subsection::Iteration

method::do
Evaluates function for each item in the IdentitySet. You must not depend on the order of items. The function is passed two arguments, the item and an integer index.
code::
IdentitySet[1, 2, 3, 300].do { |item, i| item.postln };
::

subsection::Finding an element

method::findMatch
Returns item if it is in the collection, otherwise returns nil.
code::
a = IdentitySet[1, 2, 3, 300];
a.findMatch(1);
a.findMatch(1.5);
::

EXAMPLES::

code::
// scanFor is fairly efficient. compare the following benchmarks:

// comparison of array indexing and identity set lookup
(
f = { |n=4|
	var x, y, i;
	x = (0..n);
	y = x.as(IdentitySet);
	i = x.choose;
	bench { 100.do { x[i] } };
	bench { 100.do { y.scanFor(i) } };
}
);

f.(4)
f.(8)
f.(100)
f.(10000)
::

code::
// you can use IdentitySet to efficiently remove identical duplicates from an array:

(
var e, f, g, h;
e = "such"; f = "fallacy"; g = "is"; h = "common";
a = [e, e, f, g, e, h, e];
);
a.as(IdentitySet);	// convert to set
a.as(Set).as(Array);	// and convert back

// note that the following behaves differently:
a = [ "such", "such", "fallacy", "is", "such", "common", "such" ]
a.as(IdentitySet);	// convert to set. All elements are still here.
			// Different strings may look the same, but be different objects.

// To remove equals in stead of identicals, use Set:
a.as(Set);
::
** class:: Impulse
summary:: Impulse oscillator.
related:: Classes/Blip
categories::  UGens>Generators>Deterministic


Description::

Outputs non-bandlimited single sample impulses.


classmethods::

method::ar, kr

argument::freq

Frequency in Hertz.


argument::phase

Phase offset in cycles (0..1).


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.

discussion::
An Impulse with frequency 0 returns a single impulse.

Examples::

code::
{ Impulse.ar(800, 0.0, 0.5, 0) }.play

{ Impulse.ar(XLine.kr(800,100,5), 0.0,  0.5, 0) }.play
::

modulate phase:
code::
{ Impulse.ar(4, [0, MouseX.kr(0, 1)], 0.2) }.play;
::

an Impulse with frequency 0 returns a single impulse:
code::
SynthDef(\imp, { OffsetOut.ar(0, Impulse.ar(0)); FreeSelf.kr(Impulse.kr(0)); }).add;
fork { (1 / (1..60).scramble).do { |dt| Synth.grain(\imp);  dt.wait } };
::

** class:: In
summary:: Read a signal from a bus.
related:: Classes/InFeedback, Classes/LagIn, Classes/SoundIn
categories::  UGens>InOut


Description::

In.ar and In.kr read signals from audio and control buses, respectively. (See the link::Tutorials/Getting-Started/11-Busses##Busses:: chapter of the link::Tutorials/Getting-Started/00-Getting-Started-With-SC##Getting Started:: tutorial series for details on buses.)

In.ar and In.kr behave slightly differently with respect to signals left on the bus in the previous calculation cycle.

In.ar can access audio signals that were generated in the current calculation cycle by Synth nodes located earlier in the node tree (see link::Guides/Order-of-execution::). It does not read signals left on an audio bus from the previous calculation cycle. If synth A reads from audio bus 0 and synth B writes to audio bus 0, and synth A is earlier than synth B, In.ar in synth A will read 0's (silence). This is to prevent accidental feedback. link::Classes/InFeedback:: supports audio signal feedback.

In.kr is for control buses. Control signals may be generated by Synth nodes within the server, or they may be set by the client and expected to hold steady. Therefore, In.kr does not distinguish between "new" and "old" data: it will always read the current value on the bus, whether it was generated earlier in this calculation cycle, left over from the last one, or set by the client.

Note that using the link::Classes/Bus:: class to allocate a multichannel bus simply
reserves a series of adjacent bus indices with the link::Classes/Server:: object's bus
allocators. code::abus.index:: simply returns the first of those indices.

When using a Bus with an In or  link::Classes/Out::  UGen there is nothing to
stop you from reading to or writing from a larger range, or from
hardcoding to a bus that has been allocated. You are responsible for
making sure that the number of channels match and that there are no
conflicts. See the link::Reference/Server-Architecture:: and link::Classes/Bus:: helpfiles for more
information on buses and how they are used.


The hardware input busses begin just after the hardware output busses and
can be read from using In.ar (See link::Reference/Server-Architecture:: for more
details). The number of hardware input and output busses can vary
depending on your Server's options. For a convienent wrapper class which
deals with this issue see  link::Classes/SoundIn:: .


classmethods::

method::ar, kr

argument::bus

The index of the bus to read in from.


argument::numChannels

The number of channels (i.e. adjacent buses) to read in. You
cannot modulate this number by assigning it to an argument in a
SynthDef.


Examples::

read from an audio bus:
code::
(
s = Server.local;
s.boot;
)

(
SynthDef("help-PinkNoise", { arg out=0;
	Out.ar(out, PinkNoise.ar(0.1))
}).send(s);

SynthDef("help-In", { arg out=0, in=0;
	var input;
		input = In.ar(in, 1);
		Out.ar(out, input);

}).send(s);
)

//play noise on the right channel
x = Synth("help-PinkNoise", [\out, 1]);

//read the input and play it out on the left channel
Synth.after(x, "help-In", [\out, 0, \in, 1]);
::

read from a  control bus:
code::
(
SynthDef("help-InKr",{ arg out=0, in=0;
	Out.ar(out,
		SinOsc.ar(In.kr(in, 1), 0, 0.1)
	)
}).send(s);
SynthDef("help-lfo", { arg out=0;
	Out.kr(out, LFNoise1.kr(0.3, 200, 800))
}).send(s);
)


b = Bus.control(s,1);
b.set(800);

Synth("help-InKr",[\in, b.index]);
b.set(400);
b.set(300);
Synth("help-lfo", [\out, b.index]);
::

read control data from a synth later in the node order:
code::
(
SynthDef("help-Infreq", { arg bus;
	Out.ar(0, FSinOsc.ar(In.kr(bus), 0, 0.5));
}).send(s);

SynthDef("help-Outfreq", { arg freq = 400, bus;
	Out.kr(bus, SinOsc.kr(1, 0, freq/40, freq));
}).send(s);

b = Bus.control(s,1);
)

// add the first control Synth at the tail of the default server; no audio yet
x = Synth.tail(s, "help-Outfreq", [\bus, b.index]);

// add the sound producing Synth BEFORE it; It receives x's data from the previous cycle
y = Synth.before(x, "help-Infreq", [\bus, b.index]);

// add another control Synth before y, at the head of the server
// It now overwrites x's cycle old data before y receives it
z = Synth.head(s, "help-Outfreq", [\bus, b.index, \freq, 800]);

// get another bus
c = Bus.control(s, 1);

// now y receives x's data even though z is still there
y.set(\bus, c.index); x.set(\bus, c.index);	// WARNING! gets loud!

x.free; y.free; z.free;
::

** class:: InFeedback
summary:: Read signal from a bus with a current or one cycle old timestamp.
related:: Classes/In, Classes/LagIn, Classes/LocalIn
categories::  UGens>InOut


Description::

When the various output UGens ( link::Classes/Out:: ,
link::Classes/OffsetOut:: ,  link::Classes/XOut:: ) write data to a bus,
they mix it with any data from the current cycle, but overwrite any data
from the previous cycle. ( link::Classes/ReplaceOut::  overwrites all
data regardless.) Thus depending on node order and what synths are
writing to the bus, the data on a given bus may be from the current cycle
or be one cycle old at the time of reading. In.ar checks the timestamp of
any data it reads in and zeros any data from the previous cycle (for use
within that node; the data remains on the bus). This is fine for audio
data, as it avoids feedback, but for control data it is useful to be able
to read data from any place in the node order. For this reason In.kr also
reads data that is older than the current cycle.


In some cases we might also want to read audio from a node later in the
current node order. This is the purpose of InFeedback. The delay
introduced by this is one block size, which equals about 0.0014 sec at
the default block size and sample rate. (See the resonator example below
to see the implications of this.)


The variably mixing and overwriting behaviour of the output UGens can
make order of execution crucial. (No pun intended.) For example with a
node order like the following the InFeedback UGen in Synth 2 will only
receive data from Synth 1 (→ = write out; ← = read in):
list::
## Synth1 → busA (this synth overwrites the output of Synth3 before it reaches Synth2)
## Synth2 (with InFeedback) ← busA
## Synth3 → busA
::

If Synth1 were moved after Synth2 then Synth2's InFeedback would receive
a mix of the output from Synth1 and Synth3. This would also be true if
Synth2 came after Synth1 and Synth3. In both cases data from Synth1 and
Synth3 would have the same time stamp (either current or from the
previous cycle), so nothing would be overwritten.


Because of this it is often useful to allocate a separate bus for
feedback. With the following arrangement Synth2 will receive data from
Synth3 regardless of Synth1's position in the node order:

list::
## Synth1 → busA
## Synth2 (with InFeedback) ← busB
## Synth3 → busB + busA
::
The second example below demonstrates this issue.


classmethods::

method::ar

argument::bus

The index of the bus to read in from.


argument::numChannels

The number of channels (i.e. adjacent buses) to read in. The
default is 1. You cannot modulate this number by assigning it to
an argument in a SynthDef.


Examples::
audio feedback modulation:
code::
(
SynthDef("help-InFeedback", { arg out=0, in=0;
	var input, sound;
		input = InFeedback.ar(in, 1);
		sound = SinOsc.ar(input * 1300 + 300, 0, 0.4);
		Out.ar(out, sound);

}).play;
)
::
this shows how a node can read audio from a bus that is being written to by a synth following it:
code::
(
SynthDef("help-InFeedback", { arg out=0, in=0;
	Out.ar(out,
		InFeedback.ar(in, 1)
	);
}).send(s);
SynthDef("help-SinOsc", { arg out=0, freq=440;
	Out.ar(out, SinOsc.ar(freq, 0, 0.1))
}).send(s);
)

x = Bus.audio(s, 1);

// read from bus n play to bus 0 (silent)
a = Synth("help-InFeedback",[\in, x.index, \out, 0]);

// now play a synth after this one, playing to bus x
b = Synth.after(a, "help-SinOsc", [\out, x.index]);

// add another synth before a which also writes to bus x
// now you can't hear b, as its data is one cycle old, and is overwritten by c
c = Synth.before(a, "help-SinOsc", [\out, x.index, \freq, 800]);

// free c and you can hear b again
c.free;
x.free;

a.free; b.free;
::

The example below implements a resonator. Note that you must subtract the blockSize in order for the tuning to be correct. See link::Classes/LocalIn:: for an equivalent example.
code::
(
var play, imp, initial;
SynthDef("testRes", {

play = InFeedback.ar(10, 1); // 10 is feedback channel
imp = Impulse.ar(1);

// feedback
OffsetOut.ar(10, DelayC.ar(imp + (play * 0.995), 1,
	440.reciprocal - ControlRate.ir.reciprocal)); // subtract block size

OffsetOut.ar(0, play);

}).play(s);

// Compare with this for tuning
{ SinOsc.ar(440, 0, 0.2) }.play(s, 1);
)
::

** class:: InRange
summary:: Tests if a signal is within a given range.
related:: Classes/InRect, Classes/Schmidt
categories::  UGens>Maths


Description::

If  code::in::  is ≥  code::lo::  and ≤
code::hi::  output 1.0, otherwise output 0.0. Output is
initially zero.


classmethods::

method::ar, kr, ir

argument::in

Signal to be tested.


argument::lo

Low threshold.


argument::hi

High threshold.


Examples::

code::

s.boot;

{ InRange.kr(SinOsc.kr(1, 0, 0.2), -0.15, 0.15)}.scope; // see the trigger

{ InRange.kr(SinOsc.kr(1, 0, 0.2), -0.15, 0.15) * BrownNoise.ar(0.1)}.scope; // trigger noise Burst

::

** class:: InRect
summary:: Test if a point is within a given rectangle.
related:: Classes/InRange, Classes/Schmidt
categories::  UGens>Maths


Description::
A pair of signals x and y are treated as a point (x,y) in 2-D; if they fall within the bounds of the rectangle, then this UGen outputs a one; else it outputs zero.


classmethods::
method::ar, kr

argument::x
X component signal

argument::y
Y component signal

argument::rect
A link::Classes/Rect:: which defines the rectangular region to monitor; note that Rects are in screen co-ordinates, so the top is smaller than the bottom. The Rect is created once and cannot be modulated.

examples::
code::
//we'll hear the sawtooth wave when the two sine oscillators are both in the region x = 0.0 to 0.5, y = 0.5 to 1.0
{InRect.ar(SinOsc.ar(1),SinOsc.ar(1.3),Rect(0,0.5,0.5,0.5))*LFSaw.ar(44,0,0.1) }.play

//stereo effect
{(InRect.ar(LFNoise0.ar([140,141]),LFNoise0.ar(143),Rect(0,0,0.5,1)).lag(0.1))*LFSaw.ar(SinOsc.ar(10,0,5,400),0,0.1) }.play


//for the Rect, create as left, 'top', width, height;
r= Rect(0,0,1,1)

r.left
r.right
r.top
r.bottom
::

** class:: InTrig
summary:: Generate a trigger anytime a bus is set.
categories::  UGens>InOut, UGens>Triggers


Description::

Any time the bus is "touched" ie. has its value set (using "/c_set"
etc.), a single impulse trigger will be generated. Its amplitude is the
value that the bus was set to.

If the bus is set link::Classes/Bus#Synchronous control bus methods#synchronously:: no trigger will be generated.


classmethods::

method::kr

argument::bus
The index of the bus to read in from.

argument::numChannels
The number of channels (i.e. adjacent buses) to read in. You
cannot modulate this number by assigning it to an argument in a
SynthDef.


Examples::

code::
s = Server.local;
b = Bus.control(s,1);

SynthDef("help-InTrig",{arg out=0,busnum=0;
	var inTrig;
	inTrig = InTrig.kr( busnum );
	Out.ar(out,
		EnvGen.kr(Env.perc,gate: inTrig,levelScale: inTrig ) * SinOsc.ar
	)
}).play(s,[\out, 0, \busnum, b.index]);


b.set(1.0);

b.value = 1.0;

b.value = 0.2;

b.value = 0.1;
::

compare with link::Classes/In:: example.

** class:: Index
summary:: Index into a table with a signal
related:: Classes/WrapIndex, Classes/Shaper
categories::  UGens>Buffer

Description::
Index into a table with a signal.
The input signal value is truncated to an integer value and used as an
index into the table. Out-of-range index values are clipped to the valid
range.

classmethods::

method::ar, kr

argument::bufnum
Index of the buffer.

argument::in
The input signal.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.


Examples::
code::
// indexing into a fixed table
(
{
	SinOsc.ar(
			Index.kr(
				LocalBuf.newFrom([ 200, 300, 400, 500, 600, 800 ]),
				LFSaw.kr(2.0).range(0, 7)
			),
			0,
			0.5
		)
}.play;
)

// with mouse control
(
{
	SinOsc.ar(
			Index.kr(
				LocalBuf.newFrom([ 200, 300, 400, 500, 600, 800 ]),
				MouseX.kr(0, 7)
			),
			0,
			0.5
		)
}.play;
)

(
// indexing into a changeable table
s = Server.local;
t = [ 200, 300, 400, 500, 600, 800 ];
b = Buffer(s, t.size, 1);

// alloc and set the values
s.listSendMsg( b.allocMsg( b.setnMsg(0, t) ).postln );

SynthDef(\help_Index, { arg out = 0, i_bufnum = 0;
	Out.ar(0,
		SinOsc.ar(
			Index.kr(
				i_bufnum,
				LFSaw.kr(2).range(0, 7)
			),
			0,
			0.5
		)
	)
}).play(s, [\i_bufnum, b]);
)

b.setn(*[ 200, 300, 400, 500, 600, 800 ].scramble.postln - 30);


(
SynthDef(\help_Index, { arg out=0,i_bufnum=0;
	Out.ar(0,
		SinOsc.ar(
			Index.kr(
				i_bufnum,
				MouseX.kr(0, BufFrames.ir(i_bufnum))
			),
			0,
			0.5
		)
	)
}).play(s, [\i_bufnum, b]);
)

b.free;
::

** class:: IndexInBetween
summary:: Finds the (lowest) point in the Buffer at which the input signal lies in-between the two values
categories:: UGens>Buffer
related:: Classes/Index, Classes/IndexL, Classes/SequenceableCollection#indexInBetween

description::
Finds the (lowest) point in the link::Classes/Buffer:: at which the input signal lies in-between the two values, and returns the index. The fractional part of the index is suitable for linearly interpolating between the buffer slot values.

For example, if the Buffer contains [3, 21, 25, 26] and the input has the value 22, then the output will be 1.25, because the value 22 is in-between the values stored in indices 1 and 2 and in fact is one-quarter of the way along the interval between them.

IndexInBetween is the complement of link::Classes/IndexL::.

classmethods::

method:: ar, kr
argument:: bufnum
index of the buffer.
argument:: in
the input signal.

examples::
code::
(
// autotune.
s = Server.local;
t = ([0, 1, 3, 4, 7, 11, 12] + 70).midicps;
b = Buffer(s, t.size, 1);

// alloc and set the values
s.listSendMsg( b.allocMsg( b.setnMsg(0, t) ).postln );

{
	var index, in, out, f0, fdiff;
	var bufnum = b;
	in = Pulse.ar(MouseX.kr(t.minItem, t.maxItem)) * 0.1;
	f0 = Pitch.kr(in).at(0);
	index = IndexInBetween.kr(bufnum, f0);
	fdiff = index.frac * (Index.kr(bufnum, index + 1) - Index.kr(bufnum, index));
	out = PitchShift.ar(in, 0.1, 1 - (fdiff / f0), 0.01, 0.01);
	RLPF.ar(out, [2000, 5000], 0.3)
}.play;
)

b.free;


// basic test.
(
s = Server.local;
t = [ 200, 210, 400, 430, 600, 800 ];
b = Buffer(s, t.size, 1);

// alloc and set the values
s.listSendMsg( b.allocMsg( b.setnMsg(0, t) ).postln );

{
	var index, f0, f1, f3;
	var bufnum = b;
	f0 = MouseX.kr(200, 900);
	index = IndexInBetween.kr(bufnum, f0);
	f1 = IndexL.kr(bufnum, index);
	SinOsc.ar([f0, f1]) * 0.1

}.play;
)

b.free;


// One way to map across from an arbitrary piecewise curve, onto another:
// We use IndexInBetween to "unmap" your input into integer slots,
// and then use IndexL to do the reverse, to "map" onto your other distribution.
// This example maps a sort-of-exponential curve onto a sort-of-sinusoidal curve:

~from = [1, 2, 4, 8, 16];
~to = [0, 1, 0, -1, 0];
(
x = {
	IndexL.kr(~to.as(LocalBuf), IndexInBetween.kr(~from.as(LocalBuf),MouseX.kr(~from.first, ~from.last).poll).poll).poll
}.play
)
::
** class:: IndexL
summary:: Index into a table with a signal, linear interpolated
categories:: UGens>Buffer
related:: Classes/Index, Classes/IndexInBetween

description::
The input signal value is used as an index into the table, with linear interpolation.
Out of range index values are clipped to the valid range.

classmethods::
method:: ar, kr
argument:: bufnum
index of the buffer.
argument:: in
the input signal.

examples::
code::
// indexing into a fixed table
(
{
	SinOsc.ar(
		IndexL.kr(
			LocalBuf.newFrom([ 200, 300, 400, 500, 600, 800 ].scramble),
			LFSaw.kr(2.0).range(0, 7)
		),
		0,
		0.5
	)
}.play;
)

// with mouse control
(
{
	SinOsc.ar(
		IndexL.kr(
			LocalBuf.newFrom([ 200, 300, 400, 500, 600, 800 ].scramble),
			MouseX.kr(0, 7)
		),
		0,
		0.5
	)
}.play;
)

(
// indexing into a changeable table
s = Server.local;
t = [ 200, 300, 400, 500, 600, 800 ];
b = Buffer(s, t.size, 1);

// alloc and set the values
s.listSendMsg( b.allocMsg( b.setnMsg(0, t) ).postln );

SynthDef(\help_index, { arg out = 0, i_bufnum = 0;
	Out.ar(0,
		SinOsc.ar(
			IndexL.kr(
				i_bufnum,
				LFSaw.kr(2).range(0, 7)
			),
			0,
			0.5
		)
	)
}).play(s, [\i_bufnum, b]);
)

b.setn(*[ 200, 300, 400, 500, 600, 800 ].scramble.postln - 30);


(
SynthDef(\help_index, { arg out = 0, i_bufnum = 0;
	Out.ar(0,
		SinOsc.ar(
			IndexL.kr(
				i_bufnum,
				MouseX.kr(0, BufFrames.ir(i_bufnum))
			),
			0,
			0.5
		)
	)
}).play(s, [\i_bufnum, b]);
)

b.free;
::
** class:: InfoUGenBase
summary:: Base class for info ugens
categories:: UGens>Base

description::
This is the superclass for the various info ugens.

** CLASS::Int16Array
summary::an array whose indexed slots are all of the same type
related::Classes/FloatArray, Classes/Int8Array, Classes/Int32Array, Classes/DoubleArray, Classes/SymbolArray
categories::Collections>Ordered

DESCRIPTION::
These classes implement arrays whose indexed slots are all of the same type.
list::
## Int8Array - 8 bit integer
## Int16Array - 16 bit integer
## Int32Array - 32 bit integer
## FloatArray - 32 bit floating point
## DoubleArray - 64 bit floating point
## SymbolArray - symbols
::

INSTANCEMETHODS::

method::readFromStream
** CLASS::Int32Array
summary::an array whose indexed slots are all of the same type
related::Classes/FloatArray, Classes/Int8Array, Classes/Int16Array, Classes/DoubleArray, Classes/SymbolArray
categories::Collections>Ordered

DESCRIPTION::
These classes implement arrays whose indexed slots are all of the same type.
list::
## Int8Array - 8 bit integer
## Int16Array - 16 bit integer
## Int32Array - 32 bit integer
## FloatArray - 32 bit floating point
## DoubleArray - 64 bit floating point
## SymbolArray - symbols
::

INSTANCEMETHODS::

method::readFromStream
** CLASS::Int8Array
summary::an array whose indexed slots are all of the same type
related::Classes/FloatArray, Classes/Int16Array, Classes/Int32Array, Classes/DoubleArray, Classes/SymbolArray
categories::Collections>Ordered

DESCRIPTION::
These classes implement arrays whose indexed slots are all of the same type.
list::
## Int8Array - 8 bit integer
## Int16Array - 16 bit integer
## Int32Array - 32 bit integer
## FloatArray - 32 bit floating point
## DoubleArray - 64 bit floating point
## SymbolArray - symbols
::

INSTANCEMETHODS::

method::readFromStream
** class:: Integer
summary:: Integer number
categories:: Math

description::
A 32 bit integer. Integer inherits most of its behaviour from its superclass.

instancemethods::

subsection:: Iteration

method:: do
Executes strong::function:: for all integers from zero to this minus one.
argument:: function
a link::Classes/Function:: which is passed two arguments, both of which are the same
integer from zero to this minus one. The reason two arguments are passed is for
symmetry with the implementations of do in link::Classes/Collection::.

method:: reverseDo
Executes strong::function:: for all integers from  this minus one to zero.

method:: for
Executes strong::function:: for all integers from this to strong::endval::, inclusive.
argument:: endval
an link::Classes/Integer::.
argument:: function
a link::Classes/Function:: which is passed two arguments, the first which is an integer from this to
endval, and the second which is a number from zero to the number of iterations minus one.

method:: forBy
Executes strong::function:: for all integers from this to strong::endval::, inclusive, stepping each time by strong::stepval::.
argument:: endval
an link::Classes/Integer::.
argument:: stepval
an link::Classes/Integer::.
argument:: function
a link::Classes/Function:: which is passed two arguments, the first which is an integer from this to
endval, and the second which is a number from zero to the number of iterations minus one.

method:: collect
Returns:: an link::Classes/Array:: of this size filled by objects generated from evaluating the strong::function::.

method:: collectAs
Returns:: a link::Classes/Collection:: of strong::class:: of this size filled by objects generated from evaluating the strong::function::.

method:: to
returns:: an link::Classes/Interval:: from this to strong::hi::.

method:: geom
returns:: an array with a geometric series of this size from start.

method:: fib
returns:: an array with a fibonacci series of this size beginning with strong::a:: and strong::b::.

method:: factors
returns:: the prime factors as array.

method:: factorial
returns:: the factorial of this.


subsection:: Random Numbers
See also: link::Guides/Randomness::

method:: xrand
argument:: exclude
an link::Classes/Integer::.
returns:: a random value from zero to this, excluding the value exclude.

method:: xrand2
argument:: exclude
an link::Classes/Integer::.
returns:: a random value from this.neg to this, excluding the value exclude.

subsection:: Conversion

method:: asAscii
returns:: a link::Classes/Char:: which has the ASCII value of the receiver.

method:: asDigit
returns:: a link::Classes/Char:: which represents the receiver as an ASCII digit.
discussion:: For example code::5.asDigit:: returns code::$5::.

method:: asBinaryDigits
returns:: an array with the binary digits (integer 0 or 1).

method:: asDigits
returns:: an array with the n-ary digits.
discussion::
See also the complementary method link::Classes/SequenceableCollection#-convertDigits::.
code::
2007.asDigits;
2007.asDigits(2);
::

method:: asBinaryString
returns:: a string with the binary digits (0 or 1).

method:: asHexString
returns:: a string with the hexadecimal digits (integer 0 to F).

method:: asIPString
returns:: a string in IP format.

method:: degreeToKey
Interpret this as index into a scale with a given number of steps per ocatve.
discussion::
code::
2.degreeToKey([0, 2, 5, 7, 11]);
::

method:: grayCode
Returns:: the gray code for the number.
discussion::
code::
2.grayCode
::

subsection:: Binary Representation

method:: setBit
set nth bit to zero (bool = false) or one (bool = true)

method::leadingZeroes
code:: { _CLZ } ::

method:: trailingZeroes
code:: { _CTZ } ::

method:: numBits
returns:: number of required bits


subsection:: Properties

method:: even
returns:: true if dividable by 2 with no rest

method:: odd
returns:: true if not dividable by 2 with no rest


subsection:: Powers Of Two

method:: nextPowerOfTwo
returns:: the next power of two greater than or equal to the receiver.
discussion::
code::
13.nextPowerOfTwo.postln;
64.nextPowerOfTwo.postln;
::

method:: isPowerOfTwo
returns:: the whether the receiver is a power of two.
discussion::
code::
13.isPowerOfTwo.postln;
64.isPowerOfTwo.postln;
::


subsection:: Prime Numbers

method:: nthPrime
returns:: the nth prime number. The receiver must be from 0 to 6541.
discussion::
code::
[0,1,2,3,4,5].collect({ arg i; i.nthPrime; }).postln;
::

method:: prevPrime
returns:: the next prime less than or equal to the receiver up to 65521.
discussion::
code::
25.prevPrime.postln;
::

method:: nextPrime
returns:: the next prime less than or equal to the receiver up to 65521.
discussion::
code::
25.nextPrime.postln;
::

method:: isPrime
returns:: whether the receiver is prime.
discussion::
code::
25.isPrime.postln;
13.isPrime.postln;
::

method:: indexOfPrime
returns:: the index of a prime number less than or equal to the receiver up to 65521.
If the receiver is not a prime, the answer is nil.
discussion::
code::
23.indexOfPrime;
25.indexOfPrime;
::


subsection:: Misc

method:: pidRunning
returns:: a Boolean for whether or not the specified pid is running.
discussion::
code::
p = "cat".unixCmd;
p.pidRunning; // cat will stay alive
("kill" + p).unixCmd
p.pidRunning;
::
** class:: Integrator
summary:: A leaky integrator.
categories::  UGens>Filters>Linear, UGens>Maths


Description::

Integrates an input signal with a leak. The formula implemented is:

code::
out(0) = in(0) + (coef * out(-1))
::


classmethods::

method::ar, kr

argument::in

The input signal.


argument::coef

Leak coefficient.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ Integrator.ar(LFPulse.ar(300, 0.2, 0.1), MouseX.kr(0.001, 0.999, 1)) }.play

// used as an envelope
{ Integrator.ar(LFPulse.ar(3, 0.2, 0.0004), 0.999, FSinOsc.ar(700), 0) }.play


// scope

{ Integrator.ar(LFPulse.ar(1500 / 4, 0.2, 0.1), MouseX.kr(0.01, 0.999, 1)) }.scope

::
** class:: InterplEnv
summary:: envelope specification
related:: Classes/IEnvGen, Classes/Env
categories:: Control, Envelopes

description::
An InterplEnv is a specification for a segmented envelope. InterplEnvs can be used both server-side, by an link::Classes/IEnvGen:: within a SynthDef, and clientside, with methods such as at. An InterplEnv can have any number of segments. An InterplEnv can have several shapes for its segments.

note::InterplEnv is now replaced by Env, and  will be removed in the future. Env supports all functionality of InterplEnv::

subsection::Differences between InterplEnv and Env
InterplEnvs do not have release or loop nodes.  They are of a fixed duration. Mostly, it is meant to be used with IEnvGen, where 'times' are actually an strong::index into the envelope:: shape.

ClassMethods::

private::initClass

method::new
Create a new envelope specification.

argument::levels
an array of levels. The first level is the initial value of the envelope.

argument::times
an array of durations of segments in seconds. There should be one fewer duration than there are levels.

argument::curve
a link::Classes/Symbol::, link::Classes/Float::, or an link::Classes/Array:: of those. Determines the shape of the envelope segments.

The possible values are:
table::
## code::\step:: || || flat segments
## code::\linear:: || code::\lin:: || linear segments, the default
## code::\exponential:: || code::\exp:: || natural exponential growth and decay. In this case, the levels must all be nonzero and the have the same sign.
## code::\sine:: || code::\sin:: || sinusoidal S shaped segments.
## code::\welch:: || code::\wel:: || sinusoidal segments shaped like the sides of a Welch window.
## code::\squared::  || code::\sqr:: || squared segment
## code::\cubed:: || code::\cub:: || cubed segment
## a link::Classes/Float:: || || a curvature value for all segments. 0 means linear, positive and negative numbers curve the segment up and down.
## an link::Classes/Array:: of symbols or floats || || curvature values for each segment.
::

argument::offset
used to offset an envelope into negative starttimes.

copymethod:: Env *newClear

InstanceMethods::

private::prAsArray

method::plot
Plot this envelope's shape in a window.

argument::size
The size of the plot.

argument::bounds
The window bounds (a link::Classes/Rect::).

argument::minval

argument::maxval

argument::parent

method::asArray
Converts the InterplEnv to an Array in a specially ordered format. This allows for InterplEnv parameters to be settable arguments in a link::Classes/SynthDef::.

subsection::Client-side Access and Stream Support

method::at
Returns the value of the InterplEnv at time.
code::
InterplEnv([0, 1, 0.707], [0.2, 1.3], [\lin, \sin]).at(0.5);
::
** class:: InterplPairs
summary:: envelope specification
related:: Classes/InterplEnv
categories:: Control, Envelopes

description::
Takes an array of [x, y] pairs and a curve value for all break points.
x values can be negative (for use in indexing with negartive values or signals).
See link::Classes/InterplEnv:: Help for more info.

Examples::

code::
a = InterplPairs([[0, 1], [1, 2], [2, 0]], \sin);
a.plot;

a = InterplPairs([[-1, 1], [0, 2], [1, 0]], \sin);
a.plot;
a.at(-0.5);
a.at(0.2);
::class:: InterplXYC
summary:: envelope specification
related:: Classes/InterplEnv
categories:: Control, Envelopes

description::
Takes sets of x, y and curve values and returns a new instance of InterplEnv.
x values can be negative (for use in indexing with negartive values or signals).
See link::Classes/InterplEnv:: Help for more info.

Examples::

code::
a = InterplXYC([0, 0, \lin], [1, 2, \sin], [2, 0]);
a.plot;

a = InterplXYC([[-1, 1, \sin], [0, 2, \lin], [1, 0]]);
a.plot;
a.at(-0.5);
a.at(0.2);
::class::Interpreter
summary:: The interpreter defines a context in which interactive commands are compiled and executed.
categories:: Core>Kernel

description::
In the interpreter, code::this:: refers to the interpreter itself, e.g.: code::this.postln::

classMethods::

private::new

instanceMethods::

subsection::Accessing

The interpreter defines instance variables code::a:: through code::z:: which are always available in the interpreter. By convention, the variable code::s:: is used to hold the default Server. Assigning another value to code::s:: may cause some of the examples in the documentation to fail.

method::clearAll

set the values of the variables code::a:: through code::z:: to nil.

code::
x = 123;
x.postln;
this.clearAll;
x.postln;
::

subsection::Compile & Interpret

method::interpret

Compile and execute a link::Classes/String::.

code::
this.interpret("(123 + 4000).postln");
::

method::interpretPrint

Compile and execute a link::Classes/String::, printing the result.

code::
this.interpretPrint("123 + 4000");
::

method::compile

Compile a String and return a link::Classes/Function::.

code::
(
z = this.compile("(123 + 4000).postln");
z.postln;
z.value;
)
::

method::compileFile

Reads the file at pathName, compiles it and returns a Function.
The file must contain a valid SuperCollider expression, naturally.
This will not compile class definitions, only expressions.

method::executeFile

Reads the file at pathName, compiles it and executes it, returning the result.
The file must contain a valid SuperCollider expression, naturally.
This will not compile class definitions, only expressions.

method::cmdLine

Returns the previosly interpreted code.

code::
1 + 2;
this.cmdLine
::

method::codeDump

this interpreter variable can be set to evaluate a function with any sucessfully compiled code.
see e.g. the class History.

code::
a = [ ]; // store all the code evaulated in a
this.codeDump = { |code| a = a.add(code) };
1 + 3;
f = { "hallo" };
a.postcs;
codeDump = nil; // reset to nil.
::

method::preProcessor

can be used to modify code before it is interpreted. Given appropriate delimiters, this can be used to implement little languages.

code::
// silly but simple: understand a Saw for every SinOsc
this.preProcessor = { |code| code.replace("SinOsc", "Saw") };

{ SinOsc.ar(200) * 0.1 }.play;

preProcessor = nil; // reset to nil.
::


** CLASS::Interval
summary::range of integers
categories:: Math

DESCRIPTION::
An Interval is a range of integers from a starting value to an ending value by some step value.

CLASSMETHODS::

method::new
Create a new Interval.
code::
Interval(10, 30, 4);
10 to: 30; // the message to creates an interval with step 1
::

INSTANCEMETHODS::

method::start
The starting value of the interval.

method::end
The ending value of the interval.

method::step
The step value of the interval.

method::size
Return the number of items in the interval.
code::
Interval(10, 30, 4).size.postln;
::

method::at
Return the indexed item in the interval.
code::
Interval(10, 30, 4).at(3).postln;
::

method::do
Evaluates function for each item in the interval. The function is passed two arguments, the item and an integer index.
code::
Interval(10, 30, 4).do({ arg item, i; item.postln });
::
** class:: JITGui
summary:: a superclass for just in time interfaces
categories:: Libraries>JITLib>GUI

description::
Proxies for synths, tasks and patterns as implemented in JITLib are extremely flexible. Having guis that represent their changeable states makes it easier to understand what is going on, especially when using multiple proxies together. JITGuis follow a special strategy described below.

subsection::See also

list::
## link::Classes/EnvirGui::,
## link::Classes/TdefGui::, link::Classes/TdefAllGui::, ( link::Classes/TaskProxyGui:: )	// TdefGui replaces obsolete TdefEditor
## link::Classes/PdefGui::, link::Classes/PdefAllGui::, ( link::Classes/TaskProxyAllGui:: )	// PdefGui replaces obsolete PdefEditor
## link::Classes/NdefGui::, link::Classes/MonitorGui::, link::Classes/NdefParamGui:: 	// replace NodeProxyEditor, ProxyMonitorGui
## link::Classes/ProxyMixer::
## link::Classes/NdefMixer::
::

subsection::still to be done

list::
## (ProxyChain) ProxyChainGui
## (PxPreset) PxPresetGui
## (maybe SoftSet)
::

ClassMethods::

private::initClass

subsection::Creation

method::new
Create a new JITGui that will be watching an object and displaying its state.

code::
g = JITGui.new(nil, 0);		// make one
g.object = 123;			// object gets shown asCompileString
g.object = (key: \otto); 	// if the object understands .key, key gets shown
g.object = Pseq([1, 2, 3], inf);
g.close;
::

argument::object
the object to watch

argument::numItems
the number of display items to use, e.g. how many fields for text, or how many EZSliders for single-number parameters.

argument::parent
a parent view on which to display. If nil, a new window is created; strong::parent:: can also be an existing window or a composite view.

argument::bounds
a desired size and position where to display a JITGui. can be nil, a link::Classes/Point::, or a link::Classes/Rect::. JITGuis know their minimum size ( strong::minSize:: ), and if bounds is nil, minSize is used. if bounds is a point or rect, it will be set to at least minSize. With a rect one can also supply a position where to display. If a point,shown size is the maximum of bounds and minSize

argument::makeSkip
A flag whether to make a skipjack.

argument::options
a list of additional information, e.g. flags about optional buttons. (this is used is some subclasses)

InstanceMethods::

subsection::Accessing Instance Variables

code::
g.dump;
::

method::object
the object to watch

method::numItems
the number of display items to use, e.g. how many fields for text, or how many EZSliders for single-number parameters.

method::parent
a parent view on which the gui is displayed.

method::bounds
the size and position of the JITGui

method::zone
a link::Classes/CompositeView:: inside the parent that holds the JITGui's views.

method::minSize
a JITGuis calculates its own minimum size based on numItems and options.

method::defPos
the default position where the JITGui is shown if it is in its own window.

method::skin
(Appearance)

the GUI skin to use. By default this is code::GUI.skins.jit:: .

method::font
(Appearance)

the font, also taken from JITGui.skin.

method::nameView
(specific in the JITGui class)

displays the object's key if available.

method::csView
(specific in the JITGui class)

displays the object's compileString.

method::prevState
(common to all JITGuis)

the last observed state which is kept around for comparison.

method::skipjack
(common to all JITGuis)

the skipjack that watches the object's state so it can be updated.

method::scroller
(common to all JITGuis)

an link::Classes/EZScroller:: used for scrolling which of a list of items is shown. see e.g. link::Classes/TdefGui:: for usage.

method::hasWindow
(common to all JITGuis)

a flag whether the JITGui has made its own window, and thus owns it.

subsection::Instance Methods

method::object
put an object in the gui - if the gui accepts it.

method::accepts
test whether obj is a valid object to show in a JITGui. In strong::JITGui:: itself, all objects are accepted, in the subclasses, strong::obj:: can either be nil or a specific class, such as link::Classes/Tdef::, link::Classes/Pdef::, link::Classes/Ndef::

method::name
set the text of the link::#-nameView:: and the window (if it link::#-hasWindow::)

method::getName
ask the object its name, or return code::'_anon_'::

method::winName
return a suitable name for a window: "JITGui_objname"

method::moveTo
if it has its own window, one can move it to some specific location.

method::close
close its window.

subsection::How JITGuis work

A JITGui watches the state of its object by calling its (the gui's) link::#-getState:: method. It compares the new state of the object with the previous state stored in link::#-prevState::. When something has changed, the gui elements concerned are updated.

subsection::How JITGuis work: Methods that subclasses should implement

You can write your own subclasses to JITGui very efficiently by implementing appropriate variants of the following methods in your class. For examples of these methods, see link::Classes/TdefGui::, link::Classes/EnvirGui::, link::Classes/NdefGui::.

method::setDefaults
used to calculate the required onscreen size for the jitGui's zone. Should determine zone size based on link::#-numItems:: and options. also, link::#-defPos:: (where to show your jitGui by default) can be set here, and possibly modifications to the skin used.

method::accepts
a test whether strong::obj:: can be shown in the particular kind of JITGui. Subclasses of JITGui are made for special objects, e.g. Pdefs, so they should test whether obj is the right kind.

method::makeViews
create all the views of the jitGui inside the zone.

subsection::How JITGuis work: For updating the JITGui, these are essential

method::getState
ask the object for all aspects of its current state that will be displayed.

method::checkUpdate
get the object's current state with link::#-prevState::, compare it with prevState, update all gui elements that need to be changed, and store the new state as prevState. This method is called in the skipJack.

subsection::How JITGuis work: More methods you may want to overwrite if required

method::calcBounds
how to calculate the bounds for the zone in which to display

method::makeWindow
how to make a window when no parent is given

method::makeZone
how to initalize the zone within the parent window or view

method::getName
a method for generating a name for the object.

method::winName
a method for generating a name for the JITGui's window.

method::makeScroller
Some objects may have more elements to display than the gui has slots, e.g. a link::Classes/ProxySpace:: can have more proxies than the mixer has numItems. Then, only link::#-numItems:: elements are shown, and the others can be scrolled to with link::#-scroller:: - an link::Classes/EZScroller:: next to the slot elements. The makeScroller method knows where in the zone to put the scroller.

Examples::

code::
	// some layout tests

	// make its own window - defPos, minSize is used
g = JITGui(Ndef(\a));

	// make its own window, specific size
g = JITGui(Ndef(\a), bounds: 390@20);

	// provide full bounds
g = JITGui(Ndef(\a), bounds: Rect(200, 500, 390, 24));

	// extent is 0@0: minSize x, y is used
g = JITGui(Ndef(\a), bounds: Rect(200, 500, 0, 0));
g = JITGui(Ndef(\a), bounds: Rect(200, 500, 0, 50));
g = JITGui(Ndef(\a), bounds: Rect(200, 500, 500, 0));


(	// put a JITGui in an existing window:
w = Window().front;
g = JITGui(Ndef(\a), 0, w, bounds: 300@48);
)

(	// 5 lines high
w = Window().front;
g = JITGui(Ndef(\a), 5, w);
)

(	// recommended: use a FlowLayout.
w = Window().front;
w.addFlowLayout;
EZSlider(w, 300@100, \test, []);
g = JITGui(Ndef(\a), 0, w, bounds: 300@40);
)
::
** class:: K2A
summary:: Control to audio rate converter.
related:: Classes/A2K
categories::  UGens>Conversion


Description::

To be able to play a control rate UGen into an audio rate UGen,
sometimes the rate must be converted. K2A converts via linear
interpolation.


classmethods::

method::ar

argument::in
The input signal.

Examples::

code::
{ K2A.ar(WhiteNoise.kr(0.3)) }.scope;


// compare:
(
{
	[
		K2A.ar(WhiteNoise.kr(0.3)),
		WhiteNoise.ar(0.3)
	]
}.scope;
)

(
{
	var freq, blockSize, sampleRate;
	blockSize = s.options.blockSize; // usually 64
	sampleRate = s.sampleRate;
	freq = MouseX.kr(0.1, 40, 1) / blockSize * sampleRate;
	[
		K2A.ar(LFNoise0.kr(freq)),
		LFNoise0.ar(freq)
	] * 0.3
}.scope;
)
::

** class:: KeyState
summary:: Respond to the state of a key
related:: Classes/MouseButton, Classes/MouseX, Classes/MouseY
categories::  UGens>User interaction


Description::
Respond to the state of a key.

note::
Note that this UGen does not prevent normal typing. It therefore may be
helpful to select a GUI window rather than an SC document when using
KeyState, as the latter will be altered by any keystrokes.
::

classmethods::

method::kr

argument::keycode
The keycode value of the key to check. This corresponds to the
keycode values passed into the keyDownActions of SCViews. See the
example below.

argument::minval
The value to output when the key is not pressed.

argument::maxval
The value to output  when the key is pressed.

argument::lag
A lag factor.

instancemethods::
private:: signalRange

Examples::

code::
s.boot;

// execute the code below to find out a key's keycode
// the char and keycode of any key you press will be printed in the post window
(
w = Window.new("I catch keystrokes");
w.view.keyDownAction = { arg view, char, modifiers, unicode, keycode;  [char, keycode].postln; };
w.front;
)

// then execute this and then press the 'j' key
(
w.front; // something safe to type on
{ SinOsc.ar(800, 0, KeyState.kr(38, 0, 0.1)) }.play;
)
::

** class:: KeyTrack
summary:: Key tracker
categories:: UGens>Analysis>Pitch
related:: Classes/BeatTrack, Classes/Loudness, Classes/MFCC, Classes/Onsets, Classes/Pitch

description::
A (12TET major/minor) key tracker based on a pitch class profile of energy across FFT bins and matching this to templates for major and minor scales in all transpositions. It assumes a 440 Hz concert A reference. Output is 0-11 C major to B major, 12-23 C minor to B minor.

classmethods::

method:: kr

argument:: chain
[fft] Audio input to track. This must have been pre-analysed by a 4096 size FFT. No other FFT sizes are valid except as noted below.
code::
// With standard hop of half FFT size = 2048 samples
b = Buffer.alloc(s,4096,1); // for sampling rates 44100 and 48000
//b = Buffer.alloc(s,8192,1); // for sampling rates 88200 and 96000
::

argument:: keydecay
[sk] Number of seconds for the influence of a window on the final key decision to decay by 40dB (to 0.01 its original value).

argument:: chromaleak
[sk] Each frame, the chroma values are set to the previous value multiplied by the chromadecay. 0.0 will start each frame afresh with no memory.

examples::

code::
// The following files are test materials on my machine; you will subsitute your own filenames here
// A major
d = Buffer.read(s,"/Volumes/data/stevebeattrack/samples/100.wav");
// F major; hard to track!
d = Buffer.read(s,"/Volumes/data/stevebeattrack/samples/115.wav");

// straight forward since no transients; training set from MIREX2006
// 01 = A major
// 57 = b minor
// 78 e minor
// 08 Bb major
d = Buffer.read(s, "/Users/nickcollins/Desktop/ML/training_wav/78.wav")

b = Buffer.alloc(s, 4096, 1); // for sampling rates 44100 and 48000

(
{
var in, fft, resample;
var key, transientdetection;

in = PlayBuf.ar(1, d, BufRateScale.kr(d), 1, 0, 1);

fft = FFT(b, in);

key=KeyTrack.kr(fft, 2.0, 0.5);

key.poll;

Out.ar(0,Pan2.ar(in));
}.play
)
::



code::
// alternating major and minor chords as a test
(
{
var in, fft, resample;
var key, transientdetection;

in = Mix(SinOsc.ar((60 + [0, MouseX.kr(3, 4).round(1), 7]).midicps, 0, 0.1));

// major dom 7 and minor 7; major keys preferred here
//in = Mix(SinOsc.ar((60 + (MouseY.kr(0, 11).round(1.0)) + [0, MouseX.kr(3, 4).round(1), 7, 10]).midicps, 0, 0.1));

fft = FFT(b, in);

key = KeyTrack.kr(fft);

key.poll;

Out.ar(0,Pan2.ar(in));
}.play
)
::



code::
// Nice to hear what KeyTrack thinks:

d = Buffer.read(s, "/Users/nickcollins/Desktop/ML/training_wav/78.wav")
b = Buffer.alloc(s, 4096, 1); // for sampling rates 44100 and 48000

(
{
var in, fft, resample, chord, rootnote, sympath;
var key, transientdetection;

in = PlayBuf.ar(1, d, BufRateScale.kr(d), 1, 0, 1);

fft = FFT(b, in);

key = KeyTrack.kr(fft, 2.0, 0.5);
key.poll;
key = Median.kr(101, key); // Remove outlier wibbles

chord = if(key<12, #[0, 4, 7], #[0, 3, 7]);
rootnote = if(key<12, key, key-12) + 60;

sympath = SinOsc.ar((rootnote + chord).midicps, 0, 0.4).mean;

Out.ar(0,Pan2.ar(in, -0.5) + Pan2.ar(sympath, 0.5));
}.play
)
::



code::
// Research Notes:
// See the MIREX2006 audio key tracking competition and Emilia Gomez's PhD thesis, Tonal Description of Music Audio Signals

// The following code was used to create the datasets for the UGen, and would be the basis of extensions

// Need one set of bin data for 44100 and one for 48000

// KeyTrack calculations, need to make arrays of FFT bins and weights for each chromatic tone.
// greater resolution, 4096 FFT, avoid lower octaves, too messy there
// 60*6*2 output arrays

(
var fftN, fftBins, binsize;
var midinotes;
var sr;
var wtlist, binlist;

sr = 48000; //44100;

fftN = 4096;
fftBins = fftN.div(2);
binsize = sr / fftN;

midinotes = (33..92); // 60 notes, 55 Hz up to 1661.2187903198 Hz

wtlist = List[];
binlist = List[];

// for each note have six harmonic locations
midinotes.do{ |note|
	var freq, whichbin, lowerbin, prop;

	freq = note.midicps;

	6.do{|j|
		var partialfreq, partialamp;

		partialamp = 1.0 / (j + 1);
		partialfreq = freq * (j + 1);

		whichbin = partialfreq / binsize;
		lowerbin = whichbin.asInteger;
		prop = 1.0 - (whichbin - lowerbin);

		binlist.add(lowerbin).add(lowerbin + 1);
		wtlist.add(prop * partialamp).add((1.0 - prop) * partialamp);

	};

};


Post << (binlist) << nl<< nl;

Post << (wtlist) << nl<< nl;

binlist.size.postln;
wtlist.size.postln;
)
::
** class:: Klang
summary:: Sine oscillator bank
related:: Classes/Klank, Classes/DynKlang
categories:: UGens>Generators>Deterministic

Description::
Klang is a bank of fixed frequency sine oscillators. Klang is more
efficient than creating individual oscillators but offers less
flexibility.


classmethods::

method::ar

argument::specificationsArrayRef
A link::Classes/Ref:: to an link::Classes/Array:: of three Arrays:

definitionlist::
## frequencies: || An Array of oscillator frequencies.
## amplitudes: || an Array of oscillator amplitudes, or nil. If nil, then amplitudes default to 1.0.
## phases: || an Array of initial phases, or nil. If nil, then phases default to 0.0.
::

argument::freqscale
A scale factor multiplied by all frequencies at initialization time.

argument::freqoffset
An offset added to all frequencies at initialization time.

discussion::
The parameters in code::specificationsArrayRef:: can't be changed after it has been started.
For a modulatable but less efficient version, see link::Classes/DynKlang::.


Examples::

code::
play({ Klang.ar(`[ [800, 1000, 1200], [0.3, 0.3, 0.3], [pi, pi, pi]], 1, 0) * 0.4});

play({ Klang.ar(`[ [800, 1000, 1200], nil, nil], 1, 0) * 0.25});

play({ Klang.ar(`[ Array.rand(12, 600.0, 1000.0), nil, nil ], 1, 0) * 0.05 });



(
{
loop({
	play({
		Pan2.ar(Klang.ar(`[ Array.rand(12, 200.0, 2000.0), nil, nil ], 1, 0), 1.0.rand)
			 * EnvGen.kr(Env.sine(4), 1, 0.02, doneAction: 2);
	});
	2.wait;
})
}.fork;
)

// Multichannel expansion:

(
{
loop({
	play({
		var nPartials = 12, nChans = 5, n = nPartials * nChans;
		Splay.ar(Klang.ar(`[ { { rrand(200.0, 2000.0) } ! nPartials } ! nChans, nil, nil ], 1, 0))
			 * EnvGen.kr(Env.sine(4), 1, 0.02, doneAction: 2);
	});
	2.wait;
})
}.fork;
)
::



** class:: Klank
summary:: Bank of resonators
related:: Classes/DynKlank, Classes/Klang
categories:: UGens>Generators>Deterministic, UGens>Filters>Linear


Description::

Klank is a bank of fixed frequency resonators which can be used to
simulate the resonant modes of an object. Each mode is given a ring time,
which is the time for the mode to decay by 60 dB.


classmethods::

method::ar

argument::specificationsArrayRef
A link::Classes/Ref:: to an link::Classes/Array:: of three Arrays:

definitionlist::
## frequencies: || An Array of filter frequencies.
## amplitudes: || an Array of filter amplitudes, or nil. If nil, then amplitudes default to 1.0.
## ring times: || an Array of 60 dB decay times for the filters.
::
All subarrays, if not nil, should have the same length.

argument::input
The excitation input to the resonant filter bank.

argument::freqscale
A scale factor multiplied by all frequencies at initialization time.

argument::freqoffset
An offset added to all frequencies at initialization time.

argument::decayscale
A scale factor multiplied by all ring times at initialization time.

discussion::
The parameters in code::specificationsArrayRef:: can't be changed after it has been started.
For a modulatable but less efficient version, see link::Classes/DynKlank::.


Examples::

code::
{ Klank.ar(`[[800, 1071, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play;

{ Klank.ar(`[[800, 1071, 1353, 1723], nil, [1, 1, 1, 1]], Dust.ar(8, 0.1)) }.play;

{ Klank.ar(`[[800, 1071, 1353, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar(0.007)) }.play;

{ Klank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar([0.007, 0.007])) }.play;

(
play({
	Klank.ar(`[
		Array.rand(12, 800.0, 4000.0), 		// frequencies
		nil, 							// amplitudes (default to 1.0)
		Array.rand(12, 0.1, 2)				// ring times
		], Decay.ar(Impulse.ar(4), 0.03, ClipNoise.ar(0.01)))
})
)

// multi channel expansion:
// an array of specs
(
{
Klank.ar([
	`[[500, 1078, 1201.5, 1723], nil, [1, 1, 0.5, 0.3]],
	`[[700, 1071, 1053, 1723], nil, [1, 1, 1, 1]]
	], Impulse.ar([2, 2.5], 0, 0.1))
}.play
);

// expanding specs
{ Klank.ar(`[[[800, 6000], 1071, [1153, 8000], 1723], nil, [1, 1, 1, 1]], Impulse.ar([2, 3], 0, 0.1)) }.play;



// a synth def that has 4 partials
(

SynthDef(\help_Klank, { arg out=0, i_freq;
	var klank, n, harm, amp, ring;

	// harmonics
	harm = \harm.ir(Array.series(4, 1, 1).postln);
	// amplitudes
	amp = \amp.ir(Array.fill(4, 0.05));
	// ring times
	ring = \ring.ir(Array.fill(4, 1));

	klank = Klank.ar(`[harm, amp, ring], {ClipNoise.ar(0.003)}.dup, i_freq);

	Out.ar(out, klank);
}).add;
)

// nothing special yet, just using the default set of harmonics.
a = Synth(\help_Klank, [\i_freq, 300]);
b = Synth(\help_Klank, [\i_freq, 400]);
c = Synth(\help_Klank, [\i_freq, 533.33]);
d = Synth(\help_Klank, [\i_freq, 711.11]);

a.free;
b.free;
c.free;
d.free;

a = Synth(\help_Klank, [\i_freq, 500, \harm, [4, 1, 3, 5, 7]]);
a.free;

// set geometric series harmonics
a = Synth(\help_Klank, [\i_freq, 500, \harm,Array.geom(4, 1, 1.61)]);
a.free;

// set harmonics, ring times and amplitudes
(
a = Synth(\help_Klank, [
	\i_freq, 500,
	\harm, [4, 1, 3, 5, 7],
	\ring, Array.fill(4, 0.1), // set shorter ring time
	\amp, Array.fill(4, 0.2) // set louder amps
])
);




// -- overlap texture
(
SynthDef("help-KlankOverlapTexture",
{|out = 0, freqs = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], rings = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], atk = 5, sus = 8, rel = 5, pan = 0|
	var e = EnvGen.kr(Env.linen(atk, sus, rel, 1, 4), doneAction:2);
	var i = Decay.ar(Impulse.ar(Rand(0.8, 2.2)), 0.03, ClipNoise.ar(0.01));
	var z = Klank.ar(
		`[freqs, nil, rings], 	// specs
		i					// input
	);
	Out.ar(out, Pan2.ar(z*e, pan));
}).add;

r = Routine{
	var sustain = 8, transition = 3, overlap = 4;
	var period = transition * 2 + sustain / overlap;
	0.5.wait;			// wait for the synthdef to be sent to the server
	inf.do{
		Synth("help-KlankOverlapTexture", [
			\atk, transition,
			\sus, sustain,
			\rel, transition,
			\pan, 1.0.rand2,
			\freqs, {200.0.rrand(4000)}.dup(12),
			\rings, {0.1.rrand(2)}.dup(12)
		]);
		period.wait;
	}
};
r.play;
)

r.stop;	// stop spawning new synths



// -- frequency and decay scaling
(
SynthDef("help-KlankScaling", {|out = 0, freq = 0, rings = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], pan = 0|
	var e = EnvGen.kr(Env(#[1, 1, 0], #[0.4, 0.01]), doneAction:2);
	var i = Decay.ar(Impulse.ar(0), 0.03, ClipNoise.ar(0.01));
	var z = Klank.ar(
		`[(1..12), nil, rings], 				// specs (partials, amplitudes, ringtimes)
		i, 							// input
		freq, 							// scale to this frequency
		0, 							// frequency offset
		MouseX.kr(0.2, 3)				// scale decay times
	);
	Out.ar(out, Pan2.ar(z*e, pan));
}).add;

r = Routine{
	var sustain = 8, transition = 3;
	var mode = #[0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17, 19, 21, 23, 24];
	0.5.wait;			// wait for the synthdef to be sent to the server
	inf.do{|i|
		Synth("help-KlankScaling", [
			\freq, (72 + (mode @@ i)).midicps,
			\rings, {0.1.rrand(2)}.dup(12)
		]);
		0.2.wait;
	}
};
r.play;
)

r.stop;


// -- overlap texture 2
(
SynthDef("help-KlankOverlapTexture2",
{|out = 0, freqs = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], rings = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], atk = 5, sus = 8, rel = 5, pan = 0|
	var e = EnvGen.kr(Env.linen(atk, sus, rel, 1, 4), doneAction:2);
	var i = BrownNoise.ar(0.0012);
	var z = Klank.ar(
		`[freqs, nil, rings], 	// specs
		i					// input
	);
	Out.ar(out, Pan2.ar(z*e, pan));
}).add;

r = Routine{
	var sustain = 6, transition = 4, overlap = 5;
	var period = transition*2+sustain/overlap;
	0.5.wait;			// wait for the synthdef to be sent to the server
	inf.do {
		Synth("help-KlankOverlapTexture2", [
			\atk, transition,
			\sus, sustain,
			\rel, transition,
			\pan, 1.0.rand2,
			\freqs, {6000.0.linrand+80}.dup(12),
			\rings, {0.1.rrand(3)}.dup(12)
		]);
		period.wait;
	}
};
r.play;
)

r.stop;


// -- overlap texture 3
(
SynthDef("help-KlankOverlapTexture3",
{|out = 0, freqs = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], rings = #[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], pan = 0|
	var e = EnvGen.kr(Env(#[1, 1, 0], #[18, 3]), doneAction:2);
	var i = Decay.ar(Impulse.ar(Rand(0.2, 0.6)), 0.8, ClipNoise.ar(0.001));
	var z = Klank.ar(
		`[freqs, 2, rings], 	// specs
		i					// input
	);
	Out.ar(out, Pan2.ar(z*e, pan));
}).add;

r = Routine{
	0.5.wait;			// wait for the synthdef to be sent to the server
	inf.do {
		Synth("help-KlankOverlapTexture3", [
			\pan, 1.0.rand2,
			\freqs, {12000.0.linrand+80}.dup(12),
			\rings, {3.rrand(10)}.dup(12)
		]);
		3.wait;
	}
};
r.play;
)

r.stop;
::


** class:: Knob
redirect:: implClass
summary:: A rotary controller view
categories:: GUI>Views
related:: Classes/Slider, Classes/Slider2D

DESCRIPTION::

Knob displays a value from 0.0 to 1.0 in rotary fashon, and allows to control it with either circular or linear mouse motion.

It also displays the deviation of the value from either 0.0 or 0.5, which you can choose using link::#-centered::.

To switch between the mouse interaction modes, use link::#-mode::.

The amount by which the value changes at interaction can be fine-tuned using link::#-step::, link::#-keystep::, link::#-shift_scale::, link::#-ctrl_scale::, and link::#-alt_scale::

CLASSMETHODS::

PRIVATE:: key

METHOD:: defaultMode

    The default link::#-mode:: for newly created Knobs.


INSTANCEMETHODS::


SUBSECTION:: Data

METHOD:: value

    The displayed value.

    argument::
        A Number in the range of 0.0 to 1.0.

METHOD:: valueAction

    Sets the value and triggeres link::#-action::.

METHOD:: increment
    Increments the value by link::#-keystep:: multiplied by the argument.

    argument::
        A Number.

METHOD:: decrement
    Decrements the value by link::#-keystep:: multiplied by the argument.

    argument:: zoom
        A Number.


SUBSECTION:: Interaction

METHOD:: mode

    The way value is controlled with respect to mouse movement after clicking on the view:
    list::
    ## code::\round:: - value follows circular movement
    ## code::\horiz:: - value follows linear movement in horizontal direction
    ## code::\vert:: - value follows linear movement in vertical direction
    ::

    Defaults to code::\round::.

    Argument::
        One of the symbols listed above.

METHOD:: keystep

    The amount by which the value is incremented/decremented when pressing a relevant key.

    Defaults to 0.01;

    Argument::
        A Number.

METHOD:: step

    The amount by which the value is incremented/decremented using the mouse in 'horizontal' and 'vertical' link::#-mode#modes::.

    Argument::
        A Number.

METHOD:: shift_scale
    The factor by which link::#-step:: or link::#-keystep:: is multiplied when used at mouse or keyboard interaction while the Shift key is pressed.

    argument::
        A Float.

METHOD:: ctrl_scale
    The factor by which link::#-step:: or link::#-keystep:: is multiplied when used at mouse or keyboard interaction while the Ctrl key is pressed.

    argument::
        A Float.

METHOD:: alt_scale
    The factor by which link::#-step:: or link::#-keystep:: is multiplied when used at mouse or keyboard interaction while the Alt key is pressed.

    argument::
        A Float.



SUBSECTION:: Appearance

METHOD:: centered

    Whether the deviation of value will be displayed in relation to 0.0 or 0.5 (e.g. as in a panning controller);

    Argument::
        A Boolean.

METHOD:: color

    The colors used by the Knob to draw the following elements:

    list::
    ## the main Knob color
    ## the value indicator
    ## the deviation indicator
    ## the background of the deviation indicator
    ::

    Argument::
        An Array of four Colors in the order listed above.


SUBSECTION:: Actions

METHOD:: action
    The action object evaluated whenever the user interacts with the Knob using the mouse or the keyboard.

METHOD:: defaultKeyDownAction

    Implements the default effects of key presses as follows:

    table::
    ## strong::Key::   || strong::Effect::
    ## r               || valueAction_(1.0.rand)
    ## n               || valueAction_(0)
    ## x               || valueAction_(1)
    ## c               || valueAction_(0.5)
    ## ]               || increment
    ## [               || decrement
    ## up arrow        || increment
    ## down arrow      || decrement
    ## right arrow     || increment
    ## left arrow      || decrement
    ::

    See also: link::#-keystep::, link::#-shift_scale::, link::#-ctrl_scale::, link::#-alt_scale::.

SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
    returns::
        The link::#-value::.

METHOD:: defaultCanReceiveDrag
    returns::
        True if the current drag data is a Number.

METHOD:: defaultReceiveDrag
    Sets link::#-valueAction:: to the current drag data.


EXAMPLES::

subsection:: Basic Example

code::
(
var window, size = 32; // try different sizes - from 15 to 200 or more!
window = Window.new("Knob", Rect(640,630,270,70)).front;
k = Knob.new(window, Rect(20, 10, size, size));
k.action_({|v,x,y,m| postf("action func called: %\n", v.value); });
//k.color[1] = Color.gray(alpha:0);
)

k.value
k.value = 0.25
k.valueAction = 0.125

// modes
k.mode = \vert;
k.mode = \horiz;
k.mode = \round; // default

k.visible
k.visible = false
k.visible = true
k.enabled = false
k.enabled_(true)
k.canFocus = false
k.canFocus = true
::


subsection:: Centered Mode

Center mode is useful for pan or eq gain control etc.

code::
(
var window;
window = Window.new("Pan Knob", Rect(640,630,270,70)).front;
k = Knob.new(window, Rect(20,10,36,36));
k.action_({|v,x,y,m| \pan.asSpec.map(v.value).postln; })
//  .mode_(\horiz)
    .centered_(false)
    .value_(\pan.asSpec.unmap(0)); // 0.5
//k.color[1] = Color.gray(alpha:0);
)
k.centered
k.centered = true
k.centered = false
::


subsection:: step

link::#-step:: only affects the 'horiz' and 'vert' modes:

code::
(
var window, midispec;
midispec = [0,127,'linear',1].asSpec;
window = Window.new("step Knob", Rect(640,630,270,70)).front;
k = Knob.new(window, Rect(20,10,32,32));
k.action_({|v,x,y,m| midispec.map(v.value).postln; })
       .value_(midispec.unmap(0));

k.mode = \vert;

)
k.step
k.step = 10/127 // step by 10

k.mode = \horiz;
k.mode = \round;
::


subsection:: mouseOverAction

code::
(
var size = 28;
w = Window.new("Knobs", Rect(250,500,270,70));
w.acceptsMouseOver=true; // must be true in parent window!
w.view.decorator = FlowLayout(w.view.bounds);
h = StaticText(w, 150 @ 10);
w.view.decorator.nextLine;
k = Array(8);
8.do({|item, i|
    var knob;
    knob = Knob.new(w, size @ size)
        .action_({|v,x,y,m| h.string = "val: " ++ v.value.asString; })
        .mouseOverAction_({|v,x,y| h.string = "val: " ++ v.value.asString; });

    k = k.add(knob);
});
w.front
)
k[4].value
::


subsection:: Drag and Drop

code::
(
var w, txt, size = 36;
w = Window.new("Knobs", Rect(400,400,250,100)).front;
w.acceptsMouseOver=true;
w.view.decorator = FlowLayout(w.view.bounds).gap_(10 @ 10).margin_(10 @10);
txt = StaticText(w, 200 @ 14);
w.view.decorator.nextLine;

k = Knob(w, size @ size);
k.action = {arg v,x,y;  v.value.postln; txt.string_("value: " ++ v.value); };
k.mouseOverAction = {|v| txt.string_("value: " ++ v.value); };

j = Knob(w, size @ size);
j.action = {arg v,x,y;  j.value.postln; txt.string_("value: " ++ v.value); };
j.mouseOverAction = { txt.string_("value: " ++ j.value); };

n = NumberBox(w, 100 @ 20);
//n.setProperty(\boxColor,Color.grey(alpha:0.0));
n.value = 0.0;
)

// customize drag and drop methods
k.canReceiveDragHandler
k.canReceiveDragHandler = false; // don't accept drops

k.canReceiveDragHandler = { View.currentDrag.isFloat }; // accept only if drag is float

k.receiveDragHandler = { ("value dropped in: " ++ View.currentDrag).postln }

k.receiveDragHandler = { k.valueAction = View.currentDrag.clip(0.0, 1.0); }

k.beginDragAction = { ("drag out -> " ++ k.value).postln; }

k.beginDragAction = { k.value.asFloat; }
::
** class:: LFClipNoise
summary:: Clipped noise
related:: Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Randomly generates the values -1 or +1 at a rate given by the nearest
integer division of the sample rate by the  code::freq::
argument. It is probably pretty hard on your speakers!


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

(
SynthDef("help-LFClipNoise", { arg out=0;
	Out.ar(out,
		LFClipNoise.ar(1000, 0.25)
	)
}).play;
)

//modulate frequency
(
SynthDef("help-LFClipNoise", { arg out=0;
	Out.ar(out,
		LFClipNoise.ar(XLine.kr(1000, 10000, 10), 0.25)
	)
}).play;
)

//use as frequency control
(
SynthDef("help-LFClipNoise", { arg out=0;
	Out.ar(out,
		SinOsc.ar(
			LFClipNoise.ar(4, 200, 600),
			0, 0.2
		)
	)
}).play;
)

::

** class:: LFCub
summary:: A sine like shape made of two cubic pieces
related:: Classes/LFPar, Classes/LFPulse, Classes/LFSaw, Classes/LFTri
categories::  UGens>Generators>Deterministic


Description::

A sine like shape made of two cubic pieces. Smoother than
link::Classes/LFPar:: .


classmethods::

method::ar, kr

argument::freq
Frequency in Hertz.

argument::iphase

Initial phase offset.


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ LFCub.ar(LFCub.kr(LFCub.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ LFCub.ar(LFCub.kr(0.2, 0, 400,800),0,0.1) }.play
{ LFCub.ar(800,0,0.1) }.play
{ LFCub.ar(XLine.kr(100,8000,30),0,0.1) }.play

//compare:

{ LFPar.ar(LFPar.kr(LFPar.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ LFPar.ar(LFPar.kr(0.2, 0, 400,800),0,0.1) }.play
{ LFPar.ar(800,0,0.1) }.play
{ LFPar.ar(XLine.kr(100,8000,30),0,0.1) }.play


{ SinOsc.ar(SinOsc.kr(SinOsc.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ SinOsc.ar(SinOsc.kr(0.2, 0, 400,800),0,0.1) }.play
{ SinOsc.ar(800,0,0.1) }.play
{ SinOsc.ar(XLine.kr(100,8000,30),0,0.1) }.play

{ LFTri.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ LFTri.ar(LFTri.kr(0.2, 0, 400,800),0,0.1) }.play
{ LFTri.ar(800,0,0.1) }.play
{ LFTri.ar(XLine.kr(100,8000,30),0,0.1) }.play
::

** class:: LFDClipNoise
summary:: Dynamic clipped noise
related:: Classes/LFClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Like link::Classes/LFClipNoise::, it generates the values -1 or +1 at a rate given
by the  code::freq::  argument, with two differences:
list::
## no time quantization
## fast recovery from low freq values footnote::
link::Classes/LFClipNoise:: , as well as  link::Classes/LFNoise0:: ,
link::Classes/LFNoise1::  and  link::Classes/LFNoise2::  quantize to the
nearest integer division of the samplerate, and they poll the
code::freq::  argument only when scheduled; thus they often
seem to hang when freqs get very low.
::
::

If you don't need very high or very low freqs, or use fixed freqs,
link::Classes/LFDClipNoise::  is more efficient.


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
// try wiggling the mouse quickly;
// LFNoise frequently seems stuck, LFDNoise changes smoothly.

{ LFClipNoise.ar(MouseX.kr(0.1, 1000, 1), 0.1)  }.play

{ LFDClipNoise.ar(MouseX.kr(0.1, 1000, 1), 0.1)  }.play

// silent for 2 secs before going up in freq

{ LFClipNoise.ar(XLine.kr(0.5, 10000, 3), 0.1) }.scope;

{ LFDClipNoise.ar(XLine.kr(0.5, 10000, 3), 0.1) }.scope;


// LFNoise quantizes time steps at high freqs, LFDNoise does not:

{ LFClipNoise.ar(XLine.kr(1000, 20000, 10), 0.1) }.scope;

{ LFDClipNoise.ar(XLine.kr(1000, 20000, 10), 0.1) }.scope;
::

** class:: LFDNoise0
summary:: Dynamic step noise
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Like link::Classes/LFNoise0::, it generates random values at a rate
given by the  code::freq::  argument, with two differences:

list::
## no time quantization
## fast recovery from low freq values footnote::
link::Classes/LFNoise0:: ,  link::Classes/LFNoise1::  and
link::Classes/LFNoise2::  quantize to the nearest integer division
of the samplerate, and they poll the  code::freq::
argument only when scheduled; thus they often seem to hang
when freqs get very low.
::
::


If you don't need very high or very low freqs, or use fixed freqs,
link::Classes/LFNoise0::  is more efficient.


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
// try wiggling mouse quickly;
// LFNoise frequently seems stuck, LFDNoise changes smoothly.

{ LFNoise0.ar(MouseX.kr(0.1, 1000, 1), 0.1)  }.play

{ LFDNoise0.ar(MouseX.kr(0.1, 1000, 1), 0.1)  }.play

// silent for 2 secs before going up in freq

{ LFNoise0.ar(XLine.kr(0.5, 10000, 3), 0.1) }.scope;

{ LFDNoise0.ar(XLine.kr(0.5, 10000, 3), 0.1) }.scope;


// LFNoise quantizes time steps at high freqs, LFDNoise does not:

{ LFNoise0.ar(XLine.kr(1000, 20000, 10), 0.1) }.scope;

{ LFDNoise0.ar(XLine.kr(1000, 20000, 10), 0.1) }.scope;

{ LFNoise2.ar(1000, 0.25) }.play;
::

** class:: LFDNoise1
summary:: Dynamic ramp noise
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Like  link::Classes/LFNoise1:: , it generates linearly interpolated
random values at a rate given by the  code::freq::
argument, with two differences:
list::
## no time quantization
## fast recovery from low freq values footnote::
link::Classes/LFNoise0:: ,  link::Classes/LFNoise1::  and
link::Classes/LFNoise2::  quantize to the nearest integer division
of the samplerate, and they poll the  code::freq::
argument only when scheduled; thus they often seem to hang
when freqs get very low.
::
::

If you don't need very high or very low freqs, or use fixed freqs,
link::Classes/LFNoise1::  is more efficient.


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
// try wiggling mouse quickly;
// LFNoise frequently seems stuck, LFDNoise changes smoothly.

{  SinOsc.ar(LFNoise1.ar(MouseX.kr(0.1, 1000, 1), 200, 500), 0, 0.2)  }.play

{  SinOsc.ar(LFDNoise1.ar(MouseX.kr(0.1, 1000, 1), 200, 500), 0, 0.2)  }.play


// LFNoise quantizes time steps at high freqs, LFDNoise does not:

{ LFNoise1.ar(XLine.kr(2000, 20000, 8), 0.1) }.scope;

{ LFDNoise1.ar(XLine.kr(2000, 20000, 8), 0.1) }.scope;
::

** class:: LFDNoise3
summary:: Dynamic cubic noise
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFNoise0, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Similar to  link::Classes/LFNoise2:: , it generates polynomially
interpolated random values at a rate given by the
code::freq::  argument, with 3 differences:
list::
## no time quantization
## fast recovery from low freq values footnote::
link::Classes/LFNoise0:: ,  link::Classes/LFNoise1::  and
link::Classes/LFNoise2::  quantize to the nearest integer division
of the samplerate, and they poll the  code::freq::
argument only when scheduled; thus they often seem to hang
when freqs get very low.
::
## cubic instead of quadratic interpolation
::

If you don't need very high or very low freqs, or use fixed freqs,
link::Classes/LFNoise2::  is more efficient.


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
// try wiggling mouse quickly:
// LFNoise2 overshoots when going from high to low freqs, LFDNoise changes smoothly.

{  SinOsc.ar(LFNoise2.ar(MouseX.kr(0.1, 1000, 1), 200, 500), 0, 0.2)  }.play

{  SinOsc.ar(LFDNoise3.ar(MouseX.kr(0.1, 1000, 1), 200, 500), 0, 0.2)  }.play


// LFNoise quantizes time steps at high freqs, LFDNoise does not:

{ LFNoise2.ar(XLine.kr(2000, 20000, 8), 0.1) }.scope;

{ LFDNoise3.ar(XLine.kr(2000, 20000, 8), 0.1) }.scope;

// use as frequency control
(
{
		SinOsc.ar(
			LFDNoise3.ar(4, 400, 450),
			0, 0.2
		)
}.play;
)
::

** class:: LFGauss
summary:: Gaussian function oscillator
categories:: UGens>Generators>Deterministic

description::
A non-band-limited gaussian function oscillator. Output ranges from strong::minval:: to 1.

LFGauss implements the formula:
code::
f(x) = exp(squared(x - iphase) / (-2.0 * squared(width)))
::
where x is to vary in the range -1 to 1 over the period dur. strong::minval:: is the initial value at -1.

classmethods::
method:: ar, kr

argument:: duration
duration of one full cycle ( for strong::freq:: input: strong::dur = 1 / freq:: )
argument:: width
relative width of the bell. Best to keep below 0.25 when used as envelope. (default: 0.1)
argument:: iphase
initial offset (default: 0)
argument:: loop
if loop is > 0, UGen oscillates. Otherwise it calls doneAction after one cycle (default: 1)
argument:: doneAction
doneAction, which is evaluated after cycle completes (2 frees the synth, default: 0).
See link::Reference/UGen-doneActions:: for more detail.

examples::

subsection:: Some plots

code::
s.boot ;

// a 0.1 second grain
{ LFGauss.ar(0.1, 0.12) }.plot(0.1);

// shifting left
{ LFGauss.ar(0.1, 0.12, -1, loop: 0) }.plot(0.1);

// moving further away from the center
{ LFGauss.ar(0.1, 0.12, 2) }.plot(0.2);

// several grains
{ LFGauss.ar(0.065, 0.12, 0, loop: 1) }.plot(0.3);
::

subsection:: Some calculations

assuming iphase = 0:

strong::minval:: for a given width:
code::minval = exp(-1.0 / (2.0 * squared(width)))::

strong::width:: for a given minval:
code::width = sqrt(-1.0 / log(minval))::

strong::width at half maximum (0.5):::
code::(2 * sqrt(2 * log(2)) * width) = ca. 2.355 * width::

code::
// minval for a width of 0.1:
(exp(1 / (-2.0 * squared(0.1)))) // 2e-22

// maximum width for a beginning at -60dB:
// we want the beginning small enough to avoid clicks
sqrt(-1 / ( 2 * log(-60.dbamp))) // 0.269

// minval for width of 0.25
(exp(1 / (-2.0 * squared(0.25)))).ampdb // -70dB

// maximum is always 1:
{ LFGauss.ar(0.1, XLine.kr(1, 0.03, 1), 0, loop: 1) }.plot(1);

// a gauss curve in sclang:
(0..1000).normalize(-1, 1).collect(_.gaussCurve(1, 0, 0.1)).plot;


// rescale the function to the range 0..1
(
{
var width = XLine.kr(0.04, 1.0, 1);
var min = (exp(1.0 / (-2.0 * squared(width))));
var gauss = LFGauss.ar(0.1, width, loop: 1);
gauss.linlin(min, 1, 0, 1);
}.plot(1)
);

// range does the same implicitly
(
{
var width = XLine.kr(0.04, 1.0, 1);
LFGauss.ar(0.1, width, loop: 1).range(0, 1);
}.plot(1)
);
::

subsection:: Sound examples
code::
// modulating duration
{ LFGauss.ar(XLine.kr(0.1, 0.001, 10), 0.03) * 0.2 }.play;

// modulating width, freq 60 Hz
{ LFGauss.ar(1/60, XLine.kr(0.1, 0.001, 10)) * 0.2 }.play;

// modulating both: x position is frequency, y is width factor.
// note the artefacts due to alisasing at high frequencies
{ LFGauss.ar(MouseX.kr(1/8000, 0.1, 1), MouseY.kr(0.001, 0.1, 1)) * 0.1 }.play;

// LFGauss as amplitude modulator
{ LFGauss.ar(MouseX.kr(1, 0.001, 1), 0.1) * SinOsc.ar(1000) * 0.1 }.play;

// modulate iphase
{ LFGauss.ar(0.001, 0.2, [0, MouseX.kr(-1, 1)]).sum * 0.2 }.scope;

// for very small width we are "approaching" a dirac function
{ LFGauss.ar(0.01, SampleDur.ir * MouseX.kr(10, 3000, 1)) * 0.2 }.play;

// dur and width can be modulated at audio rate
(
{ 	var dur = SinOsc.ar(MouseX.kr(2, 1000, 1) * [1, 1.1]).range(0.0006, 0.01);
	var width = SinOsc.ar(0.5 * [1, 1.1]).range(0.01, 0.3);
	LFGauss.ar(dur, width) * 0.2
}.play
);


// several frequecies and widths combined
(
{
	var mod = LFGauss.ar(MouseX.kr(1, 0.07, 1), 1 * (MouseY.kr(1, 3) ** (-1..-6)));
	var carr = SinOsc.ar(200 * (1.3 ** (0..5)));
	(carr * mod).sum * 0.1
}.play;
)

// test spectrum
(
{
	var son = LeakDC.ar(LFGauss.ar(0.005, 0.2));
	BPF.ar(son * 3, MouseX.kr(60, 2000, 1), 0.05)
}.play;
)
::

subsection:: Gabor Grain
code::
(
var freq = 1000;
var ncycles = 10;
var width = 0.25;
var dur = ncycles / freq;
{

	var env = LFGauss.ar(dur, width, loop: 0, doneAction: 2);
	var son = FSinOsc.ar(freq, 0.5pi, env);
	son
}.plot(dur);
)


(
SynthDef(\gabor, { |out, i_freq = 440, i_sustain = 1, i_pan = 1, i_amp = 0.1, i_width = 0.25 |
	var env = LFGauss.ar(i_sustain, i_width, loop: 0, doneAction: 2);
	var son = FSinOsc.ar(i_freq, 0.5pi, env);
	OffsetOut.ar(out, Pan2.ar(son, i_pan, i_amp));

}).add;
)

// modulating various parameters
(
Pdef(\x,
	Pbind(
		\instrument, \gabor,
		\freq, Pbrown(step:0.01).linexp(0, 1, 100, 14000),
		\dur, Pbrown().linexp(0, 1, 0.004, 0.02),
		\legato, Pbrown(1, 3, 0.1, inf),
		\pan, Pwhite() * Pbrown()
	)
).play
)

// modulating width only
(
Pdef(\x,
	Pbind(
		\instrument, \gabor,
		\freq, 1000,
		\dur, 0.01,
		\width, Pseg(Pseq([0.25, 0.002], inf), 10, \exp),
		\legato, 2
	)
).play
)

// compare with sine grain.
(
SynthDef(\gabor, { |out, i_freq = 440, i_sustain = 1, i_pan = 1, i_amp = 0.1, i_width=0.25 |
	var env = EnvGen.ar(Env.sine(i_sustain * i_width), doneAction: 2);
	var son = FSinOsc.ar(i_freq, 0.5pi, env);
	OffsetOut.ar(out, Pan2.ar(son, i_pan, i_amp));

}).add;
)
::
** class:: LFNoise0
summary:: Step noise
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise1, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Generates random values at a rate given by the nearest integer division
of the sample rate by the  code::freq::  argument.


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ LFNoise0.ar(1000, 0.25) }.play;

// modulate frequency

{ LFNoise0.ar(XLine.kr(1000, 10000, 10), 0.25) }.play;

// as frequency modulator
(
{ SinOsc.ar(
		LFNoise0.ar(4, 400, 450),
		0, 0.2
	)
}.play;
)

// freq is the rate of starting points
{ var freq = 1000; [LFNoise0.ar(freq), Impulse.ar(freq)] }.plot
::

** class:: LFNoise1
summary:: Ramp noise
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise2
categories::  UGens>Generators>Stochastic


Description::

Generates linearly interpolated random values at a rate given by the
nearest integer division of the sample rate by the
code::freq::  argument.


classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ LFNoise1.ar(1000, 0.25) }.play;

// modulate frequency

{ LFNoise1.ar(XLine.kr(1000, 10000, 10), 0.25) }.play;

// as frequency modulator
(
{ SinOsc.ar(
		LFNoise1.ar(4, 400, 450),
		0, 0.2
	)
}.play;
)

// freq is the rate of starting points
{ var freq = 1000; [LFNoise1.ar(freq), Impulse.ar(freq)] }.plot
::

** class:: LFNoise2
summary:: Quadratic noise.
related:: Classes/LFClipNoise, Classes/LFDClipNoise, Classes/LFDNoise0, Classes/LFDNoise1, Classes/LFDNoise3, Classes/LFNoise0, Classes/LFNoise1
categories::  UGens>Generators>Stochastic


Description::

Generates quadratically interpolated random values at a rate given by
the nearest integer division of the sample rate by the
code::freq::  argument.

note::
quadratic interpolation means that the noise values can occasionally extend beyond the normal range of +-1, if the freq varies in certain ways. If this is undesirable then you might like to clip2 the values, or use a linearly-interpolating unit instead.
::

classmethods::

method::ar, kr

argument::freq
Approximate rate at which to generate random values.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ LFNoise2.ar(1000, 0.25) }.play;

// modulate frequency

{ LFNoise2.ar(XLine.kr(1000, 10000, 10), 0.25) }.play;

// as frequency modulator
(
{ SinOsc.ar(
		LFNoise2.ar(4, 400, 450),
		0, 0.2
	)
}.play;
)

// freq is the rate of interpolation points
{ var freq = 1000; [LFNoise2.ar(freq), Impulse.ar(freq)] }.plot
::

** class:: LFPar
summary:: Parabolic oscillator
related:: Classes/LFCub, Classes/LFPulse, Classes/LFSaw, Classes/LFTri
categories::  UGens>Generators>Deterministic


Description::

A sine-like shape made of two parabolas.  It has audible odd harmonics and is non-band-limited.
Output ranges from -1 to +1.

classmethods::

method::ar, kr

argument::freq
Frequency in Hertz.

argument::iphase

Initial phase in cycles ( 0..1 ).


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
// a plot
{ LFPar.ar(Line.kr(100, 800, 0.1)) }.plot(0.1);

// 440 Hz wave
{ LFPar.ar(440) * 0.1 }.play;

// modulating frequency:
{ LFPar.ar(XLine.kr(100, 2000, 10)) * 0.1 }.play;

// amplitude modulation:
{ LFPar.kr(XLine.kr(1, 200, 10)) * SinOsc.ar(440) * 0.1 }.play;

// used as both Oscillator and LFO:
{ LFPar.ar(LFPar.kr(3, 0.3, 200, 400)) * 0.1 }.play;


// more examples:

{ LFPar.ar(LFPar.kr(LFPar.kr(0.2,0,8,10), 0, 400,800),0,0.1) }.play
{ LFPar.ar(LFPar.kr(0.2, 0, 400,800),0,0.1) }.play
{ LFPar.ar(800,0,0.1) }.play
{ LFPar.ar(XLine.kr(100,8000,30),0,0.1) }.play


// compare:

{ LFCub.ar(LFCub.kr(LFCub.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ LFCub.ar(LFCub.kr(0.2, 0, 400,800),0,0.1) }.play
{ LFCub.ar(800,0,0.1) }.play
{ LFCub.ar(XLine.kr(100,8000,30),0,0.1) }.play

{ SinOsc.ar(SinOsc.kr(SinOsc.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ SinOsc.ar(SinOsc.kr(0.2, 0, 400,800),0,0.1) }.play
{ SinOsc.ar(800,0,0.1) }.play
{ SinOsc.ar(XLine.kr(100,8000,30),0,0.1) }.play

{ LFTri.ar(LFTri.kr(LFTri.kr(0.2,0,8,10),0, 400,800),0,0.1) }.play
{ LFTri.ar(LFTri.kr(0.2, 0, 400,800),0,0.1) }.play
{ LFTri.ar(800,0,0.1) }.play
{ LFTri.ar(XLine.kr(100,8000,30),0,0.1) }.play
::

** class::LFPulse
summary::pulse oscillator
categories::UGens>Generators>Deterministic
related::Classes/LFSaw

description::
A non-band-limited pulse oscillator. Outputs a high value of one and a low value of zero.

classmethods::

method::ar, kr

argument::freq
frequency in Hertz

argument::iphase
initial phase offset in cycles ( 0..1 )

argument::width
pulse width duty cycle from zero to one.

argument::mul

argument::add

instancemethods::
private::signalRange

examples::

a plot:
code::
{ LFPulse.ar(Line.kr(100, 800, 0.1)) }.plot(0.1);
::

50 Hz wave:
code::
{ LFPulse.ar(50) * 0.1 }.play;
::

modulating frequency:
code::
{ LFPulse.ar(XLine.kr(1, 200, 10), 0, 0.2, 0.1) }.play;
::

amplitude modulation:
code::
{ LFPulse.kr(XLine.kr(1, 200, 10), 0, 0.2) * SinOsc.ar(440) * 0.1 }.play;
::

used as both Oscillator and LFO:
code::
{ LFPulse.ar(LFPulse.kr(3, 0, 0.3, 200, 200), 0, 0.2, 0.1) }.play;
::

scope:
code::
{ LFPulse.ar(500, 0, MouseX.kr, 0.5) }.scope;
::

compare with band limited Pulse UGen:
code::
(
{
    [
        Pulse.ar(100, 0.3, 0.5),
        LFPulse.ar(100, 0, 0.3, 0.5)
    ] * 0.2
}.scope(bufsize: 44100, zoom: 5)
)
::

** class:: LFSaw
summary:: Sawtooth oscillator
related:: Classes/LFCub, Classes/LFPar, Classes/LFPulse, Classes/LFTri, Classes/Saw
categories::  UGens>Generators>Deterministic


Description::

A non-band-limited sawtooth oscillator. Output ranges from -1 to +1.


classmethods::

method::ar, kr

argument::freq
Frequency in Hertz.

argument::iphase

Initial phase offset. For efficiency reasons this is a value
ranging from 0 to 2.


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
{ LFSaw.ar(500, 1, 0.1) }.play

// used as both Oscillator and LFO:
{ LFSaw.ar(LFSaw.kr(4, 0, 200, 400), 0, 0.1) }.play
::

** class:: LFTri
summary:: Triangle oscillator
related:: Classes/LFCub, Classes/LFPar, Classes/LFPulse, Classes/LFSaw
categories::  UGens>Generators>Deterministic


Description::

A non-band-limited triangle oscillator. Output ranges from -1 to +1.


classmethods::

method::ar, kr

argument::freq
Frequency in Hertz.

argument::iphase

Initial phase offset. For efficiency reasons this is a value
ranging from 0 to 4.


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
// plot:
{ LFTri.ar(40) }.plot(0.1);
{ LFTri.ar(XLine.kr(1, 800, 0.1)) }.plot(0.1);

{ LFTri.ar(500, 0, 0.1) }.play

// used as both Oscillator and LFO:
{ LFTri.ar(LFTri.kr(4, 0, 200, 400), 0, 0.1) }.play

// phase. compare
{ LFTri.ar(LFTri.kr(0.1, iphase: 0) * 200 + 400, 0, 0.1) }.play
{ LFTri.ar(LFTri.kr(0.1, iphase: 1) * 200 + 400, 0, 0.1) }.play
{ LFTri.ar(LFTri.kr(0.1, iphase: 2) * 200 + 400, 0, 0.1) }.play
{ LFTri.ar(LFTri.kr(0.1, iphase: 3) * 200 + 400, 0, 0.1) }.play

// together
{ LFTri.ar(LFTri.kr(0.05, iphase: (0..3)) * 200 + 400, 0, 0.1).sum }.play
::

** class:: LID
summary:: Linux Input Device
categories:: Platform>Linux, External Control>HID
related:: Classes/GeneralHID, Classes/HIDDeviceService

description::
This class provides a way to access devices in the linux input
layer, which supports many input devices (mouse, keyboard,
joystick, gamepad, tablet) and busses (serial, PS/2, USB).

See link::#examples:: below for documentation-by-example.

note::
It is advised to use link::Classes/GeneralHID:: instead, which wraps the link::Classes/HIDDeviceService:: functionality, and produces crossplatform compatible code.
::

examples::
subsection:: Opening a device

Input devices are accessed through device nodes, typically
/dev/input/event[0-9]. When using a userspace daemon like udev,
meaningful names can be assigned to devices.

raw device name:
code::
d = LID("/dev/input/event4");
::

symbolic device name
code::
d = LID("/dev/input/trackball");
::

device name relative to LID.deviceRoot
code::
d = LID("gamepad");
::

build a list of the available devices:
code::
LID.buildDeviceList
::
buildDeviceList builds a table of the devices found in LID.deviceRoot+"/event", trying to open all that it finds, looking up its name and closing them again. The result is returned and can later be accessed by LID.deviceList.
You can query another name than "/event" by passing an argument. (the search will be: LID.deviceRoot++"/"++name++"*")
code::
LID.buildDeviceList( "mouse" );
::
Note:: this is likely to give the info that the devices could not be opened, as "mouse" uses another interface (you can of course access mice via the "event" interface) ::

Note:: if you cannot open the devices at all, please look in the helpfile for: Linux_udev_setup ::

subsection:: Querying device information
code::
d.info;
d.info.name;
d.info.vendor.asHexString(4);
d.info.product.asHexString(4);
::

subsection:: Querying device capabilities
Device capabilities are reported as event type and event code mappings. Event type and event code constants can be found in /usr/include/linux/input.h
code::
d.caps;
d.dumpCaps;
::

subsection:: Event actions (raw events)
The device's 'action' instance variable can be used for event notifications. it is passed the event type, code and current value.
code::
(
d.action = { | evtType, evtCode, evtValue |
	[evtType.asHexString(4), evtCode.asHexString(4), evtValue].postln
}
)

d.action = nil;
::
If a device is detached LID will detect this, and close the device. It will execute a closeAction, which can be defined by the user:
code::
d.closeAction = { "device was detached".postln; };
::

subsection:: Event actions (raw slot events)

When 'action' is nil, actions can be bound to specific events.
code::
(
d.slot(0x0001, 0x0120).action = { | slot |
	[slot.type.asHexString(4), slot.code.asHexString(4), slot.rawValue].postln;
}
)
::
Relative slots can have deltaActions:
code::
d.slot(0x0002, 0x0001).deltaAction = { | slot |
	[slot.type.asHexString(4), slot.code.asHexString(4), slot.delta].postln;
}
)
::

subsection:: Device specs
Device specs are mappings between event codes and symbolic control
names. New specs can be added to LID.specs via LID>>*register.

code::
// Add a mouse device spec for a Logitech trackball
LID.register('Logitech Trackball', LID.mouseDeviceSpec);

// Add a custom device spec for a Logitech gamepad
(
LID.register('Logitech WingMan RumblePad', (
	// key
	rumble: #[0x0001, 0x0102],	// rumble (toggles ff)
	mode: #[0x0001, 0x0103],	// mode (switches h and l)
	a: #[0x0001, 0x0120],		// button a
	b: #[0x0001, 0x0121],		// button b
	c: #[0x0001, 0x0122],		// button c
	x: #[0x0001, 0x0123],		// button x
	y: #[0x0001, 0x0124],		// button y
	z: #[0x0001, 0x0125],		// button z
	l: #[0x0001, 0x0126],		// left front button
	r: #[0x0001, 0x0127],		// right front button
	s: #[0x0001, 0x0128],		// button s
	// abs
	lx: #[0x0003, 0x0000],		// left joystick x
	ly: #[0x0003, 0x0001],		// left joystick y
	rx: #[0x0003, 0x0005],		// right joystick x
	ry: #[0x0003, 0x0006],		// right joystick y
	hx: #[0x0003, 0x0010],		// hat x
	hy: #[0x0003, 0x0011],		// hat y
	slider: #[0x0003, 0x0002]	// slider
));
)
::

subsection:: Event actions (symbolic slot events)

When a device spec was registered for a given device name, slot
actions can be assigned by using the symbolic control name.
code::
d[\a].action = { | slot | [\a, slot.value].postln };
::
There is also a default keyboard device spec.
code::
(
LID.keyboardDeviceSpec.keys.do { | key |
	d[key].action = { | slot | [key, slot.value].postln }
}
)
::

subsection:: LED's
some devices have LEDs which can be turned on and off. These show up
with d.caps as events of type 0x0011
code::
d = LID("/dev/input/event0");
// LED's can be turned on:
d.setLEDState( 0x0, 1 )
// (LED 0x0 should be available on any keyboard)
// and off:
d.setLEDState( 0x0, 0 )
d.close;

// setLEDState( evtCode, evtValue ): value should be 1 or 0
::

subsection:: Grabbing devices
Given proper permissions, devices can be grabbed to prevent use in
other applications (including X). Be careful when grabbing mouse or
keyboard!
code::
d[\b].action = { d.ungrab };
d.grab;

d.isGrabbed;
::

subsection:: Closing devices
code::
d.close;
LID.closeAll;
::

** class:: LPF
summary:: 2nd order Butterworth lowpass filter
related:: Classes/BPF, Classes/BRF, Classes/HPF
categories::  UGens>Filters>Linear


Description::

A second order low pass filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Cutoff frequency in Hertz.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
{ LPF.ar(Saw.ar(200,0.1), SinOsc.kr(XLine.kr(0.7,300,20),0,3600,4000)) }.play;

// kr:
(
{ var ctl = LPF.kr(LFPulse.kr(8), SinOsc.kr(XLine.kr(1, 30, 5)) + 2);
	SinOsc.ar(ctl * 200 + 400)
}.play;
)

(
{ var ctl = LPF.kr(LFPulse.kr(8), MouseX.kr(2, 50, 1));
	SinOsc.ar(ctl * 200 + 400)
}.play;
)
::

** class:: LPZ1
summary:: Two point average filter
related:: Classes/HPZ1
categories::  UGens>Filters>Linear


Description::

A special case fixed filter. Implements the formula:
code::
out(i) = 0.5 * (in(i) + in(i-1))
::
which is a two point averager.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
//Compare:

{ WhiteNoise.ar(0.25) }.play;

{ LPZ1.ar(WhiteNoise.ar(0.25)) }.play;
::

** class:: LPZ2
summary:: Two zero fixed lowpass
related:: Classes/BPZ2, Classes/BRZ2, Classes/HPZ2
categories::  UGens>Filters>Linear


Description::

A special case fixed filter. Implements the formula:
code::
out(i) = 0.25 * (in(i) + (2 * in(i - 1)) + in(i - 2)).
::


classmethods::

method::ar, kr

argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
//Compare:

{ WhiteNoise.ar(0.25) }.play;

{ LPZ2.ar(WhiteNoise.ar(0.25)) }.play;
::

** class:: Lag
summary:: Exponential lag
related:: Classes/Lag2, Classes/Lag3, Classes/VarLag, Classes/LagUD
categories::  UGens>Filters>Linear


Description::
This is essentially the same as  link::Classes/OnePole::  except that
instead of supplying the coefficient directly, it is calculated from a 60
dB lag time. This is the time required for the filter to converge to
within 0.01% of a value. This is useful for smoothing out control
signals.

For linear and other alternatives, see link::Classes/VarLag::.

classmethods::

method::ar, kr

argument::in

The input signal.


argument::lagTime

60 dB lag time in seconds.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
(
// used to lag pitch
{
    SinOsc.ar(                              // sine wave
        Lag.kr(                             // lag the modulator
            LFPulse.kr(4, 0, 0.5, 50, 400), // frequency modulator
            Line.kr(0, 1, 15)               // modulate lag time
        ),
        0,                                  // phase
        0.3                                 // sine amplitude
    )
}.play
)
::

** class:: Lag2
summary:: Exponential lag
related:: Classes/Lag, Classes/Lag3, Classes/Ramp, Classes/Lag2UD
categories::  UGens>Filters>Linear


Description::

Lag2 is equivalent to code:: Lag.kr(Lag.kr(in, time), time) ::, thus resulting in a
smoother transition. This saves on CPU as you only have to calculate the
decay factor once instead of twice. See  link::Classes/Lag::  for more
details.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::lagTime

60 dB lag time in seconds.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
(
// used to lag pitch
{
	SinOsc.ar(		// sine wave
		Lag2.kr(			// lag the modulator
			LFPulse.kr(4, 0, 0.5, 50, 400),	// frequency modulator
			Line.kr(0, 1, 15)				// modulate lag time
		),
		0,	// phase
		0.3	// sine amplitude
	)
}.play
)
::

** class:: Lag2UD
summary:: Exponential lag
categories:: UGens>Filters
related:: Classes/Lag, Classes/Lag2, Classes/Lag3, Classes/LagUD, Classes/Lag3UD

description::
Lag2 is equivalent to Lag.kr(Lag.kr(in, time), time), thus resulting in a smoother transition. This saves on CPU as you only have to calculate the decay factor once instead of twice. See link::Classes/Lag:: for more details.

classmethods::
method:: ar, kr

argument:: in
input signal.
argument:: lagTimeU
60 dB lag time in seconds for the upgoing signal.
argument:: lagTimeD
60 dB lag time in seconds for the downgoing signal.

examples::
code::
(
// used to lag pitch
       SynthDef( \lag2ud_help,

	{ arg freq=300,lagup=1, lagdown=5;
		Out.ar( 0,
			SinOsc.ar( // sine wave
				Lag2UD.kr( // lag the frequency
					freq,
					lagup,
					lagdown
				),
				0, // phase
				0.2 // sine amplitude
			)
		);
	}).send(s);
)

x = Synth.new( \lag2ud_help ); // create the synth

x.set( \freq, 500 ); // set the frequency to a higher value (takes 1 second)
x.set( \freq, 100 ); // set the frequency to a lower value (takes 5 seconds)
x.free;
::
** class:: Lag3
summary:: Exponential lag
related:: Classes/Lag, Classes/Lag2, Classes/Ramp, Classes/Lag3UD
categories::  UGens>Filters>Linear


Description::

Lag3 is equivalent to code:: Lag.kr(Lag.kr(Lag.kr(in, time), time), time) ::, thus
resulting in a smoother transition. This saves on CPU as you only have to
calculate the decay factor once instead of three times. See
link::Classes/Lag::  for more details.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::lagTime

60 dB lag time in seconds.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
(
// used to lag pitch
{
	SinOsc.ar(		// sine wave
		Lag3.kr(			// lag the modulator
			LFPulse.kr(4, 0, 0.5, 50, 400),	// frequency modulator
			Line.kr(0, 1, 15)				// modulate lag time
		),
		0,	// phase
		0.3	// sine amplitude
	)
}.play
)
::

** class:: Lag3UD
summary:: Exponential lag
categories:: UGens>Filters
related:: Classes/Lag, Classes/Lag2, Classes/Lag3, Classes/LagUD, Classes/Lag2UD

description::
Lag3UD is equivalent to LagUD.kr(LagUD.kr(LagUD.kr(in, timeU, timeD), timeU, timeD), timeU, timeD), thus resulting in a smoother transition. This saves on CPU as you only have to calculate the decay factor once instead of three times. See link::Classes/LagUD:: for more details.

classmethods::
method:: ar, kr

argument:: in
input signal.
argument:: lagTimeU
60 dB lag time in seconds for the upgoing signal.
argument:: lagTimeD
60 dB lag time in seconds for the downgoing signal.

examples::
code::
(
// used to lag pitch
       SynthDef( \lag3ud_help,

	{ arg freq=300,lagup=1, lagdown=5;
		Out.ar( 0,
			SinOsc.ar( // sine wave
				Lag3UD.kr( // lag the frequency
					freq,
					lagup,
					lagdown
				),
				0, // phase
				0.2 // sine amplitude
			)
		);
	}).send(s);
)

x = Synth.new( \lag3ud_help ); // create the synth

x.set( \freq, 500 ); // set the frequency to a higher value (takes 1 second)
x.set( \freq, 100 ); // set the frequency to a lower value (takes 5 seconds)
x.free;
::
** class:: LagControl
summary:: Lagged control input
related:: Classes/Control, Classes/TrigControl
categories::  UGens>Synth control


Description::

code::Control:: ugen with fixed-time lags.

classmethods::

private::ir

method::kr

argument::values

Initial value (code::Float:: or code::Array:: of Floats).

argument::lags

Lag times (code::Float:: or code::Array:: of Floats).


** class:: LagIn
summary:: Read a control signal from a bus with a lag
related:: Classes/In, Classes/InFeedback
categories::  UGens>InOut


Description::

Read a control signal from a bus with a lag.


classmethods::

method::kr

argument::bus

The index of the bus to read in from.


argument::numChannels

The number of channels (i.e. adjacent buses) to read in. You
cannot modulate this number.


argument::lag

Lag factor.


** class:: LagUD
summary:: Exponential lag
categories:: UGens>Filters
related:: Classes/Lag, Classes/Lag2, Classes/Lag3, Classes/Lag2UD, Classes/Lag3UD

description::
This is essentially the same as link::Classes/Lag:: except that you can supply a different 60 dB time for when the signal goes up, from when the signal goes down. This is useful for smoothing out control signals, where "fade in" should be different from "fade out".

classmethods::
method:: ar, kr

argument:: in
input signal.
argument:: lagTimeU
60 dB lag time in seconds for the upgoing signal.
argument:: lagTimeD
60 dB lag time in seconds for the downgoing signal.
argument:: mul
argument:: add

examples::
code::
( // used to lag pitch
SynthDef( \lagud_help,
{	arg freq=300,lagup=1, lagdown=5;
	Out.ar( 0,
		SinOsc.ar( // sine wave
			LagUD.kr( // lag the frequency
				freq,
				lagup,
				lagdown
			),
			0, // phase
			0.2 // sine amplitude
		)
	);
}).send(s);
)
x = Synth.new( \lagud_help ); // create the synth
x.set( \freq, 500 ); // set the frequency to a higher value (takes 1 second)
x.set( \freq, 100 ); // set the frequency to a lower value (takes 5 seconds)
x.free;
::
** CLASS:: LanguageConfig
summary:: Access and modify interpreter configuration
categories:: Language

DESCRIPTION::
The LanguageConfig class provides access to the interpreter configuration.


section:: Configuration File Format
The configuration file is stored in YAML format, which contains one dictionary. The semantics of the dictionary is listed in
the following table:

definitionList::
## teletype::includePaths:: || List of class library paths.
## teletype::excludePaths:: || List of paths to exclude from the class library files (overrides teletype::includePaths::).
## teletype::postInlineWarnings:: || Boolean flag to post warnings about missing inline opportunities.
::

CLASSMETHODS::

METHOD:: store
Store the current configuration to file.

argument:: file
Configuration file to store. If the value is code::nil:: it defaults to code::Platform.userConfigDir +/+ "sclang_conf.yaml"::

subsection:: Library Path Handling

The language configuration mechanism provides a way to add or exclude specific paths for the class library.

note::Changes to the class library paths won't have any effect before the configuration file is stored and the class library is recompiled.::

METHOD:: includePaths
Return the class library include paths.

METHOD:: addIncludePath
Add new class library include path.

METHOD:: removeIncludePath
Remove path from class library include paths.

METHOD:: excludePaths
Return the class library exclude paths.

METHOD:: addExcludePath
Add new class library exclude path.

METHOD:: removeExcludePath
Remove path from class library exclude paths.

subsection:: Compiler Warnings

METHOD:: postInlineWarnings
Get or set the compiler flag, whether warnings should be posted if a FunctionDef cannot be inlined.
** class:: LastValue
summary:: Output the last value before the input changed
related:: Classes/LeastChange, Classes/MostChange
categories::  UGens>Triggers


Description::

Output the last value before the input changed more than a threshhold.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::diff

Difference threshhold.


Examples::

code::
d = { arg freq=440; SinOsc.ar(LastValue.ar(freq, 20), 0, 0.2) }.play;

d.set(\freq, 400);
d.set(\freq, 200);
d.set(\freq, 670);
d.set(\freq, 680);
d.set(\freq, 695);
d.free;
::

Return the difference between currrent and the last changed:
code::
(
d = { arg out=0, val=1;
	SinOsc.ar(
			abs(val - LastValue.kr(val)) * 400 + 200,
			0, 0.2
	)
}.play;
)

d.set(\val, 3);
d.set(\val, 2);
d.set(\val, 0.2);
d.set(\val, 1);
d.set(\val, 2);
d.free;
::

** class:: Latch
summary:: Sample and hold
related:: Classes/Gate
categories::  UGens>Triggers

Description::
Holds input signal value when triggered.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::trig

Trigger. Trigger can be any signal. A trigger happens when the
signal changes from non-positive to positive.


Examples::

code::
{ Blip.ar(Latch.ar(WhiteNoise.ar, Impulse.ar(9)) * 400 + 500, 4, 0.2) }.play;
::

The above is just meant as example. LFNoise0 is a faster way to generate random steps:
code::
{ Blip.ar(LFNoise0.kr(9, 400 ,500), 4, 0.2) }.play;
::

** class:: LatoocarfianC
summary:: Latoocarfian chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/LatoocarfianN, Classes/LatoocarfianL

description::
A cubic-interpolating sound generator based on a function given in Clifford Pickover's book Chaos In Wonderland, pg 26. The function is:

code::
	x[n+1] = sin(b * y[n]) + c * sin(b * x[n])
	y[n+1] = sin(a * y[n]) + d * sin(a * x[n])
::
warning:: revise formulae conversion to c like code ::

According to Pickover, parameters code::a:: and code::b:: should be in the range from -3 to +3, and parameters code::c:: and code::d:: should be in the range from 0.5 to 1.5. The function can, depending on the parameters given, give continuous chaotic output, converge to a single value (silence) or oscillate in a cycle (tone).

note::This UGen is experimental and not optimized currently, so is rather hoggish of CPU.::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: c
Equation variable
argument:: d
Equation variable
argument:: xi
Initial value of x
argument:: yi
Initial value of y

examples::
code::
// default initial params
{ LatoocarfianC.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);
::

code::
// randomly modulate all params
(
{ LatoocarfianC.ar(
	SampleRate.ir/4,
	LFNoise2.kr(2,1.5,1.5),
	LFNoise2.kr(2,1.5,1.5),
	LFNoise2.kr(2,0.5,1.5),
	LFNoise2.kr(2,0.5,1.5)
) * 0.2 }.play(s);
)
::
** class:: LatoocarfianL
summary:: Latoocarfian chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/LatoocarfianC, Classes/LatoocarfianN

description::
A linear-interpolating sound generator based on a function given in Clifford Pickover's book Chaos In Wonderland, pg 26. The function is:

code::
	x[n+1] = sin(b * y[n]) + c * sin(b * x[n])
	y[n+1] = sin(a * y[n]) + d * sin(a * x[n])
::
warning:: revise formulae conversion to c like code ::

According to Pickover, parameters code::a:: and code::b:: should be in the range from -3 to +3, and parameters code::c:: and code::d:: should be in the range from 0.5 to 1.5. The function can, depending on the parameters given, give continuous chaotic output, converge to a single value (silence) or oscillate in a cycle (tone).

note::This UGen is experimental and not optimized currently, so is rather hoggish of CPU.::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: c
Equation variable
argument:: d
Equation variable
argument:: xi
Initial value of x
argument:: yi
Initial value of y

examples::
code::
// default initial params
{ LatoocarfianL.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);
::

code::
// randomly modulate all params
(
{ LatoocarfianL.ar(
	SampleRate.ir/4,
	LFNoise2.kr(2,1.5,1.5),
	LFNoise2.kr(2,1.5,1.5),
	LFNoise2.kr(2,0.5,1.5),
	LFNoise2.kr(2,0.5,1.5)
) * 0.2 }.play(s);
)
::
** class:: LatoocarfianN
summary:: Latoocarfian chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/LatoocarfianL, Classes/LatoocarfianC

description::
A non-interpolating sound generator based on a function given in Clifford Pickover's book Chaos In Wonderland, pg 26. The function is:

code::
	x[n+1] = sin(b * y[n]) + c * sin(b * x[n])
	y[n+1] = sin(a * y[n]) + d * sin(a * x[n])
::
warning:: revise formulae conversion to c like code ::

According to Pickover, parameters code::a:: and code::b:: should be in the range from -3 to +3, and parameters code::c:: and code::d:: should be in the range from 0.5 to 1.5. The function can, depending on the parameters given, give continuous chaotic output, converge to a single value (silence) or oscillate in a cycle (tone).

note::This UGen is experimental and not optimized currently, so is rather hoggish of CPU.::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: c
Equation variable
argument:: d
Equation variable
argument:: xi
Initial value of x
argument:: yi
Initial value of y
argument:: mul
argument:: add

examples::
code::
// default initial params
{ LatoocarfianN.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);
::

code::
// randomly modulate all params
(
{ LatoocarfianN.ar(
	SampleRate.ir/4,
	LFNoise2.kr(2,1.5,1.5),
	LFNoise2.kr(2,1.5,1.5),
	LFNoise2.kr(2,0.5,1.5),
	LFNoise2.kr(2,0.5,1.5)
) * 0.2 }.play(s);
)
::
** class:: LazyEnvir
summary:: lazy environment
categories:: Libraries>JITLib>Environments
related:: Classes/Environment, Classes/EnvironmentRedirect, Classes/ProxySpace, Overviews/JITLib

description::
Environment with deferred evaluation and default values.

Consequently, calculations can be done with nonexisting objects which can then be assigned later.
Per default, a LazyEnvir returns instances of link::Classes/Maybe::. See also link::Classes/Fdef::.

InstanceMethods::

method::put
sets the value of the reference at key.

method::at
returns a reference to the object at key.

Examples::

code::
l = LazyEnvir.push;

// default objects are created on access
~a;
~a.value; // defaults to 1

// operations on placeholders
(
~c = ~a + ~b;

~c.value;
)


// variables can be assigned later
(
~a = 800;
~b = { 1.0.rand };

~c.value;
)


// variables can be exchanged later
(
~b = { 1000.rand };
~c.value;
)


// making pattern space using LazyEnvir

a = LazyEnvir.new;
a.proxyClass=\PatternProxy;

a.push;

~x = Pseq([1, 2, 30], 1);
~y = Pseq([~x], inf);

z = ~y.asStream;

z.next;
z.next;
z.next;
~x = Pseq([100, 2, 300], 1);
z.next;
z.next;
z.next;

a.pop;
::
** class:: LeakDC
summary:: Remove DC
related:: Classes/DC
categories::  UGens>Filters>Linear


Description::

This filter removes DC offset from a signal.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::coef

Leak coefficient.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
(
{
	var a;
	a = LFPulse.ar(800, 0.5, 0.5, 0.5);
	[a, LeakDC.ar(a, 0.995)]
}.scope(bufsize: 22050)
)
::

** class:: LeastChange
summary:: Output least changed
related:: Classes/MostChange, Classes/LastValue
categories::  UGens>Maths


Description::

Output the input that changed least.


classmethods::

method::ar, kr

argument::a

Input signal A.


argument::b

Input signal B.

examples::

code::
(
d = { arg amp=1.0;
	var in1, in2;
	in1 = LFNoise0.ar(800, amp);
	in2 = SinOsc.ar(800);
	LeastChange.ar(in1, in2) * 0.1;
}.play;
)

d.set(\amp, 0.1);
d.set(\amp, 0);
d.set(\amp, 3);
d.free;
::

the control that changed least is used as output:

code::
(
d = { arg freq=440;
	var internalFreq;
	internalFreq = LFNoise0.ar(0.3, 300, 800);
	SinOsc.ar(
		LeastChange.kr(freq, internalFreq) // two sources of change: one external, one internal
	) * 0.1
}.play
);

d.set(\freq, 800);
d.set(\freq, 900);
d.free;
::

** CLASS:: LevelIndicator
redirect:: implClass
summary:: a level indicator GUI widget
categories:: GUI>Views
related:: Classes/RangeSlider

DESCRIPTION::
A level indicator view, suitable for use as a level or peak meter, etc.


CLASSMETHODS::
private::key

INSTANCEMETHODS::
private::valueAction

METHOD:: value
Get or set the current level of the view.

argument:: val
A link::Classes/Float:: between 0 and 1.

returns:: A link::Classes/Float::

METHOD:: warning
Set the warning threshold. Styles 0 and 2 (see link::#-style::) implement a warning display. If link::#-critical:: is > warning the view will turn yellow if link::#-value:: is > code::val::. If critical is <= warning the view will turn yellow if value is <= to code::val::. If link::#-drawsPeak:: is true warning will be displayed based on link::#-peakLevel:: rather than value.

argument:: val
A link::Classes/Float::.

code::(
w = Window.new.front;
a = LevelIndicator(w, Rect(10, 10, 20, 160));
a.value = 0.5;
)
a.warning = 0.6; a.critical = 0.9;
a.value = 0.7;
::

METHOD:: critical
Set the warning threshold. Styles 0 and 2 (see link::#-style::) implement a critical display. If critical is > link::#-warning:: the view will turn red if link::#-value:: is > code::val::. If critical is <= warning the view will turn yellow if value is <= to code::val::. If link::#-drawsPeak:: is true critical will be displayed based on link::#-peakLevel:: rather than value.

argument:: val
A link::Classes/Float::.

code::(
w = Window.new.front;
a = LevelIndicator(w, Rect(10, 10, 20, 160));
a.style = 2;
a.numSteps = 10;
a.value = 0.5;
)
a.warning = 0.6; a.critical = 0.9;
a.value = 1;
::

METHOD:: style
note:: Not yet implemented in Qt GUI ::
Sets the style of the view.

argument:: val
An link::Classes/Integer:: from 0 to 3. 0 = colored bar; 1 = graduated black lines; 2 = LED style (see link::#-numSteps::); 3 = LED style with custom image. (See link::#-image::.)

code::(
w = Window.new.front;
w.addFlowLayout;
4.do({|i|
	a = LevelIndicator(w, Rect(0, 0, 20, 200));
	a.style = i;
	a.numSteps = 10;
	a.value = 0.5;
});
)
::

METHOD:: numSteps
The number of steps used in styles 2 and 3. (See link::#-style::.)

argument:: val
An positive link::Classes/Integer::.

code::(
w = Window.new.front;
a = LevelIndicator(w, Rect(10, 10, 200, 20));
a.style = 2;
a.value = 1;
)
a.numSteps = 10;
a.numSteps = 20;
::

METHOD:: image
note:: Not yet implemented in Qt GUI ::
Sets the image used in style 3. See below for an example.

argument:: image
An link::Classes/Image::. The default image is the SC cube.

METHOD:: numTicks
The number of ticks to display in the view's scale.

argument:: number
An link::Classes/Integer:: >= 0.

code::(
w = Window.new.front;
w.view.background = Color.black;
a = LevelIndicator(w, Rect(10, 10, 300, 30));
a.numTicks = 11;
a.value = 0.5;
)
::

METHOD:: numMajorTicks
The number of ticks in the view's scale which will be large sized.

argument:: number
An link::Classes/Integer:: >= 0.

code::(
w = Window.new.front;
w.view.background = Color.black;
a = LevelIndicator(w, Rect(10, 10, 300, 30));
a.numTicks = 11;
a.numMajorTicks = 3;
a.value = 0.5;
)
::

METHOD:: drawsPeak
Determines whether the view draws a separate peak display. This can be useful for displaying both peak and RMS values. If drawsPeak is true link::#-warning:: and link::#-critical:: will be displayed based on link::#-peakLevel:: rather than value in link::#-style#styles:: 0 and 2.

argument:: bool
A link::Classes/Boolean::. By default the peak is not drawn.

code::(
w = Window.new.front;
a = LevelIndicator(w, Rect(10, 10, 300, 30));
a.drawsPeak = true;
a.style = 1;
a.value = 0.5;
a.peakLevel = 0.6;
)
::

METHOD:: peakLevel
Sets the level of the peak display. (See link::#-drawsPeak::.)

argument:: val
A link::Classes/Float::.

code::(
w = Window.new.front;
a = LevelIndicator(w, Rect(10, 10, 20, 160));
a.drawsPeak = true;
a.peakLevel = 0.6)
)
::



EXAMPLES::

code::
s.boot;
GUI.cocoa; // just to be sure

// something to meter
(
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
x = { var colum, noise, imp, delimp, mul = 1;
	imp = Impulse.kr(10);
	delimp = Delay1.kr(imp);
	colum = PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 1) * mul;
	// measure rms and Peak
	SendReply.kr(imp, '/levels', [Amplitude.kr(colum), K2A.ar(Peak.ar(colum, delimp).lag(0, 3))]);
	colum;
}.play;
)

// a window and responder
// default style is coloured / solid
(
w = Window.new.front;
a = LevelIndicator(w, Rect(10, 10, 20, 160));
o = OSCFunc({arg msg;
	{
		a.value = msg[3].ampdb.linlin(-40, 0, 0, 1);
		a.peakLevel = msg[4].ampdb.linlin(-40, 0, 0, 1);
	}.defer;
}, '/levels', s.addr);
w.onClose = {o.free; x.free};
)

// styles 0 and 2 support warning and critical levels
(
a.warning = -6.dbamp;
a.critical = -3.dbamp;
)

// optionally show peak level
(
a.warning = 0;
a.critical = 0;
a.drawsPeak = true;
)

// style 1 is black bars
a.style = 1

// looks good with a background
a.background = Gradient(Color.red, Color.green, \v);

// all styles can have ticks
(
a.background = Color.clear;
a.numTicks = 11; // includes 0;
a.numMajorTicks = 3;
)

// style 2 is LED
(
a.drawsPeak = false;
a.style = 2;
a.numSteps = 10;
a.numTicks = 0;
)

// style 3 is as 2, but with images
a.style = 3; // use default image

// make a custom image
(
j = Image.new(20,20);
j.draw({ arg image;
var lozenge;
lozenge = Rect(3, 3, 16, 16);
Pen.addOval(lozenge);
Pen.fillAxialGradient(1@1, 19@19, Color.new255(255, 165, 0), Color.new255(238, 232, 170));
Pen.width = 1;
Pen.strokeColor = Color.blue;
Pen.strokeOval(lozenge);
});
a.image = j;
)

// be inspired
j = Image.openURL("http://bit.ly/uSMWwp");

(
a.bounds = Rect(10, 10, 380, 80);
a.numSteps = 5;
a.image = j;
)

::
** CLASS::Library
summary::keeping objects in a central place
related::Classes/Archive, Classes/LibraryBase
categories:: Collections

DESCRIPTION::
Library is a global MultiLevelIdentityDictionary.
The Library can be used as a place to store data that you want globally accesible. It is an alternative to using class variables. It is a nice place to store menus, annotations, and commonly reusable functions.

CLASSMETHODS::

private::initClass

method::postTree
Post a formatted description of the entire library.
code::
Library.postTree;
::

method::put
The last argument to put is the object being inserted:
code::
Library.put(\multi, \level, \addressing, \system, "i'm the thing you are putting in here");
Library.at(\multi, \level, \addressing, \system).postln;
Library.atList([\multi, \level, \addressing, \system]).postln;
::

** CLASS::LibraryBase
summary::Abstract global storage class
categories:: Collections

DESCRIPTION::
Base class for link::Classes/Library:: and link::Classes/Archive::

There is only one global instance: Archive.global, or Library.global, which is initialized automatically in the subclasses.

CLASSMETHODS::

method::global
Subclass responsibility

method::clear
Clear the dictionary

method::at
Access the dictionary at a path with keys. The keys may be any object, but are usually link::Classes/Symbol::s.

method::put
Store an object in the dictionary at a path, given as a list of keys and the object to be stored as last argument. The keys may be any object, but are usually link::Classes/Symbol::s.

method::atList
Access the dictionary at a path, given as a list of keys. The keys may be any object, but are usually link::Classes/Symbol::s.

method::putList
Store an object in the dictionary at a path, given as a list of keys and the object to be stored as last argument. The keys may be any object, but are usually link::Classes/Symbol::s.

EXAMPLES::

code::
// an example from the subclass Library:

Library.put(\multi, \level, \addressing, \system, "i'm the thing you are putting in here");
Library.at(\multi, \level, \addressing, \system).postln;
Library.atList([\multi, \level, \addressing, \system]).postln;
::
** class:: Limiter
summary:: Peak limiter
related:: Classes/Amplitude, Classes/Compander, Classes/CompanderD, Classes/Normalizer
categories:: UGens>Dynamics


Description::

Limits the input amplitude to the given level. Limiter will not overshoot
like  link::Classes/Compander::  will, but it needs to look ahead in the
audio. Thus there is a delay equal to twice the value of the
code::dur::  parameter.

Limiter, unlike Compander, is completely transparent for an in range signal.

classmethods::

method::ar

argument::in
The signal to be processed.

argument::level
The peak output amplitude level to which to normalize the input.

argument::dur
aka lookAheadTime.
The buffer delay time. Shorter times will produce smaller delays
and quicker transient response times, but may introduce amplitude
modulation artifacts.


Examples::

code::
(
// example signal to process
Synth.play({
	var z;
	z = Decay2.ar(
		Impulse.ar(8, LFSaw.kr(0.25, -0.6, 0.7)),
		0.001, 0.3, FSinOsc.ar(500));
}, 0.8)
)

(
Synth.play({
	var z;
	z = Decay2.ar(
		Impulse.ar(8, LFSaw.kr(0.25, -0.6, 0.7)),
		0.001, 0.3, FSinOsc.ar(500));
	[z, Limiter.ar(z, 0.4, 0.01)]
}, 0.5)
)
::

** class:: LinCongC
summary:: Linear congruential chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/LinCongN, Classes/LinCongL

description::
A cubic-interpolating sound generator based on the difference equation:

code::
	x[n+1] = (a * x[n] + c) % m
::
warning:: revise formulae converted to c like code ::

The output signal is automatically scaled to a range of [-1, 1].

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Multiplier amount
argument:: c
Increment amount
argument:: m
Modulus amount
argument:: xi
Initial value of x

examples::
code::
// default initial params
{ LinCongC.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);
::

code::
// randomly modulate params
(
{ LinCongC.ar(
	LFNoise2.kr(1, 1e4, 1e4),
	LFNoise2.kr(0.1, 0.5, 1.4),
	LFNoise2.kr(0.1, 0.1, 0.1),
	LFNoise2.kr(0.1)
) * 0.2 }.play(s);
)
::

code::
// as frequency control...
(
{
SinOsc.ar(
	LinCongC.ar(
		40,
		LFNoise2.kr(0.1, 0.1, 1),
		LFNoise2.kr(0.1, 0.1, 0.1),
		LFNoise2.kr(0.1),
		0, 500, 600
	)
) * 0.4 }.play(s);
)
::
** class:: LinCongL
summary:: Linear congruential chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/LinCongC, Classes/LinCongN

description::
A linear-interpolating sound generator based on the difference equation:

code::
	x[n+1] = (a * x[n] + c) % m
::
warning:: revise formulae converted to c like code ::

The output signal is automatically scaled to a range of [-1, 1].

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Multiplier amount
argument:: c
Increment amount
argument:: m
Modulus amount
argument:: xi
Initial value of x

examples::
code::
// default initial params
{ LinCongL.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);
::

code::
// randomly modulate params
(
{ LinCongL.ar(
	LFNoise2.kr(1, 1e4, 1e4),
	LFNoise2.kr(0.1, 0.5, 1.4),
	LFNoise2.kr(0.1, 0.1, 0.1),
	LFNoise2.kr(0.1)
) * 0.2 }.play(s);
)
::

code::
// as frequency control...
(
{
SinOsc.ar(
	LinCongL.ar(
		40,
		LFNoise2.kr(0.1, 0.1, 1),
		LFNoise2.kr(0.1, 0.1, 0.1),
		LFNoise2.kr(0.1),
		0, 500, 600
	)
) * 0.4 }.play(s);
)
::
** class:: LinCongN
summary:: Linear congruential chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/LinCongL, Classes/LinCongC

description::
A non-interpolating sound generator based on the difference equation:

code::
	x[n+1] = (a * x[n] + c) % m
::
warning:: revise formulae converted to c like code ::

The output signal is automatically scaled to a range of [-1, 1].

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Multiplier amount
argument:: c
Increment amount
argument:: m
Modulus amount
argument:: xi
Initial value of x
argument:: mul
argument:: add

examples::
code::
// default initial params
{ LinCongN.ar(MouseX.kr(20, SampleRate.ir)) * 0.2 }.play(s);
::

code::
// randomly modulate params
(
{ LinCongN.ar(
	LFNoise2.kr(1, 1e4, 1e4),
	LFNoise2.kr(0.1, 0.5, 1.4),
	LFNoise2.kr(0.1, 0.1, 0.1),
	LFNoise2.kr(0.1)
) * 0.2 }.play(s);
)
::

code::
// as frequency control...
(
{
SinOsc.ar(
	LinCongN.ar(
		40,
		LFNoise2.kr(0.1, 0.1, 1),
		LFNoise2.kr(0.1, 0.1, 0.1),
		LFNoise2.kr(0.1),
		0, 500, 600
	)
) * 0.4 }.play(s);
)
::
** class:: LinExp
summary:: Map a linear range to an exponential range
related:: Classes/LinLin
categories::  UGens>Maths


Description::

Converts a linear range of values to an exponential range of values.

classmethods::

method::ar, kr

argument::in

The input signal to convert.


argument::srclo

Lower limit of input range.


argument::srchi

Upper limit of input range.


argument::dstlo

Lower limit of output range.


argument::dsthi

Upper limit of output range.

discussion::
The code::dstlo::  and  code::dsthi::  arguments
must be nonzero and have the same sign.


Examples::

code::
// compare:
(
{
	var mod = SinOsc.kr(Line.kr(1, 10, 10));
	SinOsc.ar(mod * 400 + 500) * 0.1
}.play;
)

(
{
	var mod = SinOsc.kr(Line.kr(1, 10, 10));
	SinOsc.ar(LinExp.kr(mod, -1,1, 100, 900)) * 0.1
}.play;
)

// modulating destination values.
(
{
	var mod = LFNoise2.ar(80);
	SinOsc.ar(LinExp.ar(mod, -1,1, MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1))) * 0.1
}.play;
)
::

code::linexp:: and code::exprange:: can be used to create a LinExp implicitly from a ugen, mapping its output values from linear range to an exponential one. The rate is derived from the ugen.

code::
// linexp
(
{
	var mod = LFNoise2.ar(80);
	SinOsc.ar(mod.linexp(-1,1, MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1))) * 0.1
}.play;
)

// exprange
(
{
	var mod = LFNoise2.ar(80).exprange(MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1));
	SinOsc.ar(mod) * 0.1
}.play;
)
::

** class:: LinLin
summary:: Map a linear range to another linear range
related:: Classes/LinExp
categories::  UGens>Maths


Description::

Maps a linear range of values to another linear range of values.


classmethods::

method::ar, kr

argument::in

The input signal to convert.


argument::srclo

Lower limit of input range.


argument::srchi

Upper limit of input range.


argument::dstlo

Lower limit of output range.


argument::dsthi

Upper limit of output range.


Examples::

code::
// examples:

(
{
	var mod = SinOsc.kr(Line.kr(1, 10, 10));
	SinOsc.ar(LinLin.kr(mod, -1,1, 100, 900)) * 0.1
}.play;
)

// modulating destination values.
(
{
	var mod = LFNoise2.ar(80);
	SinOsc.ar(LinLin.ar(mod, -1,1, MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1))) * 0.1
}.play;
)

// modulating source and destination values.
(
{
	var mod = LFNoise2.ar(80);
	SinOsc.ar(
		LinLin.ar(mod,
			SinOsc.kr(0.2), SinOsc.kr(0.2543),
			MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1)
		)
	) * 0.1
}.play;
)
::

linlin and range can be used to create a LinLin implicitly from a ugen, mapping its output values from linear range to an exponential one. The rate is derived from the ugen.

code::
// linlin
(
{
	var mod = LFNoise2.ar(80);
	SinOsc.ar(mod.linlin(-1,1, MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1))) * 0.1
}.play;
)

// range
(
{
	var mod = LFNoise2.ar(80).range(MouseX.kr(200, 8000, 1), MouseY.kr(200, 8000, 1));
	SinOsc.ar(mod) * 0.1
}.play;
)
::

** class:: LinPan2
summary:: Two channel linear pan.
related:: Classes/Balance2, Classes/Pan2, Classes/Pan4, Classes/PanAz
categories::  UGens>Multichannel>Panners


Description::

Two channel linear panner. This one sounds more like the Rhodes tremolo
than  link::Classes/Pan2:: .


classmethods::

method::ar, kr

argument::in

The input signal.


argument::pos

Pan position, -1 is left, +1 is right.


argument::level

A control rate level input.


Examples::

code::

play({ LinPan2.ar(PinkNoise.ar(0.4), FSinOsc.kr(2)) });

SynthDef("help-LinPan2", {  Out.ar(0, LinPan2.ar(FSinOsc.ar(800, 0, 0.1), FSinOsc.kr(3))) }).play;

::

** class:: LinRand
summary:: Skewed random number generator.
related:: Classes/ExpRand, Classes/IRand, Classes/NRand, Classes/Rand, Classes/TExpRand, Classes/TIRand, Classes/TRand
categories:: UGens>Random

Description::

Generates a single random float value in linear distribution from
code::lo::  to  code::hi:: , skewed towards
code::lo::  if  code::minmax::  < 0, otherwise
skewed towards  code::hi:: .


classmethods::

method::new

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

argument::minmax
The output is skewed towards code::lo:: if code::minmax:: < 0, otherwise skewed towards code::hi::.

Examples::

code::

(
SynthDef("help-LinRand", { arg out=0, minmax=1;
	Out.ar(out,
		FSinOsc.ar(
			LinRand(200.0, 10000.0, minmax),
			0, Line.kr(0.2, 0, 0.01, doneAction:2))
	)
}).send(s);
)

//towards hi
(
Routine({
	loop({
		Synth.new("help-LinRand"); 0.04.wait;
	})
}).play;
)

//towards lo (doesn't work like that yet)
(
Routine({
	loop({
		Synth.new("help-LinRand", [\minmax, -1]); 0.04.wait;
	})
}).play;
)

::

** class:: LinSelectX
summary:: Mix one output from many sources
categories:: UGens>Multichannel>Select
related:: Classes/Select, Classes/SelectX, Classes/SelectXFocus

description::
The output is mixed from an array of inputs, linearly interpolating from two adjacent channels.

classmethods::
method:: ar, kr

argument:: which
argument:: array

examples::
code::
(
{
	var a;
	a = [
			SinOsc.ar,
			Saw.ar(300),
			Pulse.ar(230)
		];

	LinSelectX.ar(MouseX.kr(0, 1) * a.size, a) * 0.2
}.play;
)

(
{
	var a;
	a = [
			SinOsc.kr(0.25),
			LFSaw.kr(10),
			LFPulse.kr(0.3)
		];

	SinOsc.ar(LinSelectX.kr(MouseX.kr(0, 1) * a.size, a) * 300 + 400) * 0.2
}.play;
)
::

note::
all the ugens are continously running. This may not be the most efficient way if each input is  cpu-expensive. The array is fixed at the time of writing the SynthDef, and the whole array is embedded in the SynthDef file itself.  For small arrays this is more efficient than reading from a buffer.
::

wrap does not work yet.

(by adc)
** class:: LinXFade2
summary:: Two channel linear crossfade.
related:: Classes/XFade2
categories::  UGens>Multichannel>Select


Description::

Two channel linear crossfader.


classmethods::

method::ar, kr

argument::inA

Input signal A.


argument::inB

Input signal B.


argument::pan

Cross fade position from -1 to +1.


argument::level

A control rate level input.


Examples::

code::

play({ LinXFade2.ar(FSinOsc.ar(800, 0, 0.2), PinkNoise.ar(0.2), FSinOsc.kr(1)) });

::

** class:: Line
summary:: Line generator.
related:: Classes/XLine
categories::  UGens>Envelopes


Description::

Generates a line from the start value to the end value.


classmethods::

method::ar, kr

argument::start

Starting value.


argument::end

Ending value.


argument::dur

Duration in seconds.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


argument::doneAction

A doneAction to be evaluated when the Line is completed. See

link::Reference/UGen-doneActions::  for more detail.


Examples::

code::

// XLine is usually better than Line for frequency
play({ SinOsc.ar(Line.kr(200,17000,10),0,0.1) });

::

** class:: Linen
summary:: Simple linear envelope generator.
categories::  UGens>Envelopes
related:: Classes/EnvGen

Description::

Simple linear envelope generator.


classmethods::

method::kr

argument::gate

This triggers the envelope and holds it open while > 0.

If strong::gate:: < 0, force release with time code:: -1.0 - gate ::. See link::Classes/EnvGen#Forced release::.

argument::attackTime

The duration of the attack portion.


argument::susLevel

The level of the sustain portion.


argument::releaseTime

The duration of the release portion.


argument::doneAction

An integer representing an action to be executed when the
envelope is finished. See
link::Reference/UGen-doneActions::  for
more detail.


Examples::

code::

// trigged
(
SynthDef("help-Linen",{ arg out = 0;
	Out.ar(out,
		Linen.kr(Impulse.kr(2), 0.01, 0.6, 1.0, doneAction: 0) * SinOsc.ar(440, 0, 0.1)
	)
}).play;
)

// play once and end the synth
(
SynthDef("help-Linen",{ arg out=0;
	Out.ar(out,
		Linen.kr(Impulse.kr(0), 0.01, 0.6, 1.0, doneAction: 2) * SinOsc.ar(440, 0, 0.1)
	)
}).play;
)

// play once and sustain
(
x = SynthDef("help-Linen",{ arg gate = 1, out = 0; // use gate arg for release
	Out.ar(out,
		Linen.kr(gate, 0.01, 0.6, 1.0, doneAction: 2) * SinOsc.ar(440, 0, 0.1)
	)
}).play;
)
x.release(4); // change the release time

// longer gate, can pass in duration
(
SynthDef("help-Linen",{ arg out = 0, dur = 0.1;
	var gate;
	gate = Trig.kr(1.0, dur);
	Out.ar(out,
		Linen.kr(gate, 0.01, 0.6, 1.0, doneAction: 2) * SinOsc.ar(440, 0, 0.1)
	)
}).play(nil, [\out, 0, \dur, 2.0]);
)



// used below in a Routine varying the releaseTime
(
SynthDef("help-Linen",{ arg out=0,freq=440,attackTime=0.01,susLevel=0.6,releaseTime=0.1;
	Out.ar(out,
		Linen.kr(Impulse.kr(0), attackTime, susLevel, releaseTime, doneAction: 2)
			* SinOsc.ar(freq, 0, 0.1)
	)
}).send(s);
)

(
// debussey sleeping through math class
x = Pbrown(0.01, 2.0, 0.2, inf).asStream;
Routine({
	loop({
		Synth.grain("help-Linen",[\freq, (rrand(20, 50) * 2).midicps, \releaseTime, x.next]);
		0.25.wait;
	})
}).play(TempoClock.default)
)





(
SynthDef("help-Linen",{ arg out = 0;
	Out.ar(out,

		Linen.kr(Impulse.kr(2),
			0.01,
			// sustain level is polled at time of trigger
			FSinOsc.kr(0.1).range(0, 1),
			1.0,
			doneAction: 0)

			* SinOsc.ar(440, 0, 0.1)
	)
}).play;
)

::
** CLASS::LinkedList
summary::doubly linked list
categories:: Collections>Ordered

DESCRIPTION::
LinkedList implements a doubly linked list.

Most methods are inherited from the superclasses.

INSTANCEMETHODS::

method::addFirst
Add an item to the head of the list.

method::add
Add an item to the tail of the list.

method::remove
Remove an item from the list.

method::pop
Remove and return the last item in the list.

method::popFirst
Remove and return the first item in the list.

method::first
Return the first item in the list.

method::last
Return the last item in the list.

method::at
Return the item at the given index in the list.
This requires a scan of the list and so is O(n).

method::put
Put the item at the given index in the list.
This requires a scan of the list and so is O(n).

method::removeAt
Remove and return the item at the given index in the list.
This requires a scan of the list and so is O(n).
** CLASS::LinkedListNode
summary:: Internally used class for LinkedList nodes
categories:: Collections

DESCRIPTION::
LinkedListNode is used to implement the internal nodes of the link::Classes/LinkedList:: class.
You should not need to deal with a LinkedListNode directly.
** CLASS::List
summary::list of items of variable size
related::Classes/Array
categories::Collections>Ordered

DESCRIPTION::
List is a subclass of SequenceableCollection with unlimited growth in size. Although not a subclass of link::Classes/Array:: or its superclass link::Classes/ArrayedCollection:: it uses an Array in its implementation and is in many cases interchangeable with one. (List implements many of the same methods as Array.)

Arrays have a fixed maximum size. If you add beyond that size a new Array is created and returned, but you must use an assignment statement or the new array will be lost. (See the link::Classes/Array:: helpfile.) List has no size limitation and is thus more flexible, but has slightly more overhead.
code::
(
x = Array.new(3);
y = List.new(3);
5.do({ arg i; z = x.add(i); y.add(i); });
x.postln; z.postln; y.postln;
)
::

Many of List's methods are inherited from link::Classes/SequenceableCollection:: or link::Classes/Collection:: and are documented in those helpfiles.

CLASSMETHODS::

method::new
Creates a List with the initial capacity given by strong::size::.

method::newClear
Creates a List with the initial capacity given by strong::size:: and slots filled with nil.

method::copyInstance
Creates a List by copying strong::aList::'s array variable.

method::newUsing
Creates a List using strong::anArray::.

INSTANCEMETHODS::

method::asArray
Returns a new link::Classes/Array:: based upon this List.

method::array
Returns the List's Array, allowing it to be manipulated directly. This should only be necessary for exotic manipulations not implemented in List or its superclasses.
code::
(
x = List[1, 2, 3];
x.array.add("foo");
x.postln;
)
::

method::array
Sets the List's Array.

method::at
Return the item at strong::index::.
code::
List[ 1, 2, 3 ].at(0).postln;
::

method::clipAt
Same as link::#-at::, but values for strong::index:: greater than the size of the List will be clipped to the last index.
code::
y = List[ 1, 2, 3 ];
y.clipAt(13).postln;
::

method::wrapAt
Same as link::#-at::, but values for strong::index:: greater than the size of the List will be wrapped around to 0.
code::
y = List[ 1, 2, 3 ];
y.wrapAt(3).postln; // this returns the value at index 0
y.wrapAt(4).postln; // this returns the value at index 1
::

method::foldAt
Same as link::#-at::, but values for strong::index:: greater than the size of the List will be folded back.
code::
y = List[ 1, 2, 3 ];
y.foldAt(3).postln; // this returns the value at index 1
y.foldAt(4).postln; // this returns the value at index 0
y.foldAt(5).postln; // this returns the value at index 1
::

method::put
Put strong::item:: at strong::index::, replacing what is there.

method::clipPut
Same as link::#-put::, but values for strong::index:: greater than the size of the List will be clipped to the last index.

method::wrapPut
Same as link::#-put::, but values for strong::index:: greater than the size of the List will be wrapped around to 0.

method::foldPut
Same as link::#-put::, but values for strong::index:: greater than the size of the List will be folded back.

method::add
Adds an strong::item:: to the end of the List.

method::addFirst
Inserts the strong::item:: at the beginning of the List.

method::insert
Inserts the strong::item:: into the contents of the List at the indicated strong::index::.

method::pop
Remove and return the last element of the List.

method::grow
Increase the size of the List by strong::sizeIncrease:: number of slots.

method::removeAt
Remove and return the element at strong::index::, shrinking the size of the List.
code::
y = List[ 1, 2, 3 ];
y.removeAt(1);
y.postln;
::

method::fill
Inserts the item into the contents of the receiver, possibly returning a new collection. note::the difference between this and link::Classes/Collection#fill#Collection's *fill::.::
code::
(
var z;
z = List[1, 2, 3, 4];
z.fill(4).postln;
z.fill([1,2,3,4]).postln;
)
::

method::do
Iterate over the elements in order, calling the function for each element. The function is passed two arguments, the element and an index.
code::
List['a', 'b', 'c'].do({ arg item, i; [i, item].postln; });
::

method::reverseDo
Iterate over the elements in reverse order, calling the function for each element. The function is passed two arguments, the element and an index.
code::
List['a', 'b', 'c'].reverseDo({ arg item, i; [i, item].postln; });
::

method::pairsDo
Calls function for each subsequent pair of elements in the List. The function is passed the two elements and an index.
code::
List[1, 2, 3, 4, 5, 6].pairsDo({ arg a, b; [a, b].postln; });
::

method::copyRange
Return a new List which is a copy of the indexed slots of the receiver from start to end.
code::
(
var y, z;
z = List[1, 2, 3, 4, 5];
y = z.copyRange(1,3);
z.postln;
y.postln;
)
::

method::copySeries
Return a new List consisting of the values starting at strong::first::, then every step of the distance between strong::first:: and strong::second::, up until strong::last::.
code::
(
var y, z;
z = List[1, 2, 3, 4, 5, 6];
y = z.copySeries(0, 2, 5);
y.postln;
)
::

method::putSeries
Put strong::value:: at every index starting at strong::first::, then every step of the distance between strong::first:: and strong::second::, up until strong::last::.
code::
(
var y, z;
z = List[1, 2, 3, 4, 5, 6];
y = z.putSeries(0, 2, 5, "foo");
y.postln;
)
::

method::reverse
Return a new List whose elements are reversed.
code::
(
var y, z;
z = List[1, 2, 3, 4];
y = z.reverse;
z.postln;
y.postln;
)
::

method::scramble
Returns a new List whose elements have been scrambled. The receiver is unchanged.
code::
List[1, 2, 3, 4, 5, 6].scramble.postln;
::

method::mirror
Return a new List which is the receiver made into a palindrome. The receiver is unchanged.
code::
List[1, 2, 3, 4].mirror.postln;
::

method::mirror1
Return a new List which is the receiver made into a palindrome with the last element removed. This is useful if the list will be repeated cyclically, the first element will not get played twice. The receiver is unchanged.
code::
List[1, 2, 3, 4].mirror1.postln;
::

method::mirror2
Return a new List which is the receiver concatenated with a reversal of itself. The center element is duplicated. The receiver is unchanged.
code::
List[1, 2, 3, 4].mirror2.postln;
::

method::stutter
Return a new List whose elements are repeated strong::n:: times. The receiver is unchanged.
code::
List[1, 2, 3].stutter(2).postln;
::

rotate
Return a new List whose elements are in rotated order. Negative strong::n:: values rotate left, postive strong::n:: values rotate right. The receiver is unchanged.
code::
List[1, 2, 3, 4, 5].rotate(1).postln;
List[1, 2, 3, 4, 5].rotate(-1).postln;
List[1, 2, 3, 4, 5].rotate(3).postln;
::

method::pyramid
Return a new List whose elements have been reordered via one of 10 "counting" algorithms. The algorithms are numbered 1 through 10. Run the examples to see the algorithms.
code::
List[1, 2, 3, 4].pyramid(1).postln;

(
10.do({ arg i;
	List[1, 2, 3, 4].pyramid(i + 1).postcs;
});
)
::

method::lace
Returns a new List whose elements are interlaced sequences of the elements of the receiver's subcollections, up to size strong::length::. The receiver is unchanged.
code::
(
x = List[ [1, 2, 3], 6, List["foo", 'bar']];
y = x.lace(12);
x.postln;
y.postln;
)
::

method::permute
Returns a new List whose elements are the strong::nthPermutation:: of the elements of the receiver. The receiver is unchanged.
code::
(
x = List[ 1, 2, 3];
6.do({|i| x.permute(i).postln;});
)
::

method::wrapExtend
Returns a new List whose elements are repeated sequences of the receiver, up to size strong::length::. The receiver is unchanged.
code::
(
x = List[ 1, 2, 3, "foo", 'bar' ];
y = x.wrapExtend(9);
x.postln;
y.postln;
)
::

method::foldExtend
Same as link::#-lace:: but the sequences fold back on the list elements.
code::
(
x = List[ 1, 2, "foo"];
y = x.foldExtend(9);
x.postln;
y.postln;
)
::

method::slide
Return a new List whose elements are repeated subsequences from the receiver. Easier to demonstrate than explain.
code::
List[1, 2, 3, 4, 5, 6].slide(3, 1).postcs;
List[1, 2, 3, 4, 5, 6].slide(3, 2).postcs;
List[1, 2, 3, 4, 5, 6].slide(4, 1).postcs;
::

method::dump
Dump the List's Array.

method::clear
Replace the List's Array with a new empty one.
** class:: ListPattern
summary:: abstract class that holds a list
related:: Classes/FilterPattern
categories:: Streams-Patterns-Events>Patterns>List

Examples::

code::
// post subclasses:

ListPattern.dumpClassSubtree;
::
** CLASS:: ListView
redirect:: implClass
summary:: A view displaying a list of text items.
categories:: GUI>Views

DESCRIPTION::

A view that displays a list of text items and allows one or more of them to be selected, depending on link::#-selectionMode::.

In default selection mode (single item selection), clicking on an item will select it, and pressing the up or down arrow keys will move selection to previous or next item, respectively. Other selection modes allow more complex interaction.

There is a difference between the concepts of link::#-value#current:: item, end link::#-selection#selected:: items. In default selection mode they will always be the same, but not so in other modes.


CLASSMETHODS::

PRIVATE:: key




INSTANCEMETHODS::



SUBSECTION:: Data

METHOD:: items
	The list of items displayed by the view.

	argument::
		An Array of Strings, each String defining the text to represent an item.

METHOD:: clear
    note:: Only available in Qt GUI ::
    Removes all items.

METHOD:: value
	The index of the current item, or nil when there is no current item. Note that this may be different than link::#-selection:: when link::#-selectionMode:: allows multiple items to be selected.

	argument::
		An Integer or nil.

METHOD:: valueAction
	Sets link::#-value:: and triggers the link::#-action::.

METHOD:: selection
	note::Only in Qt GUI::
	An array of all selected indexes. When setting selection, either an array or a single integer may be used.

	Note that this may be different than link::#-value:: when link::#-selectionMode:: allows multiple items to be selected. When setting selection in single-item selection mode, only the last index will remain selected.


SUBSECTION:: Appearance

METHOD:: colors
	The background colors of the items.

	argument::
		An Array of Colors, one Color for each item.

METHOD:: stringColor
	The color used to display all the text of all unselected items.

	argument::
		A Color.

METHOD:: selectedStringColor
	The color used to display the selected item's text.

	argument::
		A Color.

METHOD:: hiliteColor
	The color used to indicate the selected item (aside from the color of its text).

	argument::
		A Color.




SUBSECTION:: Interaction

METHOD:: selectionMode
	note:: Only available in Qt GUI ::

	The allowed mode of item selection, according to the following table:

	table::
	## strong::Value::  || strong::Meaning::
	## \none            || No item can be selected.
	## \single          || Only a single item can be selected at once.
	## \multi           || Multiple items can be selected. An item's selection is toggled when clicked.
	## \extended        || Multiple items can be selected, individually by holding the Ctrl key, and in a batch by holding the Shift key.
	## \contiguous      || Mutliple neighbouring items can be selected by holding the Shift key.
	::

	argument::
		One of the Symbols listed in the table above.



SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user changes the emphasis::current:: item, i.e. when link::#-value:: changes as a result of GUI interaction.

METHOD:: selectionAction
	note::Only in Qt GUI::
	The action object evaluated whenever link::#-selection:: changes.

METHOD:: enterKeyAction
	The action object evaluated whenever the user presses the Enter (Return) key.

METHOD:: defaultKeyDownAction

	Implements the default effects of key presses as follows:

	table::
	## strong::Key::   || strong::Effect::
	## space           || select next item and trigger action
	## r               || trigger enterKeyAction
	## n               || trigger enterKeyAction
	## a number        || trigger enterKeyAction
	## up arrow        || select previous item and trigger action
	## down arrow      || select next item and trigger action
	## left arrow      || select previous item and trigger action
	## right arrow     || select next item and trigger action
	::



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The link::#-value::.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a number.

METHOD:: defaultReceiveDrag
	Sets link::#-valueAction:: to the current drag data.


EXAMPLES::

subsection:: Basic Example

code::
(
w = Window.new.front;

v = ListView(w,Rect(10,10,120,70))
    .items_([ "SinOsc", "Saw", "LFSaw", "WhiteNoise", "PinkNoise", "BrownNoise", "Osc" ])
    .background_(Color.clear)
    .hiliteColor_(Color.green(alpha:0.6))
    .action_({ arg sbs;
        [sbs.value, v.items[sbs.value]].postln; // .value returns the integer
    });
)
::


subsection:: Sound Example

Use ListView to switch filters:
code::
(
Server.default = s = Stethoscope.defaultServer.boot;
s.waitForBoot({
    var f, freq, ww;
    n={r=LFSaw.ar([220, 530],0,0.3)*LFPulse.ar(12,0,0.3,0.4); [r[0],Delay2.ar(r[1])]}.play;
    freq={SinOsc.kr(0.5,0,4000,4200)}.play;
    w=Window("Filters").front;
    v = ListView(w,Rect(10,10,180,120))
        .items_([ "No Filter","RLPF", "RHPF", "BPF", "Resonz", "MoogFF" ])
        .background_(Color.clear)
        .hiliteColor_(Color.green(alpha:0.6))
        .action_({arg v;
            v.value.switch(
            0,{try{f.free};"test".postln},
            1,{try{f.free};f={ReplaceOut.ar(0,RLPF.ar(In.ar(0,2),In.kr(0,1),0.2,0.3))}.play(addAction:\addToTail)},
            2,{try{f.free};f={ReplaceOut.ar(0,RHPF.ar(In.ar(0,2),In.kr(0,1),0.2,0.3))}.play(addAction:\addToTail)},
            3,{try{f.free};f={ReplaceOut.ar(0,BPF.ar(In.ar(0,2),In.kr(0,1),0.2,1.5))}.play(addAction:\addToTail)},
            4,{try{f.free};f={ReplaceOut.ar(0,Resonz.ar(In.ar(0,2),In.kr(0,1),0.2,2))}.play(addAction:\addToTail)},
            5,{try{f.free};f={ReplaceOut.ar(0,MoogFF.ar(In.ar(0,2),In.kr(0,1),1.5))}.play(addAction:\addToTail)}
            );
        });

    ww=FreqScope.new(400, 200, 0);
    w.bounds=Rect(50,Window.screenBounds.height-300,200,200);
    ww.window.bounds=ww.window.bounds.moveTo(255,Window.screenBounds.height-328);
    CmdPeriod.doOnce({{ww.window.close}.defer(0.5);w.close;});
            //defer or crash, because FreqScopeWindow Class contains its own routine for cleaning up on CmdPeriod
    w.onClose_({n.free;f.free;freq.free});
});
)
::
** class:: LocalBuf
summary:: Allocate a buffer local to the synth
categories:: UGens>Buffer
related:: Classes/Buffer, Classes/SetBuf, Classes/ClearBuf

classmethods::
private:: categories, new1

method:: new
Allocate a local buffer
argument:: numFrames
number of frames (default: 1)
argument:: numChannels
number of channels for multiple channel buffers (default: 1)
returns:: a new buffer – the ugen outputs its buffer number and can thus be used in any other ugen that requires a buffer number input.

method:: newFrom
Allocates a new buffer from a given list of values
argument:: list
The list may be two-dimensional for numChannels > 1.
It is then reshaped into the buffer's current format by flattening.
returns:: a new buffer
discussion::
Since newFrom is called by the as message, one may thus convert an array to a LocalBuf:
code::
[1, 2, 3].as(LocalBuf)
::

instancemethods::
method:: set
set the buffer slots with a list of values.
discussion::
If list is smaller than numFrames, it will only set
part of the buffer. The list may be two-dimensional for numChannels > 1.
offset is the starting index (default: 0)
warning::
SynthDef permits a maximum of 65536 (2**16) unique constant values in one definition. A very large array of distinct values can corrupt the SynthDef's binary format. If you need a large buffer to be pre-initialized with signal data, it is strongly recommended to use link::Classes/Buffer:: instead.
::

If the buffer is large but holds a smaller number of unique values, e.g. code::Array.fill(88200, { #[0, 0.25, 0.5, 0.75, 1.0].choose })::, this is no problem. SynthDef compacts the large array for the list of constants.

code::
SynthDef(\bigLocalBuf, {
	LocalBuf(88200).set(Array.fill(88200, { #[0, 0.25, 0.5, 0.75, 1.0].choose }))
}).add;

SynthDescLib.at(\bigLocalBuf).constants;
// prints: FloatArray[ 1, 88200, 0, 0.75, 0.5, 0.25 ]
::

method:: clear
set the buffer slot to zero.
discussion::
This is important when randomly acessing buffer slots
(e.g. with a BufRd) or not overwriting them. Clear is not an efficient real time operation
for larger buffers, so it should be only used when really needed - but then it is essential:
a LocalBuf is "created" in each new synth, and it may reuse old space. So if an older
synth has already ended, this part of memory may be the same as the new synth's.

examples::
code::
// example: FFT

(
{
var in, chain;
	in = WhiteNoise.ar(0.1.dup);
	chain = FFT({LocalBuf(2048, 1)}.dup, in);
	chain = PV_BrickWall(chain, SinOsc.kr([0.1, 0.11]));
	IFFT(chain) // inverse FFT
}.play;
)

// spawn some FFT based synths:
(
SynthDef(\fftgrain, { |out, sustain = 1, rate = 0.2|
	var in, chain;
	in = WhiteNoise.ar(0.1).dup;
	chain = FFT({LocalBuf(128, 1)}.dup, in);
	chain = PV_BrickWall(chain,
		SinOsc.kr(rate * XLine.kr(1, 15 * [1, 1.6], sustain), Rand(0, pi))
	);
	Out.ar(out, IFFT(chain) * XLine.kr(1, 0.001, sustain, doneAction: 2)) // inverse FFT
}).add;
)

(
Pbind(
	\instrument, \fftgrain,
	\rate, Pwhite().linexp(0, 1, 0.01, 300),
	\legato, Pwhite(1, 3.0, inf),
	\dur, Prand([0.2, 1, 1.2], inf)
).play
)

// IndexL
(
{
	var buf = LocalBuf.newFrom((0..5).scramble);
	var freq = IndexL.kr(buf, MouseX.kr(0, BufFrames.kr(buf))).poll * 100 + 40;
	Saw.ar(freq * [1, 1.1]) * 0.1
}.play;
)

// DetectIndex
(
{
	var buf1 = LocalBuf.newFrom((0..5).scramble);
	var buf2 = LocalBuf.newFrom((0..5).scramble - 1);
	var buf3 = LocalBuf.newFrom((0..5).scramble + 1);
	var index = DetectIndex.kr([buf1, buf2], SinOsc.kr([0.85, 0.8], 0, 6).trunc).poll;
	var freq = IndexL.kr([buf2, buf3], index).poll * 40 + 40;
	Saw.ar(freq) * 0.1
}.play;
)


// DegreeToKey
// modal space
// mouse x controls discrete pitch in dorian mode
(
play({
	var mix;

	mix =

	// lead tone
	SinOsc.ar(
		(
			DegreeToKey.kr(
				[0, 2, 3.2, 5, 7, 9, 10].as(LocalBuf),
				MouseX.kr(0, 15),		// mouse indexes into scale
				12,					// 12 notes per octave
				1,					// mul = 1
				72					// offset by 72 notes
			).poll
			+ LFNoise1.kr([3,3], 0.04)	// add some low freq stereo detuning
		).midicps,						// convert midi notes to hertz
		0,
		0.1)

	// drone 5ths
	+ RLPF.ar(LFPulse.ar([48,55].midicps, 0.15),
		SinOsc.kr(0.1, 0, 10, 72).midicps, 0.1, 0.1);

	// add some 70's euro-space-rock echo
	CombN.ar(mix, 0.31, 0.31, 2, 1, mix)
})
)

// Osc
(
{
	var buf;
	var list = Wavetable.sineFill(512, 1.0 / [1, 10, 3, 10, 5, 6, 10]);
	// list.plot;
	buf = LocalBuf.newFrom(list);
	Osc.ar(buf,
		XLine.kr(2000, 200 + {30.0.rand}.dup, 10) + SinOsc.ar(Line.kr(2, 300, 10),
		0, 100)
	) * 0.1;
}.play;
)

// see how not clearing the buffer accesses old data:
// slowly overwrite data with noise
(
{
	var buf = LocalBuf(2048, 2);
	BufWr.ar(WhiteNoise.ar(1.dup), buf, LFNoise0.ar(530).range(0, BufFrames.kr(buf)));
	PlayBuf.ar(2, buf, MouseX.kr(1, 2), loop: 1) * 0.1
}.play
)

// avoid this (unless you like the glitch) by clearing buffer first:
(
{
	var buf = LocalBuf(2048, 2).clear;
	BufWr.ar(WhiteNoise.ar(1.dup), buf, LFNoise0.ar(530).range(0, BufFrames.kr(buf)));
	PlayBuf.ar(2, buf, MouseX.kr(1, 2), loop: 1) * 0.1
}.play
)


// BufCombC stereo (needs no clearing, because delay is filled by ugen)
(
{
var z = Decay.ar(Dust.ar(1.dup, 0.1), 0.3, WhiteNoise.ar);
BufCombC.ar(LocalBuf(SampleRate.ir, 2), z, XLine.kr(0.0001, 0.01, 20), 0.2);
}.play
)

// multichannel test
(
{
var in, chain, n = 4;
	in = WhiteNoise.ar(0.1.dup(n));
	chain = FFT({LocalBuf(2048, 1)}.dup(n), in);
	chain = PV_BrickWall(chain, LFNoise2.kr(2.dup(n)));
	Splay.ar(IFFT(chain)) // inverse FFT
}.play;
)
::

** class:: LocalIn
summary:: Define and read from buses local to a synth.
related:: Classes/LocalOut
categories::  UGens>InOut

Description::

LocalIn defines buses that are local to the enclosing synth. These are
like the global buses, but are more convenient if you want to implement a
self contained effect that uses a feedback processing loop.

There can only be one audio rate and one control rate LocalIn per
SynthDef. The audio can be written to the bus using
link::Classes/LocalOut:: .

warning::
Audio written to a  link::Classes/LocalOut::  will not be read by a
corresponding LocalIn until the next cycle, i.e. one block size of
samples later. Because of this it is important to take this additional
delay into account when using LocalIn to create feedback delays with
delay times shorter than the threshold of pitch (i. e. < 0.05
seconds or > 20Hz), or where sample accurate alignment is required.
See the resonator example below.
::

classmethods::

method::ar, kr

argument::numChannels

The number of channels (i.e. adjacent buses) to read in. You
cannot modulate this number by assigning it to an argument in a
SynthDef.

argument::default

The initial value written to the bus once, so that it can be used before overwriting it with LocalOut. An array can be passed in to specify different values for each channel.


Examples::

code::
(
{
	var source, local;

	source = Decay.ar(Impulse.ar(0.3), 0.1) * WhiteNoise.ar(0.2);

	local = LocalIn.ar(2) + [source, 0]; // read feedback, add to source

	local = DelayN.ar(local, 0.2, 0.2); // delay sound

	// reverse channels to give ping pong effect, apply decay factor
	LocalOut.ar(local.reverse * 0.8);

	local
}.play;
)

(
{
	var local, in;

	in = Mix.fill(12, {
		Pan2.ar(
			Decay2.ar(Dust.ar(0.05), 0.1, 0.5, 0.1)
				* FSinOsc.ar(IRand(36,84).midicps).cubed.max(0),
			Rand(-1,1))
	});
	in = in + Pan2.ar(Decay2.ar(Dust.ar(0.03), 0.04, 0.3) * BrownNoise.ar, 0);

	4.do { in = AllpassN.ar(in, 0.03, {Rand(0.005,0.02)}.dup, 1); };

	local = LocalIn.ar(2) * 0.98;
	local = OnePole.ar(local, 0.5);

	local = Rotate2.ar(local[0], local[1], 0.23);
	local = AllpassN.ar(local, 0.05, {Rand(0.01,0.05)}.dup, 2);

	local = DelayN.ar(local, 0.3, [0.19,0.26]);
	local = AllpassN.ar(local, 0.05, {Rand(0.03,0.15)}.dup, 2);

	local = LeakDC.ar(local);
	local = local + in;

	LocalOut.ar(local);
}.play;
)

(
{
	var local, in, amp;

	in = AudioIn.ar([1,2]);

	amp = Amplitude.kr(Mix.ar(in));
	in = in * (amp > 0.02); // noise gate

	local = LocalIn.ar(2);
	local = OnePole.ar(local, 0.4);
	local = OnePole.ar(local, -0.08);

	local = Rotate2.ar(local[0], local[1], 0.2);

	local = DelayN.ar(local, 0.25, 0.25);

	local = LeakDC.ar(local);
	local = ((local + in) * 1.25).softclip;

	LocalOut.ar(local);
	local * 0.1;
}.play;
)

// Resonator, must subtract blockSize for correct tuning
(
{
	var in, imp, sound;

	in = LocalIn.ar(1);
	imp = Impulse.ar(1);
	sound = DelayC.ar(imp + (in * 0.995), 1, 440.reciprocal - ControlRate.ir.reciprocal);
	LocalOut.ar(sound); // for feedback
	in
}.play(s, 0);

// compare pitch
{
	SinOsc.ar(440, 0, 0.2)
}.play(s, 1);
)
::

** class:: LocalOut
summary:: Write to buses local to a synth.
related:: Classes/LocalIn
categories::  UGens>InOut


Description::

LocalOut writes to buses that are local to the enclosing synth. The buses
should have been defined by a  link::Classes/LocalIn::  ugen. The
code::channelsArray::  must be the same number of channels
as were declared in the  link::Classes/LocalIn:: . These are like the
global buses, but are more convenient if you want to implement a self
contained effect that uses a feedback processing loop.


warning::

Audio written to a LocalOut will not be read by a corresponding
link::Classes/LocalIn::  until the next cycle, i.e. one block size of
samples later. Because of this it is important to take this additional
delay into account when using  link::Classes/LocalIn::  to create
feedback delays with delay times shorter than the threshold of pitch
(i. e. < 0.05 seconds or > 20Hz), or where sample accurate
alignment is required. See the resonator example below.

::

classmethods::

method::ar, kr

argument::channelsArray

An Array of channels or single output to write out. You cannot
change the size of this once a SynthDef has been built.


Examples::

code::

(
{
	var source, local;

	source = Decay.ar(Impulse.ar(0.3), 0.1) * WhiteNoise.ar(0.2);

	local = LocalIn.ar(2) + [source, 0]; // read feedback, add to source

	local = DelayN.ar(local, 0.2, 0.2); // delay sound

	// reverse channels to give ping pong effect, apply decay factor
	LocalOut.ar(local.reverse * 0.8);

	Out.ar(0, local);
}.play;
)



(
z = SynthDef("tank", {
	var local, in;

	in = Mix.fill(12, {
		Pan2.ar(
			Decay2.ar(Dust.ar(0.05), 0.1, 0.5, 0.1)
				* FSinOsc.ar(IRand(36,84).midicps).cubed.max(0),
			Rand(-1,1))
	});
	in = in + Pan2.ar(Decay2.ar(Dust.ar(0.03), 0.04, 0.3) * BrownNoise.ar, 0);

	4.do { in = AllpassN.ar(in, 0.03, {Rand(0.005,0.02)}.dup, 1); };

	local = LocalIn.ar(2) * 0.98;
	local = OnePole.ar(local, 0.5);

	local = Rotate2.ar(local[0], local[1], 0.23);
	local = AllpassN.ar(local, 0.05, {Rand(0.01,0.05)}.dup, 2);

	local = DelayN.ar(local, 0.3, [0.19,0.26]);
	local = AllpassN.ar(local, 0.05, {Rand(0.03,0.15)}.dup, 2);

	local = LeakDC.ar(local);
	local = local + in;

	LocalOut.ar(local);

	Out.ar(0, local);
}).play;
)



(
z = SynthDef("tape", {
	var local, in, amp;

	in = AudioIn.ar([1,2]);

	amp = Amplitude.kr(Mix.ar(in));
	in = in * (amp > 0.02); // noise gate

	local = LocalIn.ar(2);
	local = OnePole.ar(local, 0.4);
	local = OnePole.ar(local, -0.08);

	local = Rotate2.ar(local[0], local[1], 0.2);

	local = DelayN.ar(local, 0.25, 0.25);

	local = LeakDC.ar(local);
	local = ((local + in) * 1.25).softclip;

	LocalOut.ar(local);

	Out.ar(0, local * 0.1);
}).play;
)

// Resonator, must subtract blockSize for correct tuning
(
var play, imp, initial;
SynthDef("testRes", {

play = LocalIn.ar(1);
imp = Impulse.ar(1);

LocalOut.ar(DelayC.ar(imp + (play * 0.995), 1, 440.reciprocal - ControlRate.ir.reciprocal)); // for feedback

OffsetOut.ar(0, play);

}).play(s);

{SinOsc.ar(440, 0, 0.2) }.play(s, 1); // compare pitch
)

::

** class:: Logistic
summary:: Chaotic noise function
related:: Classes/Crackle, Classes/LatoocarfianN
categories::  UGens>Generators>Chaotic


Description::

A noise generator based on the logistic map:
code::
y = chaosParam * y * (1.0 - y)
::

classmethods::
private:: categories

method::ar, kr

argument::chaosParam
a parameter of the chaotic function with useful values from 0.0 to 4.0. Chaos occurs from 3.57 up. Don't use values outside this range if you don't want the UGen to blow up.

argument::freq
Frequency of calculation; if over the sampling rate, this is clamped to the sampling rate

argument:: init
Initial value of y in the equation above

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

discussion::
y will stay in the range of 0.0 to 1.0 for normal values of the chaosParam. This leads to a DC offset, and may cause a pop when you stop the Synth. For output you might want to combine this UGen with a LeakDC or rescale around 0.0 via mul and add: see example below.

examples::
code::
// default values
{ Logistic.ar }.play

// onset of chaos
{ Logistic.ar(Line.kr(3.55, 3.6, 5), 1000) }.play

// explore via Mouse
{ Logistic.ar(MouseX.kr(3, 3.99), MouseY.kr(10, 10000, 'exponential'), 0.25, 0.5) }.play
::

** class:: LorenzL
summary:: Lorenz chaotic generator
categories:: UGens>Generators>Chaotic

description::
A strange attractor discovered by Edward N. Lorenz while studying mathematical models of the atmosphere. The system is composed of three ordinary differential equations:

code::
	x' = s * (y - x)
	y' = x * (r - z) - y
	z' = x * y - b * z
::
warning:: revise formulae converted to c like code (x', y', z'!!!) ::

The time step amount code::h:: determines the rate at which the ODE is evaluated. Higher values will increase the rate, but cause more instability. A safe choice is the default amount of 0.05.

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: s
Equation variable
argument:: r
Equation variable
argument:: b
Equation variable
argument:: h
Integration time step
argument:: xi
Initial value of x
argument:: yi
Initial value of y
argument:: zi
Initial value of z
argument:: mul
argument:: add

examples::
code::
// vary frequency
{ LorenzL.ar(MouseX.kr(20, SampleRate.ir)) * 0.3 }.play(s);
::

code::
// randomly modulate params
(
{ LorenzL.ar(
	SampleRate.ir,
	LFNoise0.kr(1, 2, 10),
	LFNoise0.kr(1, 20, 38),
	LFNoise0.kr(1, 1.5, 2)
) * 0.2 }.play(s);
)
::

code::
// as a frequency control
{ SinOsc.ar(Lag.ar(LorenzL.ar(MouseX.kr(1, 200)),3e-3)*800+900)*0.4 }.play(s);
::
** class:: Loudness
summary:: Extraction of instantaneous loudness in sones
categories:: UGens>Analysis>Amplitude
related:: Classes/BeatTrack, Classes/MFCC, Classes/Onsets, Classes/Pitch, Classes/KeyTrack

description::
A perceptual loudness function which outputs loudness in sones; this is a variant of an MP3 perceptual model, summing excitation in ERB bands. It models simple spectral and temporal masking, with equal loudness contour correction in ERB bands to obtain phons (relative dB), then a phon to sone transform. The final output is typically in the range of 0 to 64 sones, though higher values can occur with specific synthesised stimuli.


classmethods::
method:: kr

argument:: chain
[fft] Audio input to track, which has been pre-analysed by the link::Classes/FFT:: link::Classes/UGen::; see examples below for the expected FFT size.

argument:: smask
[sk] Spectral masking param: lower bins mask higher bin power within ERB bands, with a power falloff (leaky integration multiplier) of smask per bin.

argument:: tmask
[sk] Temporal masking param: the phon level let through in an ERB band is the maximum of the new measurement, and the previous minus tmask phons.

examples::
code::
// assumes hop of half fftsize, fine
b = Buffer.alloc(s, 1024, 1); // for sampling rates 44100 and 48000
//b = Buffer.alloc(s, 2048, 1); // for sampling rates 88200 and 96000
d = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// analyse loudness and poll result
(
{
var in, fft, loudness;

in = PlayBuf.ar(1, d, BufRateScale.kr(d), 1, 0, 1);

fft = FFT(b, in);

loudness = Loudness.kr(fft).poll(50);

Out.ar(0, Pan2.ar(in));
}.play
)


// TESTS
// sones = 2 ** ((phon - 40) / 10)
// sine of 40 dB = 40 phon at 1000 kHz = 1 sone
// full amp = 100 dB
// -60.dbamp = 0.001 = 1 sone
// -40.dbamp = 0.01 = 4 sone
// -20.dbamp= 0.1 = 16 sone
// 0.dbamp= 1 = 64 sone
(
{
var in, fft, loudness;

in = SinOsc.ar(1000, 0, 0.001); //should be 1 sone
//in = SinOsc.ar(1000, 0, 0.01); //should be 4 sone
//in = SinOsc.ar(1000, 0, 0.1); //should be 16 sone
//in = SinOsc.ar(1000, 0, 1); //should be 64 sone
//in = Saw.ar * SinOsc.ar(4);
//in = WhiteNoise.ar;
//in = Silent.ar; // should be small, around 2 ** ((0 - 40) / 10) = 2 ** (-4) = 0.0625
//in = DC.ar(1);
//in = SinOsc.ar(22050, pi * 0.5, 1);
// fade ins
//in = SinOsc.ar(1000, 0, Line.kr(0, 1, 2));
//in = SinOsc.ar(1000, 0, Line.kr(0, 1, 2) ** 2);
//in = WhiteNoise.ar(Line.kr(0, 1, 2));
//in = PlayBuf.ar(1, d, BufRateScale.kr(d), 1, 0, 1);

fft = FFT(b, in);

loudness = Loudness.kr(fft, 0.25, 6).poll(50);

Out.ar(0, Pan2.ar(in));
K2A.ar(loudness * 0.016)
}.plot(2.0)
)
::

Research note: This link::Classes/UGen:: is an informal juxtaposition of perceptual coding, and a Zwicker and Glasberg/Moore/Stone loudness model.
** class:: MFCC
summary:: Mel frequency cepstral coefficients
categories:: UGens>Analysis
related:: Classes/BeatTrack, Classes/Loudness, Classes/Onsets, Classes/Pitch, Classes/KeyTrack

description::
Generates a set of MFCCs; these are obtained from a band-based frequency representation (using the Mel scale by default), and then a discrete cosine transform (DCT). The DCT is an efficient approximation for principal components analysis, so that it allows a compression, or reduction of dimensionality, of the data, in this case reducing 42 band readings to a smaller set of MFCCs. A small number of features (the coefficients) end up describing the spectrum. The MFCCs are commonly used as timbral descriptors.

Output values are somewhat normalised for the range 0.0 to 1.0, but there are no guarantees on exact conformance to this. Commonly, the first coefficient will be the highest value.

classmethods::
method:: kr

argument:: chain
[fft] Audio input to track, which has been pre-analysed by the FFT UGen; see examples below for the expected FFT size.
argument:: numcoeff
[s] Number of coefficients, defaults to 13, maximum of 42; more efficient to use less of course!

returns:: code::#coeff1, coeff2, ...::

examples::
code::
// Technical note: The 0th coefficient is not generated as it consists of multiplying all bands by 1 and summing


// assumes hop of half fftsize, fine
b = Buffer.alloc(s, 1024, 1); // for sampling rates 44100 and 48000
//b = Buffer.alloc(s, 2048, 1); // for sampling rates 88200 and 96000

d = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");


(
x = {
var in, fft, array;

//in = PlayBuf.ar(1, d, BufRateScale.kr(d), 1, 0, 1);

in = SoundIn.ar(0);

fft = FFT(b, in);

array = MFCC.kr(fft);

array.size.postln;

Out.kr(0, array);

Out.ar(0,Pan2.ar(in));
}.play
)


c = Bus.new('control', 0, 13);

// poll coefficients
c.getn(13, { arg val; { val.plot; }.defer });


// Continuous graphical display of MFCC values; free routine before closing window

(
var ms;

w = Window.new("Thirteen MFCC coefficients", Rect(200, 400, 300, 300));

ms = MultiSliderView.new(w, Rect(10, 10, 260, 280));

ms.value_(Array.fill(13, 0.0));
ms.valueThumbSize_(20.0);
ms.indexThumbSize_(20.0);
ms.gap_(0);

w.front;

r = {

inf.do{

c.getn(13, { arg val; { ms.value_(val * 0.9) }.defer });

0.04.wait; // 25 frames per second
};

}.fork;

)


// tidy up
(
r.stop;
b.free;
c.free;
x.free;
w.close;
)
::

Research notes: Drafts of an MFCC UGen were prepared by both Dan Stowell and Nick Collins; their various ideas are combined here in a cross platform compatible UGen. Mel scale spacing with triangular crossfade overlap is used by default for the bands, approximately tracking the human critical band spacing and bandwidth. Variants such as BFCC (Bark) and EFCC (ERB) given similar results in practice; the Mel scale as used here is the standard as adapted from the speech recognition literature and now applied in music information retrieval.

code::
// Calculating Mel Scale Bands; allow up to 42 coefficients, so up to 42 bands
// first part of this code adapted from Dan Stowell and Jamie Bullock Mel scale implementation
// could later add Bark and ERB options, and possibility of buffer of data to be passed to the UGen for alternative freq warpings
(
var mel_freq_max, mel_freq_min, freq_bw_mel, freq_bands, freq_max, freq_min;
var mel_peak, lin_peak, fft_peak;
var freqperbin;
var fftbinstart, fftbinend, fftbinmult, fftbincumul;
var pos, tmp;
var sr, fftsize, halffftsize;
var whichbandscale, lintoscale, scaletolin;

freq_max = 18000;
freq_min = 80;
sr = 48000; //44100;
fftsize = 1024;
halffftsize = fftsize.div(2);
freq_bands = 42;

//whichbandscale = 0; // 0 = mel; 1 = bark (CB) 2 = ERB
//
//lintoscale = {arg freq;
//switch(whichbandscale,0,{1127 * log(1 + (freq / 700))}, 1, {}, 2, {}).value
//};
//scaletolin = {arg scalepos;
//switch(whichbandscale, 0, {700 * (exp(scalepos / 1127.0) -1);}, 1, {}, 2, {}).value
//};

lintoscale = {arg freq;
1127 * log(1 + (freq / 700))
};
scaletolin = {arg scalepos;
700 * (exp(scalepos / 1127.0) -1);
};

mel_freq_max = lintoscale.value(freq_max); // 1127 * log(1 + (freq_max / 700));
mel_freq_min = lintoscale.value(freq_min); //1127 * log(1 + (freq_min / 700));
freq_bw_mel = (mel_freq_max - mel_freq_min) / freq_bands;

[mel_freq_max, mel_freq_min, freq_bw_mel].postln;

mel_peak = Array.fill(freq_bands + 2, {0.0});
lin_peak = Array.fill(freq_bands + 2, {0.0});
fft_peak = Array.fill(freq_bands + 2, {0.0});

freqperbin = sr / fftsize; // SR/N

mel_peak[0] = mel_freq_min;
lin_peak[0] = freq_min; // === 700 * (exp(mel_peak[0] / 1127) - 1);
fft_peak[0] = (lin_peak[0] / freqperbin).asInteger;

for(1, freq_bands + 1,{|n|

 mel_peak[n] = mel_peak[n - 1] + freq_bw_mel;
 lin_peak[n] = scaletolin.value(mel_peak[n]); // 700 * (exp(mel_peak[n] / 1127.0) -1);
 fft_peak[n] = ((lin_peak[n] / freqperbin).asInteger).min(halffftsize); // fft size //rounds down here

});

//Post << mel_peak << nl;
//Post << lin_peak << nl;
//Post << fft_peak << nl;

//  [2 / (lin_peak[freq_bands + 1] - lin_peak[freq_bands-1]), 1.0 / (2 / (lin_peak[2] - lin_peak[0]))].postln;

fftbinstart = Array.fill(freq_bands, {0});
fftbinend = Array.fill(freq_bands, {0});
fftbincumul = Array.fill(freq_bands+1, {0});
fftbinmult = [];

pos = 0;

freq_bands.do {|i|

	//var normmult=1.0; // preserve power, don't modify band power by area
	var startbin, endbin, numbins, averager;

	if(i == 0,{
	startbin = 0;
	endbin = fft_peak[i + 1] - 1;
	},{
	startbin = fft_peak[i - 1] + 1;
	endbin = fft_peak[i + 1] - 1;
	});

	numbins = endbin - startbin + 1;
	averager = 1.0 / numbins;

	// linear crossfade (intended in power) between consecutive band centres

	tmp = fft_peak[i] - startbin;

	// could divide by averager but I'm not convinced by the perceptual necessity for this?
	// ie fftbinmult = fftbinmult ++ (Array.series(tmp + 1, 1.0 / (tmp + 1), 1.0 / (tmp + 1)) * averager);

	fftbinmult = fftbinmult ++ (Array.series(tmp + 1, 1.0 / (tmp + 1), 1.0 / (tmp + 1)));

	tmp= endbin- (fft_peak[i]);

	fftbinmult = fftbinmult ++ (Array.series(tmp, 1.0 + ((-1.0) / (tmp + 1)), (-1.0) / (tmp + 1)));

	fftbinstart[i] = startbin;
	fftbinend[i] = endbin;
	fftbincumul[i] = pos;

	pos = pos + (endbin - startbin + 1);
};

fftbincumul[freq_bands] = pos - 1;

Post << fftbinstart << nl;
Post << fftbinend << nl;
Post << fftbincumul << nl;
Post << fftbinmult << nl;

)


// future work: see http://www.ling.su.se/STAFF/hartmut/bark.htm

// Barks
a = (26.81 / (1 + (1960 / ((100, 200..22000))))) - 0.53;
a.plot;

// ERBs (rough calculation, only really valid under 6000Hz, real scale goes up to 42 rather than 37 in 22000 Hz)
a = Array.fill(220,{|i| var f; f = i * 100; 11.17 * log((f + 312) / (f + 14675)) + 43.0});
a.plot

// generating DCT coefficients
// don't generate i=0 coefficient since it
a = Array.fill(42, {|i| cos(pi / 42.0 * ((0..41) + 0.5) * (i + 1))});
Post << a.flatten << nl;
::
** CLASS:: MIDIFunc						       :midi:
   :PROPERTIES:
   :ID:       FF6C4515-A936-4C2A-BBF1-0D3E1FB8DC94
   :END:
summary:: Fast Responder for incoming MIDI Messages
categories:: External Control>MIDI
related:: Guides/MIDI, Classes/MIDIdef

DESCRIPTION::
MIDIFunc (and its subclass link::Classes/MIDIdef::) registers one or more functions to respond to an incoming MIDI message. Many of its methods are inherited from its superclass link::Classes/AbstractResponderFunc::.

note:: MIDIFunc and link::Classes/MIDIdef:: aim to improve upon the MIDIresponder classes by being faster and easier to use. They were made with the intention of creating a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. As of this time, however, they still lack some features of the MIDIresponder classes, notably the learn method. Note that unlike those classes, MIDIFuncs are removed on Cmd-. by default. This can be overriden using either of the fix or permanent methods.::


CLASSMETHODS::
private:: initClass, cmdPeriod

METHOD:: defaultDispatchers
Get or set an link::Classes/IdentityDictionary:: containing the default dispatcher objects for MIDIFuncs of different types (these are what you get if you pass nil as the dispatcher argument to link::#*new::). These objects will decide if any of their registered MIDIFuncs should respond to an incoming MIDI message. The dictionary should have the keys code::[\noteOn, \noteOff, \control, \polytouch, \touch, \program, \bend]:: and values of an appropriate subclass of link::Classes/AbstractDispatcher:: for each message type. By default these will be instances of link::Classes/MIDIMessageDispatcher:: for the the first four message types, and instances of link::Classes/MIDIMessageDispatcherNV:: for the last three.

returns:: The getter returns an link::Classes/IdentityDictionary::.

METHOD:: new
Create a new, enabled MIDIFunc. Normally one would use one of the message type specific convenience methods below, rather than use this method directly.

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated for noteOn, noteOff, control, and polytouch messages it will be passed the arguments val, num, chan, and src, corresponding to the message value (e.g. velocity, control value, etc.), message number (e.g. note number), MIDI channel, and MIDI source uid. For touch, programme change and bend messages it will be passed only val, chan, and src.

argument:: msgNum
An link::Classes/Integer:: indicating the MIDI message number (note number, control number, or programme number) for this MIDIFunc. This can be an array. If nil, the MIDIFunc will respond to messages of all possible message numbers.

argument:: chan
An link::Classes/Integer:: indicating the MIDI channel number for this MIDIFunc. This can be an array. If nil, the MIDIFunc will respond to messages received on all channels.

argument:: msgType
A link::Classes/Symbol:: indicating which kind of MIDI message this MIDIFunc should respond to. One of code::\noteOn::, code::\noteOff::, code::\control::, code::\touch::, code::\polytouch::, code::\bend::, or code::program::.

argument:: srcID
An link::Classes/Integer:: corresponding to the uid of the MIDI input. (See link::Classes/MIDIClient::.) If nil, the MIDIFunc will respond to messages received from all sources.

argument:: argTemplate
An optional link::Classes/Integer:: or link::Classes/Function:: (or object which responds to the method link::Overviews/Methods#matchItem::) used to match the value of an incoming MIDI message. (e.g. velocity, control value, program number, etc.). If a Function, it will be evaluated with the message value as an argument, and should return a link::Classes/Boolean:: indicating whether the message matches and this MIDIFunc should respond.

argument:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed.

returns:: A new instance of MIDIFunc.

METHOD:: cc
A convenience method to create a new MIDIFunc which responds to MIDI control messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI control messages.

METHOD:: noteOn
A convenience method to create a new MIDIFunc which responds to MIDI note on messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI note on messages.

METHOD:: noteOff
A convenience method to create a new MIDIFunc which responds to MIDI note off messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI note off messages.

METHOD:: polytouch
A convenience method to create a new MIDIFunc which responds to MIDI polytouch messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI polytouch messages.

METHOD:: touch
A convenience method to create a new MIDIFunc which responds to MIDI touch messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI touch messages.

METHOD:: bend
A convenience method to create a new MIDIFunc which responds to MIDI bend messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI bend messages.

METHOD:: program
A convenience method to create a new MIDIFunc which responds to MIDI program change messages. See link::#*new:: for argument descriptions.

returns:: A new instance of MIDIFunc which responds to MIDI program change messages.

METHOD:: trace
A convenience method which dumps all incoming MIDI messages.

argument:: bool
A link::Classes/Boolean:: indicating whether dumping is on or off.

INSTANCEMETHODS::
private:: init, printOn

METHOD:: chan
Get this MIDIFunc's MIDI channel number.

returns:: An link::Classes/Integer::.

METHOD:: msgNum
Get this MIDIFunc's MIDI message number.

returns:: An link::Classes/Integer::.

METHOD:: msgType
Get this MIDIFunc's message type.

returns:: A link::Classes/Symbol::; one of code::\noteOn::, code::\noteOff::, code::\control::, code::\touch::, code::\polytouch::, code::\bend::, or code::program::.


EXAMPLES::

code::
MIDIIn.connectAll
MIDIFunc.cc({arg ...args; args.postln}, 1); // match cc 1
MIDIFunc.cc({arg ...args; args.postln}, 1, 1); // match cc1, chan 1
MIDIFunc.cc({arg ...args; args.postln}, (1..10)); // match cc 1-10
MIDIFunc.noteOn({arg ...args; args.postln}); // match any noteOn

MIDIIn.doNoteOnAction(1, 1, 64, 64); // spoof a note on
MIDIIn.doControlAction(1, 1, 1, 64); // spoof a cc
MIDIIn.doControlAction(1, 1, 9, 64);
MIDIIn.doControlAction(1, 10, 1, 64);
::
** CLASS:: MIDIFuncBothCAMessageMatcher				       :midi:
summary:: Matches incoming MIDI messages to responder funcs based on message channel and source
categories:: External Control>MIDI>Matchers
related:: Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothMessageMatcher

DESCRIPTION::
This is used by link::Classes/MIDIMessageDispatcher:: to match incoming MIDI messages to instances of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: using message source and MIDI channel (when the MIDIFunc specifies an array of channels). This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: chanArray
(describe argument here)

argument:: srcID
The UID of the MIDI source to test against as an link::Classes/Integer::.

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An MIDIFuncBothCAMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaulate func if it does.

argument:: value
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: testChan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: testSrc
The UID of the source of the MIDI message as an link::Classes/Integer::.
** CLASS:: MIDIFuncBothMessageMatcher				       :midi:
summary:: Matches incoming MIDI messages to responder funcs based on message channel and source
categories:: External Control>MIDI>Matchers
related:: Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothCAMessageMatcher

DESCRIPTION::
This is used by link::Classes/MIDIMessageDispatcher:: to match incoming MIDI messages to instances of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: using message source and MIDI channel. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: chan
(describe argument here)

argument:: srcID
The UID of the MIDI source source to test against as an link::Classes/Integer::.

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An MIDIFuncBothMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaulate func if it does.

argument:: value
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: testChan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: testSrc
The UID of the source of the MIDI message as an link::Classes/Integer::.
** CLASS:: MIDIFuncChanArrayMessageMatcher			       :midi:
summary:: Matches incoming MIDI messages to responder funcs based on message channel
categories:: External Control>MIDI>Matchers
related:: Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothMessageMatcher, Classes/MIDIFuncBothCAMessageMatcher

DESCRIPTION::
This is used by link::Classes/MIDIMessageDispatcher:: to match incoming MIDI messages to instances of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: using MIDI channel (when the MIDIFunc specifies an array of channels). This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: chanArray
(describe argument here)

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An MIDIFuncChanArrayMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaulate func if it does.

argument:: value
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: testChan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: srcID
The UID of the source of the MIDI message as an link::Classes/Integer::.
** CLASS:: MIDIFuncChanMessageMatcher				       :midi:
summary:: Matches incoming MIDI messages to responder funcs based on message channel
categories:: External Control>MIDI>Matchers
related:: Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothMessageMatcher, Classes/MIDIFuncBothCAMessageMatcher

DESCRIPTION::
This is used by link::Classes/MIDIMessageDispatcher:: to match incoming MIDI messages to instances of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: using MIDI channel. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: chan
(describe argument here)

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An MIDIFuncChanMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaulate func if it does.

argument:: value
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: testChan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: srcID
The UID of the source of the MIDI message as an link::Classes/Integer::.
** CLASS:: MIDIFuncSrcMessageMatcher				       :midi:
summary:: Matches incoming MIDI messages to responder funcs based on message source
categories:: External Control>MIDI>Matchers
related:: Classes/AbstractMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothMessageMatcher, Classes/MIDIFuncBothCAMessageMatcher

DESCRIPTION::
This is used by link::Classes/MIDIMessageDispatcher:: to match incoming MIDI messages to instances of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: using message source. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: srcID
The UID of the MIDI source to test against as an link::Classes/Integer::.

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An MIDIFuncSrcMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaulate func if it does.

argument:: value
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: chan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: testSrc
The UID of the source of the MIDI message as an link::Classes/Integer::.
** CLASS:: MIDIFuncSrcMessageMatcherNV				       :midi:
summary:: Matches incoming MIDI messages to responder funcs based on message source
categories:: External Control>MIDI>Matchers
related:: Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncBothMessageMatcher, Classes/MIDIFuncBothCAMessageMatcher

DESCRIPTION::
This is used by link::Classes/MIDIMessageDispatcherNV:: to match incoming MIDI messages to instances of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: using message source. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::


INSTANCEMETHODS::

METHOD:: value
Check to see if a message matches, and evaulate func if it does.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: chan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: testSrc
The UID of the source of the MIDI message as an link::Classes/Integer::.
** class:: MIDIIn						       :midi:
   :PROPERTIES:
   :ID:       2DC112D6-791F-42D5-A3FC-98328CF31A89
   :END:
summary:: receive MIDI messages
related:: Classes/MIDIOut, Classes/MIDIFunc, Classes/MIDIdef, Guides/MIDI, Guides/UsingMIDI
categories:: External Control>MIDI

description::
This document explains technical details of the MIDI hardware interface class, MIDIIn.

MIDIIn is a simple and direct interface. When MIDI events come into Super Collider, MIDIIn evaluates simple handler functions.

note::
For general programming, strong::users should not use the MIDIIn class directly::. See the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes for higher level event matching and more flexible handling of event handlers.
::

Certain MIDI messages are supported only through MIDIIn. These are: sysex, sysrt, smpte.

See the link::Guides/UsingMIDI:: helpfile for practical considerations and techniques for using MIDI in SC.

subsection::The MIDIIn class

MIDIIn links MIDI input received from the operating system to a set of user defined functions. Only one set of MIDI input handling functions can be active at a time, they are stored in the following class variables:

	noteOff, noteOn, polytouch, control, program, touch, bend, sysex, sysrt, smpte

The first argument these functions receive is an unique identifier that specifies the source of the data.


ClassMethods::

private::prDispatchEvent, connectByUID, disconnectByUID

method::findPort
searches for a connected link::Classes/MIDIEndPoint:: by name.
code::
//list connected ins:
MIDIClient.init;
MIDIClient.sources;
::

method::addFuncTo
Add a link::Classes/Function:: or similar object to be evaluated whenever a particular MIDI message is received. This method is preferable to the setters below, since it will not overwrite any existing functions.

argument::what
A link::Classes/Symbol:: indicating the message type to wait for, one of code::'noteOn':: code::'noteOff'::, code::'polytouch'::, code::'control'::, code::'program'::, code::'touch'::, code::'bend'::, code::'sysex'::, code::'sysrt'::, code::'smpte'::, or code::'invalid':: (for invalid sysex messages).

argument::func
A link::Classes/Function:: or similar object to be evaluated when a message of the specified type is received. See the setters below for the arguments which will be passed at evaluation time.

method::removeFuncFrom
Remove a link::Classes/Function:: or similar object from the list of those to be evaluated whenever a particular MIDI message is received. This method is preferable to the setters below, since it will leave any existing functions in place.

argument::what
A link::Classes/Symbol:: indicating the message type, one of code::'noteOn':: code::'noteOff'::, code::'polytouch'::, code::'control'::, code::'program'::, code::'touch'::, code::'bend'::, code::'sysex'::, code::'sysrt'::, code::'smpte'::, or code::'invalid':: (for invalid sysex messages).

argument::func
The link::Classes/Function:: or similar object to be removed.

method::replaceFuncTo
Replace a link::Classes/Function:: or similar object in the list to be evaluated whenever a particular MIDI message is received with another one. This method is preferable to the setters below, since it will not overwrite any existing functions.

argument::what
A link::Classes/Symbol:: indicating the message type to wait for, one of code::'noteOn':: code::'noteOff'::, code::'polytouch'::, code::'control'::, code::'program'::, code::'touch'::, code::'bend'::, code::'sysex'::, code::'sysrt'::, code::'smpte'::, or code::'invalid':: (for invalid sysex messages).

argument::func
The link::Classes/Function:: or similar object to be replaced.

argument::newFunc
A link::Classes/Function:: or similar object to be evaluated when a message of the specified type is received. See the setters below for the arguments which will be passed at evaluation time.

subsection:: Getter/Setters for Specific Message Types

The methods below allow you to register a function to respond to a particular message type.

note::It is preferable to use the link::#*addFuncTo::, link::#*removeFuncFrom:: and link::#*replaceFuncTo:: methods above instead of these methods, as they will not overwrite any functions added by system objects.::

method::noteOn
argument::value
a link::Classes/Function:: evaluated whenever a MIDI noteOn message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## keyNumber || 0 - 127
## velocity || 0 - 127
::

method::noteOff
argument::value
a link::Classes/Function:: evaluated whenever a MIDI noteOff message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## keyNumber || 0 - 127
## velocity || 0 - 127 (typically 64 unless noteOff velocity is supported)
::

method::polytouch
argument::value
a link::Classes/Function:: evaluated whenever a MIDI polytouch message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## keyNumber || 0 - 127
## pressure || 0 - 127
::

method::control
argument::value
a link::Classes/Function:: evaluated whenever a MIDI control change message (CC) is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## controllerNumber || 0 - 127
## value || 0 - 127
::

method::program
argument::value
a link::Classes/Function:: evaluated whenever a MIDI program change message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## programNumber || 0 - 127
::

method::touch
argument::value
a link::Classes/Function:: evaluated whenever a MIDI after-touch message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## pressure || 0 - 127
::

method::bend
argument::value
a link::Classes/Function:: evaluated whenever a MIDI pitch wheel change message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## MIDIchannel || ranges from 0 to 15
## bend || 0 - 16383 (14bits, the midpoint is 8192)
::

method::sysex
note::
The current implementation assembles a complete system exclusive packet before evaluating the function.
::
argument::value
a link::Classes/Function:: evaluated whenever a MIDI System Exclusive message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## data || an link::Classes/Int8Array:: (includes f0 and f7). See manufacturer references for details.
::

method::sysrt
table::
## strong::index:: || strong::data:: || strong::message::
## 2 || 14bits || song pointer
## 3 || 7bits || song select
## 8 || || midiclock
## 10 || || start
## 11 || || continue
## 12 || || stop
::
argument::value
a link::Classes/Function:: evaluated whenever a MIDI System Real-Time message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## index || ranges from 0 to 15
## data ||
::

method::smpte
Over MIDI, SMPTE is transmitted at 1/4 frame intervals four times faster than the frame rate.
table::
## strong::index:: || strong::data::
## 0 || frames low nibble
## 1 || frames hi nibble
## 2 || seconds low nibble
## 3 || seconds hi nibble
## 4 || minutes low nibble
## 5 || minutes hi nibble
## 6 || hours low nibble
## 7 || hours hi emphasis::bit:: OR'ed with frameRate
list::
## 0 -> 24 fps
## 2 -> 25 fps
## 4 -> 30 fps drop frame
## 6 -> 30 fps
::
::
Nibbles are sent in ascending order.
argument::value
a link::Classes/Function:: evaluated whenever a MIDI smpte message is received. It is passed the following arguments:
definitionList::
## uid || unique identifier of the MIDI port
## index || ranges from 0 to 7
## data || 0 - 15 (4bits)
::

Examples::

subsection::Quick start for 1 port
code::
(
MIDIIn.connect;	// init for one port midi interface
// register functions:
~noteOff = { arg src, chan, num, vel;	[chan,num,vel / 127].postln; };
~noteOn = { arg src, chan, num, vel;	[chan,num,vel / 127].postln; };
~polytouch = { arg src, chan, num, vel;	[chan,num,vel / 127].postln; };
~control = { arg src, chan, num, val;	[chan,num,val].postln; };
~program = { arg src, chan, prog;		[chan,prog].postln; };
~touch = { arg src, chan, pressure;	[chan,pressure].postln; };
~bend = { arg src, chan, bend;		[chan,bend - 8192].postln; };
~sysex = { arg src, sysex;		sysex.postln; };
~sysrt = { arg src, chan, val;		[chan,val].postln; };
~smpte = { arg src, chan, val;		[chan,val].postln; };
MIDIIn.addFuncTo(\noteOn, ~noteOn);
MIDIIn.addFuncTo(\noteOff, ~noteOff);
MIDIIn.addFuncTo(\polytouch, ~polytouch);
MIDIIn.addFuncTo(\control, ~control);
MIDIIn.addFuncTo(\program, ~program);
MIDIIn.addFuncTo(\touch, ~touch);
MIDIIn.addFuncTo(\bend, ~bend);
MIDIIn.addFuncTo(\sysex, ~sysex);
MIDIIn.addFuncTo(\sysrt, ~sysrt);
MIDIIn.addFuncTo(\smpte, ~smpte);
)

//cleanup
(
MIDIIn.removeFuncFrom(\noteOn, ~noteOn);
MIDIIn.removeFuncFrom(\noteOff, ~noteOff);
MIDIIn.removeFuncFrom(\polytouch, ~polytouch);
MIDIIn.removeFuncFrom(\control, ~control);
MIDIIn.removeFuncFrom(\program, ~program);
MIDIIn.removeFuncFrom(\touch, ~touch);
MIDIIn.removeFuncFrom(\bend, ~bend);
MIDIIn.removeFuncFrom(\sysex, ~sysex);
MIDIIn.removeFuncFrom(\sysrt, ~sysrt);
MIDIIn.removeFuncFrom(\smpte, ~smpte);
)
::

subsection::Quick start for 2 or more ports
code::
(
	var inPorts = 2;
	var outPorts = 2;
	MIDIClient.init(inPorts,outPorts);	// explicitly intialize the client
	inPorts.do({ arg i;
		MIDIIn.connect(i, MIDIClient.sources.at(i));
	});
)
::

subsection::example with sound
code::
MIDIIn.connect;
s = Server.local;
s.boot;

(
SynthDef("sik-goo", { arg freq=440,formfreq=100,gate=0.0,bwfreq=800;
	var x;
	x = Formant.ar(
		SinOsc.kr(0.02, 0, 10, freq),
		formfreq,
		bwfreq
	);
	x = EnvGen.kr(Env.adsr, gate,Latch.kr(gate,gate)) * x;
	Out.ar(0, x);
}).add;
)

x = Synth("sik-goo");

//set the action:
(
~noteOn = {arg src, chan, num, vel;
	x.set(\freq, num.midicps / 4.0);
	x.set(\gate, vel / 200 );
	x.set(\formfreq, vel / 127 * 1000);
};
MIDIIn.addFuncTo(\noteOn, ~noteOn);

~noteOff = { arg src,chan,num,vel;
	x.set(\gate, 0.0);
};
MIDIIn.addFuncTo(\noteOff, ~noteOff);

~bend = { arg src,chan,val;
	//(val * 0.048828125).postln;
	x.set(\bwfreq, val * 0.048828125 );
};
MIDIIn.addFuncTo(\bend, ~bend);
)

//cleanup
MIDIIn.removeFuncFrom(\noteOn, ~noteOn);
MIDIIn.removeFuncFrom(\noteOff, ~noteOff);
MIDIIn.removeFuncFrom(\bend, ~bend);
::

subsection::writing to the bus rather than directly to the synth
code::
//i used this and got acceptable latency for triggering synths live.
//The latency might actually be less than sc2, but i haven't used it enough
//to tell for sure yet.
//Powerbook G4, 512mb ram.
//- matrix6k@somahq.com

s = Server.local;
s.boot;

(
SynthDef("moto-rev", { arg ffreq=100;
	var x;
	x = RLPF.ar(LFPulse.ar(SinOsc.kr(0.2, 0, 10, 21), [0,0.1], 0.1),
		ffreq, 0.1)
		.clip2(0.4);
	Out.ar(0, x);
}).add;
)

b = Bus.control(s);

x = Synth("moto-rev");

// map the synth's first input (ffreq) to read
// from the bus' output index
x.map(0, b);


MIDIIn.connect;
//set the action:
(
~noteOn = {arg src, chan, num, vel;
	b.value = num.midicps.postln;
};
MIDIIn.addFuncTo(\noteOn, ~noteOn);

~control = {arg src, chan, num, val;
	[chan,num,val].postln;
};
MIDIIn.addFuncTo(\control, ~control);

~bend = {arg src, chan, val;
	val.postln;
};
MIDIIn.addFuncTo(\bend, ~bend);
)

// cleanup
x.free;
b.free;
MIDIIn.removeFuncFrom(\noteOn, ~noteOn);
MIDIIn.removeFuncFrom(\control, ~control);
MIDIIn.removeFuncFrom(\bend, ~bend);
::

subsection::Keyboard Split for two voices
code::
//pbend to cutoff, mod to rez, 7 to amp
//- matrix6k@somahq.com

s.boot;
(
SynthDef("funk",{ arg freq = 700, amp = 0.2, gate = 1, cutoff = 20000, rez = 1, lfospeed=0;
	var e,x,env,range,filterfreq;
	e = Env.new([0, 0.1, 0.1, 0], [0, 0.1, 0.1], 'linear', 2);
	env=Env.adsr(0.3,1,1,1);
	range = cutoff -1;
	filterfreq = SinOsc.kr(lfospeed,0, range, cutoff).abs;
	x = RLPF.ar(Mix.ar([
			Mix.arFill(2, {Saw.ar(freq *2 + 0.2.rand2, amp)}),
			Mix.arFill(2, {Saw.ar(freq *4+ 0.2.rand2, amp)})
		]),
		EnvGen.kr(env,gate)*filterfreq,
		rez);
	Out.ar([0,1],x * EnvGen.kr(e, gate, doneAction: 2))
}).add;

SynthDef("strings",{ arg freq = 700, amp = 0.2, gate = 1;
	var x,enve;
	enve = Env.new([0, 0.1, 0.1, 0], [2, 0.1, 1], 'linear', 2);
	x = RLPF.ar(Mix.ar([
			Mix.arFill(2, {Saw.ar(freq +2.rand2,0.6)}),
			Mix.arFill(2, {Saw.ar(freq *0.5 + 2.rand2,0.6)})
		]),
		6000,1);
	Out.ar([0,1],x * EnvGen.kr(enve, gate, doneAction: 2))
}).add;
)

(
var keys, cutspec, cutbus, rezspec, rezbus, lfospec, lfobus;
keys = Array.newClear(128);

MIDIClient.init;
MIDIIn.connect(0, MIDIClient.sources.at(0));

g = Group.new;

cutspec = ControlSpec(100,10000,\linear,0.001);
cutbus = Bus.new(\control,1,1,s);
cutbus.value = 10000;

rezspec = ControlSpec(1,0,\linear,0.001);
rezbus = Bus.new(\control,2,1,s);
rezbus.value = 1.0;

lfospec = ControlSpec(0,50,\linear,0.001);
lfobus = Bus.new(\control,3,1,s);

~control = {arg src, chan, num, val;
	if(num == 1,{
		rezbus.value = rezspec.map(val/127.0);
	});
	if(num == 7,{
		lfobus.value = lfospec.map(val/127.0).postln;
	});
};
MIDIIn.addFuncTo(\control, ~control);

~bend = {arg src, chan, val;
	cutbus.value = cutspec.map(val/16383.0);
};
MIDIIn.addFuncTo(\bend, ~bend);

~noteOn = {arg src, chan, num, vel;
	var node;
	if(num < 60, {
		node = Synth.tail(g, "funk", [\freq, num.midicps, \amp, vel/255]);
		node.map("cutoff",1,"rez",2,"lfospeed",3);
//		node = Synth.basicNew("funk",s);
//		s.sendBundle(nil,
//			node.addToTailMsg(g,[\freq, num.midicps, \amp, vel/255]),
//			node.mapMsg("cutoff",1,"rez",2,"lfospeed",3)
//		);
		keys.put(num, node)
	},{
		node = Synth.tail(g, "strings", [\freq, num.midicps, \amp, vel/255]);
		keys.put(num, node)
	});
};
MIDIIn.addFuncTo(\noteOn, ~noteOn);

~noteOff = {arg src, chan, num, vel;
	var node;
	node = keys.at(num);
	if (node.notNil, {
		keys.put(num, nil);
		s.sendMsg("/n_set", node.nodeID, "gate", 0);
		// or node.release
		// then free it ... or get the NodeWatcher to do it
	});
};
MIDIIn.addFuncTo(\noteOff, ~noteOff);
)

//cleanup
MIDIIn.removeFuncFrom(\noteOn, ~noteOn);
MIDIIn.removeFuncFrom(\control, ~control);
MIDIIn.removeFuncFrom(\bend, ~bend);

::
** CLASS:: MIDIMessageDispatcher				       :midi:
summary:: The default dispatcher for MIDIFunc's and MIDIdef's set to respond to noteOn, noteOff, control, and polytouch messages.
categories:: External Control>MIDI>Dispatchers
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/AbstractWrappingDispatcher, Classes/AbstractDispatcher, Classes/MIDIMessageDispatcherNV, Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothMessageMatcher, Classes/MIDIFuncBothCAMessageMatcher, Guides/MIDI

DESCRIPTION::
MIDIMessageDispatcher is used to dispatch incoming MIDI noteOn, noteOff, control, and polytouch messages to matching functions. Normally users should not have to create or message instances of this class directly.


CLASSMETHODS::

METHOD:: new
Create a new instance.

argument:: messageType
A link::Classes/Symbol:: indicating the message type, one of code::\noteOn::, code::\noteOff::, code::\control::, or code::\polytouch::.

returns:: A new MIDIMessageDispatcher.


INSTANCEMETHODS::

METHOD:: messageType
Get this dispatcher's message type, one of code::\noteOn::, code::\noteOff::, code::\control::, or code::\polytouch::.

returns:: A link::Classes/Symbol::.

METHOD:: getKeysForFuncProxy
Get the keys at which a responder func's functions are stored in this dispatcher's active dictionary. The keys will be MIDI message numbers.

argument:: funcProxy
The link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: whose keys should be returned.

returns:: An link::Classes/Array:: containing the funcProxy's message number as an link::Classes/Integer::.

METHOD:: value
Attempt to match an incoming MIDI message with this dispatcher's responder funcs, and evaluate their functions for all matches found.

argument:: src
The UID of the source of the MIDI message as an link::Classes/Integer::.

argument:: chan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: num
The message number (e.g. note number, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

argument:: val
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

METHOD:: register
Adds this dispatcher to the appropriate receive hook in link::Classes/MIDIIn::.

METHOD:: unregister
Removes this dispatcher from the appropriate receive hook in link::Classes/MIDIIn::.

METHOD:: wrapFunc
Called internally to wrap functions in message matcher objects, if needed.

argument:: funcProxy
An instance of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: whose function(s) are to be wrapped.

METHOD:: typeKey
Gets a key indicating the type of message this dispatcher responds to, in the form: code::('MIDI ' ++ messageType).asSymbol::.

returns:: A link::Classes/Symbol::.

** CLASS:: MIDIMessageDispatcherNV				       :midi:
summary:: The default dispatcher for MIDIFunc's and MIDIdef's set to respond to touch, program, and bend messages.
categories:: External Control>MIDI>Dispatchers
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/AbstractWrappingDispatcher, Classes/AbstractDispatcher, Classes/MIDIMessageDispatcher, Classes/AbstractMessageMatcher, Classes/MIDIFuncSrcMessageMatcher, Classes/MIDIFuncChanMessageMatcher, Classes/MIDIFuncChanArrayMessageMatcher, Classes/MIDIFuncSrcMessageMatcherNV, Classes/MIDIFuncBothMessageMatcher, Classes/MIDIFuncBothCAMessageMatcher, Guides/MIDI

DESCRIPTION::
MIDIMessageDispatcherNV is used to dispatch incoming MIDI touch, program, and bend messages to matching functions. Normally users should not have to create or message instances of this class directly.


CLASSMETHODS::


INSTANCEMETHODS::

METHOD:: getKeysForFuncProxy
Get the keys at which a responder func's functions are stored in this dispatcher's active dictionary. The keys will be MIDI channels.

argument:: funcProxy
The link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: whose keys should be returned.

returns:: An link::Classes/Array:: containing the funcProxy's channel number as an link::Classes/Integer::.

METHOD:: value
Attempt to match an incoming MIDI message with this dispatcher's responder funcs, and evaluate their functions for all matches found.

argument:: src
The UID of the source of the MIDI message as an link::Classes/Integer::.

argument:: chan
The channel number of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-15.

argument:: val
The message value (e.g. velocity, etc.) of the MIDI message as an link::Classes/Integer::. Note this should be in the range 0-127.

METHOD:: wrapFunc
Called internally to wrap functions in message matcher objects, if needed.

argument:: funcProxy
An instance of link::Classes/MIDIFunc:: or link::Classes/MIDIdef:: whose function(s) are to be wrapped.

** class:: MIDIOut						       :midi:
summary:: send MIDI messages
related:: Classes/MIDIIn, Guides/MIDI, Guides/UsingMIDI
categories:: External Control>MIDI

description::
a MIDIOut is bound to a specific link::Classes/MIDIEndPoint:: as defined by the operating system.

ClassMethods::

private::connectByUID, disconnectByUID

method::new

argument::port
the index of the MIDIEndPoint in the code::MIDIClient.destinations:: array.

argument::uid
definitionList::
## Mac OSX / Windows || uid is optional; if specified, it should be the uid of that port ie. MIDIClient.destinations[port].uid. If you don't provide a uid, the correct uid will be filled in for you (easier).
## Linux || using the uid is optional as described below.
::

method::newByName
Searches for the device by name. This is safer then depending on the index which will change if your studio setup changes.
code::
//list connected out ports with names:
MIDIClient.init;
MIDIClient.destinations;
::

method::findPort
Searches for a connected MIDIEndPoint by name.
code::
//list connected out ports with names:
MIDIClient.init;
MIDIClient.destinations;
::

method::connect, disconnect
Linux only. OS X does not need to connect. On Linux it is an optional feature (see below).

InstanceMethods::

private::send, prSysex

method::latency
This sets the latency with which a midi event is sent out. Per default this is set to 0.2, in order to be equal to the Server.latency.
note::
On Linux there seems to be an ALSA or kernel bug if the latency is larger than 0, for some Linux kernels. If MIDIOut does not seem to work, set the latency to 0.
::

Examples::

code::
MIDIClient.init;

m = MIDIOut(0);
m.noteOn(16, 60, 60);
m.noteOn(16, 61, 60);
m.noteOff(16, 61, 60);
m.allNotesOff(16);


MIDIIn.connect; // 1 port midi interface
MIDIIn.sysex = { arg uid, packet; [uid,packet].postln };
MIDIIn.sysrt = { arg src, chan, val;  [src, chan, val].postln; };
MIDIIn.smpte = { arg src, chan, val;  [src, chan, val].postln; };

m.sysex(Int8Array[ 16rf0, 0, 0, 27, 11, 0,16rf7])

m.smpte(24, 16)
m.midiClock
m.start
m.continue
m.stop
::

subsection::Using patterns for sending MIDI events

code::
MIDIClient.init;
m = MIDIOut(0);

a = Pbind(\degree, Prand([1, 2, 3, [0, 5]], inf), \bend, Pwhite(0, 76, inf));


// chain a midi event into the pattern and play it (see Pchain)

(a <> (type: \midi, midiout: m)).play;
::

See link::Tutorials/A-Practical-Guide/PG_08_Event_Types_and_Parameters#MIDI output:: for a list of midi commands supported by the 'midi' event type.

subsection::Linux specific: Connecting and disconnecting ports

On Linux, a MIDIOut can be created without setting the destination:

code::
m = MIDIOut(0);
::

In this case each message will be sent to all ports connected to SuperCollider's first MIDI output.

A connection can be made through:

code::
m.connect( 2 );
::

Note that by connecting in this way, you can connect more than one destination to the MIDI output.
You can also use other tools to connect to a MIDIOut port of SC, e.g. through aconnect or QJackCtl (on the ALSA tab).

If you set the uid in MIDIOut, a direct connection is established and data will only be sent to that MIDI input port, and not to any other connections made to SC's MIDI output port (through the connect message or external tools).

subsection::OS X specific: Sending MIDI to other applications

Open the Audio MIDI Setup application. Double-click on IAC Driver and check "device is online".

reinitialize:

MIDIClient.init(numIns,numOuts)

The IAC Bus will now appear in MIDIClient.destinations. It will appear first, which means that any code that you have written that addresses the first physical bus as 0 will now have to be changed.

For this reason it is always safer to find the port by name :
code::
MIDIOut.newByName("RemoteSL IN","Port 1");
::
The IAC Bus will now also appear to other applications.


MIDIMonitor (freeware) can be very useful for troubleshooting:

http://www.snoize.com/MIDIMonitor/

subsection::Sysex example

a machinedrum manual say sysex commands should be formatted like this...
code::
$f0,$00,$20,$3c,$02,$00,command,...,$f7
::

and to set the tempo the machinedrum expects this command...
code::
$61 | Set tempo ID
%0aaaaaaa | Upper bits
%0bbbbbbb | Lower bits
$f7 | SYSEX end
Note: Tempo = %aaaaaaabbbbbbb / 24, max 300 BPM, min 30 BPM
::

so to create and send a valid set tempo sysex command from SuperCollider to this machinedrum do...
code::
MIDIClient.init;
m = MIDIOut(0);
m.sysex(Int8Array[0xf0, 0x00, 0x20, 0x3c, 0x02, 0x00, 0x61, 21, 54, 0xf7]);
::

This will set the tempo to 114.23 bpm. One can calculate the upper and lower 7bit values like this...
code::
(
var bpm, val, upper, lower;
bpm = 114.23;
val = (bpm*24).round.asInteger;
upper = val&2r11111110000000>>7;
lower = val&2r00000001111111;
[upper, lower].postln;
)
::
where the resulting 21 and 54 are the same as 2r0010101 and 2r0110110 in binary notation.
** class:: MIDIResponder					       :midi:
summary:: Register multiple functions to be evaluated when MIDI events occur
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIIn, Guides/MIDI, Guides/UsingMIDI
categories:: External Control>MIDI

description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef:: They still lack some features of the MIDIresponder classes.::

MIDIResponder is an emphasis::abstract:: class. Its subclasses allow functions to be registered to respond to midi events.

Read the general help file here and then see the individual help files.

definitionList::
## link::Classes/CCResponder:: || Respond to control messages
## link::Classes/NoteOnResponder:: || Respond to note-on messages
## link::Classes/NoteOffResponder:: || Respond to note-off messages
## link::Classes/BendResponder:: || Respond to pitch bend messages
## link::Classes/TouchResponder:: || Respond to aftertouch messages
## link::Classes/ProgramChangeResponder:: || Respond to programchange messages
::

subsection::Creation and initialization

list::
## CCResponder(function, src, chan, num, value, install = true, swallowEvent = false)
## NoteOnResponder(function, src, chan, num, veloc, install = true, swallowEvent = false)
## NoteOffResponder(function, src, chan, num, veloc, install = true, swallowEvent = false)
## BendResponder(function, src, chan, value, install = true, swallowEvent = false)
## TouchResponder(function, src, chan, value, install = true, swallowEvent = false)
## ProgramChangeResponder(function, src, chan, value, install = true)
::

definitionList::

## function || The function to execute when the incoming MIDI event matches the responder. The function takes the arguments src, chan, A, B (or for Bend, ProgramChange and Touch: src, chan, value).

## src || If a number is given, the responder will fire only for messages coming in from this port. The number may be the system UID (obtained from MIDIClient.sources[index].uid) or the index itself. If nil, the responder will match any port.

## chan || The MIDI channel(s) to match.

## num || The control or note number(s) to match.

## value || The value(s) to match.

## veloc || The velocities to match.

## install || If true, install the responder automatically so it is active and ready to respond. If false, then it will be inactive.

## swallowEvent || If true, then if the midi event is matched, cease testing any further responders. eg. if a CCResponder matches port, chan and num, and swallowEvent is set to true, then no further CCResponders will be offered the chance to respond to the event. The event is "swallowed". By default this is false. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

::

Any of the matching values may be one of the following:

definitionList::
## Nil || Match anything. eg. if chan is nil, then respond to any MIDI channel.
## Integer || Match only this specific number.
## Array || Match any item in the array. Any kind of link::Classes/Collection:: will work here.
## Function || Evaluate the function with the incoming value as the argument. The function should return true or false.
::

For instance, the following example would respond to note on messages from any port, channels 2 and 7 only, even numbered note numbers only, and only velocity values greater than 50.
code::
NoteOnResponder({ |src, chan, num, vel| [src, chan, num, vel].postln },
	nil,	// any port
	[2, 7],	// midi channels 2 or 7 only
	(0, 2..126),	// this is an array of even numbers. could also be specified as { |num| num.even } or _.even
	{ |vel| vel > 50 });	// velocities greater than 50
::

MIDIResponders automatically initialize the MIDIClient with 1 standard device. This means the first time you install any MIDIResponder, it will make sure that MIDI has been initialized. If you have more devices or a specific setup, simply initialize the MIDIClient yourself before using any MIDIResponders.

subsection::Removal

Just call .remove on the responder.
code::
c = CCResponder({ ... }, num: 1);	// respond to any modwheel

c.remove;		// stop this responder
::

Or remove all of a specific class:
code::
CCResponder.removeAll
NoteOnResponder.removeAll
NoteOffResponder.removeAll
BendResponder.removeAll
TouchResponder.removeAll
ProgramChange.removeAll
::

or remove all midi responders in all classes:
code::
MIDIResponder.removeAll
::
** CLASS:: MIDIdef						       :midi:
   :PROPERTIES:
   :ID:       DF568AFF-16DA-453E-A541-29D701762350
   :END:
summary:: MIDI response reference definition
categories:: External Control>MIDI
related:: Guides/MIDI, Classes/MIDIdef

DESCRIPTION::
MIDIdef provides a global reference to the functionality of its superclass link::Classes/MIDIFunc::. Essentially it stores itself at a key within a global dictionary, allowing replacement at any time. Most methods are inherited from its superclass.

note:: MIDIdef and link::Classes/MIDIFunc:: aim to improve upon the MIDIresponder classes by being faster and easier to use. They were made with the intention of creating a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. As of this time, however, they still lack some features of the MIDIresponder classes, notably the learn method. Note that unlike those classes, MIDIdefs are removed on Cmd-. by default. This can be overriden using either of the fix or permanent methods.::


CLASSMETHODS::
private:: initClass

METHOD:: all
Get the global dictionary of all MIDIdefs.

returns:: An link::Classes/IdentityDictionary::.

METHOD:: new
Create a new, enabled MIDIdef. If a MIDIdef already exists at this key, its parameters will be replaced with the ones provided (args for which nil is passed will use the old values). Normally one would use one of the message type specific convenience methods below, rather than use this method directly.

argument:: key
The key at which to store this OSCdef in the global collection. Generally this will be a link::Classes/Symbol::.

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated for noteOn, noteOff, control, and polytouch messages it will be passed the arguments val, num, chan, and src, corresponding to the message value (e.g. velocity, control value, etc.), message number (e.g. note number), MIDI channel, and MIDI source uid. For touch, programme change and bend messages it will be passed only val, chan, and src.

argument:: msgNum
An link::Classes/Integer:: indicating the MIDI message number (note number, control number, or programme number) for this MIDIdef. This can be an array. If nil, the MIDIdef will respond to messages of all possible message numbers.

argument:: chan
An link::Classes/Integer:: indicating the MIDI channel number for this MIDIdef. This can be an array. If nil, the MIDIdef will respond to messages received on all channels.

argument:: msgType
A link::Classes/Symbol:: indicating which kind of MIDI message this MIDIdef should respond to. One of code::\noteOn::, code::\noteOff::, code::\control::, code::\touch::, code::\polytouch::, code::\bend::, or code::program::.

argument:: srcID
An link::Classes/Integer:: corresponding to the uid of the MIDI input. (See link::Classes/MIDIClient::.) If nil, the MIDIdef will respond to messages received from all sources.

argument:: argTemplate
An optional link::Classes/Integer:: or link::Classes/Function:: (or object which responds to the method link::Overviews/Methods#matchItem::) used to match the value of an incoming MIDI message. (e.g. velocity, control value, program number, etc.). If a Function, it will be evaluated with the message value as an argument, and should return a link::Classes/Boolean:: indicating whether the message matches and this MIDIdef should respond.

argument:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed.

returns:: An instance of MIDIdef.

METHOD:: cc
A convenience method to create a new MIDIdef which responds to MIDI control messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI control messages.

METHOD:: noteOn
A convenience method to create a new MIDIdef which responds to MIDI note on messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI note on messages.

METHOD:: noteOff
A convenience method to create a new MIDIdef which responds to MIDI note off messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI note off messages.

METHOD:: polytouch
A convenience method to create a new MIDIdef which responds to MIDI polytouch messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI polytouch messages.

METHOD:: touch
A convenience method to create a new MIDIdef which responds to MIDI touch messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI touch messages.

METHOD:: bend
A convenience method to create a new MIDIdef which responds to MIDI bend messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI bend messages.

METHOD:: program
A convenience method to create a new MIDIdef which responds to MIDI program change messages. See link::#*new:: for argument descriptions.

returns:: An instance of MIDIdef which responds to MIDI program change messages.

METHOD:: freeAll
Clears and deactivates all MIDIdefs from the global collection.

INSTANCEMETHODS::
private:: addToAll, printOn

METHOD:: key
Get this MIDIdef's key.

returns:: Usually a link::Classes/Symbol::.

METHOD:: free
Clears this MIDIdef from the global collection and deactivates it.


EXAMPLES::

code::
MIDIIn.connectAll
MIDIdef.cc(\test1, {arg ...args; args.postln}, 1); // match cc 1
MIDIdef.cc(\test2, {arg ...args; args.postln}, 1, 1); // match cc1, chan 1
MIDIdef.cc(\test3, {arg ...args; args.postln}, (1..10)); // match cc 1-10
MIDIdef.noteOn(\test4, {arg ...args; args.postln}); // match any noteOn

MIDIIn.doNoteOnAction(1, 1, 64, 64); // spoof a note on
MIDIIn.doControlAction(1, 1, 1, 64); // spoof a cc
MIDIIn.doControlAction(1, 1, 9, 64);
MIDIIn.doControlAction(1, 10, 1, 64);

MIDIdef(\test1).free; // free one def
MIDIdef.freeAll;      // free all registered MIDIdefs
::
** class:: Magnitude
summary:: Comparable value in a linear continuum
categories:: Math

description::
Magnitudes represent values along a linear continuum which can be compared against each other.

instancemethods::
method:: <
returns:: a link::Classes/Boolean:: whether the receiver is less than strong::aMagnitude::.

method:: <=
returns:: a link::Classes/Boolean:: whether the receiver is less than or equal to strong::aMagnitude::.

method:: >
returns:: a link::Classes/Boolean:: whether the receiver is greater than strong::aMagnitude::.

method:: >=
returns:: a link::Classes/Boolean:: whether the receiver is greater than or equal to strong::aMagnitude::.

method:: min
returns:: the minimum of the receiver and aMagnitude.

method:: max
returns:: the maximum of the receiver and aMagnitude.

method:: clip
If the receiver is less than minVal then answer minVal, else if the receiver is greater than maxVal then answer maxVal, else answer the receiver.

method:: inclusivelyBetween
returns:: whether the receiver is greater than or equal to minVal and less than or equal to maxVal.

method:: exclusivelyBetween
returns:: whether the receiver is greater than minVal and less than maxVal.

** class::Main
categories::Core>Kernel
summary:: The concrete instance of Process
related:: Classes/StartUp

description::

Main is the concrete instance of link::Classes/Process:: (the runtime environment for the virtual machine and interpreter).
Main overrides some methods of Process. There are two methods of interest. One is named startup and is
called after the class library has been compiled. The other is called shutdown which gets called when the library gets re-compiled.

method:: thisProcess
The singleton instance of Main is available through the special keyword thisProcess.
For example, to find out what platform you're on:

code::
thisProcess.platform;	// --> e.g. "an OSXPlatform", "a LinuxPlatform", ...
::

classMethods::

subsection:: SuperCollider version
These class methods tell you which version of SuperCollider you are running and whether that version complies to your required minimum / maximum settings:

method::version

returns:: the current version as a human readable string

method::versionAtLeast
check if we are running at least version maj.min
code::
Main.versionAtLeast( 3, 1 );
::
returns:: true or false

method::versionAtMost
check if we are running version maj.min or older
code::
Main.versionAtMost( 3, 1 );
::
returns:: true or false

instanceMethods::

private::prArgv, prOpenUDPPort

method::startup

Called after the class library has been compiled.

discussion::
This calls the superclass' startup, which among other things initializes the link::Classes/AppClock:: and the top-level link::Classes/Environment::.

Main's startup then stores Server.default in the interpreter variable s, sets the platform default's link::Classes/GUI:: kit, initializes the link::Classes/GeneralHID:: system, calls a link::Classes/Platform:: specific startup method (for example OSXPlatform's startup opens the server windows), and finally invokes StartUp.run.

To add your own startup functionalities, you could either edit the special startup-file (discussed in link::Reference/StartupFile::), or use StartUp.add as discussed in the link::Classes/StartUp:: help file.

method::shutdown

Called after SuperCollider is quit or the class library is about to be re-compiled.

discussion::
This will quit all audio link::Classes/Server:: instances, perform a platform specific shutdown (e.g. on Mac OS X, the HID service is released), finally Process' shutdown method is called, resulting in successive calls to UI.shutdown, NetAddr.disconnectAll, File.closeAll, and Archive.write. To register your own shutdown code, use a call like this:

code::
ShutDown.add({ "Good bye!!".postln });
::

method::run

Override this to do whatever you want, e. g. add a class extension file like this to the class library:

code::
+ Main {
	run { "myPatch.rtf".load }
}
::

method::recvOSCfunc

Get or set a custom link::Classes/Function:: in this field that gets called whenever SuperCollider language (the client) receives an OSC message.

warning::This method has been deprecated as of SC 3.5, and users should instead should use link::#-addOSCFunc:: and link::#-removeOSCFunc:: to avoid overwriting any other functions added here by system objects.::

argument::newFunc
A link::Classes/Function:: or similar object to be set. When evaluated, this function will be passed the arguments time, replyAddr, and message, corresponding to the time the message was sent, the link::Classes/NetAddr:: of the sender, and the message itself as an link::Classes/Array::.

method::addOSCRecvFunc

Register a link::Classes/Function:: to be evaluated whenever SuperCollider language (the client) receives an OSC message. This will not overwrite any previously registered functions.

argument::func
A link::Classes/Function:: or similar object to be added. When evaluated, this function will be passed the arguments msg, time, replyAddr, and recvPort, corresponding to the message itself as an link::Classes/Array::, the time the message was sent, the link::Classes/NetAddr:: of the sender, and the port on which the message was received. Note that this order differs from that used by the deprecated method link::#-recvOSCfunc::.

code::
// post all incoming traffic except the server status messages
// basically the same as OSCFunc.trace
(
f = { |msg, time, replyAddr, recvPort|
	if(msg[0] != '/status.reply') {
		"At time %s received message % from % on port%\n".postf( time, msg, replyAddr, recvPort )
	}
};
thisProcess.addOSCRecvFunc(f);
);

// stop posting.
thisProcess.removeOSCRecvFunc(f);
::

method::removeOSCRecvFunc

Remove a link::Classes/Function:: from the list of those evaluated whenever SuperCollider language (the client) receives an OSC message. This will leave any other registered functions in place.

argument::func
A link::Classes/Function:: or similar object to be removed.

method::replaceOSCRecvFunc

Replace a link::Classes/Function:: in the list of those evaluated whenever SuperCollider language (the client) receives an OSC message with a different one. This will leave any other registered functions in place.

argument::func
The link::Classes/Function:: or similar object to be replaced.

argument::newFunc
A link::Classes/Function:: or similar object to be replace the one being removed. When evaluated, this function will be passed the arguments time, replyAddr, recvPort, and message, corresponding to the time the message was sent, the link::Classes/NetAddr:: of the sender, the port on which the message was received, and the message itself as an link::Classes/Array::.

method::openUDPPort
Attempt to open a new UDP port for receiving OSC traffic. If another application has already bound to the requested port this will fail. Once opened, ports remain bound until SC is recompiled.

If the port was already opened by SC it will return true directly without trying to open the port again.

argument::portNum
An link::Classes/Integer:: indicating the port to attempt to bind.

returns::A link::Classes/Boolean:: indicating whether the attempt was successful.

code::
thisProcess.openUDPPort(3000); // will return true or false.
thisProcess.openPorts; // returns all open ports
::

method::openPorts
Get a collection of all active UDP ports, including the main sclang port code::NetAddr.langPort::.

returns::A link::Classes/Set::.

method::pid

Returns:: The operating system's pid (process ID) for the process.

method::preferencesAction

A function to evaluate when the SuperCollider preferences menu is selected.

code::
thisProcess.preferencesAction = { arg process; SCWindow.new.front; }
::

method::recompile

Recompiles the class library. This is equivalent to restarting SC. Currently OSX (SuperCollider.app) only.

method::platform
Get the current link::Classes/Platform::

method::argv
Get the command-line arguments passed to sclang.

** class:: MantissaMask
summary:: Reduce precision.
categories::  UGens>Filters>Nonlinear


Description::

Masks off bits in the mantissa of the floating point sample value.
This introduces a quantization noise, but is less severe than linearly
quantizing the signal.


classmethods::

method::ar, kr

argument::in
The input signal.

argument::bits

The number of mantissa bits to preserve. A number from 0 to 23.


argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

// preserve only 3 bits of mantissa.
{ MantissaMask.ar(SinOsc.ar(SinOsc.kr(0.2,0,400,500), 0, 0.4), 3) }.play

// the original
{ SinOsc.ar(SinOsc.kr(0.2,0,400,500), 0, 0.4) }.play

// the difference.
(
{
	var in;
	in = SinOsc.ar(SinOsc.kr(0.2,0,400,500), 0, 0.4);
	Out.ar(0, in - MantissaMask.ar(in, 3));
}.play
)


// preserve 7 bits of mantissa.
// This makes the lower 16 bits of the floating point number become zero.
{ MantissaMask.ar(SinOsc.ar(SinOsc.kr(0.2,0,400,500), 0, 0.4), 7) }.play

// the original
{ SinOsc.ar(SinOsc.kr(0.2,0,400,500), 0, 0.4) }.play

// the difference.
(
{
	var in;
	in = SinOsc.ar(SinOsc.kr(0.2,0,400,500), 0, 0.4);
	Out.ar(0, in - MantissaMask.ar(in, 7));
}.play
)

::
** class:: MaxLocalBufs
summary:: Set the maximum number of local buffers in a synth
categories:: UGens>InOut

description::
This class is used internally by LocalBuf, sets the maximum number of local buffers in a synth.

** class:: Maybe
summary:: referentially transparent proxy object
categories:: Libraries>JITLib>Environments
related:: Classes/Fdef, Overviews/JITLib

description::
A Maybe object can contain either nil or some other object, and allows to construct calculations without knowing this other object yet. If the calculation fails, due to a loop or a not yet defined object, Maybe returns nil.

The name strong::Maybe:: stems from the programming language Haskell, where it represents a somewhat similar entity. See also: link::Classes/Fdef::

ClassMethods::

method::new
create a new instance

argument::thing
an object or nil.
code::
a = Maybe.new;
b = Maybe(a + 6);
b.value; // => nil
a.value = 1;
b.value; // => 7
::

InstanceMethods::

method::source
return or set the contained object

method::value
set the contained object or return the source, or the value of the contained object, if it is a Maybe. If there is a recursion, return nil.

method::apply
return the value, or the value of the contained object, if it is a Maybe. This method allows recursion, so that recursive calcualtions can be made.

method::doesNotUnderstand
(called by any message that Maybe doesn't understand.)

returns a composition function that, when evaluated, returns the value.
code::
a = Maybe.new;
a.respondsTo(\flop) // false: Maybe constructs a placeholder instead
b = Maybe(a.flop);
b.value; // => nil
a.value = [1, 2, [2, 3]];
b.value;	// => [ [ 1, 2, 2 ], [ 1, 2, 3 ] ]
::

Examples::

code::
// the following examples use a LazyEnvir with a Maybe as a proxy class.
// instead of writing a = Maybe.new; a.value = something;
// one can simply write ~a = something.
// the Maybe is implictly created for you.

(
	p.pop.clear;
	p = LazyEnvir.new;
	p.proxyClass = Maybe;
	p.linkDoc; // here: connect to current doc only.
);


// sets
~a = Set[0, 4, 5, 7];
~b = Set[4, 5];
~c = ~a union: ~b; // union of the two sets (note that the shortcut | does not work here.).
~d = ~a sect: ~b; // intersection of a and b
~c.postcs;""; // post the whole construction
~d.postcs;"";
~c.value; // Set[ 4, 0, 5, 7 ]
~d.value; // Set[ 4, 5 ]
~b = Set[4, 5, 13, 0];
~c.value;
~d.value; // Set[ 4, 0, 5 ]
~b.source.add(~w); // add another placeholder
~c.value; // it is part of the union.
~d.value; // but not part of the intersection


// envirs
~a = (note: [1, 2]);
~b = (dur: 1);
~c = ~a.putAll(~b) // provisionally put everything into the placholder
~c.value;
~a = (note: [1, 2, 4]);
~c.value;
~d = ~a.at(\note);
~d.value;
~a = (note: [7.5]);
~d.value; // [7.5]

// patterns
~a = Pseq([1, 2, 3]);
~b = Pseq([5, ~a, ~a + 10], inf);
~b.value.asStream.nextN(10);


~a = Prand([100, 200]);
~b.value.asStream.nextN(10);


// to do : flop!

//////////////// deep recursion

// with normal functions:
f = { |x| if(x <= 1) { 1 } { x * f.(x - 1) } };
f.(12)


~faculty = { |x| if(x == 1) { 1 } { x * ~faculty.(x - 1) } };
~faculty.(12) // doesn't work (=> nil). here we _do_ want recursion ...

// for explicit recursion use "apply"
~faculty = { |x| if(x == 1) { 1 } { x * ~faculty.apply(x - 1) } };
~faculty.(12)

/*// safety (not yet implemented)
Maybe.maxDepth = 1e2; // higher depth is risky..
~faculty = { |x| x * ~faculty.apply(x - 1) }; // infinite recursion
~faculty.(12)

Maybe.maxDepth = nil; // unsafe again.*/


//////////////// recursion prevention tests

~b = ~a;
~a = ~b;
~a.value; // => nil


~a = ~b;
~b = ~c;
~c = ~a;
~a.value; // => nil

~a = ~b + ~c;
~c = ~a;
~a.value; // => nil


~a = ~b;
~b = 19;
~a.value; // => 19
~b.value; // => 19

// function evaluation and argument passing

~a = { |x| x + 2 };
~a.value; // => nil

~a.value(~c); // => nil
~b = 2000;
~a.value(~b); // => 2002
~x = [600, 1000];

(~a + 1).value(~b); // 2003
(~a + 1).value(~x); // [ 603, 1003 ]
(~a + 1).value({ 8 }); // binary op func.
(~a + 1).value({ 5 + 3 }).value // 11

~a = { |x| x + 2 + ~b };
~a.value(8); // 2010

~c = nil;
~a = { |x| x + 2 + ~c }; // ~c is undefined.
~a.value(8); // => nil

~c = 100; // define ~c

~a.value(8); // now returns a value.

~c = ~b; // now recursion?
~b = ~a;
~a.value(8); // caught recursion => nil

~c = { 100.rand }; // ~c is a function

~a.value(8);
~a.value(8);

~c = { ~a + ~b };
~a.value(8);	// ~c is a recursion with ~a => nil


// function composition
~a = {|x| x + 1 };
~v = ~a <> ~a <> ~a; // same as: { ~a.(~a.(~a)) }
~v.value(0); // => 3

~a = {|x| x + 2 };
~v.value(0); // transparent. => 6

// {|x| x }.valueEnvir // doesn't work with current implementation of Function:valueEnvir


// calculations with functions:
~c = 0;
~a = { |ff| { ff = ff + 1; ~c + ff + 2 + ~c } };
~x = ~a.value(8);
~x.value; // return 11, 12, 13...
~x.value;
~x.value;
~c = 100;
~x.value; // return 214, 215 ...
~x.value;

// binary op functions:
~c = 0;
~a = { |ff| { [600, 800] } + { ff + 2 + ~c } };

~x = ~a.value(8);
~x.value; // return [ 610, 810 ]

~c = { [10, -10].rand };
~x.value; // return random between [ 610..620, 800..810 ]
::
** class:: Median
summary:: Median filter.
categories::  UGens>Filters>Nonlinear


Description::

Returns the median of the last length input points. This non-linear
filter is good at reducing impulse noise from a signal.


classmethods::

method::ar, kr

argument::length

Number of input points in which to find the median. Must be an
odd number from 1 to 31. If
code::length::  is 1
then Median has no effect.


argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

// a signal with impulse noise.
{ Saw.ar(500, 0.1) + Dust2.ar(100, 0.9) }.play;

// after applying median filter
{ Median.ar(3, Saw.ar(500, 0.1) + Dust2.ar(100, 0.9)) }.play;

// The median length can be increased for longer duration noise.

// a signal with longer impulse noise.
{ Saw.ar(500, 0.1) + LPZ1.ar(Dust2.ar(100, 0.9)) }.play;

// length 3 doesn't help here because the impulses are 2 samples long.
{ Median.ar(3, Saw.ar(500, 0.1) + LPZ1.ar(Dust2.ar(100, 0.9))) }.play;

// length 5 does better
{ Median.ar(5, Saw.ar(500, 0.1) + LPZ1.ar(Dust2.ar(100, 0.9))) }.play;

// long Median filters begin chopping off the peaks of the waveform
(
{
	x = SinOsc.ar(1000, 0, 0.2);
	[x, Median.ar(31, x)]
}.play;
)

// another noise reduction application:

Synth.play({ WhiteNoise.ar(0.1) + SinOsc.ar(800,0,0.1) });

// use Median filter for high frequency noise
Synth.play({ Median.ar(31, WhiteNoise.ar(0.1) + SinOsc.ar(800,0,0.1)) });

(
// use LeakDC for low frequency noise
Synth.play({
	LeakDC.ar(Median.ar(31, WhiteNoise.ar(0.1) + SinOsc.ar(800,0,0.1)), 0.9)
});
)

::
** class::Method
categories::Core>Kernel
summary:: Code that implements an operation upon instances of a Class.
related:: Classes/Class

description::
A Method is code that is a part of the set of operations upon instances of a link::Classes/Class::.

instanceMethods::

method::ownerClass
returns::
The link::Classes/Class:: for which the method is part of the implementation.

method::name
returns::
A link::Classes/Symbol:: which is the name of the Method.

method::primitiveName
returns::
A link::Classes/Symbol:: which contains the name of the primitive function that implements the Method, if there is one.

method:: filenameSymbol
returns::
A link::Classes/Symbol:: which is the full path of the source file that this method is defined in.

** class:: MidEQ
summary:: Parametric filter.
categories::  UGens>Filters>Linear


Description::

Attenuates or boosts a frequency band.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Center frequency of the band in Hertz.


argument::rq

The reciprocal of Q (bandwidth / cutoffFreq).


argument::db

Amount of boost (db > 0) or attenuation (db < 0) of the
frequency band.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

// mixer parametric eq as wahwah
{ MidEQ.ar(Saw.ar(200,0.2), FSinOsc.kr(1, 0, 24, 84).midicps, 0.3, 12) }.play


// notch filter
(
{ var in;
  in = PinkNoise.ar(0.2) + SinOsc.ar(600, 0, 0.1);
  MidEQ.ar(in, SinOsc.kr(0.2, 0.5pi) * 2 + 600, 0.01, -24)
}.play
)

/////
// first start the synth
(
x = {| freq=400, db=0, rq=0.1 |
	 var in;
	 in =  SinOsc.ar([ 400, 420 ], 0, 0.4);
	 MidEQ.ar(in, freq, Lag.kr(rq, 0.3), db)
	}.play
)

// now play with its parameters to hear how the filter affects two frequencies
// that are very close to each other

x.set(\db, -12)
x.set(\rq, 0.1)
x.set(\rq, 0.03)
x.set(\freq, 410)
x.set(\freq, 420)
x.set(\freq, 400)
x.set(\freq, 500)

::
** class:: Mix
summary:: Sum an array of channels.
categories::  UGens>Multichannel


Description::

Mix will mix an array of channels down to a single channel or an array
of arrays of channels down to a single array of channels.
More information can be found under link::Guides/Multichannel-Expansion::.


note::

Note that  code::Mix.ar::  and  code::Mix.kr::  in
SC2 are equivalent to  code::Mix.new::  in SC3,
and that  code::Mix.arFill::  and  code::Mix.krFill::  are
equivalent to  code::Mix.fill::.

::

classmethods::

method::new

argument::array
The array of channels or arrays.

method::fill

argument::n
The size of array to create.

argument::function
The array filling function.

returns:: Returns:
A newly created
link::Classes/UGen:: .

Examples::

code::

s.boot;

{ Mix.new([ PinkNoise.ar(0.1), FSinOsc.ar(801, 0.1), LFSaw.ar(40, 0.1)]) }.play

(
play({
	Mix.new( Array.fill(8, { SinOsc.ar(500 + 500.0.rand, 0, 0.05) }) );
}))

(
play({
	Mix.fill(8, { SinOsc.ar(500 + 500.0.rand, 0, 0.05) });
}))

::

** class:: Monitor
summary:: link between busses
categories:: Libraries>JITLib>NodeProxy
related:: Classes/NodeProxy

description::
For playing contiguous channels to other contiguous busses, one uses strong::play::; for more complex routings, such as splitting, spreading etc to multiple channels, strong::playN::.

InstanceMethods::

method::play
plays from a bus index with a number of channels to another index with a number of channels, within a target group, or a server.

argument::fromIndex

argument::fromNumChannels

argument::toIndex

argument::toNumChannels

argument::target
where to play (default: server default group)

argument::multi
keep old links and add new one

argument::volume
volume at which to monitor

argument::fadeTime
fade in fade out time

argument::addAction

method::playN

the arguments strong::out::, strong::amp:: and strong::in:: can be nested arrays. see also link::Reference/playN::

argument::out
array of destination channels

argument::amp
array of amplitudes for each channel

argument::in
array of source channels

argument::vol
global scaling for amplitudes

argument::fadeTime
fade in and out

argument::target
where to play (default: server default group)

argument::addAction

method::isPlaying
returns true if the group is still playing

method::stop
stops within the fadeTime

method::vol
set the volume

method::out
set the output index. doesn't work right now.

method::playToBundle
adds all playing osc messages to the bundle. the bundle should support the message strong::.add::

Examples::

code::
Server.default = s = Server.internal;
s.boot;
s.scope(16);

{ Out.ar(87, SinOsc.ar(MouseX.kr(40, 10000, 1) * [1, 2, 3], 0, 0.2)) }.play;
x = Monitor.new;
x.play(87, 3, 1, 2);
x.out = 0;
x.stop(3.0);
x.play(87, 1, 0, 1); // in > out : now mixes down (wrapping)
x.play(89, 1, 0, 2); // in < out : now distributes to 2 channels
x.stop;

// multiple play
x.play(87, 1, 0, 2, multi:true);
x.play(88, 1, 0, 2, multi:true);
x.play(89, 1, 0, 2, multi:true);
x.stop;
::

subsection::multichannel playing

code::
// examples: args are // outs, amps, ins, vol, fadeTime


(	x.playN(
		[0, 1, 4], 		// to these outs
		[0.1, 0.4, 0.3], 	// with these volumes
		[87, 88, 89]		// from these ins
	);
)
(
	x.playN(
		[0, [1, 3, 2], 4], 		// outs can be nested: 87 -> 0, 88 -> [1, 3, 2], 89 -> 4
		[0.1, [0.4, 0.2, 0.1], 0.3],	// with nested volumes 0.1, [0.4, 0.2, 0.1], and 0.3
		[87, 88, 89]); 			// reading from these ins
)
		// can also set global volume and fadetime
	x.playN(vol: 0.0, fadeTime:4);
::
** class:: MonitorGui
summary:: display and control a Monitor
categories:: Libraries>JITLib>GUI
related:: Classes/NodeProxy, Classes/Ndef, Classes/JITGui, Classes/NdefGui

description::

MonitorGui displays the state of a link::Classes/NodeProxy::'s link::Classes/Monitor::. It is used in link::Classes/NdefGui::, link::Classes/ProxyMixer::, and link::Classes/NdefMixer::.

subsection::First examples

code::
s.boot;
Ndef(\a).ar;
Ndef(\k).kr;

	// make a MonitorGui with all bells and whistles
m = MonitorGui.new(bounds: 500@40, options: [\playN, \name, \level, \fade]);

	// when it has a kr proxy, it is visible, but disabled
m.object_(Ndef(\k));
	// with an ar proxy, it is enabled
m.object_(Ndef(\a));

	// show its play state
Ndef(\a).play		//
	// and volume
Ndef(\a).vol_(0.25);
Ndef(\a).stop

	// switch to playN mode - spread outputs should show
Ndef(\a).playN([0, 2]);
	// switch back to play - spread outbox goes back
Ndef(\a).stop;
Ndef(\a).play(0);
::

ClassMethods::

private::initClass

subsection::Creation

method::new

code::
g = MonitorGui(Ndef(\a));	// barebones
(
w = Window.new.front;
w.addFlowLayout;
g = MonitorGui(Ndef(\a), w, 300@40);
)
	// different options:
	// a playN dialog button
g = MonitorGui.new(Ndef(\a), options: [\playN])

	// bounds
MonitorGui.new(Ndef(\a), bounds: Rect(100, 100, 400, 30), options: [\playN])
MonitorGui.new(Ndef(\a), bounds: 400@24, options: [\playN])

	// level name and numerical value
MonitorGui.new(Ndef(\a), options: [\playN, \level])

	// a nameView and a fadeTime setter box
MonitorGui.new(Ndef(\a), options: [\playN, \name, \fade])

	// all of 'em
MonitorGui.new(Ndef(\a), options: [\playN, \level, \name, \fade])
::

argument::object
the nodeproxy whose monitor state will be shown, or nil.

argument::parent
a parent view where MonitorGui is to be shown. If nil, a window is made.

argument::bounds
bounds where the view (or window) will be shown.

argument::makeSkip
a flag whether to create and start a link::Classes/SkipJack:: for auto-updating.

argument::options
an array of symbols for options of what to display.

subsection::Class Variables

method::lastOutBus
the highest outbus number to allow. Default is 99.

InstanceMethods::

subsection::Instance Variables

method::config
some information on what to display

method::ampSl
an link::Classes/EZSlider:: for link::Classes/Monitor:: volume

method::playBut
a play button - shows play or playN

method::setOutBox
a numberbox to set output routing

method::playNDialogBut
opens a dialog window for playN output routing by code

method::fadeBox
a numberbox for setting monitor fadeTime.

subsection::Some Methods

method::playNMode
switches between playN mode (true) and play mode (false)

method::checkUpdate
compare previous state with current state, and update gui elements.
** class:: MoogFF
summary:: Moog VCF implementation, designed by Federico Fontana
categories:: UGens>Filters
related:: Classes/RLPF, Classes/LPF

description::
A digital implementation of the Moog VCF (filter). footnote::
The design of this filter is described in the conference paper Fontana, F. (2007) emphasis::Preserving the Digital Structure of the Moog VCF::. In Proc. ICMC07, Copenhagen, 25-31 August 2007.
::
footnote::
Original Java code created by F. Fontana - August 2007 - federico.fontana@univr.it
Ported to C++ for SuperCollider by Dan Stowell
::

classmethods::
method:: ar, kr

argument:: in
the input signal.
argument:: freq
the cutoff frequency.
argument:: gain
the filter resonance gain, between zero and 4.
argument:: reset
when greater than zero, this will reset the state of the digital filters at the beginning of a computational block.
argument:: mul
argument:: add

examples::
code::
s.boot;
// Play it with the mouse...
x = { MoogFF.ar(WhiteNoise.ar(01.1), MouseY.kr(100, 10000, 1), MouseX.kr(0, 4)) }.play(s);
x.free;

// Mmmm, throbby
(
x = {
    MoogFF.ar(
        Pulse.ar([40,121], [0.3,0.7]),
        SinOsc.kr(LFNoise0.kr(0.42).range(0.001, 2.2)).range(30, 4200),
        0.83 * 4)}.play(s);
)
x.free;
::

** class:: MostChange
summary:: Output most changed.
related:: Classes/LeastChange, Classes/LastValue
categories::  UGens>Maths


Description::

Output the input that changed most.


classmethods::

method::ar, kr

argument::a

Input signal A.


argument::b

Input signal B.


Examples::

code::

//doesn't work yet.

d = SynthDef("help-MostChange", { arg amp=1.0;
	var out, in1, in2;
	in1 = LFNoise1.ar(800, amp);
	in2 = SinOsc.ar(800);
	out = MostChange.ar(in1, in2) * 0.1;
	Out.ar(0, out)
}).play;

d.set(\amp, 0.1);
d.set(\amp, 0);
d.set(\amp, 3);
d.free;

the control that changed most is used for output:

d = SynthDef("help-MostChange", { arg freq=440;
	var out, internalFreq;
	internalFreq = LFNoise0.ar(0.3, 300, 800);
	out = SinOsc.ar(
			MostChange.kr(freq, internalFreq)
	);
	Out.ar(0, out * 0.1)
}).play;

d.set(\freq, 800);
d.set(\freq, 800); //nothing changed
d.set(\freq, 900);
d.free;

::

** class:: MouseButton
summary:: Mouse button UGen.
related:: Classes/KeyState, Classes/MouseX, Classes/MouseY
categories::  UGens>User interaction


Description::

Mouse button UGen.


classmethods::

method::kr

argument::minval

Value when the button is not pressed.


argument::maxval

Value when the button is pressed.


argument::lag

Lag factor.


Examples::

code::

{ SinOsc.ar(MouseButton.kr(400, 440, 0.1), 0, 0.1) }.play;
{ SinOsc.ar(MouseButton.kr(400, 740, 2), 0, 0.1) }.play;

::

** class:: MouseX
summary:: Cursor tracking UGen.
related:: Classes/KeyState, Classes/MouseButton, Classes/MouseY
categories::  UGens>User interaction


Description::

Cursor tracking UGen.


classmethods::

method::kr

argument::minval

Value corresponding to the left edge of the screen.


argument::maxval

Value corresponding to the right edge of the screen.


argument::warp

Mapping curve. 0 is linear, 1 is exponential (e. g. for freq or
times). Alternatively you can specify: 'linear' or 'exponential'.


argument::lag

Lag factor to dezipper cursor movement.


Examples::

code::

{ SinOsc.ar(MouseX.kr(40, 10000, 1), 0, 0.1) }.play;

::

** class:: MouseY
summary:: Cursor tracking UGen.
related:: Classes/KeyState, Classes/MouseButton, Classes/MouseX
categories::  UGens>User interaction


Description::

Cursor tracking UGen.


classmethods::

method::kr

argument::minval

Value corresponding to the bottom edge of the screen.


argument::maxval

Value corresponding to the top edge of the screen.


argument::warp

Mapping curve. 0 is linear, 1 is exponential (e. g. for freq or
times). Alternatively you can specify: 'linear' or 'exponential'.


argument::lag

Lag factor to dezpipper cursor movement.


Examples::

code::

{ SinOsc.ar(MouseY.kr(40, 10000, 1), 0, 0.1) }.play;

::

** CLASS:: MovieView
redirect:: implClass
summary:: A view responding to Wacom tablet
categories:: GUI>Views
related:: Classes/Image

DESCRIPTION::

MovieView can play movies such as .mov and mpg, and image files like jpg, png, tiff and others.

note:: Not available in strong::Qt GUI:: ::

note:: strong:: prerequisits in SwingOSC ::

JSCMovieView is currently based on the Java Media Framework (JMF) which is not part of the standard java environment (Java SE) but needs to be installed separately. There is a reference implementation from Sun available for Linux, Windows and Mac OS X. It can be downloaded from http://java.sun.com/products/java-media/jmf/index.jsp (note: for Mac OS X you need the generic cross-platform version).

The reference implementation has rather poor media support (check this page: http://java.sun.com/products/java-media/jmf/2.1.1/formats.html ), so you might need to convert your movies or look out for extra JMF plug-ins. A really good plug-in is fobs4j !(ffpmeg objects for java) -> http://fobs.sourceforge.net/ !
You need to install the "jmf.jar" file in your system's java extensions folder, e.g. on Mac OS X that's "/Library/Java/Extensions". For fobs, do the same with "fobs4jmf.jar" and copy "jmf.properties" into "SwingOSC/build".

(in the future, FMJ (freedom for media in java) might be an alternative: http://fmj-sf.net)
::

CLASSMETHODS::
PRIVATE:: key


INSTANCEMETHODS::

METHOD:: path
    The path to the movie.

SUBSECTION:: Movie Control

METHOD:: start
METHOD:: stop
METHOD:: stepForward
METHOD:: stepBack
METHOD:: gotoEnd
METHOD:: gotoBeginning

METHOD:: frame
    Go to frame.

    argument::
        The frame index; an Integer.

METHOD:: playSelectionOnly

    argument::
        A Boolean.

METHOD:: skipFrames

    argument::
        An Integer.

METHOD:: muted

    argument::
        A Boolean.

METHOD:: loopMode

    Possible loop modes:
    list::
    ## 0 - Playback runs forward and backward between both endpoints.
    ## 1 - Restarts playback at beginning when end is reached.
    ## 2 - Playback stops when end is reached.
    ::

    argument::
        One of the above Integers.

METHOD:: rate

    argument::
        An instance of Float. 1.0 is the normal rate.


SUBSECTION:: Movie Editing

METHOD:: copy
METHOD:: clear
METHOD:: cut
METHOD:: paste

METHOD:: editable
    argument::
        A Boolean.

METHOD:: currentTime
    The current time.
    argument::
        Defaults to code::nil::.


SUBSECTION:: Appearance

METHOD:: showControllerAndAdjustSize

    argument:: show
        A Boolean. Default is code::true::.
    argument:: adjust
        A Boolean. Default is code::true::.

METHOD:: resizeWithMagnification
    Resizes the whole view, adjusts its contents.

    argument:: size
        A Float.

METHOD:: fixedAspectRatio
    argument::
        A Boolean.


EXAMPLES::

code::
(
w = Window("mov").front;
b = Button(w, Rect(0, 0, 150, 20))
    .states_([["pick a file"]])
    .action_({ File.openDialog("", { |path| m.path_(path) }) });
m = MovieView(w, Rect(0,20,360, 260));
)
    // random-pick a tiff from the Help folder
m.path_("Help/*/*/*.tiff".pathMatch.choose);

    // or point it to a movie (you may have that one too):
m.path_("/Library/Application\ Support/iDVD/Tutorial/Movies/Our\ First\ Snowman.mov");


m.start;            // playback
m.muted_(false);    // thank god
m.stop;

    //rate
m.rate_(1);
    // backwards
m.gotoEnd.rate_(-1).start;

    // select a range on the controller and play it
m.rate_(1).playSelectionOnly_(true).start;

    // loopModes:
m.loopMode_(1); // only one direction
m.loopMode_(0).start;   // back and forth



m.stop;
m.gotoBeginning;

    // single steps
m.stepForward;

10.do { m.stepForward; };
m.stepBack;

    // select with shift-drag, copy paste between movieviews or quicktime player
m.editable_(true);


m.showControllerAndAdjustSize(true, true);
    // resize compared to image size:
m.resizeWithMagnification(0.25);

    //goto time (in seconds)
m.currentTime_(1);

    // not there yet, but would be nice to have:
    // startFrame, length
m.setSelection_(20, 15);


m.frame_(frame);    // jump to frame
m.frame.postln; // poll current frame pos
::
** class:: MulAdd
categories:: UGens>Maths
summary:: Multiply and add to a signal

description::
Multiplies the signal by mul and adds add. This UGen is very efficient (it performs various optimisation checks, for example). It is used very heavily throughout SuperCollider to perform multiply and add operations on the server; in fact it is  what "really" performs the mul and add arguments found in many UGens.

See also the discussion of mul and add arguments in the link::Classes/UGen:: help file.

classmethods::
private:: new1

method:: new
argument:: in
input signal
argument:: mul
multiply with this value
argument:: add
add this value

discussion::
Same as:
code::
in.madd(mul, add)
::

instancemethods::
private:: init

Examples::
code::
s.boot;

// The mul and add arguments of SinOsc themselves use MulAdd!
// These two examples will create precisely the same synth graph:
x = { SinOsc.ar(440, 0, 0.1, 0.05) }.play(s);
x.trace; // You should see a "MulAdd" in the trace
x.free;

x = { MulAdd(SinOsc.ar(440, 0), 0.1, 0.05) }.play(s);
x.trace;
x.free;

// In fact this will produce the same graph too - the separate multiply and add are optimised into one MulAdd
x = { SinOsc.ar(440, 0) * 0.1 + 0.05 }.play(s);
x.trace;
x.free;
::
(Note: the "trace" message is described in the helpfile for link::Classes/Node::.)
** CLASS::MultiLevelIdentityDictionary
summary::tree of dictionaries
related:: Classes/IdentityDictionary
categories:: Collections>Unordered

DESCRIPTION::
A tree of IdentityDictionaries. Addresses within the tree are specified with a series of keys. link::Classes/Library:: is its most useful subclass.

INSTANCEMETHODS::

private::add, remove, removeFail, prChooseFrom, prPutTree, leaves, prNestedValuesFromDict, prRemoveAtPathRecursive, storeOn, printOn

method::at
Retrieves a leaf node or nil if not found.

method::put
Puts the item as a leaf node, internally creating new branches as needed to accommodate the list of keys.

method::choose
Choose a branch at each level, descend the tree until a leaf is chosen.
By using arguments strong::key1, key2 ... keyN::, one can start at an address within the tree, descend the tree until a leaf is chosen.

method::putTree
A way to insert objects into the tree with a syntax similar to the organization of the tree itself.
code::
//pseudo code:
putTree(key1,[
	key2a, item1-2a,
	key2b, item1-2b,
	[
		key3, item1-3
	] // etc...
]);
::

method::removeAt
Remove only the item located by the path.

method::removeEmptyAt
Remove the item located by the path. This might make the item's parent dictionary empty. In that case, it will remove the parent and continue up the chain, removing empty dictionaries as it goes. This is slower but cleaner.

EXAMPLES::

code::
// Example of the difference between removeAt and removeEmptyAt

m = MultiLevelIdentityDictionary.new;
m.put(\a, \b, \c, 1);

m.removeAt(\a, \b, \c);
m	// note, \a and \b dictionaries remain

m.put(\a, \b, \c, 2);
m.removeEmptyAt(\a, \b, \c);
m	// now the entire MultiLevelIdentityDictionary is empty
::
** class:: MultiOutUGen
summary:: Superclass for all UGens with multiple outputs
categories:: UGens>Base
related:: Classes/OutputProxy

Description::
This is a superclass for all UGens with multiple outputs.
MultiOutUGen creates the link::Classes/OutputProxy:: ugens needed for the multiple outputs.

classmethods::
private:: categories

instancemethods::

method:: initOutputs
Create an array of OutputProxies for the outputs.

** CLASS:: MultiSliderView
redirect:: implClass
summary:: A view displaying an array of sliders
categories:: GUI>Views

DESCRIPTION::

MultiSliderView displays a collection of values, each represented by the position of one of the sliders placed side by side.

When clicking into the view, the value of the slider under the mouse pointer will be set. Whenever the mouse is moved with a mouse button pressed, the slider currently under the mouse pointer will be adjusted.

The last slider modified is considered to be the strong::current:: one, i.e. the link::#-index:: method will return its index, and link::#-currentValue:: relates to its value.

The current slider is also considered to be the strong::selected:: one. Selection can be extended to more than one slider by modifying link::#-selectionSize::. Whenever a different slider becomes the current one, the selection size shrinks back to 1. Note that the selection will only be visually indicated if link::#-showIndex:: is code::true::.


CLASSMETHODS::

PRIVATE:: key

METHOD:: new

	note:: strong:: In Qt GUI: ::

	A new MultiSliderView is created empty, without any columns. link::#-size:: or link::#-value:: has to be set in order to create some columns.
	::

	note:: strong:: Other GUI kits: ::

	A new MultiSliderView is created with code::bounds.width/12:: sliders. However, the default link::#-thumbSize:: is 12 and the default link::#-gap:: is 1. The view width has to be code::13*n+2:: for all the sliders to automatically fit in the view.

	So if you want a specific number of sliders, then it is best to specify the link::#-size:: and set link::#-elasticMode:: to 1. Then you will get a MultiSliderView which distributes link::#-size:: amount of sliders over code::bounds.width::, where the slider widths are at maximum link::#-indexThumbSize:: (default 12) and the link::#-gap:: is adjusted accordingly.
	::



INSTANCEMETHODS::

SUBSECTION:: Data

METHOD:: size
	The amount of sliders.

	When setting -size, if the new amount is larger then the current, new sliders will be added with the value of 0. In the opposite case, the value of sliders up to the new amount will be preserved, and the rest of the sliders will be removed.

	note:: strong:: In Cocoa and SwingOSC GUIs: ::

	Changing -size after the view has been drawn or after the link::#-value:: array has been set will lead to unexpected results. Instead, you should change the link::#-value::, if you need to change the contents of the view.

	::

	argument::
		An Integer.

METHOD:: value

	Sets the values of the sliders to those of the elements of the argument.

	note::
	If the amount of elements in the argument does not match link::#-size::, then makes link::#-size:: match before applying the new values.
	::

	argument::
		An array of Floats.

METHOD:: valueAction

	Sets link::#-value:: and triggeres link::#-action::.

METHOD:: reference

	The reference values in relation to which the values will be visually represented. The default for each slider is 0.

	argument::
		An array of Floats.

METHOD:: index

	The index of the current slider, i.e. the first one in the selection.

	argument::
		An Integer.

METHOD:: selectionSize

	The amount of sliders in the selection (starting at link::#-index::).

METHOD:: currentvalue

	The value of the slider at link::#-index::

	argument::
		A Float.



SUBSECTION:: Display

METHOD:: indexIsHorizontal

	The orientation of the view: if true, the sliders are displayed in a horizontal order, otherwise in a vertical order.

	argument::
		A Boolean.

METHOD:: elasticMode

	If enabled (set to 1), the sliders from link::#-startIndex:: to the last one will be distributed so as to occupy the whole area of the view. The link::#-gap:: variable will be ignored. The size of each slider in the direction of index will be maximally link::#-indexThumbSize::, or smaller in order for all the sliders to fit into the view.

	argument::
		0 (disabled) or 1 (enabled).

METHOD:: gap

	The gap between the sliders in pixels when link::#-elasticMode:: is disabled.

	argument::
		An Integer.

METHOD:: indexThumbSize

	The size of the sliders in the direction of index in pixels . If link::#-elasticMode:: is enabled, this will be the maximum size, but the actual size might be smaller in order for all the sliders to fit into the view.

	argument::
		An Integer.

METHOD:: valueThumbSize

	The size of the slider handles in the direction of value in pixels (if drawn).

	argument::
		An Integer.

METHOD:: thumbSize

	Sets both link::#-indexThumbSize:: and link::#-valueThumbSize:: to the argument.

METHOD:: startIndex

	The index of the slider displayed at the left or top edge of the view (depending on whether link::#-indexIsHorizontal:: is true or false, respectively). Sliders with lower index than this will not be visible.

	argument::
		An Integer.


SUBSECTION:: Appearance

METHOD:: showIndex

	Wether the slider selection is visually indicated.

	argument::
		A Boolean.

METHOD:: drawRects

	Whether to draw the sliders.

	argument::
		A Boolean.

METHOD:: drawLines

	Whether to draw a line connecting the points that represent the link::#-value#values:: of the sliders, and a line connecting the points that represent the link::#-reference#references::.

	argument::
		A Boolean.

METHOD:: isFilled

	If true, the sliders will have their area between the link::#-reference:: and the link::#-value:: colored, and the area bounded by the lines connecting the reference and the value points will be colored as well.

	argument::
		A Boolean.

METHOD:: strokeColor

	The color used to draw the lines described in link::#-drawLines::.

	argument::
		A Color.

METHOD:: fillColor

	The color used to visualize the areas described in link::#-isFilled::.

	argument::
		A Color.

METHOD:: colors

	Sets link::#-strokeColor:: and link::#-fillColor:: to the two arguments, respectively.



SUBSECTION:: Interaction

METHOD:: editable

	Whether the values can be edited using mouse or keyboard.

	argument::
		A Boolean.

METHOD:: readOnly

	The opposite if link::#-editable::.

	argument::
		A Boolean.

METHOD:: step

	If the argument is larger than 0, makes the MultiSliderView keep the values quantized to the nearest multiple of the argument.



SUBSECTION:: Actions


METHOD:: action
	The action object evaluated whenever the user changes the value of a slider.

METHOD:: metaAction
	The action object evaluated whenever the user changes the value of a slider while the Ctrl key is pressed.

METHOD:: defaultKeyDownAction

	Implements the default effects of key presses as follows:

	table::
	## strong::Key::   || strong::Effect::
	## up arrow        || Qt: increment -currentValue by -step; Cocoa: decrement -gap by 1
	## down arrow      || Qt: decrement -currentValue by -step; Cocoa: increment -gap by 1
	## right arrow     || increment -index by 1
	## left arrow      || decrement -index by 1
	::



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		a) If link::#-selectionSize:: is 0, returns link::#-value::.

		b) If link::#-selectionSize:: > 1, returns an Array with the values at the indexes in the selection.

		If link::#-reference:: is not nil, returns an Array containing (a) or (b), and an Array of the corresponding reference values: code:: [[values], [references]] ::.

METHOD:: defaultCanReceiveDrag
	returns::
		True for any drag data, but the data should either be an Array of values ( code:: [values] :: ), or an Array containg an Array of values and an Array of corresponding reference values ( code:: [[values], [references]] :: ).

METHOD:: defaultReceiveDrag
	If the drag data is in one of the acceptable forms (see link::#-defaultCanReceiveDrag:: above), sets link::#-value:: (and link::#-reference::) using that data.



EXAMPLES::

subsection:: Basic Examples

code::
(
n=20;
w = Window.new.front;
m = MultiSliderView(w,Rect(10,10,n*13+2,100)); //default thumbWidth is 13
m.value=Array.fill(n, {|v| v*0.05}); // size is set automatically when you set the value
m.action = { arg q;
    q.value.postln;
};
)
::

Looks like a candlestick graph:

code::
(
var size;
size = 350 / 6;
w = Window.new;
w.view.decorator = FlowLayout(w.view.bounds);
m = MultiSliderView(w, Rect(0, 0, 350, 100));   
m.value_(Array.fill(size, {0.01}));
m.isFilled_(true); // width in pixels of each stick
m.indexThumbSize_(2.0); // spacing on the value axis
m.gap_(4);
w.front;
)

// rotate the above graph
(
m.bounds_(Rect(0, 0, 100, 350));
m.indexIsHorizontal_(false);
)
::


subsection:: Interactive Example

A walk through all the graphic options:

code::
(
n=40;

w = Window("MultiSlider Options", Rect(200, Window.screenBounds.height-550, 600, 450));
f={ 
    w.view.decorator = FlowLayout( w.view.bounds, 10@10, 10@2 );
    m = MultiSliderView(w,Rect(0,0,580,200)); // default thumbWidth is 13
    m.value=Array.fill(n, {|v| 0.5+((0.3*v).sin*0.25)});
    m.action = { arg q;q.value.postln; };

    StaticText(w,380@18).string_("indexThumbSize or thumbSize");
    Slider(w,580@10).action_({arg sl; m.indexThumbSize=sl.value*24}).value_(0.5);
    StaticText(w,380@18).string_("valueThumbSize");
    Slider(w,580@10).action_({arg sl; m.valueThumbSize=sl.value*24}).value_(0.5);
    StaticText(w,580@18).string_("xOffset or gap");
    Slider(w,580@10).action_({arg sl; m.xOffset=sl.value*50});
    StaticText(w,580@18).string_("startIndex");
    Slider(w,580@10).action_({arg sl; m.startIndex = sl.value *m.size};);

    CompositeView(w,580@10);//spacer
    Button(w,100@20).states_([["RESET",Color.red]])
        .action_({ w.view.removeAll; f.value; });
    h=StaticText(w,450@18).string_("").stringColor_(Color.yellow);
    Button(w,100@20).states_([["elasticMode = 0"],["elasticMode = 1",Color.white]])
        .action_({|b| m.elasticMode = b.value});
    Button(w,160@20).states_([["indexIsHorizontal = false"],["indexIsHorizontal = true",Color.white]])
        .action_({|b| m.indexIsHorizontal = b.value.booleanValue}).value_(1);
    Button(w,120@20).states_([["isFilled = false"],["isFilled = true",Color.white]])
        .action_({|b| m.isFilled = b.value.booleanValue});
    Button(w,120@20).states_([["drawRects = false"],["drawRects = true",Color.white]])
        .action_({|b| m.drawRects = b.value.booleanValue}).valueAction_(1);
    Button(w,100@20).states_([["drawLines = false"],["drawLines = true",Color.white]])
        .action_({|b| m.drawLines = b.value.booleanValue});
    Button(w,160@20).states_([["readOnly = false"],["readOnly = true",Color.white]])
        .action_({|b| m.readOnly = b.value.booleanValue});
    Button(w,120@20).states_([["showIndex = false"],["showIndex = true",Color.white]])
        .action_({|b| m.showIndex = b.value.booleanValue});
    Button(w,120@20).states_([["reference = nil"],["reference filled",Color.white],["reference random",Color.yellow]])
        .action_({|b| b.value.booleanValue.if({
            (b.value>1).if(
                {m.reference=Array.fill(n, {1.0.rand})},
                {m.reference=Array.fill(m.size, {0.5})});
                },{ q=m.value;m.reference=[]; h.string="reference can't be returned to nil presently. please hit RESET."}
            )
        });
    Button(w,180@20).states_([["fillColor = Color.rand"]]).action_({m.fillColor=Color.rand});
    Button(w,180@20).states_([["strokeColor = Color.rand"]]).action_({m.strokeColor=Color.rand});
    Button(w,180@20).states_([["background = Color.rand"]]).action_({m.background=Color.rand});

};
f.value;
w.front;

)
::


subsection:: Display a Sound File

code::
(
// press shift to extend the selection
// use as waveView: scrubbing over the view returns index
// if showIndex(false) the view is not refreshed (faster);
// otherwise you can make a selection with shift - drag.
var size, file, maxval, minval;
size = 640;
a = Window("test", Rect(200 , 140, 650, 150));
a.view.decorator = FlowLayout(a.view.bounds);
b = MultiSliderView(a, Rect(0, 0, size, 50));
b.readOnly_(true);
a.view.decorator.nextLine;

d = Array.new;
c = FloatArray.newClear(65493);

r = Slider( a, Rect(0, 0, size, 12));
r.action = {arg ex; b.gap = (ex.value * 4) + 1};

file = SoundFile.new;
file.openRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
file.numFrames.postln;
file.readData(c);
// file.inspect;
file.close;
minval = 0;
maxval = 0;
f = Array.new;
d = Array.new;
c.do({arg fi, i;
    if(fi < minval, {minval = fi});
    if(fi > maxval, {maxval = fi});

    //f.postln;
    if(i % 256 == 0,{
        d = d.add((1 + maxval ) * 0.5 );
        f = f.add((1 + minval ) * 0.5 );

        minval = 0;
        maxval = 0;
    });
});

b.reference_(d); // this is used to draw the upper part of the table
b.value_(f);

r = Slider( a, Rect(0, 0, size, 12));
r.action = {arg ex; b.startIndex = ex.value *f.size};

// b.enabled_(false);
b.action = {arg xb; ("index: " ++ xb.index).postln};
b.drawLines_(true);
b.drawRects_(false);
b.isFilled_(true);
b.selectionSize_(10);
b.index_(10);
b.thumbSize_(1);
b.gap_(0);
b.colors_(Color.black, Color.blue(1.0,1.0));
b.showIndex_(true);
a.front;

)
::


subsection:: Use as a Sequencer

code::
(
var size;
size = 12;
s.waitForBoot{
    n={arg freq=330; SinOsc.ar(freq,0,0.2)}.play;

    w = Window("test", Rect(200 , 450, 10 + (size * 17), 10 + (size * 17)));
    w.view.decorator = FlowLayout(w.view.bounds);
    b = MultiSliderView(w, Rect(0, 0, size * 17, size * 17));
    b.value_( Array.fill(size,{|i| i/size}) );
    b.background_(Color.rand);
    b.action = {arg xb;
        n.set(\freq, 330+(1100*xb.value.at(xb.index)));
        ("index: " ++ xb.index ++" value: " ++ xb.value.at(xb.index)).postln};
    b.elasticMode_(1); // makes the squares fit evenly
    b.showIndex = true; // cursor mode
    b.readOnly=true;
    w.front;

    r = Routine({
        0.1.wait;
        30.do({ arg i;
            b.index_(i%size);

            b.doAction;
            0.1.wait;
        });

        20.do({ arg i;
            b.index_(b.size.rand);
            b.doAction;
            [0.1,0.2].choose.wait;
        });
        1.wait;
        n.free;
        {w.close}.defer;
    });
    AppClock.play(r);
};
)
::
** class:: MultiTap
summary:: Multiple tap delay.
related:: Classes/Tap
categories::  UGens>Buffer, UGens>Delays>Buffer


Description::

This is a wrapper which creates a multiple tap delay line using
link::Classes/RecordBuf::  and  link::Classes/PlayBuf:: .


classmethods::

method::ar

argument::timesArray
A Ref to an Array of delay times in seconds.

argument::levelsArray
A Ref to an Array of amplitudes.

argument::in
The input signal.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

argument::bufnum

The number of the buffer to use for the delay. This must be at
least as long as the longest tap time.


Examples::

code::

s.boot;
b = Buffer.alloc(s, s.sampleRate);
(
{
	MultiTap.ar(`[0.1, 0.2, 0.3, 0.4], `[0.1, 0.2, 0.4, 0.8],
		Decay.ar(Dust.ar(2), 0.1, PinkNoise.ar), bufnum: b.bufnum)
}.play
)

::

** class::NAryOpFunction
summary::represent a n-ary oparation on a function
categories::Core
related::Classes/BinaryOpFunction, Classes/UnaryOpFunction, Classes/NAryOpStream, Classes/Pnaryop

description::
Operating on functions instead of numbers, what results is not a result of the calculation, but a structure that represents that calculation.

examples::
code::
// example
a = 0.8.linexp(0, 1, 40, 20000); // map (0..1) to exponentially to human frequency hearing range
a = { b }.linexp(0, 1, 40, 20000); // result is  a NAryOpFunction
b = 0.1;
a.value; // now it is evaluated, and the result is calculated
b = 0.5;
a.value; // again, with a different value.
::

code::
// sound example
(
var a = { 1.0.rand };
var b = a.linexp(0, 1, 40, 20000);
fork {
	15.do {
		(instrument: \default, freq: b.value).play;
		0.3.wait;
	}
}
)
::
** class:: NAryOpStream
summary:: several streams combined by an n-ary operator
related:: Classes/UnaryOpStream, Classes/BinaryOpStream
categories:: Streams-Patterns-Events

description::

A NAryOpStream is created as a result of a n-ary math operation on a Stream. It is defined to respond to strong::next:: by returning the result of the math operation on the strong::next:: value from the stream. It responds to strong::reset:: by resetting the Stream.

Examples::

code::
x = Routine { 6.do { arg i; i.yield; } }.wrap(0, 3);
x.dump;
::

code::
(
x = Routine { 6.do { arg i; i.yield; } }.wrap(0, 3);
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
)
::
** class:: NRand
summary:: Sum of uniform distributions.
related:: Classes/ExpRand, Classes/IRand, Classes/LinRand, Classes/Rand, Classes/TExpRand, Classes/TIRand, Classes/TRand
categories:: UGens>Random

Description::

Generates a single random float value in a sum of
code::n::  uniform distributions from
code::lo::  to  code::hi:: .


classmethods::

method::new

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

argument::n

table::

## n = 1: || Uniform distribution - same as link::Classes/Rand::.

## n = 2: || Triangular distribution.

## n = 3: || Smooth hump.

::

As
code::n::  increases, distribution converges
towards gaussian.


Examples::

code::

(
SynthDef("help-NRand", { arg out=0, n=0;
	Out.ar(out,
		FSinOsc.ar(
			NRand(1200.0, 4000.0, n),
			0, Line.kr(0.2, 0, 0.01, doneAction:2))
	)
}).send(s);
)

(
n = 0;
Routine({
	inf.do({ arg i;
		Synth.new("help-NRand", [\n, n]); 0.05.wait;
	})
}).play;
)

n = 1;
n = 2;
n = 4;

::

** class:: NamedControl
categories:: UGens>Synth control
summary:: Named reference to a control
related:: Classes/ControlName, Classes/Control

description::

A NamedControl directly combines a ControlName and a Control UGen conveniently. Also this makes it safe even if several identical controls exist (see example below).

There are syntax shortcuts that generate NamedControls from the name:
code::
\name.ar(values, lags)
\name.kr(values, lags, fixedLag)
\name.ir(values, lags)
\name.tr(values, lags)
::

ClassMethods::
method:: ar
add a new instance of link::Classes/AudioControl:: with given name and default values.
If lags are given, apply a Lag UGen to it.
discussion::
code::\symbol.ar(values, lags):: is a synonym.

method:: kr
add a new instance of link::Classes/Control:: (kr) with given name and default values.
If lags are given, apply a link::Classes/Lag:: UGen to it. If fixedLag is set to true, create a link::Classes/LagControl::
(lags cannot be modulated then, but fewer UGens are required).
discussion::
code::\symbol.kr(values, lags, fixedLag):: is a synonym.

method:: ir
add a new instance of link::Classes/Control:: (ir) with given name and default values.
If lags are given, apply a link::Classes/Lag:: UGen to it.
discussion::
code::\symbol.ir(values, lags):: is a synonym.

method:: tr
add a new instance of link::Classes/TrigControl:: with given name and default values.
If lags are given, apply a link::Classes/Lag:: UGen to it.
discussion::
code::\symbol.tr(values, lags):: is a synonym.

method:: new
add a new instance with the given rate, name and default values.
If lags are given, apply a link::Classes/Lag:: UGen to it. If fixedLag is set to true, create a link::Classes/LagControl::
(lags cannot be modulated then, but fewer UGens are required).

Examples::
code::
// use NamedControl to create a number of multichannel controls:

a = { SinOsc.ar(NamedControl.kr(\freq, [300, 330, 370], [1, 0.3, 0.02])).sum * 0.1 }.play;
a.setn(\freq, [700, 705, 890]);
a.setn(\freq, [0, 2, 5].midiratio * 400);

// synonymous:
a = { SinOsc.ar(\freq.kr([300, 330, 370], [1, 0.3, 0.02])).sum * 0.1 }.play;

// multiple usage of the same name:
a = { SinOsc.ar(\freq.kr(440, 3.5)) + Saw.ar(\freq.kr(440, 0.05) * 0.5) * 0.1 }.play;


a.set(\freq, 1220)
a.set(\freq, 120)
::

subsection:: Comparison with direct use of Controls

In the situation when functions are used to combine UGens to more complex SynthDefs, it may not be known which ControlNames are already taken by others. NamedControl allows to reuse existing control names.
code::
// compare:
(
a = {
	var x, y;
	x = NamedControl.kr(\freq, 440, 3.5);
	y = NamedControl.kr(\freq, 440, 1);
	SinOsc.ar([x, y] * [2, 1.2]) * 0.1
}.play;
)

a.set(\freq, 1220)
a.set(\freq, 120)

(
a = {
	var x, y;
	x = Control.names([\freq]).kr(440).lag(3.5);
	y = Control.names([\freq]).kr(440).lag(1);
	SinOsc.ar([x, y] * [2, 1.2]) * 0.1
}.play;
)

a.set(\freq, 1220)
a.set(\freq, 120)
::

subsection:: Using dictionary with functions to build SynthDefs
Here is a basic example using a dictionary with functions that can be combined to build SynthDefs.
code::
(
q = ();
q.makeEnv = { |q, env, doneAction = 0| EnvGen.kr(env, NamedControl.kr(\gate, 1), doneAction: doneAction) };
q.chooseNoise = { [ {PinkNoise.ar}, {WhiteNoise.ar}, {LFNoise2.ar(Rand(100, 1000))}].choose.value};
q.filterInput = { |q, in| [
	{ BPF.ar(in * 15, NamedControl.kr(\freq, 800), 0.2) },
	{ RHPF.ar(in, NamedControl.kr(\freq, 800, 0.2), 0.2) }
	].choose.value
};
)

// test the envelope:
a = { SinOsc.ar(440) * q.makeEnv(Env.asr, 2) * 0.1 }.play;
a.set(\gate, -3); // release in 3 seconds

// single channel:
a = { q.chooseNoise * q.makeEnv(Env.asr, 2) }.play;
a.set(\gate, -3); // release in 3 seconds

a = { q.filterInput(q.chooseNoise) * q.makeEnv(Env.asr, 2) }.play;
a.set(\freq, 1000); // set filter frequency
a.set(\gate, -3); // release in 3 seconds

(
a = {
	var channels = Array.fill(8, {
		q.filterInput(q.chooseNoise) * q.makeEnv(Env.asr, 2)
	});
	Splay.ar(channels);

}.play;
)
a.set(\freq, 6000); // set filter frequency
a.set(\gate, -3); // release in 3 seconds
::

** class:: Ndef
summary:: node proxy definition
categories:: Libraries>JITLib>NodeProxy
related:: Classes/ProxySpace, Classes/Tdef

description::
Reference to a proxy, forms an alternative to link::Classes/ProxySpace::. All methods are inherited from link::Classes/NodeProxy::.

code::
Ndef(key)	//returns the instance
Ndef(key, obj)	//stores the object and returns the instance, like Tdef and Pdef.
::

Graphical editor overviewing all current Ndefs: link::Classes/NdefMixer::. A general overview: link::Overviews/JITLib::.

subsection::First Example

code::
s.boot;

Ndef(\a).play; // play to hardware output.
Ndef(\a).fadeTime = 2; // fadeTime specifies crossfade
// set the source
Ndef(\a, { SinOsc.ar([350, 351.3], 0, 0.2) });
Ndef(\a, { Pulse.ar([350, 351.3] / 4, 0.4) * 0.2 });
Ndef(\a, Pbind(\dur, 0.03, \freq, Pbrown(0, 1, 0.1, inf).linexp(0, 1, 200, 350)));

Ndef(\a, { Ringz.ar(Ndef.ar(\b), [350, 351.3] * 8, 0.2) * 4 });
Ndef(\b, { Impulse.ar([5, 7]/2, [0, 0.5]) });

Ndef.clear(3); // clear all after 3 seconds
::

ClassMethods::

private::initClass

subsection::Creation

method::new
Return a new node proxy and store it in a global ProxySpace under the key. If there is already an Ndef there, replace its object with the new one. The object can be any supported class, see link::Classes/NodeProxy:: help.

argument::key
If key is an association, it is interpreted as strong::key -> server name::. (order changed in SC3.3 !). If no name is given, it uses the default server that was default when Ndef was first called. (to change it, see link::#*defaultServer::).

argument::object
an object

method::ar
equivalent to code::*new(key).ar(numChannels, offset):: (see link::Classes/NodeProxy:: help for ar method)

method::kr
equivalent to code::*new(key).kr(numChannels, offset):: (see link::Classes/NodeProxy:: help for kr method)

method::clear
clear all proxies

method::defaultServer
set the default server (default: code::Server.default::)

method::all
Return the dictionary of all servers, pointing to proxyspaces with Ndefs for each.

code::
Ndef.all;
::

method::dictFor
Return the proxyspace for a given server.

code::
Ndef.dictFor(s);
::

Examples::

code::
s.boot;

Ndef(\sound).play;
Ndef(\sound).fadeTime = 1;
Ndef(\sound, { SinOsc.ar([600, 635], 0, SinOsc.kr(2).max(0) * 0.2) });
Ndef(\sound, { SinOsc.ar([600, 635] * 3, 0, SinOsc.kr(2 * 3).max(0) * 0.2) });
Ndef(\sound, { SinOsc.ar([600, 635] * 2, 0, SinOsc.kr(2 * 3).max(0) * 0.2) });
Ndef(\sound, Pbind(\dur, 0.17, \freq, Pfunc({ rrand(300, 700) })) );

Ndef(\lfo, { LFNoise1.kr(3, 400, 800) });
Ndef(\sound).map(\freq, Ndef(\lfo));
Ndef(\sound, { arg freq; SinOsc.ar([600, 635] + freq, 0, SinOsc.kr(2 * 3).max(0) * 0.2) });
Ndef(\lfo, { LFNoise1.kr(300, 400, 800) });

Ndef.clear; //clear all
::

subsection::Simple audio routing with the <<> operator

code::
(
Ndef(\sound, {
	RHPF.ar(
		\in1.ar([0, 0]) * \in2.ar([0, 0]),
		\freq.kr(6000, 2),
		\rq.kr(0.2)
	) * 10
}).play;
);

Ndef(\a, { SinOsc.ar(MouseX.kr(300, 1000, 1) * [1, 1.2], \phase.ar([0, 0]) * 0.2) });
Ndef(\b, { LFDNoise3.ar(MouseY.kr(3, 1000, 1) * [1, 1.2]) });
Ndef(\c, { LFTri.ar(MouseY.kr(3, 10, 1) * [1, 1.2]).max(0) });

Ndef(\sound) <<>.in1 Ndef(\a);
Ndef(\sound) <<>.in2 Ndef(\b);
Ndef(\sound) <<>.in2 Ndef(\c);
Ndef(\a) <<>.phase Ndef(\sound);
Ndef(\a) <<>.phase nil;	// unmap
Ndef.clear(3);		// clear all Ndefs
::

subsection::Recursion

Ndefs can be used recursively. A structure like the following works:

code::
Ndef(\sound, { SinOsc.ar([600, 635], Ndef.ar(\sound) * 10, LFNoise1.kr(2).max(0) * 0.2) });
Ndef(\sound).play;
::

This is because there is a feedback delay (the server's strong::block size::), usually 64 samples, so that calculation can reiterate over its own outputs. For single sample feedback, see:

code::
Document.open("Examples/demonstrations/single_sample_feedback.scd")
::

subsection::Using different servers

code::
// create a new server
a = Server(\foo, NetAddr("127.0.0.1", 57123)).boot.makeWindow;
Ndef(\sound, { SinOsc.ar([600, 635]) * SinOsc.kr(2).max(0) * 0.2 }).play; // play on default
Ndef(\sound -> \foo, { SinOsc.ar([700, 745]) * SinOsc.kr(2).max(0) * 0.2 }).play;// play on foo

// clear definitions
Ndef(\sound -> \foo).clear(3);
Ndef(\sound).clear(3);
::

subsection::GUI

code::
// create a window for a given Ndef
Ndef(\sound).edit
(
Ndef(\sound, { |freq = 440, rate = 2|
	SinOsc.ar(freq * [1, 1.625]) * SinOsc.kr(rate).max(0) * 0.2
}).play;
);

// set lags for controls:
Ndef(\sound).lag(\freq, 0.2, \rate, 0.5);

// create a mixer for all Ndefs:
NdefMixer(s);
::

subsection::Using Associations

For a complete list, see link::Classes/NodeProxy::, and link::Reference/NodeProxy_roles::

code::
// setsrc
(
Ndef(\x,
	\setsrc -> Pbind(\source,
		Pseq([
			{ LFTri.ar(280 * Line.kr(1.1, 0.4, rrand(2, 3)) + [0,1]) * 0.1 },
			{ Pulse.ar(40 + [0,1]) * 0.1 },
			{ LFTri.ar(LFTri.kr(1).round(1.0.rand) + 1 * 180 + [0,1], 0.04) * 0.3 },
		], inf),
		\dur, Prand([3, 2, 4], inf)
	)
).play;
)
::
** class:: NdefGui
summary:: a gui for a NodeProxy or Ndef
categories:: Libraries>JITLib>GUI
related:: Classes/MonitorGui, Classes/NdefParamGui, Classes/NdefMixer, Classes/ProxyMixer

description::

NdefGui provides controls for handling and editing a link::Classes/NodeProxy:: or link::Classes/Ndef::, and its monitors. NdefGui replaces link::Classes/NodeProxyEditor::. It provides:

list::
## sliders for numerical settings
## mapping of kr proxies to parameters
## optional controls for playing / monitoring
::

Both link::Classes/NodeProxy:: and link::Classes/Ndef:: implement a strong::.gui:: message, which returns a NdefGui for that NodeProxy. Overview: link::Overviews/JITLib::.

ClassMethods::

private::initClass

subsection::Creation

method::new

argument::object
the nodeproxy to be shown and edited, or nil.

argument::numItems
How many sliders or textviews for paramaters to provide. Default value is 0.

argument::parent
a parent view where NdefGui is to be shown. If nil, a window is made.

argument::bounds
bounds where the view (or window) will be shown.

argument::makeSkip
a flag whether to create and start a link::Classes/SkipJack:: for auto-updating.

argument::options
an array of symbols for options of what to display. See list below.

subsection::Class Variables

method::buttonSizes
a dict for the sizes of the different gui elements.

InstanceMethods::

subsection::Instance Variables
As in all JITGuis:
	... object, numItems, parent, bounds ...
	... zone, minSize, defPos, skin, font, skipjack ...

method::nameView, typeView, monitorGui, paramGui, fadeBox, pauseBut, sendBut, edBut
Views if they were present in the options.

Examples::

code::
	// some preparation - make an ar and a kr nodeproxy.
s.boot;
(
Ndef(\lfo, { |lofreq| SinOsc.kr(lofreq) });
Ndef(\a, { |freq=300, dens=20, amp=0.1, pan|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2), pan)
});
)

	// make an NdefGui. By default, this has a lot of the options on.
n = NdefGui.new;
n.object_(Ndef(\lfo));
n.object_(Ndef(\a));

Ndef(\a).set(\lofreq, 12);
::

subsection::Some configuration options

code::
	// numItems - sliders for setting parameters
n = NdefGui(Ndef(\a), 8);

	// 4 sets of configurations are provided:
n = NdefGui(Ndef(\a), 0, options: NdefGui.control);
n = NdefGui(Ndef(\a), 0, options: NdefGui.audio);
n = NdefGui(Ndef(\a), 0, options: NdefGui.big);
n = NdefGui(Ndef(\a), 0, options: NdefGui.full);


NdefGui.control;	// used for control proxies in PxMix
->	[ \name, \pausR, \sendR, \poll, \ed ]

NdefGui.audio;		// used for audio proxies in PxMix
->	[ \monitor, \playN, \name, \pausR, \sendR, \ed ]

NdefGui.big;		// used for the big NdefGui in PxMix
->	[ \name, \type, \CLR, \reset, \scope, \doc, \end, \fade,
		\monitor, \playN, \pausR, \sendR, \poll ]

			// all of 'em
NdefGui.full;
->	[ 	name, \type, \CLR, \reset, \scope, \doc, \end, \fade, \rip,
		monitor, \playN, \pausR, \sendR, \poll, \ed ]

	// the choice of elements is
	\name		a dragboth for the proxy's name
	\type		a view for the proxy's type (ir, ar + numChans, kr + numChans)
	\CLR 		button to clear proxy
	\reset		button to reset proxy nodemap
	\scope		button to scope proxy
	\doc			button to document proxy as code
	\end			button to end proxy
	\fade		EZNumber for setting proxy fadetime

	\monitor		MonitorGui for audio proxies
	\playN		a button for editing playN settings (within the MonitorGui)

	\rip		(^)	button to open a new editor on the proxy (used in PxMix)

	\pausR		a button to toggle proxy pause/resume
	\sendR		a button to re-send; alt-click tells the proxy to rebuild
	\poll		poll the proxy

	//	Planned options - not done yet:
	\morph		add a PxPreset / morph control

		// 	pass in functions to add your own elements, such as:
	\zoink -> { |ndgui| Button(ndgui.zone, 60@20).states_([["zoink"]]).action_({ ndgui.object.zoink }) };



	// make one and watch how the elements change
n = NdefGui(Ndef(\a), 4, options: NdefGui.big);

Ndef(\a).stop;
Ndef(\a).play;
Ndef(\a).vol_(0.3);
Ndef(\a).stop;

Ndef(\a).playN([2, 5]);
Ndef(\a).playN([2, 5], vol: 0.34);


	// as in ProxyMixer, left side
n = NdefGui(Ndef(\a), options: NdefGui.audio);
n = NdefGui(Ndef(\a), 4, options: NdefGui.control); // control zone
n = NdefGui(options: NdefGui.big);

n = NdefGui(bounds: 400@20, options: NdefGui.full);

	// put in a window - then no margin is added
(
w = Window().front;
w.addFlowLayout;
n = NdefGui(Ndef(\a), 4, w, options: NdefGui.big);
)


Ndef(\a, { |freq = 10| Blip.ar(freq) }).set(\freq, 200)
Ndef(\a, { |freq = 10, amp = 0.1| Blip.ar(freq) * amp })
Ndef(\a).set(\freq, 220)
Ndef(\a).set(\harm, 20)
Ndef(\a, { |freq = 10, amp = 0.1, harm = 20| Blip.ar(freq, harm) * amp })
::

subsection::Works with ProxySpace as well

code::
p = ProxySpace.push;
n = NdefGui(~test, 4);

~test.ar;
~test.play;

	// too many controls: an EZScroller helps.
(
~test = { |freq=300, dens=20, amp=0.1, pan, ping=12, tok=13, crak|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2), pan)
};
	// gets specs for slider ranges from global lookup in Spec.specs:
Spec.add(\dens, [0.1, 100, \exp, 0.01, 10]);
)

(	// keys go away if not needed
~test = { |freq=300, dens=20, amp=0.1|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2))
};
)

(	// and are added in order if needed
~test = { |freq=300, intv=0, dens=20, amp=0.1, pan, pok, ting|
	Pan2.ar(
		Ringz.ar(
			Dust.ar(dens ! 2, amp / (dens.max(1).sqrt)),
			freq * [intv, intv.neg].midiratio, 0.2))
};
)

	// changes in settings are shown:
~test.set(\freq, exprand(100.0, 2000.0));
~test.playN([0, 2]);

	// mapping kr proxies to controls is shown
~lfo = { LFNoise0.kr(8, 4) };
~test.map(\intv, ~lfo);
~test.unmap(\intv);

Spec.add(\intv, ControlSpec(0, 24, \lin, 0.01, 0));
	// setting a param value unmaps a previous control source
~test.set(\freq, rrand(200, 500), \intv, rrand(-5.5, 5.5));
::

subsection::You can drag and drop proxies between NodeProxyEditors

code::
(
//	p = ProxySpace.push(s.boot);

l = NdefGui(nil, 3).moveTo(10, 120);
m = NdefGui(nil, 3).moveTo(10, 240);
n = NdefGui(nil, 3).moveTo(10, 360);
o = NdefGui(nil, 3).moveTo(10, 480);

Spec.add(\dens, [0.1, 300, \exp]);

	// make 3 kinds of proxies: using tilde/proxyspace, Ndef, and unnamed.
~spacy = {|dens=5| Formlet.ar(Dust.ar(dens ! 2), LFDNoise0.kr(20 ! 2).lag(0.1).linexp(-1, 1, 300, 5000), 0.003, 0.03) };
Ndef(\ndeffy, { GrayNoise.ar( 0.1 ! 2) });
c = NodeProxy.audio.source_({ PinkNoise.ar(0.1 ! 2) });

	// put one in each editor
l.object_(~spacy);
m.object_(Ndef(\ndeffy));
n.object_(c);
)
	// one can also drag and drop text into the drag:
(	Ndef(\a)	)
::

subsection::test replacing keys - needed for ProxyChain

code::
(
Ndef(\a, { |freq=300, dens=20, amp=0.1, pan|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2), pan)
});
n = NdefGui(Ndef(\a));
)
n.addReplaceKey(\freq, \myFreak);
	// ATM needs an extra update:
x = n.object; n.object_(nil); n.object_(x);
::
** class:: NdefMixer
summary:: mix control for an Ndef proxyspace
categories:: Libraries>JITLib>GUI
related:: Classes/ProxyMixer, Classes/JITGui, Classes/NdefGui

description::

NdefMixer is nearly identical to link::Classes/ProxyMixer::, except that it looks at the proxyspaces for each server that code::Ndef.all:: contains.

Examples::

code::
n = NdefMixer(s);

s.boot;

"bcdefghijk".do { |k| Ndef(k.asSymbol).ar };

"lmnopqrtuvw".do { |k| Ndef(k.asSymbol).kr };

"abcdefghijk".do { |k| Ndef(k.asSymbol).playN };
(
Ndef(\aaaaaa, { |freq=250, intv=19, timescale=1, curve=0, loopnode=0|
	var env = EnvGen.kr(
		Env({ 1.0.rand2 }!11, {1.0.rand}!10, curve, releaseNode: 9, loopNode: loopnode),
		timeScale: timescale);
	var pitch = (env * [1, 0.33, -1] * intv).midiratio * freq;
	Splay.ar(Formant.ar(pitch, pitch.scramble * 2, pitch.scramble)) * 0.1;
});
)

n.switchSize(2);
n.switchSize(1);
n.switchSize(0);
n.editGui.object_(Ndef(\aaaaaa));

NdefMixer(Server.internal, 24);
::
** class:: NdefMixerOld
summary:: mix control for all Ndefs on a given server
categories:: Libraries>JITLib>GUI
related:: Classes/NdefMixer

description::

For more details see: link::Classes/ProxyMixer::

ClassMethods::

subsection::Creation

method::new
Return a new window for a given server.

code::
// ndef mxers for other servers
n = NdefMixer(\internal);
n = NdefMixer(\localhost);
n = NdefMixer(\trala);		// fails, no such server
::

argument::server
Server object ( link::Classes/Server:: ) or server name ( link::Classes/Symbol:: )

argument::nProxies
an Integer.

argument::title
a String.

argument::bounds
a Rect.

InstanceMethods::

method::proxyspace
Return the proxyspace.


Examples::

code::
n = NdefMixer(s);		// for the default server
// make a new proxy
(
Ndef(\a, {
	Pan2.ar(
		Ringz.ar(
			Impulse.ar(exprand(0.5, 4)),
			exprand(300, 3000),
			0.02
		),
	1.0.rand2,
	0.2)
})
);



n.proxyspace;

Ndef(\duster, { Dust.kr(4) });

Ndef(\a).ar;
Ndef(\a).fadeTime = 2;
Ndef(\a).end;
::
** class:: NdefParamGui
summary:: display the settings of a nodeproxy
categories:: Libraries>JITLib>GUI
related:: Classes/EZText, Classes/NdefGui

description::

NdefParamGui displays all settings and mappings of a nodeproxy, so one can change them flexibly. Single number get displayed with an link::Classes/EZSlider::, and anything else is shown as an link::Classes/EZText:: (a text field). Its main use is within link::Classes/NdefGui::.

ClassMethods::

subsection::Creation

method::new
create a new NdefParamGui

code::
// simple example
g = NdefParamGui.new(nil, 5);	// empty with 5 slots
g.object_(Ndef(\a));		// put in a nodeproxy
Ndef(\a, { |freq = 300, amp = 0.2| SinOsc.ar(freq) * amp });
Ndef(\a).set(\freq, 2000);	// add a setting

g.object_(nil);			// put in a nodeproxy

g.object_(Ndef(\a)); 		// put in a nodeproxy
Ndef(\a).set(\amp, 0.125);	// add a setting
Ndef(\a, { |freq = 300, amp = 0.2| SinOsc.ar(freq) * amp });
Ndef(\a).set(\freq, 234);	// add a setting

Ndef(\a).play
Ndef(\lfo, { LFNoise0.kr([12, 8], 200).sum + 500 });
Ndef(\a).map(\freq, Ndef(\lfo));// mapped proxies are shown


//Multichannel controls are shown in EZText

Ndef(\a, { |freqs = #[300, 303], pan, amp = 0.2, moddd = 0.1| SinOsc.ar(freqs).sum * amp });
Ndef(\a).play
Ndef(\a).setn(\freqs, [300, 350])
Ndef(\a).setn(\freqs, [330, 350])
Ndef(\a).set(\harm, 123)

Ndef(\a).nodeMap.clear

Ndef(\lfos, { LFNoise0.kr([12, 8], 200) + 500 });
Ndef(\a).map(\freqs, Ndef(\lfos))

g.parent.close
::

argument::object
the nodeproxy whose settings are to be displayed.

argument::numItems
the number of items to display. If an envir is given, and no num, num is envir.size.

argument::parent
the parent view to display in; if none is given, a new window is created.

argument::bounds
the bounds within which to display; if none is given, bounds are calculated.

argument::makeSkip
flag whether to make a skipjack to manage updates of the envirgui. default is true.

argument::options
a list of additional information, e.g. flags about optional buttons.

InstanceMethods::

method::name
if in its own window, set the window's name

code::
g.name = "Yoohoo";
::

Examples::

code::
	// put an NdefParamGui in an existing window - margin becomes 0@0
(
w = Window().front;
w.addFlowLayout;
g = NdefParamGui(Ndef(\a), 3, w);
NdefParamGui(Ndef(\c), 15, w);
)
	// even
Ndef(\c).set(\otto, 123, \mops, [1,2,3], \kotzt, [0, 6, 0, 6]);
Ndef(\c).nodeMap.clear
::
** class:: NetAddr
summary:: network address
related:: Classes/OSCFunc
categories:: Control, External Control>OSC

ClassMethods::

private::initClass

method::new
create new net address.
note::To send messages internally, loopback IP is used: "127.0.0.1"::

argument::hostname
a link::Classes/String::, either an IP number (e.g. "192.168.34.56") or a hostname such as "otherHost.local".

argument::port
a port number, like 57110.

method::fromIP
create new net address using an integer IP number.

method::langPort
Get the port sclang is currently listening on (may change after a recompile).

method::localAddr
Get a NetAddr which corresponds to localhost and the port sclang is listening on.

method::disconnectAll
close all TCP connections.

method::broadcastFlag
Get or set the broadcast flag (whether or not broadcast messages can be sent).

InstanceMethods::

private::prConnect, prDisconnect, prConnectionClosed, recover

method::sendMsg
send a message without timestamp to the addr.

method::sendBundle
send a bundle with timestamp to the addr.

method::sendRaw
send a raw message without timestamp to the addr.

method::connect
open TCP connection.

argument::disconnectHandler
called when the connection is closed (either by the client or by the server).

method::disconnect
close TCP connection.

method::ip
returns the ip number (as a link::Classes/String::).
code::
n = NetAddr("localhost", 57110);
n.ip;
::

Examples::

code::
n = NetAddr("127.0.0.1", 57120); // 57120 is sclang default port
r = OSCFunc({ arg msg, time; [time, msg].postln }, '/good/news', n);

n.sendMsg("/good/news", "you", "not you");
n.sendMsg("/good/news", 1, 1.3, 77);


n.sendBundle(0.2, ["/good/news", 1, 1.3, 77]);

r.free;
n.disconnect;

// note that different NetAddr objects with the same port and ip are independent.

r = OSCFunc({ "message arrived".postln }, '/x');

n = NetAddr("127.0.0.1", 57120);
n.sendMsg("/x")


u = NetAddr("127.0.0.1", 57120);
u.sendMsg("/x");

n.disconnect

u.sendMsg("/x");

r.free;
u.disconnect;
::


** class::Nil
categories::Core
summary::Represents uninitialized data

description::

Nil has a single instance named nil and is used to represent uninitialized data,
bad values, or terminal values such as end-of-stream.

instancemethods::

private::do, reverseDo, pairsDo, collect, select, reject, detect, collectAs, selectAs, rejectAs, pop, source, source_, changed, 	addDependant, removeDependant, release, update, swapThisGroup, performMsg, remove, seconds_, throw, superclassesDo, !?, play, printOn, storeOn, archiveAsCompileString, set, addDependant


method::isNil
Answers true because this is nil. In class Object this message is defined to answer false.

method::notNil
Answer false. In class Object this message answers true.

method::?

return first non-nil argument. Since this IS nil then return anObject.
In class link::Classes/Object::, ? is defined to answer the receiver.

method::??
If the receiver is nil, value the function and return the result.  Since this IS nil, then value the function and return the result. In class Object, ?? is defined to answer the receiver.

method::add
Returns an array with the value. This makes it unecessary to initialize when adding to a variable.

method::addAll
Returns an array with all the values. This makes it unecessary to initialize when adding to a variable.

method::remove
Returns nil. This makes it unecessary to initialize when adding to a variable.

method::++
Returns an array with all the values. This makes it unecessary to initialize when adding to a variable.

method::booleanValue
Returns false.

method::rate
Returns nil.

method::numChannels
Returns nil.

method::isPlaying
Returns false.

method::dependants
Returns an empty IdentitySet.

method::transformEvent
Return the argument.

method::awake
Returns nil.

method::nextTimeOnGrid
Returns clock.nextTimeOnGrid.

method::asQuant
Returns Quant.default.

method::matchItem
Returns true.

method::add
Returns an array with item.

method::addAll
Returns array.asArray.

method::++
Returns array.

method::asCollection
Returns empty array.

method::get
Returns prevVal.

method::addFunc
Returns the function or a FunctionList.

method::removeFunc
Returns Nil.

method::asSpec
Returns the default ControlSpec

method::handleError
Either report error or inspect error and halt execution.

method::push
Executes function.

method::appendStream
Retuns stream.

subsection::Dependancy

All the messages for the Dependancy protocol (See class link::Classes/Object::) are defined in class Nil
to do nothing. This eliminates the need to check for nil when sending dependancy messages.

subsection::Other Methods

Many other messages are defined in class Nil to do nothing. This eliminates the need to check for nil.


** class:: Node
summary:: Abstract superclass of Synth and Group
related:: Reference/Server-Architecture, Classes/Synth, Classes/Group, Classes/RootNode
categories:: Server>Nodes, Server>Abstractions

Description::
This class is the abstract super class of Synth and Group, which represent synth and group nodes on the server.  Node objects are not made explicitly, but Synth and Group are subclasses, and inherit the methods  documented below.

subsection:: Freed Nodes and Node Status

Nodes which you explicitly free using the methods free or release will have their group instance variable set to nil. However Nodes which are automatically freed after a certain time (for instance by an link::Classes/EnvGen:: with a doneAction of 2) will not.
This keeps the implementation of the classes simple and lightweight.

To have the current state of a Node tracked you can register it with an instance of link::Classes/NodeWatcher::, either by calling register on the Node instance or on the NodeWatcher singleton. This will enable two variables, isPlaying and isRunning, which you can use for checking purposes.

subsection:: Bundling

Many of the methods below have two versions: a regular one which sends its corresponding message to the server immediately, and one which returns the message in an link::Classes/Array:: so that it can be added to a bundle.
It is also possible to capture the messages generated by the regular methods using Server's automated bundling capabilities. See link::Classes/Server:: and link::Guides/Bundled-Messages:: for more details.

classmethods::
private:: initClass

method:: addActions
Returns:: the list of addActions as an event.
discussion::
Useful for converting addAction symbols to their corresponding integer codes.
code::
(
Node.addActions.at(\addToTail)
);
// returns 1
::

instancemethods::

subsection:: Instance Variables

The following getter methods also have corresponding setters, but they should be used with extreme care and only if you are sure you know what you're doing.

method:: nodeID
Returns:: the Node's node ID number.
discussion::
Normally you should not need to access this since instances of Node can be passed directly as link::Classes/UGen:: inputs or link::Classes/Synth:: args.

method:: group
Returns:: an instance of Group or RootNode corresponding to this Node's group on the server.

method:: server
Returns:: an instance of Server corresponding to this Node's server app.

method:: isPlaying
Returns:: a boolean indicating if this node is currently on the server, providing this Node has been registered with a link::Classes/NodeWatcher::.
discussion::
N.B. If this Node has not been registered this will likely be false in any case.

method:: isRunning
Returns:: a boolean indicating if this node is currently on the server, providing this Node has been registered with a link::Classes/NodeWatcher::.
discussion::
N.B. If this Node has not been registered this will likely be false in any case.

subsection:: Node Commands

See the Node Commands section in link::Reference/Server-Command-Reference:: for the OSC equivalents of the methods outlined below.

method:: free, freeMsg
Stop this Node and free it from its parent group on the server. Once a Node has been freed, you cannot restart it.
argument:: sendFlag
a boolean indicating whether the free message should be sent. If false an n_free message will not be sent to this Node's server, but its isPlaying and isRunning variables will be set to false. The default for sendFlag is true.
discussion::
If this Node is a link::Classes/Group:: this will free all Nodes within the Group.
code::
s.boot;
x = Synth("default");
x.free;
::

method:: run, runMsg
Set the running state of this Node according to a boolean. False will pause the node without freeing it. The default is true.
discussion::
If this Node is a Group this will set the running state of all Nodes within the Group.
code::
s.boot;
(
x = SynthDef("help-node-set", {arg freq = 440, out = 0;
	Out.ar(out, SinOsc.ar(freq, 0, 0.1));}).play(s);
)
x.run(false);
x.run; // default is true
x.free;
::

method:: set, setMsg
Set controls in this Node to values.
discussion::
Controls are defined in a SynthDef as args or instances of link::Classes/Control::. They are specified here using symbols, strings, or indices, and are listed in pairs with values. If this Node is a Group this will set all Nodes within the Group.
code::
s.boot;
(
x = SynthDef("help-node-set", {| freq = 440, out = 0 |
	Out.ar(out, SinOsc.ar(freq, 0, 0.1));
});
x = x.play(s);
)
x.set(\freq, 880, \out, 1); // two pairs
x.set(0, 660, 1, 0); // freq is the first argument, so it's index is 0. out is index 1.
x.free;
::
Values that are arrays are sent using the OSC array type-tags ($[ and $]).  These values will be assigned to subsequent controls in the manner of setn.
code::
s.boot;
(
x = SynthDef("help-node-set", {| freq = #[440, 450, 460], out = 0 |
	Out.ar(out, Mix(SinOsc.ar(freq, 0, 0.1)));
});
x = x.play(s);
)
x.set(\freq, [1,2,3] * 400 + [1,2,3], \out, 1); // two pairs
x.set(\freq, [3] * 400 + [1,2,3], \out, 1); // two pairs
x.set(0, [660, 680, 720], 1, 0); // freq is the first argument, so it's index is 0. out is index 1.
x.free;
::

method:: setn, setnMsg
Set sequential ranges of controls in this Node to values.
discussion::
Controls are defined in a SynthDef as args or instances of link::Classes/Control::. They are specified here using symbols, strings, or indices, and are listed in pairs with arrays of values. If this Node is a Group this will setn all Nodes within the Group.
code::
s.boot;
(
x = SynthDef("help-node-setn", {
	arg freq1 = 440, freq2 = 440, freq3 = 440, amp1 = 0.05, amp2 = 0.05, amp3 = 0.05;
	Out.ar(0, Mix(SinOsc.ar([freq1, freq2, freq3], 0, [amp1, amp2, amp3])));}).play(s);
)
// set 3 controls starting from \freq1, and 3 controls starting from \amp1
x.setn(\freq1, [440, 880, 441], \amp1, [0.3, 0.1, 0.3]);
x.free;
::

method:: fill, fillMsg
Set sequential ranges of controls in this Node to a single value.
discussion::
Controls are defined in a SynthDef as args or instances of link::Classes/Control::. They are specified here using symbols, strings, or indices, and are listed in groups of three along with an integer indicating the number of controls to set, and the value to set them to. If this Node is a Group this will fill all Nodes within the Group.

method:: map, mapMsg
Map controls in this Node to read from control or audio rate link::Classes/Bus::es.
discussion::
Controls are defined in a SynthDef as args or instances of link::Classes/Control:: or its subclasses. They are specified here using symbols, strings, or indices, and are listed in pairs with Bus objects. The number of sequential controls mapped corresponds to the Bus' number of channels.

If this Node is a Group this will map all Nodes within the Group.

Note that with mapMsg if you mix audio and control rate busses you will get an Array of two messages rather than a single message. Integer bus indices are assumed to refer to control buses. To map a control to an audio bus, you must use a Bus object.
code::
s.boot;
(
b = Bus.control(s, 1); b.set(880);
c = Bus.control(s, 1);	c.set(884);
x = SynthDef("help-Node-map", { arg freq1 = 440, freq2 = 440;
	Out.ar(0, SinOsc.ar([freq1, freq2], 0, 0.1));
}).play(s);)
x.map(\freq1, b, \freq2, c);
x.free; b.free; c.free;

// same as above with a multichannel Bus and Control
(
b = Bus.control(s, 2); b.set(880, 884);
x = SynthDef("help-Node-map2", { arg freqs = #[440, 440];
	Out.ar(0, SinOsc.ar(freqs, 0, 0.1));
}).play(s);)
x.map(\freqs, b);
x.free; b.free;
::

method:: mapn, mapnMsg
Map sequential ranges of controls in this Node to read from control rate Buses.
discussion::
This is similar to map above, but you specify the number of sequential Controls to map. If this Node is a Group this will mapn all Nodes within the Group.

method:: release, releaseMsg
This is a convenience method which assumes that the synth contains an envelope generator (an EnvGen, Linen, or similar UGen) running a sustaining envelope (see Env) and that it's gate argument is set to a control called \gate. This method will cause the envelope to release.
argument:: releaseTime
if not nil, it will override the envelope's decay or release time.
discussion::
If this Node is a Group this will release all Nodes within the Group.
code::
x = { arg gate=1; BrownNoise.ar(0.5) * EnvGen.kr(Env.cutoff(1), gate, doneAction:2) }.play;
x.release(5); // overide the Env's specified 1 second release time
::

method:: query
Sends an n_query message to the server, which will reply with a message containing information about this node and its place in the server's node tree.
discussion::
This information will be printed to the post window. (See also the queryAllNodes method of Server.) "parent" indicates the Node's enclosing group. If "prev" or "next" are equal to -1 that indicates that there are no other nodes in the enclosing group before or after this one, respectively.
code::
g = Group.new;
x = Synth.head(g, "default");
x.query;
g.query;
s.queryAllNodes; // Note the RootNode (ID 0) and the default Group (ID 1)
x.free; g.free;
::

method:: trace
Causes a synth to print out the values of the inputs and outputs of its unit generators for one control period to the post window. Causes a group to print the node IDs and names of each node in the group for one control period.
code::
g = Group.new;
x = Synth.head(g, "default");
x.trace;
g.trace;
x.free; g.free;
::

method:: register
Registers the node at the link::Classes/NodeWatcher:: object.
discussion::
This will enable two variables, isPlaying and isRunning, which you can use for checking purposes.
code::
(
b = s.makeBundle(false, {
	a = Group.new(s); //create a node object
	a.register; // register before creating on the server
});
)
a.isPlaying;
s.listSendBundle(nil, b); //start the node on the server
a.isPlaying;
a.isRunning;
a.run(false);
a.isRunning;
s.freeAll; //free all nodes
a.isPlaying;
a.isRunning;
::

subsection:: Changing the order of execution

The following methods can be used to change the Node's place in the order of execution. See the link::Guides/Order-of-execution:: help file for more information on this important topic. See link::Reference/Server-Command-Reference:: for the OSC equivalents of these methods.

method:: moveAfter, moveAfterMsg
Move this Node to be directly after aNode. N.B. n_after, the OSC message which this method encapsulates, allows already freed nodes as targets. This is so that one may attempt a series of moves, with the last successful one taking effect. For this reason this method will fail silently if either the target or this node have already been freed. If you will need to check, you may register the relevant nodes with a NodeWatcher.

method:: moveBefore, moveBeforeMsg
Move this Node to be directly before aNode. N.B. n_before, the OSC message which this method encapsulates, allows already freed nodes as targets. This is so that one may attempt a series of moves, with the last successful one taking effect. For this reason this method will fail silently if either the target or this node have already been freed. If you will need to check, you may register the relevant nodes with a NodeWatcher.

method:: moveToHead, moveToHeadMsg
If aGroup is a Group then this method will move this Node to the head of that Group. If it is nil this will move this Node to the head of the default_group of this Node's Server.

method:: moveToTail, moveToTailMsg
If aGroup is a Group then this method will move this Node to the tail of that Group. If it is nil this will move this Node to the tail of the default_group of this Node's Server.

subsection:: Other Methods

method:: asTarget
Returns:: this Node. See the link::Reference/asTarget:: help file for more details.

method:: printOn
Prints this Node's link::Classes/Class:: (link::Classes/Synth:: or link::Classes/Group::) and nodeID on stream.

method:: hash
Returns:: server.hash bitXor: nodeID.hash

method:: ==
Returns:: true if this Node and aNode have the same nodeID and the same Server object, otherwise returns false.
discussion::
Under certain circumstances this Node and aNode might not be the same object, even though this returns true.
code::
g = Group.basicNew(s, 1); // the default group of s
h = Group.basicNew(s, 1); // and again
g == h; 	// true
g === h;	// false
::

method:: onFree
Evaluate function when this Node is freed.
discussion::
code::
{PinkNoise.ar(1) * Line.kr(1,0,2,doneAction:2)}.play.onFree {"done".postln};
::

method:: waitForFree
Wait until this Node is freed. Should be used inside a Routine or similar.
discussion::
code::
(
fork {
    {SinOsc.ar(440!2) * Line.kr(0,1,5,doneAction:2)}.play.waitForFree;
    {PinkNoise.ar(1) * Line.kr(1,0,2,doneAction:2)}.play.onFree {"done".postln};
}
)
::

code::
(
SynthDef(\help, {
	var mod = LFNoise2.kr(Rand(1, 6)) * 0.2;
	var snd = mod * Blip.ar(Rand(200, 800) * (mod + 1));
	Out.ar(0, snd);
	FreeSelf.kr(mod < 0);
}).add;
)

(
fork {
	10.do {
		"started a synth".postln;
		Synth(\help).waitForFree;
		"This one ended. Wait a second, I will start the next one.".postln;
		1.wait;
	};
	"This is it.".postln;
}
);
::

** class:: NodeControl
summary:: Encapsulates in an object a node and an index.
categories:: Server>Nodes

description::
This object can be held by a client and have its value set without otherwise having to store the details about where the node's input is.

classmethods::
method:: new
argument:: node
The node to encapsulate
argument:: index
The index to encapsulate

instancemethods::
method:: value
set the value


examples::
code::
d = SynthDef("help-NodeControl",{ arg out=0,freq=400;
	Out.ar(out,
		 SinOsc.ar(freq, 0, 0.5)
	)
});
y = d.play; // the synth

c = NodeControl(y,1);

c.value = 500;

c.value = 300;
::

** class:: NodeMap
summary:: store control values and bus mappings
categories:: Libraries>JITLib>NodeProxy
related:: Classes/Bus

description::
Object to store control values and bus mappings independant of of a specific node.

InstanceMethods::

method::set
set arguments of a node

method::map
set bus mappings of a node

method::unset
remove settings

method::unmap
remove mappings

method::setn
set ranges of controls

method::mapn
map num busses mappings to node

method::at
return setting at that key.

method::sendToNode
apply a setting to a node by sending a bundle

method::send
apply a setting to a node by sending a bundle

method::addToBundle
add all my messages to the bundle

Examples::

code::

s.boot;

(
SynthDef("modsine",
	{ arg freq=320, amp=0.2;
		Out.ar(0, SinOsc.ar(freq, 0, amp));
	}).send(s);
SynthDef("lfo",
	{ arg rate=2, busNum=0;
		Out.kr(busNum, LFPulse.kr(rate, 0, 0.1, 0.2))
	}).send(s);
)

//start nodes
(
b = Bus.control(s,1);
x = Synth("modsine");
y = Synth.before(x, "lfo", [\busNum, b]);
)

//create some node maps
(
h = NodeMap.new;
h.set(\freq, 800);
h.map(\amp, b);

k = NodeMap.new;
k.set(\freq, 400);
k.unmap(\amp);
)

//apply the maps

h.sendToNode(x); //the first time a new bundle is made
k.sendToNode(x);

h.sendToNode(x); //the second time the cache is used
k.sendToNode(x);

h.set(\freq, 600);

h.sendToNode(x); //when a value was changed, a new bundle is made

//free all
x.free; b.free; y.free;
::
** class:: NodeProxy
summary:: a reference on a server
categories:: Libraries>JITLib>NodeProxy
related:: Classes/ProxySpace

description::
Generally a strong::proxy:: is a placeholder for something. A node proxy is a placeholder for something strong::playing on a server:: that writes to a limited number of busses (e.g. a synth or an event stream). NodeProxy objects can be replaced and recombined while they play. Also they can be used to build a larger structure which is used and modified later on. Overview: link::Overviews/JITLib::.

NodeProxy is used internally in link::Classes/ProxySpace:: and it is a superclass of link::Classes/Ndef::, allowing to easily access and combine a large number of placeholders.

Graphical editor for a node proxy: link::Classes/NodeProxyEditor::.

note::
NodeProxy plays on a emphasis::private bus::. If you want to strong::hear:: the output, use link::#-play:: and link::#-stop::. To free inner players and stop listen: link::#-end::. Entirely removing all inner settings: link::#-clear::
::

subsection::Further reading

list::
## link::Tutorials/JITLib/the_lazy_proxy::
## link::Tutorials/JITLib/jitlib_efficiency::
## link::Tutorials/JITLib/jitlib_fading::
## link::Tutorials/JITLib/jitlib_asCompileString::
## link::Reference/NodeProxy_roles::
::

subsection::First Example

code::
s.boot;

a = NodeProxy.new.play; // play to hardware output.
a.fadeTime = 2; // fadeTime specifies crossfade
// set the source
a.source = { SinOsc.ar([350, 351.3], 0, 0.2) };
a.source = { Pulse.ar([350, 351.3] / 4, 0.4) * 0.2 };
a.source = Pbind(\dur, 0.03, \freq, Pbrown(0, 1, 0.1, inf).linexp(0, 1, 200, 350));

b = NodeProxy.new;
a.source = { Ringz.ar(b.ar, [350, 351.3] * 8, 0.2) * 4 };
b.source = { Impulse.ar([5, 7]/2, [0, 0.5]) };

a.clear(3); // clear after 3 seconds
b.clear(3);
::

ClassMethods::

subsection::Creation

method::new
Return a new instance of NodeProxy.

code::
// new node proxy
a = NodeProxy(s, \audio, 4);
a.numChannels;
a.clear; // remove bus.
a.numChannels; // nil.
::

argument::server
The server on which to run and where the bus is allocated (default: code::Server.default::)

argument::rate
If given, proxy is initialized to this rate

argument::numChannels
If given, proxy is initialized to this number of channels

argument::inputs
If given, proxy is initialized with the given inputs as objects on subsequent slots.

method::audio
Return a new audio rate NodeProxy of a given number of channels.

argument::server
The server on which to run and where the bus is allocated (default: code::Server.default::)

argument::numChannels
If given, proxy is initialized to this number of channels (default: 2)

method::control
Return a new control rate NodeProxy of a given number of channels.

argument::server
The server on which to run and where the bus is allocated (default: code::Server.default::)

argument::numChannels
If given, proxy is initialized to this number of channels (default: 1)

method::for
Return a new instance of NodeProxy using a given link::Classes/Bus::.

subsection::Accessing Class Variables

method::defaultNumAudio, defaultNumControl
set the default channel number for audio/control busses

InstanceMethods::

private::prFadeTime, linkNodeMap, generateUniqueName, prepareOutput, addToChild

subsection::Listening to the output

method::play
plays to a bus index ( strong::out:: ) with a number of channels ( strong::numChannels:: ) within a target strong::group:: ( link::Classes/Group:: or link::Classes/Server:: ).

argument::multi
keep old links and add new one

argument::vol
volume at which to monitor

argument::fadeTime
fade in fade out time

method::playN
see link::Reference/playN::.

argument::outs
array of destination channels

argument::amps
array of amplitudes for each channel

argument::ins
array of source channels

method::stop
stop to play out public channels (private channels keep playing as others might listen still) this stops the monitoring. To stop the objects playing, use link::#-free::, link::#-release::.

argument::fadeTime
decay time for this action

method::end
releases the synths and stops playback.

argument::fadeTime
decay time for this action

argument::reset
a boolean

method::ar, kr
return a link to my output, which is limited by [numChannels]. causes an uninitialized proxy to create a matching bus. normally strong::ar:: defaults to stereo, strong::kr:: to mono. this can be set in the classvars: link::#*defaultNumAudio::, link::#*defaultNumControl::.

subsection::Setting the source

NodeProxy keeps a number of slots which can be sources and are mixed on the same bus.. The default source is the slot 0. All objects can be exchanged while running, and also before and after. Normally, the source is active immediately. If sources are to be exchanged "quietly", set the node proxy to sleep (awake = false), or use the message prime().

See the list under section link::#Supported sources::

method::source
Play a new synth through proxy and release/remove any old ones.

argument::obj
can be one of the supported inputs (see link::#Supported sources::)

method::prime
Set source without starting the synth. To start it, link::#-send:: can be used later. Running synths are released and proxy is initialized if still neutral.

method::add
Add a new source to the present ones

method::removeAt
Remove the object at index i and its synths, if they exist.

method::removeLast
Remove the last object and its synths, if they exist.

method::put
Set the source by index. Objects can be inserted at any index, only the order of indices is relevant. Internally, NodeProxy uses an link::Classes/Order:: to access the sources.

argument::index
where the object should be placed in the internal order. if code::-1::, all objects are freed

argument::obj
A valid source (see link::#Supported sources::).

argument::channelOffset
using a multichannel setup it can be useful to set this, when the objects numChannels is smaller than the proxy

argument::extraArgs
Arguments that can be sent with the object directly (not cached)

argument::now
if set to false, only prepare the source and do not start the object (see link::#-prime::)

code::
// put can be used with the array indexing syntax:
a = NodeProxy.new.play;
a[0] = { SinOsc.ar(Rand(200, 899)) * 0.1.dup };
a[2] = { SinOsc.ar(Rand(200, 899)) * 0.1.dup };
a.sources.do(_.postcs);
// using multiple index expands into multiple objects
a[0..5] = { SinOsc.ar(Rand(200, 899)) * 0.1.dup };
a.sources.do(_.postcs);
a.send; // exchange synths, using the sources as definitions
a.clear;
::

method::pause
Pause all objects and set proxy to paused

method::resume
If paused, start all objects

method::rebuild
Rebuild all SynthDefs from sources.

method::orderNodes
Arrange the order of groups from this to the last. This can be important when external input is filtered in order to strong::minimize latency::. Note that if a link::#-parentGroup:: was provided, the nodes must be in the same parentGroup.

method::<--
Usage: strong::proxyA <-- proxyB::.  Set proxyA source to proxyB and play proxyA. If proxyB was playing, fade it out. This is convenient in the following situation:

code::
b = NodeProxy.new.play;
b.source = { PinkNoise.ar(0.2.dup) };
// now I want to filter b through a new proxy.
a = NodeProxy.new;
a <-- b; a.source = { HPF.ar(b.ar, 7000) };
a.source = { HPF.ar(b.ar, 3000) };// changing the source
a.clear; b.clear;
::

method::<<>
Chaining. Usage: strong::proxyA <<> proxyB	<<> proxyC <<> ...:: . Map proxyC source to proxyB code::\in:: argument, and proxyB to proxyA's in argument.

code::
a = NodeProxy.new.play;
a.source = { RLPF.ar(\in.ar(0!2), [4600, 7000], 0.1) };
b = NodeProxy.new.source_ { Impulse.ar([5, 7] / 2) };
a <<> b;
::

method::<>>
Inverse of the above. Usage: strong::proxyA <>> proxyB	<>> proxyC <>> ...:: .

subsection::Release and cleaning up

method::free
Release all running synths and the group. If patterns are playing, stop them.

argument::fadeTime
decay time for this action

argument::freeGroup
a boolean

method::release
release running synths. If patterns are playing, stop them.

argument::fadeTime
decay time for this action

method::clear
reset everything to nil, neutralizes rate/numChannels

argument::fadeTime
if a fadeTime is given, first fade out, then clear.

subsection::Accessing Instance Variables

method::sources
Returns an array of all sources

method::source
Returns the first source.

method::server
The node proxy's server (a link::Classes/Server::).

method::bus
The node proxy's private bus (a link::Classes/Bus::). Because it has a private bus, it is not audible directly - monitoring it by (.play or playN) routs it to the hardware output channels.

method::rate
The bus rate (default: nil) The rate and number of channels is determined either when the instance is created (.control/.audio) or by lazy initialisation from the first source (see link::Tutorials/JITLib/the_lazy_proxy::)

method::numChannels
The bus numChannels (default: nil)

method::isNeutral
true if the proxy has no initialized bus.

method::group
The node proxy's group (a link::Classes/Group::). This is maintained by the proxy and serves as a context in which all synths are placed.

method::parentGroup
Access the parentGroup (default: nil), which can be set to run the proxy's group in another group. This group has to be maintained (kept playing etc.) externally.

method::clock
A clock, which can be set to account for different timing schemes, such as beat accurate replacement of sources.

method::quant
A quant value, to specify quantizes replacement of sources. Compatible with the general use of quant in SuperCollider.

method::quantize
Synchronize the proxies by resending and adjusting to quant.

method::monitor
Access the link::Classes/Monitor:: object, which plays back the output of the proxy's private bus.

method::loaded
Returns true if the object has been initialized on the server, e.g. a synthDef has been stored.

method::paused
Returns true if the processes are paused.

method::awake
If set to false (default: true), a change of the source does not start a new synth immediately. This is useful when synths are triggered by link::#-spawn::, and a change of sound should not duplicate sends.

method::fadeTime
set the crossfade time. See: link::Tutorials/JITLib/jitlib_fading:: .

subsection::Setting synth controls

method::set, unset, unmap
NodeProxy behaves like its nodeMap ( link::Classes/NodeMap:: )

method::map
Map the arguments in keys to the subsequent channels of another proxy (keys can be a symbol or a number). If the proxy has strong::multiple channels::, subsequent channels of the control, if present, are mapped. Note that you should not map to more channels than the control has.

method::setn
set ranges of controls

method::xset
set with crossfade into new setting

method::xmap
map with crossfade into new setting

method::xsetn
untested

method::lag
set the lag values of these args (identical to link::#-setRates::). To remove these settings, use: code::lag(\key1, nil, key2, nil, ...)::

method::setRates
set the default rate (\tr, \ir, numerical) for synthDef arg. A rate of nil removes setting.

method::controlNames
Returns the link::Classes/ControlName:: objects of all slots, strong::except:: the names of this list (default: code::[\out, \i_out, \gate, \fadeTime]:: , which are used internally).

method::controlKeys
Returns the keys (symbols) of all control names objects of all slots, strong::except:: the names of this list. (default: none).

argument::except
list of names

argument::noInternalKeys
If noInternalKeys is true (default: true), it ignores the keys code::[\out, \i_out, \gate, \fadeTime]:: .

method::getKeysValues
Get all key value pairs from both link::Classes/NodeMap:: (the settings) and default arguments.

method::controlKeysValues
Get all key value pairs from default arguments.

subsection::Sending synths to server

method::send
Send a new synth without releasing the old one. If the source is a stream or a pattern, it starts a new one.

argument::extraArgs
Arguments used to set the synth. the argument list is applied to the synth only.

argument::index
What slot to send a new synth with. If nil, uses all. (default: nil)

argument::freeLast
if to free the last synth at that index or not (default: true)

method::sendAll
Send all synths, or restart all objects.

argument::extraArgs
Arguments used to set the synth. the argument list is applied to the synth only.

argument::freeLast
if to free the last synth at that index or not (default: true)

method::sendEach
Like send, just iterating seperately over the objects.

method::wakeUp
Until the proxy is not used by any output ( either .play or .ar/.kr ) it is not running on the server. you can wake it up to force it playing. Normally this is not needed.

subsection::GUI

method::edit
Returns a new instance of link::Classes/NodeProxyEditor:: for this proxy.

code::
a = NodeProxy.new;
a.edit;

(
a.source = { |freq = 440, rate = 2|
	SinOsc.ar(freq * [1, 1.625]) * SinOsc.kr(rate).max(0) * 0.2
}
);
::

section::Supported sources

definitionList::
## link::Classes/NodeProxy:: || played by reading from the other node proxie's bus.
## link::Classes/Function:: || interpreted as ugen function, and plays a link::Classes/Synth::, similar to Function.play.
## link::Classes/SimpleNumber:: || write this value to the bus continuously
## link::Classes/Bus:: || reads from the bus
## link::Classes/SynthDef:: || plays a link::Classes/Synth:: using the SynthDef. This is useful for triggering.
## link::Classes/Symbol:: || plays a link::Classes/Synth:: from the SynthDef with this name. This is useful for triggering.
## link::Classes/Pattern:: || played as event pattern (using link::Classes/Pbind:: or other event patterns)
## link::Classes/Stream:: || played as event stream (a stream returning events)
## nil || link::Classes/Nil:: removes all objects.
## link::Classes/Pdef::, link::Classes/EventPatternProxy:: || played like a stream
## link::Classes/Task:: || played, no output is assigned.
## link::Classes/Tdef:: || played like Task
## link::Classes/Event:: || played like in a pattern.

## Associations: ||
definitionList::
## (\filter -> func) || filter previous input (with post control)
## (\filterIn -> func) || filter previous input (with pre control)
## (\set -> event pattern) || set controls with the event keys of the pattern
## (\setbus -> event pattern) || set bus with an event pattern. Bus value is the \value key of each event.
## (\setsrc -> event pattern) || set the source with an event pattern. source is the \source key of event.
## (\control -> array or number) || prepare an efficient way to set values by index
## (\mix -> func) || mix audio
::

## crucial library: ||
definitionList::
## AbstractPlayer || started in a separate bus, mapped to this bus
## Instr || converted to player and started
::
::

Definitions for other sources can be added easily.

Examples::

For more, see link::Classes/ProxySpace::

code::
///////////////////// using node proxy with ugen functions /////////////////////

s.boot;

a = NodeProxy.audio(s, 2);
a.play; // play to hardware output, return a group with synths

// setting the source
a.source = { SinOsc.ar([350, 351.3], 0, 0.2) };

// the proxy has two channels now:
a.numChannels.postln;
a.source = { SinOsc.ar([390, 286] * 1.2, 0, 0.2) };

// exeeding channels wrap:
a.source = { SinOsc.ar([390, 286, 400, 420, 300] * 1.2, 0, 0.2) };

// other inputs
a.source = { WhiteNoise.ar([0.01,0.01]) };
a.source = 0;
a.source = \default; // synthDef on server
a.source = SynthDef("w", { arg out=0; Out.ar(out,SinOsc.ar([Rand(430, 600), 600], 0, 0.2)) });
a.source = nil; // removes any object

// feedback
a.source = { SinOsc.ar(a.ar * 7000 * LFNoise1.kr(1, 0.3, 0.6) + 200, 0, 0.1) };
a.source = { SinOsc.ar(a.ar * 6000 * MouseX.kr(0, 2) + [100, 104], 0, 0.1) };

// fadeTime
a.fadeTime = 2.0;
a.source = { SinOsc.ar([390, 286] * ExpRand(1, 3), 0, 0.2) };


// adding nodes
a.add({ SinOsc.ar([50, 390]*1.25, 0, 0.1) });
a.add({ BrownNoise.ar([0.02,0.02]) });

// setting nodes at indices:
a[0] = { SinOsc.ar( 700 * LFNoise1.kr(1, 0.3, 0.6) + 200, 0, 0.1) };
a[1] = { LFPulse.kr(3, 0.3) * SinOsc.ar(500, 0, 0.1) };
a[2] = { LFPulse.kr(3.5, 0.3) * SinOsc.ar(600, 0, 0.1) };
a[3] = { SinOsc.ar([1,1.25] * 840, 0, 0.1) };

// filtering: the first argument is the previous bus content. more args can be used as usual.
a[3] = \filter -> { arg in; in * SinOsc.ar(Rand(100,1000)) };
a[2] = \filter -> { arg in; in * MouseY.kr(0,1) };
a[8] = \filter -> { arg in; in * MouseX.kr(0,1) };
a[4] = \filter -> { arg in; in * SinOsc.ar(ExpRand(1,5)).max(0) };



// setting controls
a.fadeTime = 2.0;
a.source = { arg f=400; SinOsc.ar(f * [1,1.2] * rrand(0.9, 1.1), 0, 0.1) };
a.set(\f, rrand(900, 300));
a.set(\f, rrand(1500, 700));
a.xset(\f, rrand(1500, 700)); // crossfaded setting
a.source = { arg f=400; RLPF.ar(Pulse.ar(f * [1,1.02] * 0.05, 0.5, 0.2), f * 0.58, 0.2) };

// control lags
a.lag(\f, 0.5); // the objects are built again internally and sent to the server.
a.set(\f, rrand(1500, 700));
a.lag(\f, nil);
a.set(\f, rrand(1500, 700));

a.fadeTime = 1.0;

// mapping controls to other node proxies

c = NodeProxy.control(s, 2);
c.source = { SinOsc.kr([10,20] * 0.1, 0, 150, 1300) };
a.map(\f, c);
a[0] = { arg f=400; RHPF.ar(Pulse.ar(f * [1,1.2] * 0.05, 0.5, 0.2), f * 0.58, 0.2) };
c.source = { SinOsc.kr([10,16] * 0.02, 0, 50, 700) };
c.source = { Line.kr(300, 1500, 10) + SinOsc.kr(20 * [1,2], 0, 100) };
a[1] = { arg f; LFPar.ar(f % MouseX.kr(1, 40, 1) * 4 + 360, 0, 0.2) };

// map multiple channels of one proxy to multiple controls of another
// recently changed behaviour!

a.source = { arg f=#[400, 400]; LPF.ar(Pulse.ar(f[0] * [0.4,1], 0.2, 0.2), f[1] * 3) };
a.map(\f, c); // multichannel proxy c is mapped to multichannel control of a
a.source = { arg f=#[400, 400]; LPF.ar(Pulse.ar(f, 0.2, 0.2), f[1]) };
a.source = { arg f=#[400, 400]; Formant.ar(140, f * 1.5, 100, 0.1) };
c.source = { SinOsc.kr([Line.kr(1, 30, 10), 1], 0, [100, 700], [300, 700]) };
c.source = 400;


c.fadeTime = 5.5;
c.source = { LFNoise0.kr([2.3, 1.0], [100, 700], [300, 1700]) };
c.source = { SinOsc.kr([2.3, 1.0], 0, [100, 700], [300, 1700]) };
c.source = 400;


// behave like a sc2 plug
c.gate(1400, 0.1);
c.gate(1000, 0.1);
c.line(1000, 1);

// direct access
a.lineAt(\f, 300, 2);
a.xlineAt(\f, 600, 0.3);
a.gateAt(\f, 1600, 0.3);


// changing nodeMaps
a.unmap(\f);
n = a.nodeMap.copy;
n.set(\f, 700);
a.fadeToMap(n);
n = a.nodeMap.copy;
n.set(\f, 400);
a.fadeTime = 1.0;
a.fadeToMap(n, [\f]); // linear interpolation to new map: experimental
a.map(\f, c); // restore mapping


// sending envelopes (up to 8 levels)
w = Env.new(Array.rand(3, 400, 1000),Array.rand(2, 0.3, 0.001), -4);
c.env(w);
c.env(w);
w = Env.new(Array.rand(8, 400, 1000),Array.rand(7, 0.03, 0.1));
c.env(w);
c.env(w);

// stop synthesis, then wake up proxies:

a.stop; // stop the monitor
a.play; // start the monitor
a.end;	// release the synths and stop the monitor
c.free;	// free the control proxy c
::

code::

///////////////////// channel offset/object index /////////////////////


a = NodeProxy.audio(s,2);
a.play;
a[0] = { Ringz.ar(Impulse.ar(5, 0, 0.1), 1260) };
a.put(1, { Ringz.ar(Impulse.ar(5.3, 0, 0.1), 420) }, 1);
a.put(0, { Ringz.ar(Dust.ar([1,1]*15.3, 0.1), 720) }, 1);
a.put(1, { Ringz.ar(Impulse.ar(5.3, 0, 0.1), 420) }, 1);
a.end;
::

code::

///////////////////// beat accurate playing /////////////////////




a = NodeProxy.audio(s,2);
a.play;

a.clock = TempoClock(2.0).permanent_(true); // round to every 2.0 seconds
a.source = { Ringz.ar(Impulse.ar(0.5, 0, 0.3), 3000, 0.01) };
a[1] = { Ringz.ar(Impulse.ar([0.5, 1], 0, 0.3), 1000, 0.01) };
a[2] = { Ringz.ar(Impulse.ar([3, 5]/2, 0, 0.3), 8000, 0.01) };
a[3] = { Ringz.ar(Impulse.ar([3, 5]*16, 0, 0.3), 5000, 0.01) * LFPulse.kr(0.5, 0, 0.05) };

a.removeLast;
a.removeAt(2);

a.clear;
::

code::

///////////////////// using patterns - event streams /////////////////////


(
// must have 'out' or 'i_out' argument to work properly
SynthDef("who", { arg freq, gate=1, out=0, ffreq=800, amp=0.1;
	var env;
	env = Env.asr(0.01, amp, 0.5);
	Out.ar(out, Pan2.ar(
		Formant.ar(freq, ffreq, 300, EnvGen.kr(env, gate, doneAction:2)), Rand(-1.0, 1.0))
	)
}).add;

)


(
s.boot;
a = NodeProxy.audio(s, 2);
a.fadeTime = 2;
b = NodeProxy.audio(s,2);
b.fadeTime = 3;
)

a.play; // monitor output

// play the pattern silently in b
b.source = Pbind(\instrument, \who, \freq, 500, \ffreq, 700, \legato, 0.02);

// play b out through a:
a.source = b;

// filter b with ring modulation:
a.source = { b.ar * SinOsc.ar(SinOsc.kr(0.2, 300, 330)) }; // filter the input of the pattern
a.source = { b.ar * LFCub.ar([2, 8], add: -0.5) }; // filter the input of the pattern

a.source = b;

// map b to another proxy
c = NodeProxy.control(s, 1).fadeTime_(1);
c.source = { SinOsc.kr(2, 0, 400, 700) };


// now one can simply embed a control node proxy into an event pattern.
// (this works not for \degree, \midinote, etc.)
// embedding in other patterns it will still return itself.


b.source = Pbind(\instrument, \who, \freq, 500, \ffreq, c, \legato, 0.02);

c.source = { SinOsc.kr(SinOsc.kr(0.2, 0, 10, 10), 0, 400, 700) };

c.source = { LFNoise1.kr(5, 1300, 1500) };
c.source = { MouseX.kr(100, 5500, 1) };

(
b.source = Pbind(
			\instrument, \who,
			\freq, Pseq([600, 350, 300],inf),
			\legato, 0.1,
			\ffreq, Pseq([c, 100, c, 100, 300, 600], inf), // use proxy in a pattern
			\dur, Pseq([1, 0.5, 0.75, 0.25] * 0.4, inf),
			\amp, Pseq([0.2, 0.2, 0.1, 0.1, 0.2], inf)
		);
)



b[2] = Pbind(\instrument, \who, \freq, 620, \ffreq, Prand([500,c],inf), \legato, 0.1, \dur, 0.1);
b[3] = Pbind(\instrument, \who, \ffreq, 5000, \freq, Pseq([720, 800],inf), \legato, 0.1, \dur, 0.1, \amp, 0.01);
b[4] = Pbind(\instrument, \who, \freq, Pseq([700, 400],inf), \legato, 0.1, \ffreq, 200);
b[1] = { WhiteNoise.ar([0.01,0.01]) };
b[4] = { arg ffreq=800; Resonz.ar(WhiteNoise.ar([1,1]), ffreq, 0.05) };


b.map(\ffreq, c); // map the control to the proxy
b.removeLast;
b.removeLast;
a.source = { b.ar * WhiteNoise.ar(0.1, 1) };
a.source = { b.ar * WhiteNoise.ar(0.1, 1) + (b.ar * SinOsc.ar(SinOsc.kr(0.01, 0, 50, 330))) };

c.source = { XLine.kr(1900, 10, 10) };

a.clear(10); b.clear(10); c.clear(10); // fade out and clear all (free bus, group and synths)
::
** class:: NodeProxyEditor
summary:: editor for a nodeproxy - replaced by NdefGui!
categories:: Libraries>JITLib>GUI
related:: Classes/NdefGui

description::

warning::
NodeProxyEditor has been rewritten and renamed link::Classes/NdefGui::, which has the same functionality, but is both more consistent and more flexible. There are some changes to the strong::*new:: method:

definitionList::
## instead of || *new(proxy, nSliders=16, parent, extras=[\CLR, \reset, \scope, \doc, \end, \fade], monitor, sinks, morph)
## NdefGui uses || *new(object, numItems = 0, parent, bounds, makeSkip, options)
::

strong::proxy:: is now strong::object::, strong::nSliders:: is now strong::numItems::, strong::parent:: is still strong::parent::. strong::bounds:: - can be code::Rect(l, t, w, h):: or code::width@heights::, strong::makeSkip:: - is an option to build without skipjack. strong::extras:: are now strong::options::, and have become more flexible.

Please see link::Classes/NdefGui:: for more details.
::

NodeProxyEditor provides controls for handling and editing a node proxy and its monitors (cross-platform graphics).

list::
## sliders for numerical settings
## mapping of kr proxies to parameters
## optional controls for playing / monitoring
::

link::Classes/NodeProxy:: and link::Classes/Ndef:: implement an strong::edit:: message, which returns a link::Classes/NodeProxyEditor::. Overview: link::Overviews/JITLib::

ClassMethods::

private::initClass

subsection::Creation

method::new
Returns a new instance for a given proxy. If a window (win) or a composite view is given, it uses this.

Examples::

code::
	// preparation
s.boot;
p = ProxySpace.push(s);

(
~test = { |freq=300, dens=20, amp=0.1, pan|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2), pan)
};
)

	// make a NodeProxyEditor
n = NodeProxyEditor();
n.proxy_(~test);

	// some configuration options
	// number of sliders
n = NodeProxyEditor(~test, 6);

	// the top line has a choice of elements:
	\CLR 		button to clear proxy
	\reset		button to reset proxy nodemap
	\scope		button to scope proxy
	\doc		button to document proxy as code
	\end		button to end proxy
	\fade		EZNumber for setting fadetime

		not in the default elements:
	\rip		button to open a new editor on the proxy (used in ProxyMixer)

	\pausR		a button to toggle pause/resume
	\sendR		a button to re-send; alt-click does Rebuild

	\send		just send
	\rebuild	just rebuild
	\poll		poll the proxy

		// maybe provide later this?
	\name -> { func }; 	// add your own element...

	// The default buttons/controls are:
NodeProxyEditor(extras: nil, monitor: true, sinks: true);
	// these are:
NodeProxyEditor(extras: [\CLR, \reset, \scope, \doc, \end, \fade], monitor: true, sinks: true);
	// if no monitor line, you can add pausR and sendR buttons
NodeProxyEditor(extras: [\CLR, \reset, \pausR, \sendR, \scope], monitor: false, sinks: false);


	// barebones
NodeProxyEditor(extras: [], monitor: false);

	// not done yet - presets and morphing
NodeProxyEditor( morph: true);

	// also works with Ndef
Ndef(\a).ar;
NodeProxyEditor(Ndef(\a));

	// place in existing window
(
w = Window("testing");
n = NodeProxyEditor(nSliders: 6, win: w);
n.proxy_(~test);
)
	// too many controls: an EZScroller helps.
(
~test = { |freq=300, dens=20, amp=0.1, pan, ping=12, tok=13, crak|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2), pan)
};
Spec.add(\dens, [0.1, 100, \exp, 0.01, 10]);
)
	// gets specs for slider ranges from global lookup in Spec.specs:
Spec.add(\dens, [0.1, 100, \exp, 0.01, 10]);
n.fullUpdate;

(	// keys go away if not needed
~test = { |freq=300, dens=20, amp=0.1|
	Pan2.ar(Ringz.ar(Dust.ar(dens, amp / (dens.max(1).sqrt)), freq, 0.2))
};
)

(	// and are added in order if needed
~test = { |freq=300, intv=0, dens=20, amp=0.1, pan, pok, ting|
	Pan2.ar(
		Ringz.ar(
			Dust.ar(dens ! 2, amp / (dens.max(1).sqrt)),
			freq * [intv, intv.neg].midiratio, 0.2))
};
)

	// changes in settings are shown:
~test.set(\freq, exprand(100.0, 2000.0));
~test.playN;

	// mapping kr proxies to controls is shown
~lfo = { LFNoise0.kr(8, 4) };
~test.map(\intv, ~lfo);
~test.unmap(\intv);

Spec.add(\intv, ControlSpec(0, 24, \lin, 0.01, 0)); n.fullUpdate;
	// setting a param value unmaps a previous control source
~test.set(\freq, rrand(200, 500), \intv, rrand(-5.5, 5.5));
::

subsection::You can drag and drop proxies between NodeProxyEditors

code::
(
// p = ProxySpace.push(s.boot);

l = NodeProxyEditor(nil, 3); l.w.bounds_(l.w.bounds.moveBy(0, 120));
m = NodeProxyEditor(nil, 3); m.w.bounds_(m.w.bounds.moveBy(0, 240));
n = NodeProxyEditor(nil, 3); n.w.bounds_(n.w.bounds.moveBy(0, 360));
o = NodeProxyEditor(nil, 3); o.w.bounds_(o.w.bounds.moveBy(0, 480));

Spec.add(\dens, [0.1, 300, \exp]);

	// make 3 kinds of proxies: using tilde/proxyspace, Ndef, and unnamed.
~spacy = {|dens=5| Formlet.ar(Dust.ar(dens ! 2), LFDNoise0.kr(20 ! 2).lag(0.1).linexp(-1, 1, 300, 5000), 0.003, 0.03) };
Ndef(\ndeffy, { GrayNoise.ar( 0.1 ! 2) });
c = NodeProxy.audio.source_({ PinkNoise.ar(0.1 ! 2) });

	// put one in each editor
l.proxy_(~spacy);
m.proxy_(Ndef(\ndeffy));
n.proxy_(c);
)
::
** class:: NodeWatcher
summary:: notify sc-lang side node objects of their server sided state
related:: Reference/Server-Command-Reference, Classes/Node, Classes/DebugNodeWatcher
categories:: Control, Server>Nodes

description::
Node instances (Synths and Groups) can be registered with the NodeWatcher.
It watches for server node status messages:
n_go n_end n_off n_on

and sets the isPlaying and isRunning variables on the Node instance accordingly. A Node that ends is unregistered at that time.

In some cases this can be an invaluable service. The use of an independant object to maintain the state keeps the implementation of the Node classes simple.
Note that server notification should be on. (this is default. see: aServer.notify)

code::
//the most common use:
NodeWatcher.register(aNode);
::

ClassMethods::

private::initClass

method::new
Create a new instance listening to the server's address

method::newFrom
Create a new instance listening to the server's address. If there is one present already return that one.

method::register

argument::node
Can be a Group or a Synth. The NodeWatcher is created internally.

argument::assumePlaying
If true, the node's strong::isPlaying:: field is set to true.

method::unregister
Remove the node from the list of nodes. This happens also when a node is freed.

InstanceMethods::

method::start
Add the OSCFunc to listen to the address.

method::stop
Remove the OSCFunc to stop listen to the address.

Examples::

code::
(
b = s.makeBundle(false, {
	a = Group.new(s);	//create a node object
	NodeWatcher.register(a); // register before creating on the server
});
)
a.isPlaying;
s.listSendBundle(nil, b);	//start the node on the server
a.isPlaying;
a.isRunning;
a.run(false);
a.isRunning;
s.freeAll;	//free all nodes
a.isPlaying;
a.isRunning;
::
** class:: Normalizer
summary:: Flattens dynamics.
related:: Classes/Amplitude, Classes/Compander, Classes/CompanderD, Classes/Limiter
categories:: UGens>Dynamics


Description::

Normalizes the input amplitude to the given level. Normalizer will not
overshoot like  link::Classes/Compander::  will, but it needs to look
ahead in the audio. Thus there is a delay equal to twice the value
of the  code::dur::  parameter.


classmethods::

method::ar

argument::in
The signal to be processed.

argument::level
The peak output amplitude level to which to normalize the input.

argument::dur

The buffer delay time. Shorter times will produce smaller delays
and quicker transient response times, but may introduce amplitude
modulation artifacts.


Examples::

code::

(
// example signal to process
Synth.play({
	var z;
	z = Decay2.ar(
		Impulse.ar(8, LFSaw.kr(0.25, -0.6, 0.7)),
		0.001, 0.3, FSinOsc.ar(500));
}, 0.8)
)

(
Synth.play({
	var z;
	z = Decay2.ar(
		Impulse.ar(8, LFSaw.kr(0.25, -0.6, 0.7)),
		0.001, 0.3, FSinOsc.ar(500));
	[z, Normalizer.ar(z, 0.4, 0.01)]
}, 0.5)
)

::

** class:: NoteOffResponder
summary:: allow functions to be registered to respond to MIDI noteOff events
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIResponder, Classes/NoteOnResponder
categories:: External Control>MIDI

Description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. They still lack some features of the MIDIresponder classes.::
ClassMethods::

method::new

argument::function
A link::Classes/Function:: to be evaluated. Arguments passed to the function are: src, chan, num, value.

argument::src
The src number may be the system UID (obtained from code:: MIDIClient.sources[index].uid ::) or the index of the source in the code:: MIDIClient.sources :: array. nil matches all.

argument::chan
An link::Classes/Integer:: between 0 and 15 that selects which MIDI channel to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 2 }

argument::num
An link::Classes/Integer:: between 0 and 127 that selects which note number to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val >= 4 }

argument::veloc
An link::Classes/Integer:: between 0 and 127 to filter values. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 50 }

argument::install
If true, install the responder automatically so it is active and ready to respond. If false, then it will be inactive.

argument::swallowEvent
If true, then if the midi event is matched, cease testing any further responders. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

InstanceMethods::

method::learn
Wait for the next noteOff message, reset self to match src, chan.
code::
(
c = NoteOffResponder({ |src,chan,note,vel|
		[src,chan,note,vel].postln;
	});
	c.learn; // wait for the first note off
)
NoteOffResponder.removeAll
::


Examples::

code::
(
	c = NoteOffResponder({ |src,chan,note,vel|
		[src,chan,note,vel].postln;
		},
		nil, // any source
		nil, // any channel
		nil, // any note
		nil // any vel
	)
)

c.remove
::

code::
(
	c = NoteOffResponder({ |src,chan,note,vel|
		[src,chan,note,vel].postln;
		},
		nil, // any source
		nil, // any channel
		(50..60), // within this note range
		nil // any vel
	)
)

c.remove
::
** class:: NoteOnResponder
summary:: allow functions to be registered to respond to MIDI noteOn events
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIResponder, Classes/CCResponder
categories:: External Control>MIDI

Description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. They still lack some features of the MIDIresponder classes.::
ClassMethods::

method::new

argument::function
A link::Classes/Function:: to be evaluated. Arguments passed to the function are: src, chan, num, value.

argument::src
The src number may be the system UID (obtained from code:: MIDIClient.sources[index].uid ::) or the index of the source in the code:: MIDIClient.sources :: array. nil matches all.

argument::chan
An link::Classes/Integer:: between 0 and 15 that selects which MIDI channel to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 2 }

argument::num
An link::Classes/Integer:: between 0 and 127 that selects which note number to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val >= 4 }

argument::veloc
An link::Classes/Integer:: between 0 and 127 to filter values. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 50 }

argument::install
If true, install the responder automatically so it is active and ready to respond. If false, then it will be inactive.

argument::swallowEvent
If true, then if the midi event is matched, cease testing any further responders. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

InstanceMethods::

method::learn
Wait for the next noteOn message, reset self to match src, chan.
code::
(
c = NoteOnResponder({ |src,chan,note,vel|
		[src,chan,note,vel].postln;
	});
	c.learn; // wait for the first note
)
NoteOnResponder.removeAll
::


Examples::

code::
(
	c = NoteOnResponder({ |src,chan,note,vel|
		[src,chan,note,vel].postln;
		},
		nil, // any source
		nil, // any channel
		nil, // any note
		nil // any vel
	)
)

c.remove
::

code::
(
	c = NoteOnResponder({ |src,chan,note,vel|
		[src,chan,note,vel].postln;
		},
		nil, // any source
		nil, // any channel
		(50..60), // within this note range
		nil // any vel
	)
)

c.remove
::
** class:: NotificationCenter
summary:: let an object emit notifications
related:: Classes/SimpleController, Classes/NodeWatcher
categories:: Control

description::
One common OOP pattern is Model-View-Controller where one object (the controller) is a dependant of the model. Every time the model changes it notifies all of its dependants. In this case the model has a dictionary of dependants and iterates through those.

Another common pattern is NotificationCenter wherein an object emits a notification and clients can register functions that will be executed when that notification happens.

A link::Classes/Server:: emits a \newAllocators notification when it creates new node and bus allocators which it does when it quits or boots.

code::
NotificationCenter.notify(Server.default, \newAllocators);
::

You can listen for this:

code::
NotificationCenter.register(Server.default, \newAllocators, yourself, {
	// throw away all your node variables
	// or stop the music
});
::

The link::Classes/Buffer:: class register a function to clear its info cache whenever a server restarts. The server is emiting changed messages quite often (every 0.4 secs for the status updates), and the Buffer class is only interested in boot/quit events, so this is a more lightweight system for this purpose.

ClassMethods::

private::initClass

method::notify
The object emits a message and may also pass extra args.

method::register
An interested client can register the action function for the object/message notification. A listener may only register one action per object/message notification.

method::unregister
Remove the registrations.

method::registerOneShot
After the notification has been emited and handled, automatically unregister.

method::registrationExists
Simply confirms if a registration is already in place.
** class:: NumAudioBuses
summary:: Number of audio busses.
related:: Classes/NumBuffers, Classes/NumControlBuses, Classes/NumInputBuses, Classes/NumOutputBuses, Classes/NumRunningSynths
categories::  UGens>Info


Description::

Number of audio busses.


classmethods::

method::ir

** class:: NumBuffers
summary:: Number of open buffers.
related:: Classes/NumAudioBuses, Classes/NumControlBuses, Classes/NumInputBuses, Classes/NumOutputBuses, Classes/NumRunningSynths
categories::  UGens>Info


Description::

Number of open buffers.


classmethods::

method::ir

** class:: NumChannels
summary:: Ensures the number of output channels
categories:: UGens>Multichannel

Description::
Ensures the output has the stated number of channels, regardless of the number of input channels.

classmethods::

method:: ar
argument:: input
the audio signal
argument:: numChannels
an integer
argument:: mixdown
true/false, whether you want to mixdown or just use the first channel

discussion::
Mono input is copied.
Multi-channels clumped and if code::mixdown:: is true mixed down, else the first channel used.

Examples::
code::
(
{
	NumChannels.ar(
		SinOsc.ar(100,0,0.2), // 1 becomes 2
		2)
}.play
)

(
{
	NumChannels.ar(
		SinOsc.ar([100,200,300],0,0.2), // 3 becomes 2
		2)
}.play
)

(
{
	NumChannels.ar(
		SinOsc.ar([100,200,300,100],0,0.2), // 4 becomes 2

		2)
}.play
)
::

** class:: NumControlBuses
summary:: Number of control busses.
related:: Classes/NumAudioBuses, Classes/NumBuffers, Classes/NumInputBuses, Classes/NumOutputBuses, Classes/NumRunningSynths
categories::  UGens>Info


Description::

Number of control busses.


classmethods::

method::ir

** class:: NumInputBuses
summary:: Number of input busses.
related:: Classes/NumAudioBuses, Classes/NumControlBuses, Classes/NumBuffers, Classes/NumOutputBuses, Classes/NumRunningSynths
categories::  UGens>Info


Description::

Number of input busses.


classmethods::

method::ir

** class:: NumOutputBuses
summary:: Number of output busses.
related:: Classes/NumAudioBuses, Classes/NumControlBuses, Classes/NumBuffers, Classes/NumInputBuses, Classes/NumRunningSynths
categories::  UGens>Info


Description::

Number of output busses.


classmethods::

method::ir

** class:: NumRunningSynths
summary:: Number of currently running synths.
related:: Classes/NumAudioBuses, Classes/NumControlBuses, Classes/NumBuffers, Classes/NumInputBuses, Classes/NumOutputBuses
categories::  UGens>Info


Description::

Number of currently running synths.


classmethods::

method::ir

Examples::

code::

// example: frequency is derived from the number of synths running
(
SynthDef("numRunning", { arg out;
	Out.ar(out, SinOsc.ar(NumRunningSynths.ir * 200 + 400, 0, 0.1));
}).send(s);
)

s.sendMsg("/s_new", "numRunning", -1, 0, 0);
s.sendMsg("/s_new", "numRunning", -1, 0, 0);
s.sendMsg("/s_new", "numRunning", -1, 0, 0);
s.sendMsg("/s_new", "numRunning", -1, 0, 0);

::

** class:: Number
summary:: Mathematical quantity
categories:: Math

description::
Number represents a mathematical quantity.

instancemethods::

subsection:: Math

method:: +
Addition.

method:: -
Subtraction.

method:: *
Multiplication.

method:: /
Division.

method:: div
Integer division.

method:: %
Modulo.

method:: **
Exponentiation.


subsection:: Polar Coordinate Support

method:: rho
Answer the polar radius of the number.

method:: theta
Answer the polar angle of the number.


subsection:: Complex Number Support

method:: real
Answer the real part of the number.

method:: imag
Answer the imaginary part of the number.


subsection:: Conversion

method:: @
Create a new link::Classes/Point:: whose x coordinate is the receiver and whose y coordinate is aNumber.

method:: complex
Create a new link::Classes/Complex:: number whose real part is the receiver with the given imaginary part.

method:: polar
Create a new link::Classes/Polar:: number whose radius is the receiver with the given angle.


subsection:: Iteration

method:: for
Calls strong::function:: for numbers from this up to endval, inclusive, stepping each time by 1.
argument:: endValue
a link::Classes/Number::.
argument:: function
a link::Classes/Function:: which is passed two arguments, the first which is an number from this to
argument:: endval, and the second which is a number from zero to the number of iterations minus one.

method:: forBy
Calls strong::function:: for numbers from this up to endval stepping each time by step.
argument:: endValue
a link::Classes/Number::.
argument:: stepValue
a link::Classes/Number::.
argument:: function
a link::Classes/Function:: which is passed two arguments, the first which is an number from this to
endval, and the second which is a number from zero to the number of iterations minus one.

method:: forSeries
Calls strong::function:: for numbers from this up to endval stepping each time by a step specified by second.
argument:: second
a link::Classes/Number::.
argument:: last
a link::Classes/Number::.
argument:: function
a link::Classes/Function:: which is passed two arguments, the first which is an number from this to
endval, and the second which is a number from zero to the number of iterations minus one.

** CLASS:: NumberBox
redirect:: implClass
summary:: A view displaying a modifiable numerical value.
categories:: GUI>Views

DESCRIPTION::

A view that displays a numerical value and allows to modify it by typing the value in, and incrementing or decrementing it using the keyboard, or mouse.

Using the keyboard, the value will change on each arrow key press by the amount defined by link::#-step::.

Mouse scrolling is performed by pressing a mouse button inside the view and dragging the mouse vertically. The value will change according to the mouse cursor movement, in steps defined by link::#-scroll_step::.

By default, holding down the Shift, Ctrl, or Alt key while incrementing or decrementing the value will multiply the steps by 100, 10, or 0.1 respectively, though you can customize this by setting link::#-shift_scale::, link::#-ctrl_scale::, or link::#-alt_scale::. Scrolling can be enabled or disabled by modifying the link::#-scroll:: variable.




CLASSMETHODS::

PRIVATE:: key




INSTANCEMETHODS::




SUBSECTION:: Data

METHOD:: value
	Numerical value between 0 and 1.

	argument::
		A Float.

METHOD:: valueAction
	Sets link::#-value:: to the argument and triggeres link::#-action::.

METHOD:: increment
	Increments the value by link::#-step:: multiplied by 'factor'.

	argument:: factor
		Any number.

METHOD:: decrement
	Decrements the value by link::#-step:: multiplied by 'factor'.

	argument:: factor
		Any number.

METHOD:: string
	Text to be displayed instead of the numerical value. Setting link::#-value:: after this will display the value again.

	argument::
		A String.

METHOD:: object
	If link::#-setBoth:: is true, setting this variable also sets link::#-string:: to the argument interpreted link::Classes/Object#-asString#as String::.

	argument::
		Any object, typically one which makes sense to display as a string, such as a Float.

METHOD:: setBoth
	A variable stating whether setting link::#-object:: will also set link::#-string::.

	argument::
		A Boolean.




SUBSECTION:: Restrictions on data

METHOD:: clipLo
	The lowest numerical value allowed. Trying to set a lower value will clip it to this.

	argument::
		A Float.

METHOD:: clipHi
	The highest numerical value allowed. Trying to set a higher value will clip it to this.

	argument::
		A Float.

METHOD:: minDecimals
	The minimum amount of decimal places displayed. If the value can be completely described with less decimal places, zeros will be appended until reaching this.

	argument::
		An Integer.

METHOD:: maxDecimals
	The maximum amount of decimal places displayed. The value will always be rounded to this amount of decimals.

	argument::
		An Integer.

METHOD:: decimals
	Sets both link::#-minDecimals:: and link::#-maxDecimals:: to the argument.

	argument::
		An Integer.




SUBSECTION:: Appearance

METHOD:: align
	The alignment of the displayed value. See link::Reference/gui_alignments:: for possible values.

METHOD:: stringColor
	The color used to display the value before it is ever changed by user interaction.

	argument::
		A Color.

METHOD:: normalColor
	The color used to display the value after is has been typed in.

	argument::
		A Color.

METHOD:: typingColor
	The color used to display the value while it is being typed in.

	argument::
		A Color.




SUBSECTION:: Interaction

METHOD:: step
	The amount by which the value will changed when link::#-increment:: or link::#-decrement:: is called, or when related keys are pressed.

	argument::
		A Float.

METHOD:: scroll_step
	The amount by which the value will changed when scrolled using the mouse.

	argument::
		A Float.

METHOD:: shift_scale
	The factor by which link::#-step:: or link::#-scroll_step:: is multiplied when incrementing or decrementing the value using keyboard or mouse while the Shift key is pressed.

	argument::
		A Float.

METHOD:: ctrl_scale
	The factor by which link::#-step:: or link::#-scroll_step:: is multiplied when incrementing or decrementing the value using keyboard or mouse while the Ctrl key is pressed.

	argument::
		A Float.

METHOD:: alt_scale
	The factor by which link::#-step:: or link::#-scroll_step:: is multiplied when incrementing or decrementing the value using keyboard or mouse while the Alt key is pressed.

	argument::
		A Float.



SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user changes the value by interacting with the view.

METHOD:: defaultKeyDownAction

	Any key representing a character that can make part of a floating point number representation will initiated the editing of the value. Pressing Return (or Enter) will finish the editing and store the value typed in as a Float.

	Aside from that, this method implements the default effects of key presses as follows:

	table::
	## strong::Key::   || strong::Effect::
	## up arrow        || increment
	## down arrow      || decrement
	## right arrow     || increment
	## left arrow      || decrement
	::



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The link::#-value::.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a number.

METHOD:: defaultReceiveDrag
	Sets link::#-valueAction:: to the current drag data.



EXAMPLES::

subsection:: Basic Example

code::
(
    w = Window("NumberBox Example", Rect(100, 500, 400, 120));
    b =     NumberBox(w, Rect(150, 10, 100, 20));
    b.value = rrand(1,15);
    b.action = {arg numb; numb.value.postln; };
    w.front
)
// try these one at time
b.value = rrand(1,15) ;     // sets the value but does not perform the action
b.valueAction_(5);      // sets the value and performs the action
b.step_(0.1);           // change the increment/decrement size for the arrow keys
b.scroll_step=10;    // change the increment/decrement size for the mosueScrolling

b.background_(Color.grey);          // change the background color of the box
b.typingColor_(Color(0.3,1,0.3));   // change the typing color for the box
b.normalColor_(Color.white);        // change the normal color for the box. won't change until next value change

b.stringColor = Color.red;
b.align = \center;

b.increment; // increment or decrement by step
b.decrement;
::


subsection:: Sound Example

Change freqency of a playing synth by step using arrow keys:

code::
(
s.waitForBoot({

    n={arg freq=220;
        var out;
        out=SinOsc.ar(freq,0,0.2);
        8.do{out = AllpassN.ar(out, 0.2,0.02+0.20.rand,8)};
        out;
    }.play;

    w = Window("Use arrow keys to change the frequency by steps", Rect(100, 500, 500, 120));
    b =     NumberBox(w, Rect(200, 10, 100, 20));
    b.value = 220;
    b.action = {arg numb; n.set(\freq,numb.value); };
    b.step=55; //make the step a fraction of the freq
    b.focus;
    w.front;

    CmdPeriod.doOnce({w.close});

});
)
::
** CLASS:: OSCArgsMatcher
summary:: Test for specific OSC arguments before evaluating a Function
categories:: External Control>OSC>Matchers
related:: Classes/OSCFunc, Guides/OSC_communication

DESCRIPTION::
OSCArgMatcher matches an argument template to a link::Classes/Function:: or similar object. When its value method is called, it evaluates the function if all of the arguments in its template pass a link::Reference/matchItem:: test.  This is used by link::Classes/OSCMessageDispatcher:: and link::Classes/OSCMessagePatternDispatcher:: to match incoming OSC messages to instances of link::Classes/OSCFunc:: or link::Classes/OSCdef:: using sender address. This class is private, and generally users should not need to address instances directly.

CLASSMETHODS::

METHOD:: new
Make a new OSCArgsMatcher

argument:: argTemplate
An link::Classes/Array:: comprising a template for determining if incoming arguments match. For each argument that you wish to test, you may include a constant (for exact matching), code::nil:: (indicating that all possible values and types will match), or a link::Classes/Function:: to test the incoming argument (see link::Reference/matchItem:: for examples). These should be in the same order as the items in the incoming OSC message, starting from index 1. (Index 0 is the OSC address.)

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated it will be passed the arguments msg, time, addr, and recvPort, corresponding to the message as an link::Classes/Array:: in the form code::[OSCAddress, ...otherArgs]::, the time that the message was sent, a link::Classes/NetAddr:: corresponding to the IP address of the sender, and an link::Classes/Integer:: corresponding to the port on which the message was received.


INSTANCEMETHODS::
private:: init

METHOD:: value
Test if an incoming message's arguments match, and if so evaluate this object's function. In normal usage (within an OSCFunc) this is done behind the scenes.

argument:: testMsg
An link::Classes/Array:: in the form code::[OSCAddress, …msgArgs]::.

argument:: time
The time that the message was sent as a link::Classes/Float::.

argument:: addr
A link::Classes/NetAddr:: corresponding to the IP address of the sender.

argument:: recvPort
An link::Classes/Integer:: corresponding to the port on which the message was received.


EXAMPLES::

code::
// Basic example (standalone use)
m = OSCArgsMatcher([1, nil, 2], {'matches!'.postln});
m.value(['/myAddress', 1, 3, 2], 0.0, NetAddr.localAddr, NetAddr.langPort); // matches!
::
** class:: OSCBundle
summary:: network bundle object
related:: Guides/OSC_communication
categories:: External Control>OSC

description::
A bundle object that allows to add preparation messages for async processes. If this feature is not needed, a list object can be used instead.

InstanceMethods::

private::prSend

method::add
Add an osc message to the bundle.

method::addAll
Add an array of osc messages to the bundle.

method::addPrepare
Add a preparation osc message, which is sent before the bundle is sent.

method::send
Send the bundle to a server. If preparation messages are given, they are sent, the process waits for their reception abd then sends the bundle.

method::schedSend
Like send, but the sending is synced to a given clock to the next beat.

argument::server
A link::Classes/Server::.

argument::clock
A link::Classes/TempoClock::.

argument::quant
Can be a pair of values: [quant, offset].

Examples::

code::
// create a new, empty instance
a = OSCBundle.new;

// a synthdef that needs to be sent to the server, an operation that is asynchronous,
// i.e. we have to wait until it is finished.
x = SynthDef("test", { OffsetOut.ar(0, BPF.ar(Impulse.ar(4) * 10, Rand(9000, 1000), 0.1)) });
// this is why addPrepare is used.
a.addPrepare(["/d_recv", x.asBytes]);
// add is used with synchronous operations, like starting synths.
a.add(["/s_new", "test", -1]);

// the bundle has now the synchronous separated from the asynchronous bundles:
a.messages;
a.preparationMessages;

// this can be simply sent - the bundle takes care of the server client communication
// like waiting for the synthdef to be loaded. the synth is started when the preparation
// is finished.

s.boot; // boot the server
a.send(s);

s.freeAll; // free all nodes on the server

// scheduled sending: the synths are started on the next beat.

a.schedSend(s, TempoClock.default, 1);
a.schedSend(s, TempoClock.default, 1);
a.schedSend(s, TempoClock.default, 1);

s.freeAll; // free all nodes on the server

// the bundle can contain several preparation messages and messages at a time.
// the proparationMessages are sent first and only when they are all completed,
// the other bundles are sent.
// the bundle can also be reused, if there is no specific allocated buffers/node ids.
::
** CLASS:: OSCFunc
summary:: Fast Responder for incoming Open Sound Control Messages
categories:: External Control>OSC
related:: Guides/OSC_communication, Classes/OSCdef, Classes/OSCresponderNode, Classes/NetAddr

DESCRIPTION::
OSCFunc (and its subclass link::Classes/OSCdef::) registers one or more functions to respond to an incoming OSC message which matches a specified OSC Address. Many of its methods are inherited from its superclass link::Classes/AbstractResponderFunc::. OSCFunc supports pattern matching of wildcards etc. in incoming messages. For efficiency reasons you must specify that an OSCFunc will employ pattern matching by creating it with the link::#*newMatching:: method, or by passing a matching dispatcher to link::#*new::. For details on the Open Sound Control protocol, see http://opensoundcontrol.org/spec-1_0

note:: Use of the older classes OSCresponder, OSCresponderNode, and OSCpathResponder can be unsafe, since responders in user and class code can override each other unintentionally. OSCFunc and link::Classes/OSCdef:: are faster, safer, have more logical argument order, and support pattern matching and custom listening ports. Thus they are the recommended way of registering for incoming OSC messages as of SC 3.5. (See below for an example demonstrating OSCpathResponder-type arg matching.)::


CLASSMETHODS::
private:: initClass, cmdPeriod

METHOD:: defaultDispatcher
Get or set the default dispatcher object for OSCFuncs (this is what you get if you pass nil as the dispatcher argument to link::#*new::). This object will decide if any of its registered OSCFuncs should respond to an incoming OSC message.

returns:: By default this will be an link::Classes/OSCMessageDispatcher::, but it can be set to any instance of an appropriate subclass of link::Classes/AbstractDispatcher::.

METHOD:: defaultMatchingDispatcher
Get or set the default matching dispatcher object for OSCFuncs (this is what you get if when you create an OSCFunc using link::#*newMatching::). This object will decide if any of its registered OSCFuncs should respond to an incoming OSC message using pattern matching.

returns:: By default this will be an link::Classes/OSCMessagePatternDispatcher::, but it can be set to any instance of an appropriate subclass of link::Classes/AbstractDispatcher::.

METHOD:: new
Create a new, enabled OSCFunc.

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated it will be passed the arguments msg, time, addr, and recvPort, corresponding to the message as an link::Classes/Array:: in the form code::[OSCAddress, ...otherArgs]::, the time that the message was sent, a link::Classes/NetAddr:: corresponding to the IP address of the sender, and an link::Classes/Integer:: corresponding to the port on which the message was received.

argument:: path
A link::Classes/Symbol:: indicating the path of the OSC address of this object. Note that OSCFunc demands OSC compliant addresses. If the path does not begin with a / one will be added automatically.

argument:: srcID
An optional instance of link::Classes/NetAddr:: indicating the IP address of the sender. If set this object will only respond to messages from that source.

argument:: recvPort
An optional link::Classes/Integer:: indicating the port on which messages will be received. If set this object will only respond to message received on that port. This method calls link::Classes/Main#-openUDPPort:: to ensure that the port is opened.

argument:: argTemplate
An optional link::Classes/Array:: composed of instances of link::Classes/Integer:: or link::Classes/Function:: (or objects which respond to the method link::Overviews/Methods#matchItem::) used to match the arguments of an incoming OSC message. If a Function, it will be evaluated with the corresponding message arg as an argument, and should return a link::Classes/Boolean:: indicating whether the argument matches and this OSCFunc should respond (providing all other arguments match). Template values of nil will match any incoming argument value.

argument:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed.

returns:: A new instance of OSCFunc.

METHOD:: newMatching
A convenience method to create a new, enabled OSCFunc whose dispatcher will perform pattern matching on incoming OSC messages to see if their address patterns match this object's path.

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated it will be passed the arguments msg, time, addr, and recvPort, corresponding to the message as an link::Classes/Array:: [OSCAddress, other args], the time that the message was sent, a link::Classes/NetAddr:: corresponding to the IP address of the sender, and an link::Classes/Integer:: corresponding to the port on which the message was received.

argument:: path
A link::Classes/Symbol:: indicating the path of the OSC address of this object. Note that OSCFunc demands OSC compliant addresses. If the path does not begin with a / one will be added automatically. Pattern matching will be applied to any incoming messages to see if they match this address. Note that according to the OSC spec, regular expression wildcards are only permitted in the incoming message's address pattern. Thus path should not contain wildcards. For more details on OSC pattern matching, see http://opensoundcontrol.org/spec-1_0

argument:: srcID
An optional instance of link::Classes/NetAddr:: indicating the IP address of the sender. If set this object will only respond to messages from that source.

argument:: recvPort
An optional link::Classes/Integer:: indicating the port on which messages will be received.

argument:: argTemplate
An optional link::Classes/Array:: composed of instances of link::Classes/Integer:: or link::Classes/Function:: (or objects which respond to the method link::Overviews/Methods#matchItem::) used to match the arguments of an incoming OSC message. If a Function, it will be evaluated with the corresponding message arg as an argument, and should return a link::Classes/Boolean:: indicating whether the argument matches and this OSCFunc should respond (providing all other arguments match). Template values of nil will match any incoming argument value.

returns:: A new instance of OSCFunc.

METHOD:: trace
A convenience method which dumps all incoming OSC messages.

argument:: bool
A link::Classes/Boolean:: indicating whether dumping is on or off.


INSTANCEMETHODS::

private:: init, printOn

METHOD:: path
Get the path of this OSCFunc's OSC Address.

returns:: A link::Classes/String::

METHOD:: recvPort
Get this OSCFunc's receiving port.

returns:: An link::Classes/Integer::



EXAMPLES::

code::
n = NetAddr("127.0.0.1", NetAddr.langPort); // local machine

OSCFunc.newMatching({|msg, time, addr, recvPort| \matching.postln}, '/chat', n); // path matching
OSCFunc({|msg, time, addr, recvPort| \oneShot.postln}, '/chat', n).oneShot; // once only
OSCdef(\test, {|msg, time, addr, recvPort| \unmatching.postln}, '/chat', n); // def style

m = NetAddr("127.0.0.1", NetAddr.langPort); // loopback

m.sendMsg("/chat", "Hello App 1");
m.sendMsg("/chat", "Hello App 1"); // oneshot gone
m.sendMsg("/ch?t", "Hello App 1");
m.sendMsg("/*", "Hello App 1");
m.sendMsg("/chit", "Hello App 1"); // nothing

// Introspection

AbstractResponderFunc.allFuncProxies
AbstractResponderFunc.allEnabled
OSCdef(\test).disable;
AbstractResponderFunc.allDisabled

// change funcs
OSCdef(\test).enable;
OSCdef(\test, {|msg, time, addr, recvPort| 'Changed Unmatching'.postln}, '/chat', n); // replace at key \test
m.sendMsg("/chat", "Hello App 1");
OSCdef(\test).add(f = {\foo.postln}); // add another func
m.sendMsg("/chat", "Hello App 1");
OSCdef(\test).clear; // remove all functions
m.sendMsg("/chat", "Hello App 1");

//////// Use an argTemplate for finer grained matching

s.boot;
x = Synth(\default);
OSCFunc({ 'ended!'.postln }, '/n_end', s.addr, nil, [x.nodeID]).oneShot;
x.release(3);
::
** CLASS:: OSCFuncAddrMessageMatcher
summary:: Matches incoming messages to responder funcs based on sender address
categories:: External Control>OSC>Matchers
related:: Classes/AbstractMessageMatcher, Classes/OSCFuncRecvPortMessageMatcher, Classes/OSCFuncBothMessageMatcher

DESCRIPTION::
This is used by link::Classes/OSCMessageDispatcher:: and link::Classes/OSCMessagePatternDispatcher:: to match incoming OSC messages to instances of link::Classes/OSCFunc:: or link::Classes/OSCdef:: using sender address. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: addr
The link::Classes/NetAddr:: to attempt to match.

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An OSCFuncAddrMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaulate func if it does.

argument:: msg
The OSC message as an link::Classes/Array:: in the form code::[OSCAddress, other args]::.

argument:: time
A link::Classes/Float:: indicating the time the incoming message was sent.

argument:: testAddr
A link::Classes/NetAddr:: indicating the source of the message.

argument:: recvPort
An link::Classes/Integer:: indicating the port on which the message was received.

** CLASS:: OSCFuncBothMessageMatcher
summary:: Matches incoming messages to responder funcs based on receive port and sender address
categories:: External Control>OSC>Matchers
related:: Classes/AbstractMessageMatcher, Classes/OSCFuncAddrMessageMatcher, Classes/OSCFuncRecvPortMessageMatcher, Classes/OSCFuncBothMessageMatcher

DESCRIPTION::
This is used by link::Classes/OSCMessageDispatcher:: and link::Classes/OSCMessagePatternDispatcher:: to match incoming OSC messages  to instances of link::Classes/OSCFunc:: or link::Classes/OSCdef:: using receive port and sender address. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: addr
The link::Classes/NetAddr:: to attempt to match.

argument:: recvPort
The receive port to attempt to match, in the form of an link::Classes/Integer::.

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An OSCFuncBothMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaulate func if it does.

argument:: msg
The OSC message as an link::Classes/Array:: in the form code::[OSCAddress, other args]::.

argument:: time
A link::Classes/Float:: indicating the time the incoming message was sent.

argument:: testAddr
A link::Classes/NetAddr:: indicating the source of the message.

argument:: testRecvPort
An link::Classes/Integer:: indicating the port on which the message was received.

** CLASS:: OSCFuncRecvPortMessageMatcher
summary:: Matches incoming messages to responder funcs based on receive port
categories:: External Control>OSC>Matchers
related:: Classes/AbstractMessageMatcher, Classes/OSCFuncAddrMessageMatcher, Classes/OSCFuncRecvPortMessageMatcher, Classes/OSCFuncBothMessageMatcher

DESCRIPTION::
This is used by link::Classes/OSCMessageDispatcher:: and link::Classes/OSCMessagePatternDispatcher:: to match incoming OSC messages  to instances of link::Classes/OSCFunc:: or link::Classes/OSCdef:: using receive port. This class is private, and generally users should not need to address instances directly.


CLASSMETHODS::

METHOD:: new
Make a new instance.

argument:: recvPort
The receive port to attempt to match, in the form of an link::Classes/Integer::.

argument:: func
The link::Classes/Function:: to evaluate if a match is found.

returns:: An OSCFuncRecvPortMessageMatcher.


INSTANCEMETHODS::
private:: init

METHOD:: value
Check to see if a message matches, and evaulate func if it does.

argument:: msg
The OSC message as an link::Classes/Array:: in the form code::[OSCAddress, other args]::.

argument:: time
A link::Classes/Float:: indicating the time the incoming message was sent.

argument:: addr
A link::Classes/NetAddr:: indicating the source of the message.

argument:: testRecvPort
An link::Classes/Integer:: indicating the port on which the message was received.

** CLASS:: OSCMessageDispatcher
summary:: The default dispatcher class for OSCFunc and OSCdef.
categories:: External Control>OSC>Dispatchers
related:: Classes/OSCFunc, Classes/OSCdef, Classes/AbstractWrappingDispatcher, Classes/AbstractDispatcher, Classes/AbstractMessageMatcher, Classes/OSCMessagePatternDispatcher, Classes/OSCFuncAddrMessageMatcher, Classes/OSCFuncRecvPortMessageMatcher, Classes/OSCFuncBothMessageMatcher, Guides/OSC_communication

DESCRIPTION::
OSCMessageDispatcher dispatches incoming OSC messages to matching functions. Normally users should not have to create or message instances of this class directly.


CLASSMETHODS::


INSTANCEMETHODS::

METHOD:: wrapFunc
Called internally to wrap functions in message matcher objects, if needed.

argument:: funcProxy
An instance of link::Classes/OSCFunc:: or link::Classes/OSCdef:: whose function(s) are to be wrapped.

METHOD:: getKeysForFuncProxy
Get the keys at which a responder func's functions are stored in this dispatcher's active dictionary. The keys will be an OSC path.

argument:: funcProxy
The link::Classes/OSCFunc:: or link::Classes/OSCdef:: whose keys should be returned.

returns:: An link::Classes/Array:: containing the funcProxy's path as a link::Classes/Symbol::.

METHOD:: value
Attempt to match an incoming OSC message with this dispatcher's responder funcs, and evaluate their functions for all matches found.

argument:: msg
The OSC message as an link::Classes/Array:: in the form code::[OSCAddress, other args]::.

argument:: time
A link::Classes/Float:: indicating the time the incoming message was sent.

argument:: addr
A link::Classes/NetAddr:: indicating the source of the message.

argument:: recvPort
An link::Classes/Integer:: indicating the port on which the message was received.

METHOD:: register
Adds this dispatcher to thisProcess.recvOSCfunc.

METHOD:: unregister
Removes this dispatcher from thisProcess.recvOSCfunc.

METHOD:: typeKey
Returns code::'OSC unmatched'::.

returns:: A link::Classes/Symbol::.

** CLASS:: OSCMessagePatternDispatcher
summary:: The default pattern matching dispatcher for OSCFunc and OSCdef.
categories:: External Control>OSC>Dispatchers
related:: Classes/OSCFunc, Classes/OSCdef, Classes/AbstractWrappingDispatcher, Classes/AbstractDispatcher, Classes/AbstractMessageMatcher, Classes/OSCMessageDispatcher, Classes/OSCFuncAddrMessageMatcher, Classes/OSCFuncRecvPortMessageMatcher, Classes/OSCFuncBothMessageMatcher, Guides/OSC_communication

DESCRIPTION::
OSCMessageDispatcher dispatches incoming OSC messages to matching functions, using pattern matching to see if regular expressions wildcards in the incoming message's address pattern match one of this dispatcher's OSCFuncs' paths. Normally users should not have to create or message instances of this class directly. For details on OSC pattern matching, see http://opensoundcontrol.org/spec-1_0


CLASSMETHODS::


INSTANCEMETHODS::

METHOD:: value
Attempt to match an incoming OSC message with this dispatcher's responder funcs, and evaluate their functions for all matches found.

argument:: msg
The OSC message as an link::Classes/Array:: in the form code::[OSCAddress, other args]::.

argument:: time
A link::Classes/Float:: indicating the time the incoming message was sent.

argument:: addr
A link::Classes/NetAddr:: indicating the source of the message.

argument:: recvPort
An link::Classes/Integer:: indicating the port on which the message was received.

METHOD:: typeKey
Returns code::'OSC unmatched'::.

returns:: A link::Classes/Symbol::.

** CLASS:: OSCdef
summary:: OSC response reference definition
categories:: External Control>OSC>Dispatchers
related:: Guides/OSC_communication, Classes/OSCFunc, Classes/OSCresponderNode, Classes/NetAddr

DESCRIPTION::
OSCdef provides a global reference to the functionality of its superclass link::Classes/OSCFunc::. Essentially it stores itself at a key within a global dictionary, allowing replacement at any time. Most methods are inherited from its superclass.

note:: Use of the older classes OSCresponder, OSCresponderNode, and OSCpathResponder can be unsafe, since responders in user and class code can override each other unintentionally. link::Classes/OSCFunc:: and OSCdef are faster, safer, have more logical argument order, and support pattern matching. Thus they are the recommended way of registering for incoming OSC messages as of SC 3.5. (See below for an example demonstrating OSCpathResponder-type arg matching.)::


CLASSMETHODS::
private:: initClass

METHOD:: all
Get the global dictionary of all OSCdefs.

returns:: An link::Classes/IdentityDictionary::.

METHOD:: new
Create a new, enabled OSCdef. If an OSCdef already exists at this key, its parameters will be replaced with the ones provided (args for which nil is passed will use the old values).

argument:: key
The key at which to store this OSCdef in the global collection. Generally this will be a link::Classes/Symbol::.

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated it will be passed the arguments msg, time, addr, and recvPort, corresponding to the message as an link::Classes/Array:: in the form code::[OSCAddress, other args]::, the time that the message was sent, a link::Classes/NetAddr:: corresponding to the IP address of the sender, and an link::Classes/Integer:: corresponding to the port on which the message was received.

argument:: path
A link::Classes/Symbol:: indicating the path of the OSC address of this object. Note that OSCdef demands OSC compliant addresses. If the path does not begin with a / one will be added automatically.

argument:: srcID
An optional instance of link::Classes/NetAddr:: indicating the IP address of the sender. If set this object will only respond to messages from that source.

argument:: recvPort
An optional link::Classes/Integer:: indicating the port on which messages will be received. If set this object will only respond to message received on that port. This method calls link::Classes/Main#-openUDPPort:: to ensure that the port is opened.

argument:: argTemplate
An optional link::Classes/Array:: composed of instances of link::Classes/Integer:: or link::Classes/Function:: (or objects which respond to the method link::Overviews/Methods#matchItem::) used to match the arguments of an incoming OSC message. If a Function, it will be evaluated with the corresponding message arg as an argument, and should return a link::Classes/Boolean:: indicating whether the argument matches and this OSCdef should respond (providing all other arguments match). Template values of nil will match any incoming argument value.

argument:: dispatcher
An optional instance of an appropriate subclass of link::Classes/AbstractDispatcher::. This can be used to allow for customised dispatching. Normally this should not be needed.

returns:: An instance of OSCdef.

METHOD:: newMatching
A convenience method to create a new, enabled OSCdef whose dispatcher will perform pattern matching on incoming OSC messages to see if their address patterns match this object's path.

argument:: key
The key at which to store this OSCdef in the global collection. Generally this will be a link::Classes/Symbol::.

argument:: func
A link::Classes/Function:: or similar object which will respond to the incoming message. When evaluated it will be passed the arguments msg, time, addr, and recvPort, corresponding to the message as an link::Classes/Array:: [OSCAddress, other args], the time that the message was sent, a link::Classes/NetAddr:: corresponding to the IP address of the sender, and an link::Classes/Integer:: corresponding to the port on which the message was received.

argument:: path
A link::Classes/Symbol:: indicating the path of the OSC address of this object. Note that OSCdef demands OSC compliant addresses. If the path does not begin with a / one will be added automatically. Pattern matching will be applied to any incoming messages to see if they match this address. Note that according to the OSC spec, regular expression wildcards are only permitted in the incoming message's address pattern. Thus path should not contain wildcards. For more details on OSC pattern matching, see http://opensoundcontrol.org/spec-1_0

argument:: srcID
An optional instance of link::Classes/NetAddr:: indicating the IP address of the sender. If set this object will only respond to messages from that source.

argument:: recvPort
An optional link::Classes/Integer:: indicating the port on which messages will be received.

argument:: argTemplate
An optional link::Classes/Array:: composed of instances of link::Classes/Integer:: or link::Classes/Function:: (or objects which respond to the method link::Overviews/Methods#matchItem::) used to match the arguments of an incoming OSC message. If a Function, it will be evaluated with the corresponding message arg as an argument, and should return a link::Classes/Boolean:: indicating whether the argument matches and this OSCFunc should respond (providing all other arguments match). Template values of nil will match any incoming argument value.

returns:: An instance of OSCdef.

METHOD:: freeAll
Clears and deactivates all OSCdefs from the global collection.

INSTANCEMETHODS::
private:: addToAll, printOn

METHOD:: key
Get this OSCdef's key.

returns:: Usually a link::Classes/Symbol::.

METHOD:: free
Clears this OSCdef from the global collection and deactivates it.


EXAMPLES::

code::
n = NetAddr("127.0.0.1", 57120); // local machine

OSCdef(\test, {|msg, time, addr, recvPort| \unmatching.postln}, '/chat', n); // def style
OSCdef.newMatching(\test2, {|msg, time, addr, recvPort| \matching.postln}, '/chat', n); // path matching
OSCdef(\test3, {|msg, time, addr, recvPort| \oneShot.postln}, '/chat', n).oneShot; // once only


m = NetAddr("127.0.0.1", 57120); // loopback

m.sendMsg("/chat", "Hello App 1");
m.sendMsg("/chat", "Hello App 1"); // oneshot gone
m.sendMsg("/ch?t", "Hello App 1");
m.sendMsg("/*", "Hello App 1");
m.sendMsg("/chit", "Hello App 1"); // nothing

// Introspection

AbstractResponderFunc.allFuncProxies
AbstractResponderFunc.allEnabled
OSCdef(\test).disable;
AbstractResponderFunc.allDisabled

// change funcs
OSCdef(\test).enable;
OSCdef(\test, {|msg, time, addr, recvPort 'Changed Unmatching'.postln}, '/chat', n); // replace at key \test
m.sendMsg("/chat", "Hello App 1");
OSCdef(\test).add(f = {\foo.postln}); // add another func
m.sendMsg("/chat", "Hello App 1");
OSCdef(\test).clear; // remove all functions
m.sendMsg("/chat", "Hello App 1");
OSCdef(\test).free;  // unregister OSCdef


//////// Use an argTemplate for finer grained matching

s.boot;
x = Synth(\default);
OSCdef(\watchForXEnd, { 'ended!'.postln }, '/n_end', s.addr, nil, [x.nodeID]).oneShot;
x.release(3);


::
** class:: OSCpathResponder
summary:: client side network responder
related:: Classes/OSCFunc, Classes/OSCdef, Guides/OSC_communication, Classes/OSCresponderNode
categories:: External Control>OSC

description::

note:: As of SC 3.5 link::Classes/OSCFunc:: and link::Classes/OSCdef:: are the recommended way of registering for incoming OSC messages. They are faster, safer, and have more logical argument order than the old responder classes, and they support pattern matching and custom listening ports. Use of the older classes OSCresponder, OSCresponderNode, and OSCpathResponder can be unsafe, since responders in user and class code can override each other unintentionally. They are maintained for legacy code only.

The replacement for path matching is to be found in the template argument of OSCFunc and OSCDef (see example below).

::

Register a function to be called upon receiving a command with a specific path.

Other applications sending messages to SuperCollider should distinguish between sending messages to the server or the language. Server messages are documented in the link::Reference/Server-Command-Reference:: and should be sent to the server's port - code::s.addr.port:: - which is strong::57110:: by default. Messages sent to the server will not be processed by any link::Classes/OSCresponder:: in the language.

Messages from external clients that should be processed by OSCresponders must be sent to the language port, strong::57120:: by default. Use code::NetAddr.langPort:: to confirm which port the SuperCollider language is listening on.

See link::Guides/OSC_communication:: for more details.

subsection::Command paths

OSC commands sometimes include additional parameters to specify the right responder.

For example code::/tr:: commands, which are generated on the server by the link::Classes/SendTrig:: Ugen create an OSC packet consisting of: code:: [ /tr, nodeID, triggerID, value] ::.
This array actually specifies the source of value: code:: [ /tr, nodeID, triggerID] ::.
We will refer to that array as a command path.

To create an OSCpathResponder for a specific trigger, the strong::cmdName:: parameter is simply replaced by the complete command path.

subsection::Path defaults

Any element of the command path array can be set to nil to create a responder that will handle multiple command paths.

For example, setting the commandpath: code:: ['/tr', nil, triggerID] :: makes a responder that responds to code::/tr:: messages from any Synth but with a specific triggerID.

ClassMethods::

method::new

argument::addr
An instance of link::Classes/NetAddr::, usually obtained from your server: server-addr. An address of nil will respond to messages from anywhere.

argument::cmdPath
A command path, such as ['\c_set', bus index].

argument::action
A link::Classes/Function:: that will be evaluated when a cmd of that name is received from addr. arguments: time, theResponder, message
note::
OSCresponderNode evaluates its function in the system process. In order to access the application process (e.g. for GUI access ) use { ... }.defer; within the action function, e.g., code:: { |time, resp, msg| { gui.value_(msg[3]) }.defer } ::
::

Examples::

code::
s.boot;

(
	var commandpath, response, aSynth, nodeID, triggerID;
	triggerID = 1;
	aSynth = { arg freq = 1, triggerID = 1;
		SendTrig.kr(SinOsc.kr(freq), triggerID, 666)
	}.play;
	nodeID = aSynth.nodeID;
	commandpath = ['/tr', nodeID, triggerID];
	response = { arg time, responder, message; message.postln };

	o = OSCpathResponder(s.addr, commandpath, response);
	o.add;
)

// switch on and off:
o.remove;
o.add;


// this can be written now conveniently and efficiently with OSCFunc.
// the argTemplate is like the "path" of OSCpathResponder, but without the OSC-path itself.
(
	var commandpath, response, aSynth, nodeID, triggerID;
	triggerID = 1;
	aSynth = { arg freq = 1, triggerID = 1;
		SendTrig.kr(SinOsc.kr(freq), triggerID, 666)
	}.play;
	nodeID = aSynth.nodeID;
	commandpath = [nodeID, triggerID];
	response = { arg message; message.postln };

	o = OSCFunc(response, '/tr', s.addr, argTemplate: commandpath);

)

// an OSCFunc is removed with cmd-Period.
// in order to switch it on and off programmatically:
o.remove;
o.add;

::
** class:: OSCresponder
summary:: client side network responder
related:: Classes/OSCFunc, Classes/OSCdef, Guides/OSC_communication, Classes/OSCresponderNode, Classes/NetAddr
categories:: External Control>OSC

description::
note:: As of SC 3.5 link::Classes/OSCFunc:: and link::Classes/OSCdef:: are the recommended way of registering for incoming OSC messages. They are faster, safer, and have more logical argument order than the old responder classes, and they support pattern matching and custom listening ports. Use of the older classes OSCresponder, OSCresponderNode, and OSCpathResponder can be unsafe, since responders in user and class code can override each other unintentionally. They are maintained for legacy code only.::

Register a function to be called upon receiving a specific command from a specific OSC address.

Other applications sending messages to SuperCollider should distinguish between sending messages to the server or the language. Server messages are documented in the link::Reference/Server-Command-Reference:: and should be sent to the server's port - code::s.addr.port:: - which is strong::57110:: by default. Messages sent to the server will not be processed by any OSCresponder in the language.

Messages from external clients that should be processed by OSCresponders must be sent to the language port, strong::57120:: by default. Use code::NetAddr.langPort:: to confirm which port the SuperCollider language is listening on.

See link::Guides/OSC_communication:: for more details.

note::
It is highly recommended to use link::Classes/OSCresponderNode:: or link::Classes/OSCpathResponder:: instead of OSCresponder directly. OSCresponders can overwrite each other, but OSCresponderNodes with the same address and command name can coexist peacefully.
::

ClassMethods::

private::initClass

method::new

argument::addr
The address the responder strong::receives from:: (an instance of link::Classes/NetAddr::, e.g. code::Server.default.addr::). An address of nil will respond to messages from anywhere. An address with a port of nil will respond to messages from any port from that specific IP.

argument::cmdName
An OSC command eg. code::'/done'::.

argument::action
A link::Classes/Function:: that will be evaluated when a cmd of that name is received from addr. arguments: time, theResponder, message, addr
note::
OSCresponder evaluates its function in the system process. In order to access the application process (e.g. for GUI access ) use { ... }.defer; within the action function, e.g., code:: { |time, resp, msg| { gui.value_(msg[3]) }.defer } ::
::

Examples::

see link::Classes/OSCresponderNode::.
** class:: OSCresponderNode
summary:: client side network responder
related:: Classes/OSCFunc, Classes/OSCdef, Guides/OSC_communication, Classes/OSCpathResponder, Classes/NetAddr
categories:: External Control>OSC

description::
note:: As of SC 3.5 link::Classes/OSCFunc:: and link::Classes/OSCdef:: are the recommended way of registering for incoming OSC messages. They are faster, safer, and have more logical argument order than the old responder classes, and they support pattern matching and custom listening ports. Use of the older classes OSCresponder, OSCresponderNode, and OSCpathResponder can be unsafe, since responders in user and class code can override each other unintentionally. They are maintained for legacy code only.::

Register a function to be called upon receiving a specific command from a specific OSC address. Same interface like link::Classes/OSCresponder::, but allows strong::multiple responders to the same command::.

Note that OSCresponderNode evaluates its function in the system process.
In order to access the application process (e.g. for GUI access ) use { ... }.defer;

Other applications sending messages to SuperCollider should distinguish between sending messages to the server or the language. Server messages are documented in the link::Reference/Server-Command-Reference:: and should be sent to the server's port - code::s.addr.port:: - which is strong::57110:: by default. Messages sent to the server will not be processed by any OSCresponder in the language.

Messages from external clients that should be processed by OSCresponders must be sent to the language port, strong::57120:: by default. Use code::NetAddr.langPort:: to confirm which port the SuperCollider language is listening on.

See link::Guides/OSC_communication:: for more details.

Examples::

subsection::Setting up OSCresponderNode for listening to a remote application

code::
// example: two SuperCollider apps communicating

// application 1:
n = NetAddr("127.0.0.1", 57120); // the url should be the one of computer of app 2 (or nil)

o = OSCresponderNode(n, '/chat', { |t, r, msg| ("time:" + t).postln; msg[1].postln }).add;

// application 2:
m = NetAddr("127.0.0.1", 57120); // the url should be the one of computer of app 1
m.sendMsg("/chat", "Hello App 1");

// sending bundles (including timestamps)
(
m.sendBundle(2.0, ["/chat", "Hello App 1"], ["/chat", "Hallo Wurld"]);
m.sendBundle(0.0, ["/chat", "Hello App 1"], ["/chat", "Hallo Wurld"]);
)

// end application 1:
o.remove;
::

subsection::Listening to data from _any_ client

code::
// same as above, but we set the address to nil so we can receive from anywhere
// no need for a NetAddr since we are just listening (and not sending)

o = OSCresponderNode(nil, '/test', { |t, r, msg| msg.postln }).add;
o.remove;
::

subsection::Listening to data from _any_ client, but from a specific host

code::
// same as above, but we use a NetAddr with a port of nil, so we can receive from a specific host, but from any port

n = NetAddr("127.0.0.1", nil); // the url should be the one of computer of app 2
o = OSCresponderNode(n, '/test', { |t, r, msg| msg.postln }).add;
o.remove;
::

subsection::Listening to data from the server

code::
// example from SendTrig

(
s = Server.local;
s.boot;
s.notify;
)

(
SynthDef("help-SendTrig",{
	SendTrig.kr(Dust.kr(1.0), 0, 0.9);
}).send(s);

// register to receive this message
a = OSCresponderNode(s.addr, '/tr', { arg time, responder, msg;
	[time, responder, msg].postln;
}).add;
b = OSCresponderNode(s.addr, '/tr', { arg time, responder, msg;
	"this is another call".postln;
}).add;
)

x = Synth.new("help-SendTrig");
a.remove;
b.remove;
x.free;
::

subsection::Watching for something specific

code::
// end of group message

s.boot;

a = OSCresponderNode(s.addr,'/n_end',{ arg time,responder,msg;
	[time, responder, msg].postln;
	if(msg[1] == g.nodeID,{
		"g is dead !".postln;
		// g = Group.new;
	});
}).add;

g = Group.new;

g.free;

a.remove;
::

subsection::Watching for errors

code::
// example from ServerErrorGui in crucial lib

f = OSCresponderNode(s.addr, '/fail', { arg time, responder, msg;
	{
		var mins,secs;
		mins = (time/60).round(1);
		secs = (time%60).round(0.1);
		if(secs<10,{ secs = "0"++secs.asString; },{ secs=secs.asString;});
		// put this on a gui
		//errors.label = "% % (%:%)".format(msg[1], msg[2], mins, secs);
		//errors.stringColor = Color.white;
		"% % (%:%)".format(msg[1], msg[2], mins, secs).postln;
	}.defer
});
f.add;

// cause a failure
Synth("gthhhhppppppp!");

f.remove
::
** class:: Object
summary:: abstract superclass of all objects
categories:: Core>Kernel, Language>OOP

related:: Classes/Class, Guides/Intro-to-Objects, Reference/Classes

description::
Object is the root class of all other classes. All objects are indirect instances of class Object.
We call "receiver" the object the message is sent to: receiver.method(argument).


classmethods::
private:: prNewCopyArgs,prNew
method::readArchive

Read in an object from a text archive. pathname is a String containing the archive file's path.
discussion::
code::
a = Array.fill(100, { 100.0.rand });
a.writeArchive(PathName.tmp ++ "myArray");
b = Object.readArchive(PathName.tmp ++ "myArray");
a == b // true

/////////

// closed Function
(
f = { 1 + 2 };
f.writeArchive(PathName.tmp ++ "myFunc"); // succeeds
)
// open Function
(
var num;
num = 2;
f = { num + 2 };
f.writeArchive(PathName.tmp ++ "myFunc"); // fails
)
::

method::new

Create a new instance. The creation of new instances of any Object actually happens in this method (or with newCopyArgs ) when it is called by a child class. see link::Guides/WritingClasses::

method::newCopyArgs

Creates a new instance and copies the arguments to the instance variables in the order that the variables were defined.

code::
MyClass{
	var a,b,c;

	*new{ |arg1,arg2,arg3|
		^super.newCopyArgs(arg1,arg2,arg3) //will copy arg1,arg2,arg3 to variables a,b,c
	}
}
::

instancemethods::
private::addFunc, addFuncTo, removeFunc, removeFuncFrom

subsection::Class Membership

method::class

Answer the class of the receiver.

code::
5.class;
::

method::respondsTo

Answer a Boolean whether the receiver understands the message selector. selector must be a Symbol.

code::
5.respondsTo('+');
::

method::isKindOf

Answer a Boolean indicationg whether the receiver is a direct or indirect instance of aClass. Use of this message in code must be questioned, because it often indicates a missed opportunity to exploit object polymorphism.

code::
5.isKindOf(Magnitude);
::

method::isMemberOf

Answer a Boolean whether the receiver is a direct instance of aClass. Use of this message in code is almost always a design mistake.

code::
5.isMemberOf(Magnitude);
::

subsection::Accessing

method::size

Different classes interpret this message differently.  Object always returns 0.


subsection::Copying

method::copy

Make a copy of the receiver. The implementation of this message depends on the object's class.  In class Object, copy calls shallowCopy.

method::shallowCopy

Makes a copy of the object. The copy's named and indexed instance variables refer to the same objects as the receiver.

method::deepCopy

Recursively copies the object and all of the objects contained in the instance variables, and so on down the structure. This method works with cyclic graphs.

method::copyImmutable

If object is immutable then return a shallow copy, else return receiver.

subsection::Conversion

To convert an object of a certain Class into a similar, Object provides a number of methods.

method::as

Returns a similar new Object of a different class.

code::
[1, 2, 3].as(Set);
Pwhite(0.0, 1.0, 10).as(Set);
::

method::asArray

Returns an Array with the receiver, unless it is an Array already.

code::
[1, 2, 3].asArray;
5.asArray;
::

method::asCompileString

Returns a String that can be interpreted to reconstruct a copy of the receiver.
For the complementary method, see String interpret	.

code::
a = { 10.do { 10.postln } };
a.asCompileString.postcs;
a.postcs;
::

method::cs

shortcut for asCompileString

code::
{ 10.do { 10.postln } }.cs;
::

subsection::Archiving

Object implements methods for writing and retrieving objects from disk. Note that you cannot archive instances of Thread and its subclasses (i.e. Routine), or open Functions (i.e. a Function which refers to variables from outside its own scope).

method::writeArchive

Write an object to disk as a text archive. pathname is a String containing the resulting file's path.


subsection::Equality and Identity

method::==

equality: Answer whether the receiver equals anotherObject. The definition of equality depends on the class of the receiver. The default implementation in Object is to answer if the two objects are identical (see below).

note:: Whenever == is overridden in a class, hash should be overridden as well.::

code::
5.0 == 5; // true
5.0 === 5; // false
a = [1, 2, 3]; b = [1, 2, 3];
a == b; // equal
a === b; // not identical
"worth trying" == "worth trying"; // equal
::


method::===

identity: Answer whether the receiver is the exact same object as anotherObject.

code::
5.0 === 5; // false
"worth trying" === "worth trying"; // not identical
'worth trying' === 'worth trying'; // identical (symbols are unique)
::

method::!=

non-equality: Answer whether the receiver does not equal anotherObject. The default implementation in Object is to answer if the two objects are not identical (see below).

method::fuzzyEqual

Retruns the degree of equality (in the range from 0 to 1) between two objects with regard to a given precision. Objects to compare must support max, substraction and division.

code::
5.0.fuzzyEqual(5.0, 0.5); // 1 - full equality
5.25.fuzzyEqual(5.0, 0.5); // 0.5 - 50 % equality
5.9.fuzzyEqual(5.0, 0.5); // 0 - no equality
::

method::compareObject

Tests if two Objects (of the same class) are the same in a certain respect: It returns true if instVarNames are equal in both. If none are given, all instance variables are tested (see also: instVarHash)

code::
a = Pseq([1, 2, 3], inf); b = Pseq([100, 200, 300], inf);
a.compareObject(b, [\repeats]); // true
a.compareObject(b, [\list]); // false
::

method::hash

Answer a code used to index into a hash table. This is used by Dictionary and Set and their subclasses to implement fast object lookup.  Objects which are equal == should have the same hash values. Whenever == is overridden in a class, hash should be overridden as well.

code::
a = "worth trying"; b = "worth trying";
a.hash;
b.hash;
::

method::identityHash

Answer a code used to index into a hash table. This method is implemented by a primitive and is not overridden. Objects which are identical === should have the same hash values.

code::
a = "worth trying"; b = "worth trying";
a.identityHash;
b.identityHash;
::

method::instVarHash

Returns a combined hash value for the object's instance variables and the object's class. If none are given, all instance variables are tested (see also: compareObject).


code::
a = Pseq([1, 2, 3], inf); b = Pseq([100, 200, 300], inf);

a.instVarHash([\repeats]); // same
b.instVarHash([\repeats]);

a.instVarHash([\list]); // different
b.instVarHash([\list]);

a = Pseq([1, 2, 3], inf); b = Prand([1, 2, 3], inf);
a.instVarHash([\list]); // different
b.instVarHash([\list]);
::


subsection::Testing

method::isNil

Answer a Boolean indicating whether the receiver is nil.

method::notNil

Answer a Boolean indicating whether the receiver is not nil.

method::isNumber

Answer a Boolean indicating whether the receiver is an instance of Number.

method::isInteger

Answer a Boolean indicating whether the receiver is an instance of Integer.

method::isFloat

Answer a Boolean indicating whether the receiver is an instance of Float.

method::?

If the receiver is nil then answer anObject, otherwise answer the receiver.

method::??

If the receiver is nil, evaluate the link::Classes/Function:: and return the result.

method::!?

If the receiver is not nil, evaluate the link::Classes/Function:: passing in the receiver as argument and return the result, otherwise return nil.

note::
The function will be inlined if it contains no variables or arguments.
::

discussion::
This method allow building up chains of actions to be performed on an object (possibly across several methods) without having to check if the object is nil or not. After all the desired actions are performed, link::#-??:: can be used to check if result the result is nil and supply a default value in that case.

Examples:
code::
x !? ( _ * 3 ) ?? { "It was a nil, so I give a default value".postln; Point(1,1) }
::
With code::x = nil::, this will result in:
teletype::
It was a nil, so I give a default value
Point( 1, 1 )
::
But if code::x = Point(3,4)::, the result will be:
teletype::
Point( 9, 12 )
::

Nested nil checks:
code::
(
x = nil;
y = Point(3,4);
z = Point(5,6);
x !? { |x| y !? { |y| z !? { |z|  x.rho * y.rho * z.rho } } }
)
::
Results in teletype::nil::
code::
(
x = Point(1,2);
y = Point(3,4);
z = Point(5,6);
x !? { |x| y !? { |y| z !? {  |z| x.rho * y.rho * z.rho } } }
)
::
Results in teletype::87.321245982865::

method::pointsTo

Returns true if receiver has a direct reference to obj.

code::
a = 9;
b = [1, a, 6, 8];
c = [1, b, 5];
c.pointsto(b); // true
c.pointsto(a); // false
::

method::mutable

Returns true if receiver is mutable.

code::
a = #[1, 2, 3]; b = [1, 2, 3];
a.mutable; // false
b.mutable; // true
::

method::frozen

Returns true if receiver is frozen.

method::switch

Object implements a switch method which allows for conditional evaluation with multiple cases. These are implemented as pairs of test objects (tested using if this == test.value) and corresponding functions to be evaluated if true. In order for switch to be inlined (and thus be as efficient as nested if statements) the matching values must be literal Integers, Floats, Chars, Symbols and the functions must have no variables or arguments.

discussion::
code::
(
var x, z;
z = [0, 1, 1.1, 1.3, 1.5, 2];
switch (z.choose.postln,
	1,   { \no },
	1.1, { \wrong },
	1.3, { \wrong },
	1.5, { \wrong },
	2,   { \wrong },
	0,   { \true }
).postln;
)
::

or:

code::
(
var x, z;
z = [0, 1, 1.1, 1.3, 1.5, 2];
x = switch (z.choose)
	{1}   { \no }
	{1.1} { \wrong }
	{1.3} { \wrong }
	{1.5} { \wrong }
	{2}   { \wrong }
	{0}   { \true };
x.postln;
)
::

subsection::Messaging

Instead of directly sending a method to an object, a method may be invoked given a method selector only (a Symbol). The other arguments may be provided by passing them directly, from an environment. If it si not known whether the receiver implements the metod, tryPerform only sends if it does, and superPerform invokes the method of the superclass.


method::perform

The selector argument must be a Symbol. Sends the method named by the selector with the given arguments to the receiver.

method::performList

The selector argument must be a Symbol. Sends the method named by the selector with the given arguments to the receiver. If the last argument is a List or an Array, then its elements are unpacked and passed as arguments.

code::
a = { |a, b, c| postf("% plus % plus % is %\n", a, b, c, a + b + c); "" };
a.performList(\value, [1, 2, 3]);
::

method::performMsg

The argument must be a List or Array whose first element is a Symbol representing a method selector. The remaining elements are unpacked and passed as arguments to the method named by the selector.

code::
a = { |a, b, c| postf("% plus % plus % is %\n", a, b, c, a + b + c); "" };
a.performMsg([\value, 1, 2, 3]);
::

method::performWithEnvir

argument:: selector
A Symbol representing a method selector.
argument:: envir
The remaining arguments derived from the environment and passed as arguments to the method named by the selector.
discussion::
code::
a = { |a, b, c| postf("% plus % plus % is %\n", a, b, c, a + b + c); "" };
a.performWithEnvir(\value, (a: 1, c: 3, d: 4, b: 2));
::

method::performKeyValuePairs

argument:: selector
A Symbol representing a method selector.
argument:: pairs
Array or List with key-value pairs.
discussion::
code::
a = { |a, b, c| postf("% plus % plus % is %\n", a, b, c, a + b + c); "" };
a.performKeyValuePairs(\value, [\a, 1, \b, 2, \c, 3, \d, 4]);
::

method::tryPerform

Like 'perform', but tryPerform passes the method to the receiver only if the receiver understands the method name. If the receiver doesn't implement that method, the result is nil. Note that this does not catch errors like 'try' does (see Exception). If the receiver does have a matching method but that method throws an error, execution will halt. But, 'tryPerform' is faster than 'try'.

code::
(a: 1, b: 2, c: 3).tryPerform(\keysValuesDo, { |key, value| [key, value].postln });

// Array does not understand keysValuesDo -- result is nil
[1, 2, 3].tryPerform(\keysValuesDo, { |key, value| [key, value].postln });

// Error occurs within keysValuesDo -- error is thrown back to halt execution
(a: 1, b: 2, c: 3).tryPerform(\keysValuesDo, { |key, value| [key, value].flippityblargh });
::

method::superPerform

Like perform, superPerform calls a method, however it calls the method on the superclass.
selector: A Symbol representing a method selector.
args: Method arguments.


method::superPerformList

Like performList, superPerformList calls a method, however it calls the method on the superclass.
selector: A Symbol representing a method selector.
args: Method arguments. If the last argument is a List or an Array, then its elements are unpacked and passed as arguments.

method::multiChannelPerform
Perform selector with multichannel-expansion.
argument:: selector
A Symbol representing a method selector.
argument:: ... args
Method arguments, which if they contain an array, will call the method multiple times for each sub-element.
discussion::
Example:
code::
a = { |a, b, c| format("% plus % times % is %", a, b, c, a + b * c).quote; };
a.multiChannelPerform(\value, [1, 10, 100, 1000], [2, 7, 9], [3, 7]);

["foo","bar"].multiChannelPerform('++',["l","bro","t"]);
::
See also link::Guides/Multichannel-Expansion::

subsection::Unique Methods

Method definitions not yet implemented may be added to an Object instance.

method::addUniqueMethod

Add a unique method.

code::
a = 5;
a.addUniqueMethod(\sayHello, { |to| "hello " ++ to ++ ", I am 5" });
a.sayHello;
::

method::removeUniqueMethod

Remove a unique method.

code::
a.removeUniqueMethod(\sayHello);
a.sayHello;
::

method::removeUniqueMethods

Remove all unique methods of an Object.

subsection::Dependancy

method::addDependant

Add aDependant to the receiver's list of dependants.

method::removeDependant

Remove aDependant from the receiver's list of dependants.

method::dependants

Returns an IdentitySet of all dependants of the receiver.

method::changed

Notify the receiver's dependants that the receiver has changed. The object making the change should be passed as theChanger.

method::update

An object upon which the receiver depends has changed. theChanged is the object that changed and theChanger is the object that made the change.

method::release

Remove all dependants of the receiver. Any object that has had dependants added must be released in order for it or its dependants to get garbage collected.

subsection::Error Support

Object implements a number of methods which throw instances of Error. A number of methods (e.g. doesNotUnderstand) are 'private' and do not normally need to be called directly in user code. Others, such as those documented below can be useful for purposes such as object oriented design (e.g. to define an abstract interface which will be implemented in subclasses) and deprecation of methods. The reserved keyword thisMethod can be used to refer to the enclosing method. See also Method and Function (for exception handling).

method::throw

Throws the receiver as an Exception, which may or may not be caught and handled by any enclosing Function.

method::subclassResponsibility

Throws a SubclassResponsibilityError. Use this to indicate that this method should be defined in all subclasses of the receiver.

discussion::
code::
someMethod {
	this.subclassResponsibility(thisMethod);
}
::

method::shouldNotImplement

Throws a ShouldNotImplementError. Use this to indicate that this inherited method should not be defined or used in the receiver.

method::deprecated

Throws a DeprecatedError. Use this to indicate that the enclosing method has been replaced by a better one (possibly in another class), and that it will likely be removed in the future. Unlike other errors, DeprecatedError only halts execution if Error.debug == true. In all cases it posts a warning indicating that the method is deprecated and what is the recommended alternative.

discussion::
code::
foo {
	this.deprecated(thisMethod, ThisOrSomeOtherObject.findMethod(\foo);
	… // execution of this method will continue unless Error.debug == true
}
::

subsection::Printing and Introspection

method::post

Print a string representation of the receiver to the post window.
"hello".post; "hello".post; "";

method::postln

Print a string representation of the receiver followed by a newline.
"hello".postln; "hello".postln; "";

method::postc

Print a string representation of the receiver preceded by comments.
"hello".postc; "hello".postc; "";

method::postcln

Print a string representation of the receiver preceded by comments, followed by a newline.
"hello".postcln; "hello".postcln; "";

method::postcs

Print the compile string representation of the receiver, followed by a newline.
"hello".postcs; "hello".postcs; "";

method::dump

Print a detailed low level representation of the receiver to the post window.

subsection::System Information

method::gcInfo

Posts garbage collector information in a table format.

discussion::
list::
## flips: the number of times the GC "flipped", i.e. when it finished incremental scanning of all reachable objects
## collects: the number of partial collections performed
## nalloc: total number of allocations
## alloc: total allocation in bytes
## grey: the number of "grey" objects, i.e. objects that point to reachable objects and are not determined to be (un)reachable yet
::

Then for each size class: numer of black, white and free objects, total number of objects and the total set size.

code::
flips 241  collects 689096   nalloc 40173511   alloc 322496998   grey 346541
	0  bwf t sz:    882      0 368573   369455    2955640
	1  bwf t sz:   6197    122 5702377   5708696   91339136
2  bwf t sz:    947      4 1500009   1500960   48030720
	3  bwf t sz:   8056  65201 301800   375057   24003648
4  bwf t sz:   4047    145   3457     7649     979072
5  bwf t sz:    422      1    431      854     218624
6  bwf t sz:    124      2     72      198     101376
7  bwf t sz: 153504      1      0   153505   157189120
8  bwf t sz:     22      0      0       22      45056
9  bwf t sz:      5      0      0        5      20480
10  bwf t sz:      5      0      0        5      40960
12  bwf t sz:      2      0      0        2      65536
13  bwf t sz:      1      0      0        1      65536
19  bwf t sz:      1      0      3        4   16777216
tot bwf t sz: 174215  65476 7876722   8116413   341832120
::


you can also query the amount of free memory with Object.totalFree and dump the currently grey objects with Object.dumpGrey. More memory status methods are: Object.largestFreeBlock, Object.gcDumpSet, and Object.gcSanity.

subsection::Iteration

method::do

Object evaluates the function with itself as an argument, returning the reasult. Different classes interpret this message differently.
discussion::
code::
f = { |x, i| [x, i].postln; };
[1, 2, 3].do(f); // Array.do
10.do(f); // Integer.do
($Q).do(f); // Object.do
::

method::generate

Object iterates by the message do, sent to the receiver.
This method is used internally by list comprehensions.

method::dup

Duplicates the receiver n times, returning an array of n copies. Different classes interpret this message differently.  The shortcut "!" can be used in place.
discussion::
code::
8.dup(10);
8 ! 10; // same as above
x = [[1], [2], [3]].dup(5);
x[0] === x[1]; // false: copies receiver.
x[0][0] === x[1][0] // true: doesn't deepCopy receiver
{ 1.0.rand }.dup(5) // other objects respond differently to dup
::

subsection:: Scheduling

method:: awake

This method is called by a link::Classes/Clock:: on which the object was
scheduled when its scheduling time is up. It calls link::#-next::, passing
on the scheduling time in beats as an argument.

argument:: beats
The scheduling time in beats. This is equal to the current logical time
(link::Classes/Thread#-beats::).

argument:: seconds
The scheduling time in seconds. This is equal to the current logical time
(link::Classes/Thread#-seconds::).

argument:: clock
The clock on which the object was scheduled.


subsection:: Stream Support

method:: next

Does nothing; simply returns the object itself.

method:: reset

Does nothing; simply returns the object itself.


subsection::Routine Support

Objects support the basic interface of Stream, just returning itself in respone to the following messages:
next, reset, stop, free, clear, removedFromScheduler, asStream.

method::yield

Must be called from inside a Routine. Yields control to the calling thread. The receiver is the result passed to the calling thread's method. The result of yield will be the value passed to the Routine's next method the next time it is called.

method::yieldAndReset

Must be called from inside a Routine. Yields control to the calling thread. The receiver is the result passed to the calling thread's method. The Routine is reset so that the next time it is called, it will start from the beginning. yieldAndReset never returns within the Routine.

method::alwaysYield

Must be called from inside a Routine. Yields control to the calling thread. The receiver is the result passed to the calling thread's method. The Routine, when called subsequently will always yield the receiver until it is reset. alwaysYield never returns within the Routine.

method::embedInStream

Yields the receiver

method::idle

within a routine, return values (the receiver) until this time is over. (for an example, see Routine)
Time is measured relative to the thread's clock.

method::iter

Returns a OneShotStream with the receiver as return value.

method::cyc

Embeds the receiver in the stream n times (default: inf), each time resetting it.

method::fin

Calls next with the receiver n times only (default: 1), yielding the result.

method::repeat

Repeatedly embeds the receiver in the stream using a Pn (may thus be used for patterns and other objects alike)

method::loop

Indefinitely embeds the receiver in the stream

subsection::FunctionList

The messages addFunc, addFuncTo, removeFunc, removeFuncFrom are supported by Object. See link::Classes/Function::.


** CLASS:: ObjectGui
summary:: Controller class for MVC architecture, superclass for all XYZGui classes
related:: Reference/gui
categories:: GUI

DESCRIPTION::
In the MVC architecture this is the Controller, which creates Views for manipulating the properties of your Model, and receives messages from the View and enacts the changes on the Model.

Each class specifies its Gui class via the guiClass method.

The default guiClass for an Object is ObjectGui.  So if a class does not implement guiClass at all, then at least there is a default ObjectGui that will display the name.

Many subclasses overide the guiClass method to specify a different class, one that subclasses ObjectGui.

It is the simplest display, it is just the object asString.

The .gui method is called on your model:

code::
// standard usage
theModel.gui( parent, bounds )

// this results in these steps:
guiClass = theModel.guiClass;
gui = guiClass.new( theModel );
gui.gui( parent, bounds );
::

In addition to those steps the model/gui dependencies are managed, defaults (nil parent or nil bounds) are managed and when the window or parent view is closed then dependencies are safely managed.


CLASSMETHODS::

METHOD:: new
Create a gui controller object but does not yet create the views / window.  Call .gui to create the views.

argument:: model
The model is the object that the GUI is a graphical interface for.

returns:: the ObjectGui or subclass object


INSTANCEMETHODS::

METHOD:: guiBody
When implementing subclasses this is the primary and often the only method that needs to be implemented.  The ObjectGui parent class takes care of setting up all windows and dependencies and then the guiBody method adds views to the layout.  It is normal to declare instance variables in the ObjectGui subclass that are used to store the widgets so they can be updated later.

argument:: layout
Usually a FlowView : a parent view with a FlowLayout to add views to.

argument:: bounds
nil or a Rect.

argument:: ... args
More args may be passed here.

returns:: this

METHOD:: update
When the model is changed and the .changed method is called then .update is called on all dependants including this gui object.  Update the views you have placed in the guiBody.

argument:: changed
The model.  Within your gui class the model is already in the instance variable 'model'.

argument:: changer
Depends on the conventions of how .changed was called.  If an object called someModel.changed(this) then it is supplying itself as the changer and will be passed through here.  Sometimes a flag is used: someModel.changed('points') and the gui may know of and particpate in that convention.  Sometimes no changer is passed in.


METHOD:: gui
The standard method to create a view / window.  Usually you call yourModel.gui(parent,bounds) and this creates the gui (of the related ObjectGui subclass) and then theObjectGui.gui(parent,bounds) is called, forwarding the arguments.  So this method is what receives the forwarded (parent,bounds) from the initial call to theModel.gui(parent,bounds). Usually you do not call this manually and would avoid reimplementing it.

argument:: parent
parent view : nil, a Window, a FlowView or any other usable container view.

argument:: bounds
nil or a Rect.  The default of nil will offer the entire bounds to the guiBody method and then shrink the view size afterwards to the exact size of the contents that were actually added.

argument::  ... args
More args may be passed into theModel.gui(parent,bounds,anArg,moreArg) and will be forwarded to guiBody.

returns:: this

METHOD:: guify
This converts a supplied parent and bounds into a usable parent container view on a window.  It creates a window if needed.

argument:: parent
parent view or nil

argument:: bounds
desired bounds or nil

argument:: title
window title IF a new window is being created.  if there is a parent view then title is ignored.

returns:: converted parent


METHOD:: model
set a new model. This allows to use a single gui and dynamically swap in a different model of the same class.  The old model releases the gui as a dependant and the new model adds the gui as a dependent.  Then the views are updated.

argument:: newModel
The new object

returns:: (returnvalue)

METHOD:: dragSource
The default implementation of writeName places a nameplate on the gui that is draggable.  This method is an accessor for that dragSource object.

returns:: a GUi.dragSource

METHOD:: viewDidClose
This is called when the parent view closes. It releases dependants.

returns:: this

METHOD:: background
Each ObjectGui subclass may implement a default background color.

returns:: a color

METHOD:: writeName
ObjectGui by default makes a nameplate with the name of the model.  Implement this in subclasses if a different name style or no nameplate is desired.  Note: this may change in the near future.  So many classes overide this to shut off the name.

argument:: layout
The layout to place the nameplate on.  Probably the same as is being passed to guiBody

METHOD:: prWriteName
The default write name implementation.  You could call this from a subclass if you are primarily implementing writeName to customize what name is shown or to add other items to that area.

argument:: layout
the layout

argument:: name
the string to display


EXAMPLES::

code::

YourSimpleGuiClass : ObjectGui {

	guiBody { arg layout;
	
		// we refer to the model and
		// access its variable howFast.
		// if its a simple number, it will display
		// using the default ObjectGui class, which
		// will simply show its value as a string.
		model.howFast.gui(layout);
	}
}


// more complex
YourGuiClass : ObjectGui {
	
	var numberEditor;
	
	//for example
	guiBody { arg layout;
		var r;
		// the object you are making a gui for is referred to as the model
		
		// display some param on screen.
		// here we assume that someParam is something that
		//  has a suitable gui class
		// implemented, or that the default ObjectGui is sufficient.
		model.someParam.gui(layout);
		
		// using non 'gui' objects
		r = layout.layRight(300,300); // allocate yourself some space
		Button(layout.win,r)
			.action_({ arg butt;
				model.goApeShit;
			});
		
		// note: NumberEditor is a cruciallib class
		// which is itself a model (its an editor of a value)
		// and has its own gui class that creates and manages the NumberBox view
		numberEditor = NumberEditor(model.howFast,[0,100])
			.action_({ arg val; 
				model.howFast = val; 
				model.changed(this); 
				// tell the model that this gui changed it
			});
		numberEditor.gui(layout);
	}
	
	// your gui object will have update called any time the .changed message
	// is sent to your model
	update { arg changed,changer;
	
		if(changer !== this,{ 
			/* if it is this gui object that changed the value
				using the numberEditor, then we already have a correct
				display and don't need to waste cpu to update it.
				if anyone else changed anything about the model,
				we will update ourselves here.
			*/
			numberEditor.value = model.howFast;
			/*
				note that 
					numberEditor.value = model.howFast;
				is passive, and does not fire the numberEditor's action.	

				numberEditor.activeValue = model.howFast
				would fire the action as well, resulting in a loop that would
				probably crash your machine.
			*/
		}
	}

}
::
** CLASS::ObjectTable
summary::associate objects with IDs
categories:: Collections>Unordered

DESCRIPTION::
An ObjectTable is used to associate an id with an object. This is useful
for enabling references to objects on remote systems via Open Sound Control.

CLASSMETHODS::

private::initClass

method::add
Put an object in the main ObjectTable and generate an Integer id.
argument::obj
the object to put in the table.

method::put
Put an object in the main ObjectTable under a specific key.
argument::key
a link::Classes/Symbol::.
argument::obj
the object to put in the table.

method::at
Get an object in the main ObjectTable.
argument::id
an link::Classes/Integer:: or link::Classes/Symbol::.

method::getID
Get the ID of an object in the table.
argument::obj
an object in the table.

INSTANCEMETHODS::

method::add
Put an object in an ObjectTable and generate an Integer id.
argument::obj
the object to put in the table.
** class:: OffsetOut
summary:: Write a signal to a bus with sample accurate timing.
related:: Classes/Out, Classes/ReplaceOut, Classes/XOut
categories::  UGens>InOut


Description::

Output signal to a bus,  the sample offset within the bus is kept
exactly; i.e. if the synth is scheduled to be started part way through a
control cycle, OffsetOut will maintain the correct offset by buffering
the output and delaying it until the exact time that the synth was
scheduled for.


For achieving subsample accuracy see  link::Classes/SubsampleOffset::

note::

Note that if you have an input to the synth, it will be coming in and
its normal time, then mixed in your synth, and then delayed with the
output. So you shouldn't use OffsetOut for effects or gating.

::

See the link::Reference/Server-Architecture:: and link::Classes/Bus:: helpfiles for more information on
buses and how they are used.


classmethods::

method::ar

argument::bus

The index of the bus to write out to. The lowest numbers are
written to the audio hardware.


argument::channelsArray

An Array of channels or single output to write out. You cannot
change the size of this once a SynthDef has been built.


Examples::

code::

(
SynthDef("help-OffsetOut",
	{ arg out=0, freq=440, dur=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, dur, 0.2), doneAction:2);
		OffsetOut.ar(out, SinOsc.ar(freq, 0, env))
}).send(s);

SynthDef("help-Out",
	{ arg out=0, freq=440, dur=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, dur, 0.2), doneAction:2);
		//compare to Out:
		Out.ar(out, SinOsc.ar(freq, 0, env))
}).send(s);
)


// these are in sync
(
Routine({
	loop {
		s.sendBundle(0.2, ["/s_new", "help-OffsetOut", -1]);
		0.01.wait;
	}
}).play;
)

// these are less reliably in sync and are placed at multiples of blocksize.
(
Routine({
	loop {
		s.sendBundle(0.2, ["/s_new", "help-Out", -1]);
		0.01.wait;
	}
}).play;
)



SynthDef("trig1",{
	var gate,tone;
	gate = Trig1.ar(1.0,t);
	tone = In.ar(10,1); // tone comes in normally
	// but is then delayed when by the OffsetOut
	OffsetOut.ar(0,
		tone * EnvGen.ar(
				Env([0,0.1,0.1,0],[0.01,1.0,0.01],[-4,4],2),
				gate,doneAction: 2
			)
	)
})

::

** class:: OnError
summary:: register functions to be evaluated when an error occurs
related:: Classes/StartUp, Classes/ShutDown, Classes/ServerQuit, Classes/ServerTree, Classes/CmdPeriod
categories:: Control

description::
OnError registers functions to perform an action when an error occurs.

ClassMethods::

method::run
Call the object in order.
** class:: OnePole
summary:: One pole filter.
related:: Classes/OneZero
categories::  UGens>Filters>Linear


Description::

A one pole filter. Implements the formula:

code::

out(i) = ((1 - abs(coef)) * in(i)) + (coef * out(i-1)).

::


classmethods::

method::ar, kr

argument::in

The input signal.


argument::coef

Feedback coefficient. Should be between -1 and +1


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ OnePole.ar(WhiteNoise.ar(0.5), 0.95) }.play

{ OnePole.ar(WhiteNoise.ar(0.5), -0.95) }.play

{ OnePole.ar(WhiteNoise.ar(0.5), Line.kr(-0.99, 0.99, 10)) }.play

::

** class:: OneZero
summary:: One zero filter.
related:: Classes/OnePole
categories::  UGens>Filters>Linear


Description::

A one zero filter. Implements the formula:

code::

out(i) = ((1 - abs(coef)) * in(i)) + (coef * in(i-1)).

::


classmethods::

method::ar, kr

argument::in

The input signal.


argument::coef

Feed forward coefficient.


+0.5 makes a two point averaging filter
(see also
link::Classes/LPZ1:: ).


-0.5 makes a differentiator
(see also
link::Classes/HPZ1:: ).


+1 makes a single sample delay
(see also
link::Classes/Delay1:: ).


-1 makes an inverted single sample delay.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ OneZero.ar(WhiteNoise.ar(0.5), 0.5) }.play

{ OneZero.ar(WhiteNoise.ar(0.5), -0.5) }.play

{ OneZero.ar(WhiteNoise.ar(0.5), Line.kr(-0.5, 0.5, 10)) }.play

::

** class:: Onsets
summary:: Onset detector
categories:: UGens>Analysis
related:: Classes/BeatTrack, Classes/Loudness, Classes/MFCC, Classes/Pitch, Classes/KeyTrack

description::
An onset detector for musical audio signals - detects the beginning of notes/drumbeats/etc. Outputs a control-rate trigger signal which is 1 when an onset is detected, and 0 otherwise.

For more details of all the processes involved, the different onset detection functions, and their evaluation, see:

D. Stowell and M. D. Plumbley. Adaptive whitening for improved real-time audio onset detection. emphasis::Proceedings of the International Computer Music Conference (ICMC'07)::, Copenhagen, Denmark, August 2007. [http://www.elec.qmul.ac.uk/digitalmusic/papers/2007/StowellPlumbley07-icmc.pdf]

classmethods::
private:: categories

method:: kr

argument:: chain
an FFT chain.
argument:: threshold
the detection threshold, typically between 0 and 1, although in rare cases you may find values outside this range useful.
argument:: odftype
chooses which emphasis::onset detection function:: is used. In many cases the default will be fine. The following choices are available:

definitionlist::
## code::\power:: || generally OK, good for percussive input, and also very efficient
## code::\magsum:: || generally OK, good for percussive input, and also very efficient
## code::\complex:: || performs generally very well, but more CPU-intensive
## code::\rcomplex:: || performs generally very well, and slightly more efficient than code::\complex::
## code::\phase:: || generally good, especially for tonal input, medium efficiency
## code::\wphase:: || generally very good, especially for tonal input, medium efficiency
## code::\mkl:: || generally very good, medium efficiency, pretty different from the other methods
::

discussion::
For the FFT chain, you should typically use a frame size of 512 or 1024 (at 44.1 kHz sampling rate) and 50% hop size (which is the default setting in SC). For different sampling rates choose an FFT size to cover a similar time-span (around 10 to 20 ms).

The onset detection should work well for a general range of monophonic and polyphonic audio signals. The onset detection is purely based on signal analysis and does not make use of any "top-down" inferences such as tempo.

Which onset detection function should you choose? The differences aren't large, so I'd recommend you stick with the default code::\rcomplex:: unless you find specific problems with it. Then maybe try code::\wphase::. The code::\mkl:: type is a bit different from the others so maybe try that too. They all have slightly different characteristics, and in tests perform at a similar quality level.

subsection:: Advanced features

Further options are available, which you are welcome to explore if you want. They are numbers that modulate the behaviour of the onset detector:

list::
## strong::relaxtime:: and strong::floor:: are parameters to the whitening process used, a kind of normalisation of the FFT signal. (Note: in \mkl mode these are not used.)
	list::
	## strong::relaxtime:: specifies the time (in seconds) for the normalisation to "forget" about a recent onset. If you find too much re-triggering (e.g. as a note dies away unevenly) then you might wish to increase this value.
	## strong::floor:: is a lower limit, connected to the idea of how quiet the sound is expected to get without becoming indistinguishable from noise. For some cleanly-recorded classical music with wide dynamic variations, I found it helpful to go down as far as 0.000001.
	::
## strong::mingap:: specifies a minimum gap (in FFT frames) between onset detections, a brute-force way to prevent too many doubled detections.
## strong::medianspan:: specifies the size (in FFT frames) of the median window used for smoothing the detection function before triggering.
::

examples::
code::
(
s.boot.doWhenBooted {
	// Prepare the buffers
	b = Buffer.alloc(s, 512);
	// Feel free to load a more interesting clip!
	// a11wlk01 is not an ideal example of musical onsets.
	d = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
};
)

////////////////////////////////////////////////////////////////////////////////////////////////
// Move the mouse to vary the threshold
(
x = {
	var sig, chain, onsets, pips;

	// A simple generative signal
	sig = LPF.ar(Pulse.ar(TIRand.kr(63, 75, Impulse.kr(2)).midicps), LFNoise2.kr(0.5).exprange(100, 10000)) * Saw.ar(2).range(0, 1);
	// or, uncomment this line if you want to play the buffer in
	//sig = PlayBuf.ar(1, d, BufRateScale.kr(d), loop: 1);

	chain = FFT(b, sig);

	onsets = Onsets.kr(chain, MouseX.kr(0,1), \rcomplex);

	// You'll hear percussive "ticks" whenever an onset is detected
	pips = WhiteNoise.ar(EnvGen.kr(Env.perc(0.001, 0.1, 0.2), onsets));
	Out.ar(0, Pan2.ar(sig, -0.75, 0.2) + Pan2.ar(pips, 0.75, 1));
}.play;
)
x.free; // Free the synth

////////////////////////////////////////////////////////////////////////////////////////////////
// Or we could expand this multichannel, run a series of different thresholds at the same time,
// to sonify the effect of the threshold value.
// A little hard to listen to at first: try and identify a pitch at which the best sort of
// detection is happening.
// You'll hear "bobbling" at low pitches where the threshold is definitely too low.

(
var threshes = (0.1, 0.2 .. 1);
x = {
	var sig, chain, onsets, pips;

	// A simple generative signal
	sig = LPF.ar(Pulse.ar(TIRand.kr(63, 75, Impulse.kr(2)).midicps), LFNoise2.kr(0.5).exprange(100, 10000)) * Saw.ar(2).range(0, 1);
	// or, uncomment this line if you want to play the buffer in
	//sig = PlayBuf.ar(1, d, BufRateScale.kr(d), loop: 1);

	chain = FFT(b, sig);

	onsets = Onsets.kr(chain, threshes, \rcomplex);

	// Generate pips at a variety of pitches
	pips = SinOsc.ar((threshes).linexp(0, 1, 440, 3520), 0, EnvGen.kr(Env.perc(0.001, 0.1, 0.5), onsets)).mean;
	Out.ar(0, Pan2.ar(sig, -0.75, 0.2) + Pan2.ar(pips, 0.75, 1));
}.play;
)

x.free; // Free the synth
[b, d].do(_.free); // Free the buffers
::

** CLASS::Order
summary::an order of elements with a numerical index
related::Classes/SparseArray
categories:: Collections>Ordered

DESCRIPTION::
Keeps elements in an order and allows to put them at arbitrary slots
without having to allocate a large array.

note::
link::#-put:: and link::#-at:: are slower than in link::Classes/IdentityDictionary:: / link::Classes/PriorityQueue::, link::#-do:: is faster.
::

CLASSMETHODS::

method::new
Create a new order.
code::
g = Order.new;
g.put(7, 100); // put a value (100) at index 7
g.clear; // empty
::

method::newFromIndices
Create a new order from given items and indices.

INSTANCEMETHODS::

private::resetIndices, nextSlotFor, slotFor, prPutSlot

method::doRange
Iterate over a range of the order's items.

method::pos
Return the current write position.

EXAMPLES::

code::
a = Order.new;

a[0] = \z;
a[0] = \y;
a[5] = \five;
a[4] = \four;

a[0] = \z;
a[5] = \five;
a[4] = \four;

a.indices;

a[9] = 100;
a.indices;
::
** CLASS::OrderedIdentitySet
summary::a set according to identity
related::Classes/IdentitySet, Classes/List, Classes/Dictionary
categories::Collections>Ordered

DESCRIPTION::
An OrderedIdentitySet is a collection of objects, no two of which are the same object (aka. "identical").
Most of its methods are inherited. (see link::Classes/Collection:: and link::Classes/Set:: classes).
Unlike link::Classes/IdentitySet::, contents of an OrderedIdentitySet are ordered.

INSTANCEMETHODS::

private::putCheck

method::do
Evaluates strong::function:: for each item in the OrderedIdentitySet. You may depend on the order of items. The function is passed two arguments, the item and an integer index.
code::
OrderedIdentitySet[1, 2, 3, 300].do { |item, i| item.postln };
::
** class:: Osc
summary:: Interpolating wavetable oscillator.
related:: Classes/COsc, Classes/OscN, Classes/VOsc, Classes/VOsc3, Classes/Wavetable
categories::  UGens>Generators>Deterministic


Description::

Linear interpolating wavetable lookup oscillator with frequency and
phase modulation inputs.


This oscillator requires a buffer to be filled with a wavetable format
signal. This preprocesses the Signal into a form which can be used
efficiently by the Oscillator. The buffer size must be a power of 2.


This can be acheived by creating a Buffer object and sending it one of
the "b_gen" messages ( link::Classes/Buffer#-sine1::, link::Classes/Buffer#-sine2::, link::Classes/Buffer#-sine3:: ) with the wavetable flag set
to true.


This can also be achieved by creating a link::Classes/Signal:: object and sending it
the 'asWavetable' message, thereby creating a Wavetable object in the required format. Then, the wavetable data may be transmitted to the server using the link::Classes/Buffer#*sendCollection:: or link::Classes/Buffer#*loadCollection:: methods.


classmethods::

method::ar, kr

argument::bufnum
Buffer index.

argument::freq
Frequency in Hertz.

argument::phase
Phase offset or modulator in radians.
(Note: phase values should be within the range +-8pi. If your phase values are larger then simply use code::.mod(2pi):: to wrap them.)

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

(
s = Server.local;
b = Buffer.alloc(s, 512, 1);
b.sine1(1.0/[1,2,3,4,5,6], true, true, true);

SynthDef("help-Osc",{ arg out=0,bufnum=0;
	Out.ar(out,
		Osc.ar(bufnum, 200, 0, 0.5)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
s = Server.local;
b = Buffer.alloc(s, 512, 1);
b.sine1(1.0/[1,2,3,4,5,6], true, true, true);

SynthDef("help-Osc",{ arg out=0,bufnum=0;
	Out.ar(out,
		Osc.ar(bufnum, XLine.kr(2000,200), 0, 0.5)// modulate freq
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)


(
s = Server.local;
b = Buffer.alloc(s, 512, 1);
b.sine1([1.0], true, true, true);

SynthDef("help-Osc",{ arg out=0,bufnum=0;
	Out.ar(out,
		Osc.ar(bufnum,
			Osc.ar(bufnum,
				XLine.kr(1,1000,9),
				0,
				200,
				800),
			0,
			0.25)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)


(
// modulate phase
s = Server.local;
b = Buffer.alloc(s, 512, 1);
b.sine1([1.0], true, true, true);

SynthDef("help-Osc",{ arg out=0,bufnum=0;
	Out.ar(out,
		Osc.ar(bufnum,
				800,
				Osc.ar(bufnum,
						XLine.kr(20,8000,10),
						0,
						2pi),
				0.25)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)



(
// change the buffer while its playing
s = Server.local;
b = Buffer.alloc(s, 4096, 1);
b.sine1(1.0/[1,2,3,4,5,6], true, true, true);

SynthDef("help-Osc",{ arg out=0,bufnum=0;
	Out.ar(out,
		Osc.ar(bufnum, [80,80.2], 0, 0.2)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
fork {
	var n = 32;
	50.do {
		b.sine1(Array.rand(n,0,1).cubed, true, true, true);
		0.25.wait;
	};
};
)

::

** class:: OscN
summary:: Noninterpolating wavetable oscillator.
related:: Classes/COsc, Classes/Osc, Classes/VOsc, Classes/VOsc3
categories::  UGens>Generators>Deterministic


Description::

Noninterpolating wavetable lookup oscillator with frequency and phase
modulation inputs. It is usually better to use the interpolating
oscillator  link::Classes/Osc:: .


classmethods::

method::ar, kr

argument::bufnum
Buffer index.  the buffer size must be a power of 2.
The buffer should NOT be filled using Wavetable format (b_gen
commands should set wavetable flag to false. Raw signals (not
converted with asWavetable) can be saved to disk and loaded
into the buffer.


argument::freq
Frequency in Hertz.

argument::phase
Phase offset or modulator in radians.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

// compare examples below with interpolating Osc examples.

(
s = Server.local;
b = Buffer.alloc(s,512,1);
b.sine1(1.0/[1,2,3,4,5,6],true,false,true);

SynthDef("help-OscN",{ arg out=0,bufnum=0;
	Out.ar(out,
		OscN.ar(bufnum, 500, 0, 0.5)
	)
}).play(s,[0,0,1,b.bufnum]);

)
b.free;



(
// noninterpolating - there are noticeable artifacts
// modulate freq

s = Server.local;
b = Buffer.alloc(s,512,1);
b.sine1(1.0/[1,2,3,4,5,6].squared,true,false,true);

SynthDef("help-OscN",{ arg out=0,bufnum=0;
	Out.ar(out,
		OscN.ar(bufnum, XLine.kr(2000,200), 0, 0.5)
	)
}).play(s,[\out,0,\bufnum,b.bufnum]);

)
b.free;

(
// sounds very different than the Osc example
s = Server.local;
b = Buffer.alloc(s, 512, 1);
b.sine1([1.0], true, true, true);

SynthDef("help-OscN",{ arg out=0,bufnum=0;
	Out.ar(out,
		OscN.ar(bufnum,
			OscN.ar(bufnum,
				XLine.kr(1,1000,9),
				0,
				200,
				800),
			0,
			0.25)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);

)
b.free;

(
// modulate phase
s = Server.local;
b = Buffer.alloc(s, 512, 1);
b.sine1([1.0], true, true, true);

SynthDef("help-OscN",{ arg out=0,bufnum=0;
	Out.ar(out,
		OscN.ar(bufnum,
				800,
				OscN.ar(bufnum,
						XLine.kr(20,8000,10),
						0,
						2pi),
				0.25)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)
b.free;


(
// change the buffer while its playing
s = Server.local;
b = Buffer.alloc(s, 4096, 1);
b.sine1(1.0/[1,2,3,4,5,6], true, true, true);

SynthDef("help-OscN",{ arg out=0,bufnum=0;
	Out.ar(out,
		OscN.ar(bufnum, [80,80.2], 0, 0.2)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
Routine({
	var n = 32;
	50.do({
		b.sine1(Array.rand(n,0,1).cubed, true, true, true);
		0.25.wait;
	});
}).play;
)
b.free;

::

** class:: Out
summary:: Write a signal to a bus.
related:: Classes/OffsetOut, Classes/ReplaceOut, Classes/XOut
categories::  UGens>InOut


Description::

Write a signal to a bus.


Note that using the Bus class to allocate a multichannel bus simply
reserves a series of adjacent bus indices with the Server object's bus
allocators. abus.index simply returns the first of those indices. When
using a Bus with an In or Out UGen there is nothing to stop you from
reading to or writing from a larger range, or from hardcoding to a bus
that has been allocated. You are responsible for making sure that the
number of channels match and that there are no conflicts.


note::

Out is subject to control rate jitter. Where sample accurate output is
needed, use  link::Classes/OffsetOut:: .

::

See the link::Reference/Server-Architecture:: and link::Classes/Bus:: helpfiles for more information on
buses and how they are used.


classmethods::

method::ar, kr

argument::bus

The index of the bus to write out to. The lowest numbers are
written to the audio hardware.


argument::channelsArray

An Array of channels or single output to write out. You cannot
change the size of this once a SynthDef has been built.


Examples::

code::

(
SynthDef("help-out", { arg out=0, freq=440;
	var source;
		source = SinOsc.ar(freq, 0, 0.1);

		// write to the bus, adding to previous contents
		Out.ar(out, source);

}).send(s);
)


Synth("help-out", [\freq, 500]);
Synth("help-out", [\freq, 600]);
Synth("help-out", [\freq, 700]);

::

** class:: OutputProxy
summary:: Place holder for multiple outputs
categories:: UGens>Base

Description::

OutputProxy is used by some UGens as a place holder for multiple outputs.
There is no reason for a user to create an OutputProxy directly.

code::
var out;
// Pan2 uses an OutputProxy for each of its two outputs.
out = Pan2.ar(WhiteNoise.ar, 0.0);
out.postln;
::

classmethods::
private:: categories

InstanceMethods::

method:: source
The UGen that is the source for this OutputProxy.
discussion::
code::
var left, right;
// Pan2 uses an OutputProxy for each of its two outputs.
# left, right = Pan2.ar(WhiteNoise.ar, 0.0);
left.source.postln;
::

The code::source:: method is also defined in Array, so that the source can be obtained this way as well:

code::
var out;
// Pan2 uses an OutputProxy for each of its two outputs.
out = Pan2.ar(WhiteNoise.ar, 0.0);
out.postln;
out.source.postln;
::

** class:: PMOsc
summary:: Phase modulation oscillator pair.
categories::  UGens>Generators>Deterministic


Description::

Phase modulation sine oscillator pair.


classmethods::

method::ar, kr

argument::carfreq
Carrier frequency in cycles per second.

argument::modfreq
Modulator frequency in cycles per second.

argument::pmindex
Modulation index in radians.

argument::modphase
A modulation input for the modulator's phase in radians.

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

play({ PMOsc.ar(Line.kr(600, 900, 5), 600, 3, 0, 0.1) }); // modulate carfreq

play({ PMOsc.ar(300, Line.kr(600, 900, 5), 3, 0, 0.1) }); // modulate modfreq

play({ PMOsc.ar(300, 550, Line.ar(0,20,8), 0, 0.1) }); // modulate index

(
e = Env.linen(2, 5, 2);
Routine.run({
	loop({
		play({
			LinPan2.ar(EnvGen.ar(e) *
				PMOsc.ar(2000.0.rand,800.0.rand, Line.kr(0.0, 12.0.rand,9),0,0.1), 1.0.rand2)});
		2.wait;
	})
}))

::
** class:: PSinGrain
summary:: Very fast sine grain with a parabolic envelope
categories::  UGens>Generators>Deterministic


Description::

Very fast sine grain with a parabolic envelope.


classmethods::
private:: categories

method::ar

argument::freq

Frequency in Hertz.


argument::dur

Grain duration.


argument::amp

Grain amplitude.

** class:: PV_Add
summary:: Complex addition.
related:: Classes/FFT, Classes/IFFT, Classes/PV_CopyPhase, Classes/PV_MagMul, Classes/PV_Max, Classes/PV_Min, Classes/PV_Mul
categories:: UGens>FFT

Description::

Complex addition:

code::

RealA + RealB, ImagA + ImagB

::


classmethods::

method::new

argument::bufferA
FFT buffer A.

argument::bufferB
FFT buffer B.

Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-add", { arg out=0, soundBufnum;
	var inA, chainA, inB, chainB, chain ;
	inA = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	inB =  PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum) * 0.5, loop: 1);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_Add(chainA, chainB);
	Out.ar(out,  0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b.bufnum]);
)

b.free

::
** class:: PV_BinScramble
summary:: Scramble bins.
categories:: UGens>FFT

Description::

Randomizes the order of the bins. The trigger will select a new random ordering.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::wipe

Scrambles more bins as wipe moves from 0 to 1.


argument::width

A value from zero to one, indicating the maximum randomized
distance of a bin from its original location in the spectrum.


argument::trig

A trigger, that selects a new random ordering.


Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
//trig with MouseY
SynthDef("help-binScramble", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BinScramble(chain, MouseX.kr , 0.1, MouseY.kr > 0.5 );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)

::
** class:: PV_BinShift
summary:: Shift and stretch bin position.
related:: Classes/FFT, Classes/IFFT, Classes/PV_MagShift
categories:: UGens>FFT

Description::

Shift and scale the positions of the bins. Can be used as a very crude
frequency shifter/scaler.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::stretch

Scale bin location by factor.


argument::shift

Add an offset to bin position.

argument::interp

Set to 0 (default) for no interpolation, or 1 to linear-interpolate between bins.


Examples::

code::

s.boot;

(
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)

(
SynthDef("help-binStretch", { arg out=0;
	var in, chain;
	in = LFSaw.ar(200, 0, 0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BinShift(chain, MouseX.kr(0.25, 4, \exponential) );
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play;
)

(
SynthDef("help-binStretch2", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BinShift(chain, MouseX.kr(0.25, 4, \exponential) );
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \soundBufnum, c.bufnum]);
)

(
SynthDef("help-binShift", { arg out=0, bufnum=0;
	var in, chain;
	in = LFSaw.ar(200, 0, 0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BinShift(chain, 1, MouseX.kr(-128, 128) );
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play;
)

(
SynthDef("help-binShift2", {  arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_BinShift(chain, 1, MouseX.kr(-128, 128) );
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \soundBufnum, c.bufnum]);
)

::

** class:: PV_BinWipe
summary:: Combine low and high bins from two inputs.
categories:: UGens>FFT

Description::

Copies low bins from one input and the high bins of the other.


classmethods::

method::new

argument::bufferA

FFT buffer A.


argument::bufferB

FFT buffer B.


argument::wipe

Can range between -1 and +1.


If
code::wipe::  == 0, then the output is the same
as
code::bufferA:: .


If
code::wipe::  > 0, then it begins replacing
with bins from
code::bufferB::  from the bottom up.


If
code::wipe::  < 0, then it begins replacing
with bins from
code::bufferB::  from the top down.


Examples::

code::
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-binWipe", { arg out=0;
	var inA, chainA, inB, chainB, chain;
	inA = WhiteNoise.ar(0.2);
	inB = LFSaw.ar(100, 0, 0.2);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_BinWipe(chainA, chainB, MouseX.kr(-1, 1));
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-binWipe2", { arg out=0, soundBufnum=2;
	var inA, chainA, inB, chainB, chain;
	inA = WhiteNoise.ar(0.2);
	inB = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_BinWipe(chainA, chainB, MouseX.kr(-1, 1));
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)
::
** class:: PV_BrickWall
summary:: Zero bins.
related:: Classes/FFT, Classes/IFFT
categories:: UGens>FFT

Description::

Clears bins above or below a cutoff point.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::wipe

Can range between -1 and +1.


If
code::wipe::  == 0 then there is no effect.


If
code::wipe::  > 0 then it acts like a high
pass filter, clearing bins from the bottom up.


If
code::wipe::  < 0 then it acts like a low
pass filter, clearing bins from the top down.


Examples::

code::

s.boot;

b = Buffer.alloc(s,2048,1);

(
SynthDef("help-brick", { arg out=0, bufnum=0;
	var in, chain;
	in = {WhiteNoise.ar(0.2)}.dup;
	chain = FFT(bufnum, in);
	chain = PV_BrickWall(chain, SinOsc.kr(0.1));
	Out.ar(out, IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

::

** class:: PV_ChainUGen
summary:: Base class for UGens that alter FFT chains
categories:: UGens>FFT

description::
"PV_ChainUGen" is an abstract class - in other words, a class that you do not use directly. Instead, use one of its subclasses. It represents phase-vocoder UGens - i.e. UGens which apply some kind of transformation to the frequency-domain signal produced by FFT.

(Strictly, this class encompasses all units whose output is an FFT chain. This is why FFT is in this group but IFFT is not - the IFFT unit outputs ordinary time-domain audio.)

For more info on using these units, see link::Guides/FFT-Overview::.

classmethods::
private:: categories

instancemethods::
method:: pvcalc
Process the bins of an FFT chain
discussion::
code::
chain = chain.pvcalc(numframes, func, frombin, tobin, zeroothers)
::
pvcalc applies function code::func:: to the frequency-domain data of an FFT chain.
code::func:: should be a function that takes two arrays as inputs (magnitude, and phase) and returns a resulting pair of arrays code::[magnitude, phase]::.

frombin, tobin, and zeroothers are optional arguments which limit the processing to a specified integer range of FFT bins. If zeroothers is set to 1 then bins outside of the range being processed are silenced.

See code::pvcollect:: below for discussion of efficiency considerations. See also code::pvcalc2:: below, and link::Classes/UnpackFFT::.

method::pvcalc2
Process the bins of two FFT chains
discussion::
code::
chain = chain.pvcalc2(chain2, numframes, func, frombin, tobin, zeroothers)
::
pvcalc2 is just like pvcalc but can combine two FFT chains together. See code::pvcalc:: above for more information.

code::func:: should be a function that takes four arrays as inputs (magnitudes1, phases1, magnitudes2, phases2) and returns a resulting pair of arrays code::[magnitude, phase]::.

method:: pvcollect
Process each bin of an FFT chain, separately
discussion::
code::
chain = chain.pvcollect(numframes, func, frombin, tobin, zeroothers)
::
pvcollect applies function code::func:: to each bin of an FFT chain. func should be a function that takes code:: magnitude, phase, bin, index :: as inputs and returns a resulting code::[magnitude, phase]::.

The "bin" is the integer bin number, starting at 0 for DC, while "index" is the iteration number, always starting with 0. You can optionally ignore the phase and only return a single (magnitude) value, in which case the phase is assumed to be left unchanged.

frombin, tobin, and zeroothers are optional arguments which limit the processing to a specified integer range of FFT bins. If zeroothers is set to 1 then bins outside of the range being processed are silenced.

Note that this procedure can be relatively CPU-heavy, depending on how you use it.
Using pvcollect (or its components, UnpackFFT & PackFFT) is usually less efficient than using a single "PV_" unit generator to process an FFT chain, because it involves the creation of quite a large graph of demand-rate unit generators.

If you wish to reduce the CPU impact of using this approach, try the following:
list::
## Use the frombin and tobin arguments to limit the number of FFT bins that will be included in the calculation. Often the lower FFT bins contain the loudest and/or most relevant information, so perhaps your effect sounds very similar if you ignore the higher-up bins (either leave them unprocessed, or discard them by setting the zeroothers argument to 1, which has the effect of a band-pass frequency-domain filter).
## Use a smaller FFT buffer size.
## Avoid creating ugens inside your calculation function if at all possible. For example, a deterministic ugen such as LFPar.kr(0.5, 0, 1) will be replicated once for each bin if specified inside the function, despite the fact that the output is always the same. Define it outside the calculation function and then reference it by variable name.
## Avoid unused calculations! For example, uncommenting all the different lines in the above will waste effort because many values will be calculated but not used. This cannot be optimised away during compilation. It is particularly important because all calculations are duplicated (once for each bin) so can have a significant impact on efficiency.
## If you find yourself calling pvcollect on an FFT chain more than once in series, you should definitely try to combine your processing into a single pvcollect function, to avoid unneccessary unpacking-then-packing-then-unpacking-then-packing.
::

Examples::

subsection:: pvcalc
code::
(
s.boot.doWhenBooted{
	c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
}
)

(
x = {
	var in, chain, v;
	in = PlayBuf.ar(1, c, BufRateScale.kr(c), loop: 1);
	chain = FFT(LocalBuf(1024), in);

	chain = chain.pvcalc(1024, {|mags, phases|
//////// Try uncommenting each of these lines in turn and re-running the synth:
		[mags * {1.5.rand}.dup(mags.size), phases + {pi.rand}.dup(phases.size)]; // Arbitrary filter, arbitrary phase shift
		//[mags.reverse, phases.reverse]; // Upside-down!
		//[mags.differentiate, phases.differentiate]; // Differentiate along frequency axis
		//[mags[30..] ++ mags[..30], phases[30..] ++ phases[..30]]; // ".rotate" doesn't work directly, but this is equivalent
	}, frombin: 0, tobin: 250, zeroothers: 0);

	Out.ar(0, 0.5 * IFFT(chain).dup);
}.play(s);
)
x.free;
::

subsection:: pvcalc2
code::
(
s.boot.doWhenBooted {
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
}
)

(
x = {
	var fftsize = 1024;
	var in, chain, in2, chain2, out;
	in = PlayBuf.ar(1, c, BufRateScale.kr(c), loop: 1);
	chain = FFT(LocalBuf(fftsize), in);

	// in2 = PlayBuf.ar(1, e, BufRateScale.kr(e), loop: 1);
	// JMcC babbling brook
	in2 = ({
		RHPF.ar(OnePole.ar(BrownNoise.ar, 0.99), LPF.ar(BrownNoise.ar, 14)
			* 400 + 500, 0.03, 0.003)}!2)
			+ ({RHPF.ar(OnePole.ar(BrownNoise.ar, 0.99), LPF.ar(BrownNoise.ar, 20)
			* 800 + 1000, 0.03, 0.005)}!2
		)
			* 4;
	chain2 = FFT(LocalBuf(fftsize), in2);

	chain = chain.pvcalc2(chain2, fftsize, {|mags, phases, mags2, phases2|
		[mags * mags2 / 10, phases2 + phases]
	}, frombin: 0, tobin: 125, zeroothers: 0);

	out = IFFT(chain);
	Out.ar(0, 0.5 * out.dup);
}.play(s);
)
x.free;
::

subsection:: pvcollect
code::
(
s.boot.doWhenBooted{
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
}
)

(
x = {
	var in, chain, v;
	in = PlayBuf.ar(1, c, BufRateScale.kr(c), loop: 1);
	chain = FFT(LocalBuf(1024), in);

	v = LFPar.kr(0.5).range(0.1, 1);

	chain = chain.pvcollect(1024, {|mag, phase, index|
//////// Try uncommenting each of these lines in turn and re-running the synth:
		//mag;
		//[mag, phase];
		//[mag, phase] / 3;
		//[mag, phase].sqrt;
		//[mag, 3.14.rand];
		//[mag, LFNoise0.kr.range(0, 3.14)];
		//[mag * Dseq([1, 0, 0, 1, 1, 0, 1, 0].stutter(8), 999999999999)]; // Can even use Demand ugens! One val demanded each frame
		//[mag.sqrt, 3.14.rand];
		//if(index % 7 == 0, mag, 0); // Comb filter
		//if(LFNoise0.kr(10) > 0.5, mag, 0);
		//mag + DelayN.kr(mag, 1, v); // Spectral delay
		if((index-LFPar.kr(0.1).range(2, 1024/20)).abs < 10, mag, 0); // Swept bandpass
	}, frombin: 0, tobin: 250, zeroothers: 0);

	Out.ar(0, 0.5 * IFFT(chain).dup);
}.play(s);
)
x.free;
::
** class:: PV_ConformalMap
summary:: Complex plane attack.
related:: Classes/FFT, Classes/IFFT
categories:: UGens>FFT

Description::

Applies the conformal mapping

code::

z → (z - a) / (1 - za*)

::

to the phase vocoder bins z with a given by the real and imag imputs to
the UGen.


Makes a transformation of the complex plane so the output is full of
phase vocoder artifacts but may be musically fun. Usually keep

code::
|a| < 1
::
but
you can of course try bigger values to make it really noisy.

code::
a = 0
::
should
give back the input mostly unperturbed.


See  link::http://mathworld.wolfram.com/ConformalMapping.html:: .


classmethods::

method::new

argument::buffer

FFT buffer.


argument::areal

Real part of a.


argument::aimag

Imaginary part of a.


Examples::

code::

//explore the effect
(
SynthDef("conformer1", {
	var in, chain;
	in = AudioIn.ar(1,0.5);
	chain = FFT(LocalBuf(1024), in);
	chain=PV_ConformalMap(chain, MouseX.kr(-1.0,1.0), MouseY.kr(-1.0,1.0));
	Out.ar(0, Pan2.ar(IFFT(chain),0));
}).add;
)

a = Synth("conformer1")
a.free

(
SynthDef("conformer2", {
	var in, chain, out;
	in = Mix.ar(LFSaw.ar(SinOsc.kr(Array.rand(3,0.1,0.5),0,10,[1,1.1,1.5,1.78,2.45,6.7]*220),0,0.3));
	chain = FFT(LocalBuf(2048), in);
	chain=PV_ConformalMap(chain, MouseX.kr(0.01,2.0, 'exponential'), MouseY.kr(0.01,10.0, 'exponential'));
	out=IFFT(chain);

	Out.ar(0, Pan2.ar(CombN.ar(out, 0.1, 0.1, 10, 0.5, out), 0, 0.3));
}).add;
)

a = Synth("conformer2")
a.free
::

** class:: PV_Conj
summary:: Complex conjugate
categories:: UGens>FFT

description::
Converts the FFT frames to their complex conjugate (i.e. reverses the sign of their imaginary part). This is not usually a useful audio effect in itself, but may be a component of other analysis or transformation processes...

classmethods::
method:: new
argument:: chain
fft chain.

examples::
code::
s.boot;

(
b = Buffer.alloc(s,2048,1);
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
d = Buffer.alloc(s,2048,1);
)

(
SynthDef(\help_pvconj, {  arg out=0, bufnum=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(bufnum, in);
	chain = PV_Conj(chain);
	// Original is left, conj is right
	Out.ar(out, 0.3 * [in, IFFT(chain)]);
}).play(s,[\out, 0, \bufnum, b, \soundBufnum, c]);
)

(
SynthDef(\help_pvconj2, {  arg out=0, bufnum=0, soundBufnum=2;
	var in, chainA, chainB;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chainA = FFT(bufnum, in);
	chainB = PV_Copy(chainA, d);
	chainB = PV_Conj(chainB);
	// Now we have the original and conjugate, what happens if we add them?
	Out.ar(out, 0.3 * (IFFT(PV_Add(chainA, chainB)).dup));
}).play(s,[\out, 0, \bufnum, b, \soundBufnum, c]);
)
::

** class:: PV_Copy
summary:: Copy an FFT buffer
categories:: UGens>FFT


description::

Copies the spectral frame in bufferA to bufferB at that point in the chain of PV UGens. This allows for parallel processing of spectral data without the need for multiple FFT UGens, and to copy out data at that point in the chain for other purposes. bufferA and bufferB must be the same size.

classmethods::
method:: new
argument:: bufferA
source buffer.
argument:: bufferB
destination buffer.

examples::
code::
(
s.waitForBoot {
	d = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
}
)


//// crossfade between original and magmul-ed whitenoise
(
x = { var in, in2, chain, chainB, chainC;
	in = PlayBuf.ar(1, d, BufRateScale.kr(d), loop: 1) * 2;
	in2 = WhiteNoise.ar;
	chain = FFT(LocalBuf(2048), in);
	chainB = FFT(LocalBuf(2048), in2);
	chainC = PV_Copy(chain, LocalBuf(2048));
	chainB = PV_MagMul(chainB, chainC);
	XFade2.ar(IFFT(chain), IFFT(chainB) * 0.1, SinOsc.kr(0.1, 1.5pi));
}.play(s);
)
x.free;




//// as previous but with Blip for 'vocoder' cross synthesis effect
(
x = { var in, in2, chain, chainB, chainC;
	in = PlayBuf.ar(1, d, BufRateScale.kr(d), loop: 1) * 2;
	in2 = Blip.ar(100, 50);
	chain = FFT(LocalBuf(2048), in);
	chainB = FFT(LocalBuf(2048), in2);
	chainC = PV_Copy(chain, LocalBuf(2048));
	chainB = PV_MagMul(chainB, chainC);
	XFade2.ar(IFFT(chain), IFFT(chainB) * 0.1, SinOsc.ar(0.1));
}.play(s);
)
x.free;


//// Spectral 'pan'
(
x = { var in, chain, chainB, pan;
	in = PlayBuf.ar(1, d, BufRateScale.kr(d), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chainB = PV_Copy(chain, LocalBuf(2048));
	pan = MouseX.kr(0.001, 1.001, 'exponential') - 0.001;
	chain = PV_BrickWall(chain, pan);
	chainB = PV_BrickWall(chainB, -1 + pan);
	0.5 * IFFT([chain, chainB]);
}.play(s);
)
x.free;


(
s.waitForBoot {
	b = Buffer.alloc(s,2048,1);
	c = Buffer.alloc(s,2048,1);
	d = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
	e = Buffer.alloc(s,2048,1);
	f = Buffer.alloc(s,2048,1);
}
)


//// proof of concept
(
x = { var inA, chainA, inB, chainB, chain;
	inA = LFClipNoise.ar(100);
	chainA = FFT(b, inA);
	chainB = PV_Copy(chainA, c);
	IFFT(chainA) - IFFT(chainB); // cancels to zero so silent!
}.play(s);
)
x.free;
// IFFTed frames contain the same windowed output data
b.plot(\b, Rect(200, 430, 700, 300)); c.plot(\c, Rect(200, 100, 700, 300));



//// Multiple Magnitude plots
(
x = { var in, chain, chainB, chainC;
	in = WhiteNoise.ar;
	chain = FFT(b, in);
	PV_Copy(chain, LocalBuf(2048)); // initial spectrum
	chain = PV_RectComb(chain, 20, 0, 0.2);
	PV_Copy(chain, LocalBuf(2048)); // after comb
	2.do({chain = PV_MagSquared(chain)});
	PV_Copy(chain, LocalBuf(2048)); // after magsquared
	0.00001 * Pan2.ar(IFFT(chain));
}.play(s);
)
x.free;

(
c.getToFloatArray(action: { arg array;
	var z, x;
	z = array.clump(2).flop;
	// Initially data is in complex form
	z = [Signal.newFrom(z[0]), Signal.newFrom(z[1])];
	x = Complex(z[0], z[1]);
	{x.magnitude.plot('Initial', Rect(200, 560, 700, 200))}.defer
});
e.getToFloatArray(action: { arg array;
	var z, x;
	z = array.clump(2).flop;
	// RectComb doesn't convert, so it's still complex
	z = [Signal.newFrom(z[0]), Signal.newFrom(z[1])];
	x = Complex(z[0], z[1]);
	{x.magnitude.plot('After RectComb', Rect(200, 330, 700, 200))}.defer
});
f.getToFloatArray(action: { arg array;
	var z, x;
	z = array.clump(2).flop;
	// MagSquared converts to Polar
	x = Signal.newFrom(z[0]); // magnitude first
	{x.plot('After MagSquared', Rect(200, 100, 700, 200))}.defer
})
)

[b, c, d, e, f].do(_.free); // free the buffers
::

** class:: PV_CopyPhase
summary:: Copy magnitudes and phases.
related:: Classes/FFT, Classes/IFFT, Classes/PV_Add, Classes/PV_MagMul, Classes/PV_Max, Classes/PV_Min, Classes/PV_Mul
categories:: UGens>FFT

Description::

Combines magnitudes of first input and phases of the second input.


classmethods::

method::new

argument::bufferA
FFT buffer A.

argument::bufferB
FFT buffer B.

Examples::

code::
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-copyPhase", { arg out=0;
	var inA, chainA, inB, chainB, chain;
	inA = SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08, 0, 6, 6.2).squared, 0, 100, 800));
	inB = WhiteNoise.ar(0.2);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_CopyPhase(chainA, chainB);
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-copyPhase2", { arg out=0, soundBufnum=2;
	var inA, chainA, inB, chainB, chain;
	inA = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	inB =  SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08, 0, 6, 6.2).squared, 0, 100, 800));
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_CopyPhase(chainA, chainB);
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);

)

::

** class:: PV_Diffuser
summary:: Random phase shifting.
related:: Classes/FFT, Classes/IFFT, Classes/PV_PhaseShift, Classes/PV_PhaseShift90, Classes/PV_PhaseShift270
categories:: UGens>FFT

Description::

Adds a different constant random phase shift to each bin. When triggered, it selects a new set of random phases.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::trig

A trigger, that selects a new set of random values.


Examples::

code::



(
// trig with MouseY crossing center of screen
{
	var in, chain;
	in = Mix.ar(SinOsc.ar(200 * (1..10), 0, Array.fill(10, { rrand(0.1, 0.2) }) ));
	chain = FFT(LocalBuf(2048), in);
	chain = PV_Diffuser(chain, MouseY.kr > 0.5 );
	0.5 * IFFT(chain).dup;
}.play
);

(
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// trig with MouseY crossing center of screen
{
	var in, chain;
	in = PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_Diffuser(chain, MouseY.kr > 0.5 );
	0.5 * IFFT(chain).dup;
}.play
);

::

** class:: PV_Div
summary:: Complex division
categories:: UGens>FFT
related:: Classes/PV_Mul, Classes/PV_MagDiv

classmethods::

method:: new
argument:: bufferA
fft buffer A.
argument:: bufferB
fft buffer B.

Examples::
In this example we estimate the transfer function of the LPF UGen. The transfer function is estimated by dividing the FFT of the output, by the FFT of the input, and looking at the magnitudes in the result.
code::
(
s.waitForBoot {
	var fftsize = 16384;
	b = Buffer.alloc(s, fftsize)
}
);


(
x = {
	// Any input should theoretically be OK, white noise is a good choice
	var son = WhiteNoise.ar;
//	var son = Impulse.ar;
	var out = LPF.ar(son, MouseX.kr(100, 10000, 1));
	var fft1 = FFT(LocalBuf(b.numFrames), son, wintype: 1);
	var fft2 = FFT(b, out, wintype: 1);

	// As with most PV_ ugens, the result is *actually* stored in the first fft buf
	var result = PV_Div(fft2, fft1);

	Out.ar(0, out.dup * 0.1);
}.play;
)

// Now we can grab the FFT buffer and peek at the magnitudes
(
w = Window.new.front;
t = Task{loop{
	0.1.wait;
	b.loadToFloatArray(action: {|data| {
		w.view.children.do(_.remove);
		w.refresh;
		data[2..].clump(2)
		.collect {|a| (a[0].squared + a[1].squared)}
		.collect {|a| if(a.isNaN){ 0.post }{ a } }
		.plot(parent: w)
	}.defer});
}}.play;
)
::

** class:: PV_HainsworthFoote
summary:: FFT onset detector.
related:: Classes/PV_JensenAndersen
categories::  UGens>FFT


Description::

FFT onset detector based on work described in emphasis:: Hainsworth, S. (2003) Techniques for the Automated Analysis of Musical Audio. PhD, University of Cambridge engineering dept. ::
See especially p128. The Hainsworth metric is a modification of the Kullback Liebler
distance.


The onset detector has general ability to spot spectral change, so may
have some ability to track chord changes  aside from obvious transient
jolts, but there's no guarantee it won't be confused by frequency
modulation artifacts.


Hainsworth metric on it's own gives good results but Foote might be
useful in some situations: experimental.


classmethods::
private:: categories

method::ar

argument::buffer

FFT buffer.


argument::proph

What strength of detection signal from Hainsworth metric to use.


argument::propf

What strength of detection signal from Foote metric to use. The
Foote metric is normalised to (0..1).


argument::threshold

Threshold hold level for allowing a detection.


argument::waittime

If triggered, minimum wait until a further frame can cause
another spot (useful to stop multiple detects on heavy signals).


Examples::

code::

//just Hainsworth metric with low threshold
(
SynthDef(\fftod, {
	var source1, detect;
	source1= AudioIn.ar(1);
	detect= PV_HainsworthFoote.ar(FFT(LocalBuf(2048),source1), 1.0, 0.0);
	Out.ar(0,SinOsc.ar([440,445],0,Decay.ar(0.1*detect,0.1)));
}).play(s);
)


//spot note transitions
(
SynthDef(\fftod, {
	var source1, detect;
	source1= LFSaw.ar(LFNoise0.kr(1,90,400),0,0.5);
	detect= PV_HainsworthFoote.ar(FFT(LocalBuf(2048),source1), 1.0, 0.0, 0.9, 0.5);
	Out.ar(0,Pan2.ar(source1,-1.0)+ Pan2.ar(SinOsc.ar(440,0,Decay.ar(0.1*detect,0.1)),1.0));
}).play(s);
)



//Foote solo- never triggers with threshold over 1.0, threshold under mouse control
(
SynthDef(\fftod, {
	var source1, detect;
	source1= AudioIn.ar(1);
	detect= PV_HainsworthFoote.ar(FFT(LocalBuf(2048),source1), 0.0, 1.0, MouseX.kr(0.0,1.1), 0.02);
	Out.ar(0,Pan2.ar(source1,-1.0)+ Pan2.ar(SinOsc.ar(440,0,Decay.ar(0.1*detect,0.1)),1.0));
}).play(s);
)


//compare to Amplitude UGen
(
SynthDef(\fftod, {
		var source1, detect;
		source1= AudioIn.ar(1);
		detect= (Amplitude.ar(source1)) > (MouseX.kr(0.0,1.1));
		Out.ar(0,Pan2.ar(source1,-1.0)+ Pan2.ar(SinOsc.ar(440,0,Decay.ar(0.1*detect,0.1)),1.0));
	}).play(s);
)

::

** class:: PV_JensenAndersen
summary:: FFT feature detector for onset detection.
related:: Classes/PV_HainsworthFoote
categories::  UGens>FFT


Description::

FFT feature detector for onset detection based on work described in
emphasis::
Jensen, K. & Andersen, T. H. (2003). Real-time Beat Estimation
Using Feature Extraction. In Proceedings of the Computer Music Modeling
and Retrieval Symposium, Lecture Notes in Computer Science. Springer
Verlag.
::

First order derivatives of the features are taken.
code::threshold::  may need to be set low to pick up on
changes.


classmethods::
private:: categories
method::ar

argument::buffer

FFT buffer.


argument::propsc

Proportion of spectral centroid feature.


argument::prophfe

Proportion of high frequency energy feature.


argument::prophfc

Proportion of high frequency content feature.


argument::propsf

Proportion of spectral flux feature.


argument::threshold

Threshold level for allowing a detection.


argument::waittime

If triggered, minimum wait until a further frame can cause
another spot (useful to stop multiple detects on heavy signals).


Examples::

code::
(
SynthDef(\fftod, { var source1, detect;
		source1 = AudioIn.ar(1);
		detect = PV_JensenAndersen.ar(FFT(LocalBuf(2048), source1),
			threshold:MouseX.kr(0.1,1.0));
		Out.ar(0, SinOsc.ar([440,445], 0, Decay.ar(0.1*detect, 0.1)));
	}).play(s);
)
::
** class:: PV_LocalMax
summary:: Pass bins which are a local maximum.
related:: Classes/FFT, Classes/IFFT, Classes/PV_MagAbove, Classes/PV_MagBelow, Classes/PV_MagClip
categories:: UGens>FFT

Description::

Passes only bins whose magnitude is above a threshold and above their nearest neighbors.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::threshold

Magnitude threshold.


Examples::

code::
s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");


(
SynthDef("help-localMax", { arg out=0;
	var in, chain;
	in = Mix.arFill(3, { LFSaw.ar(exprand(100, 500), 0, 0.1); });
	chain = FFT(LocalBuf(2048), in);
	chain = PV_LocalMax(chain, MouseX.kr(0, 50));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-localMax2", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_LocalMax(chain, MouseX.kr(0, 100));
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)

::

** class:: PV_MagAbove
summary:: Pass bins above a threshold.
related:: Classes/FFT, Classes/IFFT, Classes/PV_LocalMax, Classes/PV_MagBelow, Classes/PV_MagClip
categories:: UGens>FFT

Description::

Passes only bins whose magnitude is above a threshold.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::threshold

Magnitude threshold.


Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");


(
SynthDef("help-magAbove", { arg out=0;
	var in, chain;
	in = SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08, 0, 6, 6.2).squared, 0, 100, 800));
	//in = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagAbove(chain, 310);
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magAbove2", { arg out=0;
	var in, chain;
	in = WhiteNoise.ar(0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagAbove(chain, MouseX.kr(0, 10));
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magAbove3", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagAbove(chain, MouseX.kr(0, 310));
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)

::
** class:: PV_MagBelow
summary:: Pass bins below a threshold.
related:: Classes/FFT, Classes/IFFT, Classes/PV_MagAbove, Classes/PV_LocalMax, Classes/PV_MagClip
categories:: UGens>FFT

Description::

Passes only bins whose magnitude is below a threshold.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::threshold

Magnitude threshold.


Examples::

code::

s.boot;

(
b = Buffer.alloc(s,2048,1);
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)

(
SynthDef("help-magBelow", { arg out=0, bufnum=0;
	var in, chain;
	in = SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08, 0, 6, 6.2).squared, 0, 100, 800));
	chain = FFT(bufnum, in);
	chain = PV_MagBelow(chain, 10);
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
SynthDef("help-magBelow2", { arg out=0, bufnum=0;
	var in, chain;
	in = WhiteNoise.ar(0.2);
	chain = FFT(bufnum, in);
	chain = PV_MagBelow(chain, MouseX.kr(0, 7));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
SynthDef("help-magBelow3", { arg out=0, bufnum=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(bufnum, in);
	chain = PV_MagBelow(chain, MouseX.kr(0, 310));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum, \soundBufnum, c.bufnum]);
)

::

** class:: PV_MagClip
summary:: Clip bins to a threshold.
related:: Classes/FFT, Classes/IFFT, Classes/PV_MagAbove, Classes/PV_LocalMax, Classes/PV_MagBelow
categories:: UGens>FFT

Description::

Clips bin magnitudes to a maximum threshold.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::threshold

Magnitude threshold.


Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
	var in, chain;
	in = Mix.arFill(3, { LFSaw.ar(exprand(100, 500), 0, 0.1); });
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagClip(chain, MouseX.kr(0, 15));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magClip2", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagClip(chain, MouseX.kr(0, 50));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)

::

** class:: PV_MagDiv
summary:: Division of magnitudes
categories:: UGens>FFT

description::
Divides magnitudes of two inputs and keeps the phases of the first input.

classmethods::
private:: categories

method:: new
argument:: bufferA
fft buffer A.
argument:: bufferB
fft buffer B.
argument:: zeroed
number to use when bins are zeroed out, i.e. causing division by zero (defaults to 0.0001)

examples::
code::
s.boot;

(
SynthDef("help-magMul", { arg out=0;
	var inA, chainA, inB, chainB, chain;
	inA = WhiteNoise.ar(0.2);
	inB = LFSaw.ar(100, 0, 0.2);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_MagDiv(chainA, chainB);
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play;
)


c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-magMul2", { arg out=0, soundBufnum=0;
	var inA, chainA, inB, chainB, chain;
	inA = LFSaw.ar([100, 150], 0, 0.2);
	inB = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_MagDiv(chainA, chainB);
	Out.ar(out,  0.1 * IFFT(chain));
}).play(s,[\out, 0, \soundBufnum, c]);
)

c.free;
::

** class:: PV_MagFreeze
summary:: Freeze magnitudes.
categories:: UGens>FFT

Description::

Freezes magnitudes at current levels when  code::freeze::  > 0.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::freeze

If > 0, then magnitudes are frozen at current levels.


Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");


(
SynthDef("help-magFreeze", { arg out=0;
	var in, chain;
	in = SinOsc.ar(LFNoise1.kr(5.2,250,400));
	chain = FFT(LocalBuf(2048), in);
	// moves in and out of freeze
	chain = PV_MagFreeze(chain, SinOsc.kr(0.2) );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);

)

(
//trig with MouseY
SynthDef("help-magFreeze2", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagFreeze(chain, MouseY.kr > 0.5 );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s,[\soundBufnum, b]);
)

b.free

::
** class:: PV_MagMul
summary:: Multiply magnitudes.
related:: Classes/FFT, Classes/IFFT, Classes/PV_Add, Classes/PV_CopyPhase, Classes/PV_Max, Classes/PV_Min, Classes/PV_Mul
categories:: UGens>FFT

Description::

Multiplies magnitudes of two inputs and keeps the phases of the first input.


classmethods::

method::new

argument::bufferA
FFT buffer A.

argument::bufferB
FFT buffer B.

Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-magMul", { arg out=0;
	var inA, chainA, inB, chainB, chain;
	inA = WhiteNoise.ar(0.2);
	inB = LFSaw.ar(100, 0, 0.2);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_MagMul(chainA, chainB);
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magMul2", { arg out=0, soundBufnum=2;
	var inA, chainA, inB, chainB, chain;
	inA = LFSaw.ar([100, 150], 0, 0.2);
	inB = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_MagMul(chainA, chainB);
	Out.ar(out,  0.03 * IFFT(chain));
}).play(s, [\soundBufnum, b.bufnum]);
)

b.free

::

** class:: PV_MagNoise
summary:: Multiply magnitudes by noise.
related:: Classes/FFT, Classes/IFFT
categories:: UGens>FFT

Description::

Magnitudes are multiplied with noise.


classmethods::

method::new

argument::buffer

FFT buffer.


Examples::

code::

s.boot;

b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-magNoise", { arg out=0;
	var in, chain;
	in = SinOsc.ar(SinOsc.kr(SinOsc.kr(0.08, 0, 6, 6.2).squared, 0, 100, 800));
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagNoise(chain);
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magNoise2", {  arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagNoise(chain);
	Out.ar(out, 0.2 * IFFT(chain).dup);
}).play(s,[\soundBufnum, b]);
)

b.free;

::

** class:: PV_MagShift
summary:: shift and stretch magnitude bin position.
related:: Classes/FFT, Classes/IFFT, Classes/PV_BinShift
categories:: UGens>FFT

Description::

Shift and stretch the positions of only the magnitude of the bins. Can be used as a very crude frequency shifter/scaler.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::stretch

Scale bin location by factor.


argument::shift

Add an offset to bin position.


Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
SynthDef("help-magStretch", { arg out=0, bufnum=0;
	var in, chain;
	in = LFSaw.ar(200, 0, 0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagShift(chain, MouseX.kr(0.25, 4, \exponential) );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magStretch2", { arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagShift(chain, MouseX.kr(0.25, 4, \exponential) );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)

(
SynthDef("help-magShift", { arg out=0;
	var in, chain;
	in = LFSaw.ar(200, 0, 0.2);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagShift(chain, 1, MouseX.kr(-128, 128) );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)

(
SynthDef("help-magShift2", {  arg out=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(LocalBuf(2048), in);
	chain = PV_MagShift(chain, 1, MouseX.kr(-128, 128) );
	Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s, [\soundBufnum, b]);
)

::

** class:: PV_MagSmear
summary:: Average magnitudes across bins.
categories:: UGens>FFT

Description::

Average a bin's magnitude with its neighbors.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::bins

Number of bins to average on each side of bin. As this number
rises, so will CPU usage.


Examples::

code::

s.boot;

(
b = Buffer.alloc(s,2048,1);
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)

(
SynthDef("help-magSmear", { arg out=0, bufnum=0;
	var in, chain;
	in = LFSaw.ar(500, 0, Decay2.ar(Impulse.ar(2,0,0.2), 0.01, 2));
	chain = FFT(bufnum, in);
	chain = PV_MagSmear(chain, MouseX.kr(0, 100));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
SynthDef("help-magSmear2", { arg out=0, bufnum=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(bufnum, in);
	chain = PV_MagSmear(chain, MouseX.kr(0, 100));
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum, \soundBufnum, c.bufnum]);
)

::
** class:: PV_MagSquared
summary:: Square magnitudes.
related:: Classes/FFT, Classes/IFFT
categories:: UGens>FFT

Description::

Squares the magnitudes and renormalizes to previous peak. This makes weak
bins weaker.


classmethods::

method::new

argument::buffer

FFT buffer.


Examples::

code::

s.boot;

(
b = Buffer.alloc(s,2048,1);
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)

(
SynthDef("help-magSquared", {  arg out=0, bufnum=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(bufnum, in);
	chain = PV_MagSquared(chain);
	Out.ar(out, 0.003 * IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum, \soundBufnum, c.bufnum]);
)

::

** class:: PV_Max
summary:: Maximum magnitude.
related:: Classes/FFT, Classes/IFFT, Classes/PV_Add, Classes/PV_CopyPhase, Classes/PV_MagMul, Classes/PV_Min, Classes/PV_Mul
categories:: UGens>FFT

Description::

Output copies bins with the maximum magnitude of the two inputs.


classmethods::

method::new

argument::bufferA
FFT buffer A.

argument::bufferB
FFT buffer B.

Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
var exBuf;
Dialog.getPaths({ arg paths; //get a second soundfile;
	paths.do({ arg p; exBuf = Buffer.read(s, p);
		SynthDef("help-max", { arg out=0, soundBufnum1=2, soundBufnum2 = 3;
			var inA, chainA, inB, chainB, chain ;
			inA = PlayBuf.ar(1, soundBufnum1, BufRateScale.kr(soundBufnum1), loop: 1);
			inB =  PlayBuf.ar(1, soundBufnum2, BufRateScale.kr(soundBufnum2), loop: 1);
			chainA = FFT(LocalBuf(2048), inA);
			chainB = FFT(LocalBuf(2048), inB);
			chain = PV_Max(chainA, chainB);
			Out.ar(out,  0.1 * IFFT(chain).dup);
		}).play(s, [\soundBufnum1, b.bufnum, \soundBufnum2, exBuf.bufnum]);
	})
},{
	"cancelled".postln;
});
)

b.free;

::

** class:: PV_Min
summary:: Minimum magnitude.
related:: Classes/FFT, Classes/IFFT, Classes/PV_Add, Classes/PV_CopyPhase, Classes/PV_MagMul, Classes/PV_Max, Classes/PV_Mul
categories:: UGens>FFT

Description::

Output copies bins with the minimum magnitude of the two inputs.


classmethods::

method::new

argument::bufferA
FFT buffer A.

argument::bufferB
FFT buffer B.

Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
var exBuf;
Dialog.getPaths({ arg paths; //get a second soundfile;
	paths.do({ arg p; exBuf = Buffer.read(s, p);
		SynthDef("help-min", { arg out=0, soundBufnum1=2, soundBufnum2 = 3;
			var inA, chainA, inB, chainB, chain ;
			inA = PlayBuf.ar(1, soundBufnum1, BufRateScale.kr(soundBufnum1), loop: 1);
			inB =  PlayBuf.ar(1, soundBufnum2, BufRateScale.kr(soundBufnum2), loop: 1);
			chainA = FFT(LocalBuf(2048), inA);
			chainB = FFT(LocalBuf(2048), inB);
			chain = PV_Min(chainA, chainB);
			Out.ar(out,  0.1 * IFFT(chain).dup);
		}).play(s,[\soundBufnum1, b.bufnum, \soundBufnum2, exBuf.bufnum]);
	})
},{
	"cancelled".postln;
});
)

b.free

::

** class:: PV_Mul
summary:: Complex multiply.
related:: Classes/FFT, Classes/IFFT, Classes/PV_Add, Classes/PV_CopyPhase, Classes/PV_MagMul, Classes/PV_Max, Classes/PV_Min
categories:: UGens>FFT

Description::

Complex Multiplication:

code::

(RealA * RealB) - (ImagA * ImagB),
(ImagA * RealB) + (RealA * ImagB)

::


classmethods::

method::new

argument::bufferA
FFT buffer A.

argument::bufferB
FFT buffer B.

Examples::

code::

s.boot;

(
SynthDef("help-mul", { arg out=0;
	var inA, chainA, inB, chainB, chain ;
	inA = SinOsc.ar(500, 0, 0.5);
	inB =  SinOsc.ar(Line.kr(100, 400, 5), 0, 0.5);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_Mul(chainA, chainB);
	Out.ar(out,  0.1 * IFFT(chain).dup);
}).play(s);
s.scope;
)

(
SynthDef("help-mul2", { arg out=0;
	var inA, chainA, inB, chainB, chain ;
	inA = SinOsc.ar(500, 0, 0.5) * Line.kr;
	inB = LFNoise1.ar(20);
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_Mul(chainA, chainB);
	Out.ar(out,  0.1 * IFFT(chain).dup);
}).play(s);
s.scope;
)

::

** class:: PV_PhaseShift
summary:: Shift phase.
related:: Classes/FFT, Classes/IFFT, Classes/PV_PhaseShift90, Classes/PV_PhaseShift270, Classes/PV_Diffuser
categories:: UGens>FFT

Description::

Shift phase of all bins.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::shift

Phase shift in radians.

argument::integrate

If greater than zero, integrate the phase-shift across calls (for an accumulating phase shift).

Examples::

code::

s.boot;

(
SynthDef("help-phaseShift", { arg out=0;
        var in, chain;
        in = SinOsc.ar(500);
        chain = FFT(LocalBuf(2048), in);
        chain = PV_PhaseShift(chain, LFNoise2.kr(1, 180, 180));
        Out.ar(out, 0.1 * IFFT(chain).dup);
}).play(s);
)
::

** class:: PV_PhaseShift270
summary:: Shift phase by 270 degrees.
related:: Classes/FFT, Classes/IFFT, Classes/PV_PhaseShift, Classes/PV_PhaseShift90, Classes/PV_Diffuser
categories:: UGens>FFT

Description::

Shift phase of all bins by 270 degrees.


classmethods::

method::new

argument::buffer

FFT buffer.


Examples::

code::

s.boot;

(
{  arg out=0;
	var in, fft, fft2, shifted;
	in = SinOsc.ar(500, 0, 0.1);
	fft = FFT(LocalBuf(2048), in);
	fft2 = FFT(LocalBuf(2048), in);
	shifted = PV_PhaseShift270(fft);
	Out.ar(0,  [IFFT(fft2), IFFT(shifted)]);
}.scope
)

::

** class:: PV_PhaseShift90
summary:: Shift phase by 90 degrees.
related:: Classes/FFT, Classes/IFFT, Classes/PV_PhaseShift, Classes/PV_PhaseShift270, Classes/PV_Diffuser
categories:: UGens>FFT

Description::

Shift phase of all bins by 90 degrees.


classmethods::

method::new

argument::buffer

FFT buffer.


Examples::

code::

s.boot;

(
{ arg out=0, bufnum=0;
	var in, fft, fft2, shifted;
	in = SinOsc.ar(500, 0, 0.1);
	fft = FFT(LocalBuf(2048), in);
	fft2 = FFT(LocalBuf(2048), in);
	shifted = PV_PhaseShift90(fft);
	Out.ar(0, [IFFT(fft2), IFFT(shifted)]);
}.scope
)

::

** class:: PV_RandComb
summary:: Pass random bins.
related:: Classes/PV_RandWipe
categories:: UGens>FFT

Description::

Randomly clear bins.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::wipe

Clears bins from input in a random order as wipe goes from 0 to
1.


argument::trig

A trigger, that selects a new random ordering.


Examples::

code::

s.boot;

(
b = Buffer.alloc(s,2048,1);
c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
)

(
SynthDef("help-randcomb", { arg out=0, bufnum=0;
	var in, chain;
	in = {WhiteNoise.ar(0.8)}.dup;
	chain = FFT(bufnum, in);
	chain = PV_RandComb(chain, 0.95, Impulse.kr(0.4));
	Out.ar(out, IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
//trig with MouseY
SynthDef("help-randcomb2", { arg out=0, bufnum=0, soundBufnum=2;
	var in, chain;
	in = PlayBuf.ar(1, soundBufnum, BufRateScale.kr(soundBufnum), loop: 1);
	chain = FFT(bufnum, in);
	chain = PV_RandComb(chain, MouseY.kr, Impulse.kr(0.4));
	Out.ar(out, IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum, \soundBufnum, c.bufnum]);
)

::

** class:: PV_RandWipe
summary:: Crossfade in random bin order.
related:: Classes/PV_RandComb
categories:: UGens>FFT

Description::

Crossfades between two sounds by copying bins in a random order.


classmethods::

method::new

argument::bufferA

FFT buffer A.


argument::bufferB

FFT buffer B.


argument::wipe

Copies bins from bufferB in a random order as wipe goes from 0
to 1.


argument::trig

A trigger, that selects a new random ordering.


Examples::

code::

s.boot;

(
//trig with MouseY
SynthDef("help-randWipe", { arg out=0;
	var inA, chainA, inB, chainB, chain;
	inA = Mix.arFill(6, { LFSaw.ar(exprand(400, 1000), 0, 0.1) });
	inB = Mix.arFill(6, { LFPulse.ar(exprand(80, 400), 0, 0.2, SinOsc.kr(8.0.rand, 0, 0.2).max(0)) });
	chainA = FFT(LocalBuf(2048), inA);
	chainB = FFT(LocalBuf(2048), inB);
	chain = PV_RandWipe(chainA, chainB, MouseX.kr.poll, MouseY.kr.poll > 0.5);
	Out.ar(out, 0.5 * IFFT(chain).dup);
}).play(s);
)

::

** class:: PV_RectComb
summary:: Make gaps in spectrum.
related:: Classes/FFT, Classes/IFFT, Classes/PV_RectComb2
categories:: UGens>FFT

Description::

Makes a series of gaps in a spectrum.


classmethods::

method::new

argument::buffer

FFT buffer.


argument::numTeeth

Number of teeth in the comb.


argument::phase

Starting phase of comb pulse.


argument::width

Pulse width of the comb.


Examples::

code::

s.boot;

b = Buffer.alloc(s,2048,1);

(
SynthDef("help-rectcomb", { arg out=0, bufnum=0;
	var in, chain;
	in = {WhiteNoise.ar(0.2)}.dup;
	chain = FFT(bufnum, in);
	chain = PV_RectComb(chain, 8, LFTri.kr(0.097, 0, 0.4, 0.5),
		LFTri.kr(0.24, 0, -0.5, 0.5));
	Out.ar(out, IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

(
SynthDef("help-rectcomb2", { arg out=0, bufnum=0;
	var in, chain;
	in = {WhiteNoise.ar(0.2)}.dup;
	chain = FFT(bufnum, in);
	chain = PV_RectComb(chain,  MouseX.kr(0, 32), MouseY.kr, 0.2);
	Out.ar(out, IFFT(chain).dup);
}).play(s,[\out, 0, \bufnum, b.bufnum]);
)

::

** class:: PV_RectComb2
summary:: Make gaps in spectrum.
related:: Classes/FFT, Classes/IFFT, Classes/PV_RectComb
categories:: UGens>FFT

Description::

Alternates blocks of bins between the two inputs.


classmethods::

method::new

argument::bufferA

FFT buffer A.


argument::bufferB

FFT buffer B.


argument::numTeeth

Number of teeth in the comb.


argument::phase

Starting phase of comb pulse.


argument::width

Pulse width of the comb.


Examples::

code::

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
var exBuf;
Dialog.getPaths({ arg paths; //get a second soundfile;
	paths.do({ arg p; exBuf = Buffer.read(s, p);

		SynthDef("help-max", { arg out=0, soundBufnum1=2, soundBufnum2 = 3;
			var inA, chainA, inB, chainB, chain ;
			inA = PlayBuf.ar(1, soundBufnum1, BufRateScale.kr(soundBufnum1), loop: 1);
			inB =  PlayBuf.ar(1, soundBufnum2, BufRateScale.kr(soundBufnum2), loop: 1);
			chainA = FFT(LocalBuf(2048), inA);
			chainB = FFT(LocalBuf(2048), inB);
			chain = PV_RectComb2(chainA, chainB,  MouseX.kr(0, 32), MouseY.kr, 0.3);
			Out.ar(out,  0.5 * IFFT(chain).dup);
		}).play(s, [\soundBufnum1, b, \soundBufnum2, exBuf]);
	})
},{
	"cancelled".postln;
});
)

::

** class:: PackFFT
summary:: Pack separate demand-rate FFT bin streams into an FFT chain buffer
categories:: UGens>FFT
related:: Classes/UnpackFFT

description::
Takes an array of magnitudes and phases, and packs them into an FFT buffer ready for transforming back into time-domain audio using IFFT.

Most people won't need to use this directly - instead, use pvcollect, pvcalc, or pvcalc2 methods from the link::Classes/PV_ChainUGen:: base class.

classmethods::
private:: categories

method:: new

argument:: chain
The link::Classes/FFT:: chain

argument:: bufsize
FFT buffer size

argument:: magsphases
The input data should be a flat array containing magnitude and phase of all bins in ascending order.
e.g. code:: [mag0, phase0, mag1, phase1, mag2, phase2, ... magN, phaseN] ::
This input is typically demand-rate.

argument:: frombin
restricts the frequency band

argument:: tobin
restricts the frequency band

argument:: zeroothers
set to 1 to zero all the magnitudes outside the restricted frequency band

discussion::
This is technically similar to Demand or Duty in that it calls demand-rate UGens further up the graph to process the values, eventually calling UnpackFFT. These two ends of the process must in most cases see the same chain...! Otherwise behaviour is undefined and, who knows, possibly unpleasant.

Optional parameters: frombin and tobin allow you to fill the supplied data only into a subset of the FFT bins (i.e. a single delimited frequency band), and if you do this, you can also optionally set zeroothers to 1 to zero all the magnitudes outside this band (otherwise they stay intact).

examples::
Here's an unusual example which uses PackFFT without using UnpackFFT first - essentially creating our FFT data from scratch.
code::
// Reminder: This isn't the intended typical usage! It's OK to do this though.
(
x = {
	var mags, phases, chain, sig;
	// Create simple undulating magnitudes
	mags = {FSinOsc.kr(ExpRand(0.1, 1)).range(0, 1)}.dup(100);
	// Then give them a "rolloff" to make the sound less unpleasant
	mags = mags  * ((1, 0.99 .. 0.01).squared);
	// Let's turn the bins on and off at different rates, I'm *sure* that'll sound interesting
	mags = mags * {LFPulse.kr(2 ** IRand(-3, 5)).range(0, 1)}.dup(100);
	// Let's ignore phase for now
	phases = 0.dup(100);
	// We need to create an FFT chain to feed our data in to.
	// The easiest way is to do an FFT on some signal which we then ignore!
	chain = FFT(LocalBuf(512), FSinOsc.ar);
	// Now we can do the packing
	chain = PackFFT(chain, 512, [mags, phases].flop.flatten, 0, 99, 1);
	sig = IFFT(chain);
	Out.ar(0, sig.dup);
}.play(s);
)
x.free;
::

** class:: Padd
summary:: add to value of a key in event stream
related:: Classes/Paddp, Classes/Pmul
categories:: Streams-Patterns-Events>Patterns>Math

ClassMethods::

method::new

argument::value
can be a pattern or a stream. The resulting stream ends when that incoming stream ends.

Examples::

code::
(
var a, b;
a = Padd(\freq, 801, Pbind(\freq, 100));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
(
var a, b;
a = Padd(\freq, Pseq([401, 801], 2), Pbind(\freq, 100));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
//sound example
(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, gate=1;
		var env;
		env = EnvGen.kr(Env.asr(0.001, 1, 0.2), gate, doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain, \freq, 440);
b = Padd(\freq, Pseq([10, 30, 100], inf), a);
b.play;
)
::
** class:: Paddp
summary:: add each value of a pattern to value of a key in event stream
related:: Classes/Padd, Classes/Pmulp
categories:: Streams-Patterns-Events>Patterns>Math

description::

Adds a value in an event stream until it ends, repeats this with new values until the value stream ends.

ClassMethods::

method::new

argument::value
can be a pattern, a stream or an array. The resulting stream ends when that incoming stream ends.

Examples::

code::
(
var a, b;
a = Paddp(\freq, Pseq([2, 3, pi],inf), Pbind(\freq, Pseq([100, 200, 300])));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
//sound example
(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\freq, Pseq([500, 600, 700]), \instrument, \sinegrain);
a = Paddp(\freq, Pseq([30, 90, -100], inf), a);
a.play;
)
::
** class:: Paddpre
summary:: event pattern that adds to existing value of one key
related:: Classes/Padd, Classes/Paddp
categories:: Streams-Patterns-Events>Patterns>Math

description::

Adds a value in an event, strong::before it is passed up:: the stream. To add to the value after it has been passed to the stream, use link::Classes/Padd::.

code::
(
var a, b;
a = Paddpre(\x, 8, Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next((\x:4)).postln; });
)
::

Paddpre does not override incoming values:
code::
(
var a, b;
a = Paddpre(\freq, 302, Pset(\freq, 500, Pbind(\dur, 0.3)));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)
::

ClassMethods::

method::new

argument::value
can be a pattern or a stream. The resulting stream ends when that incoming stream ends.

Examples::

code::
(
var a, b;
a = Paddpre(\legato, Pseq([0.2, 0.4], 2), Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)
::

code::
//sound example
(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain);
b = Paddpre(\freq, Pseq([10, 30, 100], inf), a);
b.play;
)
::
** CLASS:: PageLayout
summary:: a Window with a FlowView on it for use in ObjectGui's MVC model
categories:: GUI
related:: Classes/ObjectGui, Classes/FlowView, Classes/Window, Classes/NotificationCenter

DESCRIPTION::
This class encapsulates the common task of creating a Window, adding a FlowView (CompositeView with a FlowLayout on it).  It also supports the MVC model by registering controllers that are then removed (sent the .remove message) when the Window closes.  Additionally it can resize itself to fit the contents.


CLASSMETHODS::

METHOD:: new
Create a Window with a FlowView on it.  The PageLayout object can be treated like a Window or like a View.

argument:: title
Window title

argument:: bounds
Bounds or nil.  Default of nil will size the window to the entire screen size.  Use .resizeToFit to shrink the window to the content size.

argument:: margin
FlowLayout margin.

argument:: background
Background color

argument:: scroll
boolean: add scroll bars or not.

argument:: front
boolean: whether to immediately display the window, bringing it to the front.  default is true.  You may choose to first add your views to the window and then front it which is useful for large slow GUIs

returns:: a PageLayout


INSTANCEMETHODS::

METHOD:: window
the Window object

returns:: a Window

METHOD:: view
the top most view on the Window

returns:: a View

METHOD:: isClosed
boolean: has the window been closed ?

returns:: boolean

METHOD:: onClose
Just as for Window, this method is called when the PageLayout's window is closed.  The actual Window's onClose method is used to trigger clean up operations, releasing dependencies and will also call this onClose function.

returns:: get/set onClose handler

METHOD:: asView
returns the top view

returns:: a View

METHOD:: asFlowView

argument:: bounds
if bounds are nil then it returns self, as a PageLayout is compatible with FlowView.  If bounds are supplied then a child FlowView is placed and returned

returns:: self or a new FlowView

METHOD:: bounds
inner bounds of the top level view.

returns:: a Rect

METHOD:: asPageLayout
Similar to asFlowView, this message converts nil and various other objects to a PageLayout. This is already a PageLayout, so it returns self.

argument:: name
Ignored. If the receiver had been nil then the name would be the Window name. 

argument:: bounds
Ignored. Would have been used to size the PageLayout

returns:: self

METHOD:: startRow
compatible with FlowView

returns:: self

METHOD:: indentedRemaining
compatible with FlowView

returns:: self

METHOD:: checkNotClosed
isClosed.not

returns:: boolean

METHOD:: front
bring Window to the front

returns:: self

METHOD:: hide
Hide window

returns:: self

METHOD:: show
Show the window if it was previously hidden.

returns:: self

METHOD:: close
Close the window, releasing any dependencies and calling the onClose handler.

returns:: self

METHOD:: refresh
Refresh the top level view

returns:: self

METHOD:: background
set background color of top level view

argument:: c
color

returns:: self

METHOD:: removeOnClose
Register an object, usually a ObjectGui subclass or an Updater so that when the Window closes the .remove message will be sent to it. This will cause the object to release its dependencies on its Model.  This means the ObjectGui (or other controller object) will stop getting update messages and will stop trying to update the View which has just been closed along with the Window.  It also means that if there is no link to the Model and no longer any Views that held links to the controller object, that the controller is now unreferenced and will be garbage collected.

argument:: dependant
the object that wishes to be sent .remove on closing the window

returns:: self

METHOD:: resizeToFit
Resize the top FlowView to fit its contents and then resize the Window to fit that.=

argument:: reflow
boolean: FlowView can relay all of its child views in cases where the bounds have changed or views have been removed.  This puts them all back in place one by one for the updated bounds.  So this may result in smaller over all bounds, after which the window is shrunk.

argument:: center
boolean: after resizing, re-center the window in the screen.

returns:: self

METHOD:: reflowAll
see FlowView reflowAll

returns:: self

METHOD:: fullScreen
go Full screen

returns:: self

METHOD:: endFullScreen
end full screen

returns:: self

subsection::FlowView extensions

METHOD:: flow
Place a new FlowView on the window

argument:: func
A handler that recieves the new FlowView as argument

argument:: bounds
Bounds fo the FlowView

returns:: (returnvalue)

METHOD:: vert
(describe method here)

argument:: func
(describe argument here)

argument:: bounds
(describe argument here)

argument:: spacing
(describe argument here)

returns:: (returnvalue)

METHOD:: horz
(describe method here)

argument:: func
(describe argument here)

argument:: bounds
(describe argument here)

argument:: spacing
(describe argument here)

returns:: (returnvalue)

METHOD:: comp
(describe method here)

argument:: func
(describe argument here)

argument:: bounds
(describe argument here)

returns:: (returnvalue)

METHOD:: scroll
(describe method here)

argument::  ... args
(describe argument here)

returns:: (returnvalue)


EXAMPLES::

code::
PageLayout.new
::
** CLASS::Pair
summary::LISP-like two element cells
categories:: Collections>Ordered

DESCRIPTION::

note::
Implementation incomplete. See link::Guides/J-concepts-in-SC:: for similar functionality.
::

Most methods are inherited from the superclasses.

CLASSMETHODS::

method::new
Return new instance.

method::newFrom
Convert collection (e.g. arrays of arrays) to pairs.

INSTANCEMETHODS::

private::storeOn, printOn, storeArgs

method::size
Return the size when linking across.

method::depth
Return the size when linking down.

method::do
Iterate over the two elements.

Traverse
Same like: link::#-depthFirstPreOrderTraversal::

method::depthFirstPreOrderTraversal
Traverse the data structure first link down, then across (see link::#Examples::).

method::depthFirstPostOrderTraversal
Traverse the data structure from bottom up (see link::#Examples::).

EXAMPLES::

code::
a = Pair(Pair(Pair(1, 2), 4), Pair(5, 6));

a.size;
a.depth;
a.do { |x| x.postln };
a.traverse { |x| x.postln };
a.depthFirstPreOrderTraversal { |x| x.postln };
a.depthFirstPostOrderTraversal { |x| x.postln };


// alternative instantiations:

Pair.newFrom([1, [2, [[4, 5], 6]]]);

[1, [2, [[4, 5], 6]]].as(Pair); // equivalent.
::
** class:: Pan2
summary:: Two channel equal power pan.
related:: Classes/Balance2, Classes/LinPan2, Classes/Pan4, Classes/PanAz
categories::  UGens>Multichannel>Panners


Description::

Two channel equal power panner.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::pos

Pan position, -1 is left, +1 is right.


argument::level

A control rate level input.


Examples::

code::

SynthDef("help-Pan2", { Out.ar(0, Pan2.ar(PinkNoise.ar(0.4), FSinOsc.kr(2), 0.3)) }).play;

::

** class:: Pan4
summary:: Four channel equal power pan.
related:: Classes/Balance2, Classes/LinPan2, Classes/Pan2, Classes/PanAz
categories::  UGens>Multichannel>Panners


Description::

Four channel equal power panner. Outputs are in order LeftFront,
RightFront, LeftBack, RightBack.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::xpos

X  pan position from -1 to +1 (left to right).


argument::ypos

Y pan position from -1 to +1 (back to front).


argument::level

A control rate level input.


Examples::

code::

// You'll only hear the front two channels on a stereo setup.
(
SynthDef("help-Pan4", {
	Out.ar(0, Pan4.ar(PinkNoise.ar, FSinOsc.kr(2), FSinOsc.kr(1.2), 0.3))
}).play;
)

play({ Pan4.ar(PinkNoise.ar, -1,  0, 0.3) }); // left pair
play({ Pan4.ar(PinkNoise.ar,  1,  0, 0.3) }); // right pair
play({ Pan4.ar(PinkNoise.ar,  0, -1, 0.3) }); // back pair
play({ Pan4.ar(PinkNoise.ar,  0,  1, 0.3) }); // front pair

play({ Pan4.ar(PinkNoise.ar,  0,  0, 0.3) }); // center

::

** class:: PanAz
summary:: Azimuth panner
related:: Classes/Balance2, Classes/LinPan2, Classes/Pan2, Classes/Pan4
categories::  UGens>Multichannel>Panners


Description::

Multichannel equal power panner.


classmethods::

method::ar, kr

argument::numChans

Number of output channels.


argument::in

The input signal.


argument::pos

pan position. Channels are evenly spaced over a cyclic period of
2.0 in pos with 0.0 equal to channel zero and 2.0/numChans equal
to channel 1, 4.0/numChans equal to channel 2, etc.


Thus all channels will be cyclically panned through if a sawtooth
wave from -1 to +1 is used to modulate the pos.


argument::level

A control rate level input.


argument::width

The width of the panning envelope. Nominally this is 2.0 which
pans between pairs of adjacent speakers. Width values greater
than two will spread the pan over greater numbers of speakers.
Width values less than one will leave silent gaps between
speakers.


argument::orientation

Should be zero if the front is a vertex of the polygon. The first
speaker will be directly in front. Should be 0.5 if the front
bisects a side of the polygon. Then the first speaker will be the
one left of center.


Examples::

code::

// five channel circular panning
s.boot;
(
{
	PanAz.ar(
		5, 				// numChans
		ClipNoise.ar, 	// in
		LFSaw.kr(MouseX.kr(0.2, 8, 'exponential')), // pos
		0.5,			// level
		3			// width
	);
}.play;
s.scope;
)

::

** class:: PanB
summary:: Ambisonic B-format panner.
related:: Classes/BiPanB2, Classes/DecodeB2, Classes/PanB2, Classes/Rotate2
categories::  UGens>Multichannel>Ambisonics


Description::

Ambisonic B format panner. Output channels are in order W, X, Y, Z.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::azimuth

Azimuth in radians, -π to +π.


argument::elevation

Elevation in radians, -0.5π to +0.5π.


argument::gain

A control rate level input.


Examples::

code::

// You'll only hear the first two channels on a stereo setup.
play({
	#w, x, y, z = PanB.ar(WhiteNoise.ar, LFSaw.kr(0.5,pi), FSinOsc.kr(0.31, 0.5pi), 0.3);
	//decode for 4 channels
	DecodeB2.ar(4, w, x, y, 0.5);
});

::

** class:: PanB2
summary:: 2D Ambisonic B-format panner.
related:: Classes/BiPanB2, Classes/DecodeB2, Classes/PanB, Classes/Rotate2
categories::  UGens>Multichannel>Ambisonics


Description::

Encodes a mono signal to 2-dimensional ambisonic B-format.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::azimuth

Position around the circle from -1 to +1. -1 is behind, -0.5 is
left, 0 is forward, +0.5 is right, +1 is behind.


argument::gain

Amplitude control.


Examples::

code::

(
{
	var w, x, y, p, a, b, c, d;

	p = PinkNoise.ar; // source

	// B-format encode
	#w, x, y = PanB2.ar(p, MouseX.kr(-1,1), 0.1);

	// B-format decode to quad
	#a, b, c, d = DecodeB2.ar(4, w, x, y);

	[a, b, d, c] // reorder to my speaker arrangement: Lf Rf Lr Rr
}.play;
)

::

** class:: ParGroup
summary:: Client-side representation of a parallel group node on the server
categories:: Server>Nodes, Server>Abstractions

Description:: Parallel Groups are server-side node containers that work similar to link::Classes/Group::s, but without
ordering constraints for the contained nodes. This means that on parallel architectures the elements of a Parallel Group
can be executed concurrently.

ClassMethods::
private:: creationCmd

subsection:: Creation with Immediate Instantiation on the Server

copymethod:: Group *new

subsection:: Convenience methods for add actions
The following convenience methods correspond to the add actions above:

copymethod:: Group *after
copymethod:: Group *before
copymethod:: Group *head
copymethod:: Group *tail
copymethod:: Group *replace

subsection:: Creation without Instantiation on the Server

Like with Groups, it is possible to create a a ParGroup object without immediately creating a parallel group in the server.

method:: basicNew
Create and return a ParGroup object without creating a group node on the server. (This method is inherited from Node and is documented here only for convenience.)
argument:: server
An optional instance of Server. If nil this will default to the default Server.
argument:: nodeID
An optional node ID number. If not supplied one will be generated by the Server's NodeIDAllocator. Normally you should not need to supply an ID.

discussion::
For a detailed discussion please refer to link::Classes/Group#*basicNew::.

Examples::

code::
fork {
	p = ParGroup.new;
	loop {
		(
			degree: rrand(0.0, 12.0).round(1/4),
			group: p,
			db: rrand(-30, -25),
			pan: rrand(-1.0, 1.0)
		).play;
		0.2.wait;
	}
}
::
** class:: PartConv
summary:: Real-time partitioned convolution
categories:: UGens>FFT, UGens>Convolution
related:: Classes/Convolution, Classes/Convolution2, Classes/Convolution2L, Classes/Convolution3

description::
Partitioned convolution. Various additional buffers must be supplied.

Mono impulse response only! If inputting multiple channels, you'll need independent PartConvs, one for each channel.

But the charm is: impulse response can be as large as you like (CPU load increases with IR size. Various tradeoffs based on fftsize choice, due to rarer but larger FFTs. This plug-in uses amortisation to spread processing and avoid spikes).

Normalisation factors difficult to anticipate; convolution piles up multiple copies of the input on top of itself, so can easily overload.

classmethods::
method:: ar

argument:: in
processing target.
argument:: fftsize
spectral convolution partition size (twice partition size). You must ensure that the blocksize divides the partition size and there are at least two blocks per partition (to allow for amortisation).
argument:: irbufnum
prepared buffer of spectra for each partition of the inpulse response.
argument:: mul
argument:: add

examples::
code::
// preparation; essentially, allocate an impulse response buffer, then follow a special buffer preparation step to set up the data the plugin needs. Different options are provided commented out for loading impulse responses from soundfiles.
(
~fftsize=2048; // also 4096 works on my machine; 1024 too often and amortisation too pushed, 8192 more high load FFT

s.waitForBoot {

{
var ir, irbuffer, bufsize;

	// // MONO ONLY
	// pre-existing impulse response sound files
	// (could also use any general soundfile too for cross-synthesis effects)
	// irbuffer= Buffer.read(s, "/Volumes/data/audio/ir/ir2.wav");
	// irbuffer= Buffer.read(s, "/Volumes/data/audio/ir/ir.wav");
	// this is a two second long hall IR
	// irbuffer= Buffer.read(s, "/Volumes/data/audio/ir/bighall2.wav");


	// synthesise the honourable 'Dan Stowell' impulse response

	ir = ([1] ++0.dup(100) ++ ((1, 0.99998 .. 0).collect{|f| f =
	f.squared.squared; f = if(f.coin){0}{f.squared}; f =
	if(0.5.coin){0-f}{f} } * 0.1)).normalizeSum;
	// ir.plot;

	irbuffer = Buffer.loadCollection(s, ir);

	s.sync;

	bufsize= PartConv.calcBufSize(~fftsize, irbuffer);

	// ~numpartitions= PartConv.calcNumPartitions(~fftsize, irbuffer);

	~irspectrum= Buffer.alloc(s, bufsize, 1);

	~irspectrum.preparePartConv(irbuffer, ~fftsize);

	s.sync;

	irbuffer.free; // don't need time domain data anymore, just needed spectral version
}.fork;

};

)



~target= Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
// ~target= Buffer.read(s, "sounds/break");

(

{ var input, kernel;

input= PlayBuf.ar(1, ~target, loop:1);

Out.ar(0, PartConv.ar(input, ~fftsize, ~irspectrum.bufnum, 0.5));
 }.play;

)


// convolve with live input
(

{ var input, kernel;

input= SoundIn.ar(0);

Out.ar(0, PartConv.ar(input, ~fftsize, ~irspectrum.bufnum));
}.play;
)


// should get back original impulse response (once every four seconds)
(

{ var input, kernel;

input= Impulse.ar(0.25);

Out.ar(0, PartConv.ar(input, ~fftsize, ~irspectrum.bufnum));
 }.play;

)


// only free buffers once you're finished with examples
// if you free whilst PartConv is still running, the server won't crash, but PartConv output will go to zero abruptly
(
~irspectrum.free;
~target.free;
currentEnvironment.clear;
)
::
** class:: PathName
summary:: file and directory path utilities
related:: Classes/File, Classes/String
categories:: Files

description::
PathName is a utility class for manipulating file names and paths. It expects a path to a file, and lets you access parts of that file path.

ClassMethods::

private::initClass

method::new

argument::path
a link::Classes/String:: which likely contains one or more / as typical for folder separation. ~ will be converted to your fully addressed home directory, as per link::Classes/String#-standardizePath::.
code::
PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
::

method::tmp
Get or set the global temp directory as a link::Classes/String::. This is used by link::Classes/Buffer::, etc. By default this is "/tmp/" for Linux and OSX, and "/WINDOWS/TEMP/" for Windows.

InstanceMethods::

method::fileName
returns just the name of the file itself; i.e. everything after the last slash in the full path.
code::
(
var myPath;
myPath = PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.fileName.postln;
)
::

method:: fileNameWithoutExtension
returns the name of the file itself without the file extension.

method::extension
returns the file extension, i.e. everything after the last full-stop in the link::#-fileName::.

method::pathOnly
returns the full path up to the file name itself; i.e. everything up to and including the last slash. This is handy e.g. for storing several files in the same folder.

code::
(
var myPath;
myPath = PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.pathOnly.postln;
)
::

method::isAbsolutePath, asAbsolutePath, isRelativePath, asRelativePath
you MUST have correctly initialized the scroot classvar for this to know what it is relative to !

method::folderName
returns only the name of the folder that the file is in; i.e. everything in between the last but one and the last slash.
code::
(
var myPath;
myPath = PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.folderName.postln;
)
::

method::fullPath
returns the full path name that PathName contains.
code::
(
var myPath;
myPath = PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.fullPath.postln;
)
::

method::entries
returns a list of all the files+folders inside the folder represented by this path.
code::
(
var myPath;
myPath = PathName.new("./");
myPath.entries.postln;
)
::

method::files
returns a list of all the files in the folder represented by this path.
code::
(
var myPath;
myPath = PathName.new("./");
myPath.files.postln;
)
::

method::folders
returns a list of all the subfolders of the folder represented by this path.
code::
(
var myPath;
myPath = PathName.new("./");
myPath.folders.postln;
)
::

method::isFile
returns a link::Classes/Boolean:: indicating whether or not the path represents a file (not a folder).
code::
(
var myPath;
myPath = PathName.new("./");
myPath.isFile.postln;
)
::

method::isFolder
returns a link::Classes/Boolean:: indicating whether or not the path represents a folder (not a file).
code::
(
var myPath;
myPath = PathName.new("./");
myPath.isFolder.postln;
)
::

method::filesDo
Iterates over all files found in the pathname, including ones in subfolders.
code::
(
var myPath;
myPath = PathName.new("./");
myPath.filesDo{|afile| afile.postln};
)
::

method::allFolders
returns a list of all the folder names contained in the pathname itself.
code::
(
var myPath;
myPath = PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.allFolders.postln;
)
::

method::diskName
if path is an absolute path, returns the disk name; else a blank string.
code::
(
var myPath;
myPath = PathName.new("MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.diskName.postln;
)

( // note the / at the start
var myPath;
myPath = PathName.new("/MyDisk/SC 2.2.8 f/Sounds/FunkyChicken");
myPath.diskName.postln;
)
::

method::+/+
Path concatenation operator - useful for avoiding doubling-up slashes unnecessarily.
code::
(PathName("/somewhere") +/+ PathName("over/the/rainbow")).postln;
(PathName("/somewhere") +/+ PathName("/over/the/rainbow")).postln;
::

method::endNumber
returns a number at the end of PathName. Returns zero if there is no number.
code::
PathName("floating1").endNumber.postln;
PathName("floating").endNumber.postln;
::

method::noEndNumbers
returns link::#-fullPath:: without any numbers at the end.
code::
PathName("floating1").noEndNumbers.postln;
PathName("floating").noEndNumbers.postln;
::

method::nextName
generates a sensible next name for a file by incrementing a number at the end of PathName, or by adding one if there is none. This is useful for recording files with consecutive names, and e.g. to generate a new filename when you don't want to overwrite an existing file with the current name.
code::
PathName("floating34").nextName.postln;
PathName("floating").nextName.postln;
PathName("floating12_3A4X_56.7").nextName.postln;
::

Examples::

Here is an example that uses many instance methods. Just pick any file to see all the parts of its path.

code::
(
GetFileDialog.new(
	{ arg ok, path;
	var myPathName;
	if (ok,
		{
			myPathName = PathName.new(path);

			"New PathName object:  ".postc;
			myPathName.postln;

			"fileName only:        ".postc;
			myPathName.fileName.postln;

			"path up to file only: ".postc;
			myPathName.pathOnly.postln;

			"folder Name:          ".postc;
			myPathName.folderName.postln;
		}
	)
	}
)
)
::

Choose a soundfile to put into the library, using its foldername and filename.

code::
(
GetFileDialog.new(
	{ arg ok, path;
	var myPathName, myFile;
	if (ok,
		{
			myPathName = PathName.new(path);

			// read your file from disk, e.g. a soundFile/

			myFile = SoundFile.new;
			if (myFile.openRead(path),
				{
					Library.put(
						[ myPathName.folderName.asSymbol, myPathName.fileName.asSymbol ],
						myFile);
					("Check Library.global" + myPathName.folderName + "please.").postln;
				},
				{ ("Could not read soundfile" + path ++ ".").postln; }
			);
			myFile.close;
		}
	)
	}
)
)
::

Save three tables in the same folder. Note: The file name chosen in the dialog is ignored! The files are always named table1, table2, table3.

code::
(
var table1, table2, table3;

table1 = Wavetable.sineFill(1024, [1,2,3]);
table2 = Signal.newClear.asWavetable;
table3 = Wavetable.sineFill(1024, Array.rand(64, 0.0, 1.0));

GetFileDialog.new(
	{ arg ok, path;
	var myPathName, myPathOnly;
	if (ok,
		{
			myPathName = PathName.new(path);
			myPathOnly = myPathName.pathOnly;
			("writing files tables1-3 to"+myPathOnly).postln;
			table1.write(myPathOnly ++ "table1");
			table2.write(myPathOnly ++ "table2");
			table3.write(myPathOnly ++ "table3");
		}
	)
	}
)
)
::
** class:: Pattern
summary:: abstract class that holds a list
related:: Classes/Stream, Classes/FilterPattern, Classes/ListPattern
categories:: Streams-Patterns-Events>Patterns

description::

subsection::Patterns versus Streams

strong::Pattern:: is an abstract class that is the base for the Patterns library. These classes form a rich and concise score language for music. The series of help files entitled link::Tutorials/Streams-Patterns-Events1:: gives a detailed introduction. This attemps a briefer characterization.

A strong::Stream:: is an object that responds to code::next::, code::reset::, and code::embedInStream::. Streams represent sequences of values that are obtained one at a time by with message code::next::. A code::reset:: message will cause the stream to restart (many but not all streams actually repeat themselves.) If a stream runs out of values it returns code::nil:: in response to code::next::. The message code::embedInStream:: allows a stream definition to allow another stream to "take over control" of the stream.
All objects respond to code::next:: and code::reset::, most by returning themselves in response to next. Thus, the number 7 defines a Stream that produces an infinite sequence of 7's. Most objects respond to code::embedInStream:: with a singleton Stream that returns the object once.

A strong::Pattern:: is an object that responds to code::asStream:: and code::embedInStream::. A Pattern defines the behavior of a Stream and creates such streams in response to the messages code::asStream::.
The difference between a Pattern and a Stream is similar to the difference between a score and a performance of that score or a class and an instance of that class. All objects respond to this interface, most by returning themselves. So most objects are patterns that define streams that are an infinite sequence of the object and embed as singleton streams of that object returned once.

Patterns are defined in terms of other Patterns rather than in terms of specific values. This allows a Pattern of arbitrary complexity to be substituted for a single value anywhere within a Pattern definition. A comparison between a Stream definition and a Pattern will help illustrate the usefulness of Patterns.

subsection::example 1 - Pseq vs. Routine

The Pattern class strong::Pseq(array, repetitions):: defines a Pattern that will create a Stream that iterates an array. The class strong::Routine(func, stackSize):: defines a single Stream, the function that runs within that stream is defined to perform the array iteration.

Below a stream is created with link::Classes/Pseq:: and an code::asStream:: message and an identical stream is created directly using Routine.

code::
// a Routine vs a Pattern
(
	a = [-100, 00, 300, 400];			// the array to iterate

	p = Pseq(a);					// make the Pattern
	q = p.asStream;					// have the Pattern make a Stream
	r = Routine({ a.do({ arg v; v.yield}) }) ;	// make the Stream directly

	5.do({ Post << Char.tab << r.next << " " << q.next << Char.nl; });
)
::

subsection::example 2 - Nesting patterns

In example 1, there is little difference between using link::Classes/Pseq:: and link::Classes/Routine::. But Pseq actually iterates its array as a collection of emphasis::patterns to be embedded::, allowing another Pseq to replace any of the values in the array. The Routine, on the other hand, needs to be completely redefined.

code::
(
	var routinesA;
	a = [3, Pseq([-100, 00, 300, 400]), Pseq([-100, 00, 300, 400].reverse) ];
	routinesA = [[3], [-100, 00, 300, 400], [-100, 00, 300, 400].reverse];
	p = Pseq(a);
	q = p.asStream;

	r = Routine({
		routinesA.do({ arg v;
			v.do({ arg i; i.yield})
		}) ;
	});
	10.do({ Post << Char.tab << r.next << " " << q.next << Char.nl; });
)
::

subsection::example 3 - Stream-embedInStream

The message code::embedInStream:: is what allows Patterns to do this kind of nesting. Most objects
(such as the number 3 below) respond to code::embedInStream:: by yielding themselves once and returning. Streams respond to embedInStream by iterating themselves to completion, effectively "taking over" the calling stream for that time.

A Routine can perform a pattern simply by replacing calls to code::yield:: with calls to code::embedInStream::.
code::
(
	a = [3, Pseq([-100, 00, 300, 400]), Pseq([-100, 00, 300, 400].reverse) ];

	r = Routine({ a.do({ arg v; v.embedInStream}) }) ;
	p = Pseq(a);
	q = p.asStream;
	10.do({ Post << Char.tab << r.next << " " << q.next << Char.nl; });
)
::

Of course, there is no concise way to emphasis::define:: this stream without using Pseq.

note::
For reasons of efficiency, the implementation of code::embedInStream:: assumes that it is called from within a link::Classes/Routine::. Consequently, code::embedInStream:: should never be called from within the function that defines a link::Classes/FuncStream:: or a link::Classes/Pfunc:: (the pattern that creates FuncStreams).
::

subsection::Event Patterns

An link::Classes/Event:: is a link::Classes/Environment:: with a 'play' method. Typically, an Event consists of a collection of key/value pairs that determine what the play method actually does. The values may be any object including functions defined in terms of other named attributes. Changing those values can generate a succession of sounds sometimes called 'music'... The pattern link::Classes/Pbind:: connects specific patterns with specific names. Consult its help page for details.

subsection::Playing Event Patterns

The link::#-play:: method does not return the pattern itself. Instead, it returns the link::Classes/EventStreamPlayer:: object that actually runs the pattern. Control instructions -- stop, pause, resume, play, reset -- should be addressed to the EventStreamPlayer. (The same pattern can play many times simultaneously, using different EventStreamPlayers.)

code::
p = Pbind(...);
p.play;
p.stop;	// does not stop because p is not the EventStreamPlayer that is actually playing

p = Pbind(...).play;
p.stop;	// DOES stop because p is the EventStreamPlayer
::

subsection::Recording Event Patterns

Patterns may be recorded in realtime or non-realtime. See the method link::#-record:: for realtime recording.

For non-realtime recording see the link::Classes/Score:: helpfile, especially "creating Score from a pattern." It can be tricky, because NRT recording launches a new server instance. That server instance is not aware of buffers or other resources loaded into the realtime server you might have been using for tests. The pattern is responsible for (re)loading any resources (buffers, effects etc.). link::Classes/Pfset:: or link::Classes/Pproto:: may be useful.

InstanceMethods::

method::play

argument::clock
The tempo clock that will run the pattern. If omitted, TempoClock.default is used.

argument::protoEvent
The event prototype that will be fed into the pattern stream on each iteration. If omitted, event.default is used.

argument::quant
see the link::Classes/Quant:: helpfile.

method::record
Opens a disk file for recording and plays the pattern into it.

argument::path
Disk location for the recorded file. If not given, a filename is generated for you and placed in the default recording directory: code::thisProcess.platform.recordingsDir::.

argument::headerFormat
File format, default "AIFF" - see link::Classes/SoundFile:: for supported header and sample formats.

argument::sampleFormat
Sample format, default "float".

argument::numChannels
Number of channels to recorde, default 2.

argument::dur
How long to run the pattern before stopping. If nil (default), the pattern will run until it finishes on its own; then recording stops. Or, use cmd-period to stop the recording. If a number is given, the pattern will run for that many beats and then stop (using link::Classes/Pfindur::), ending the recording as well.

argument::fadeTime
How many beats to allow after the last event before stopping the recording. Default = 0.2.

argument::clock
Which clock to use for play. Uses TempoClock.default if not otherwise specified.

argument::protoEvent
Which event prototype to use for play. Falls back to Event.default if not otherwise specified.

argument::server
Which server to play and record. Server.default if not otherwise specified.

argument::out
Output bus to hear the pattern while recording, default = 0.

Examples::

Below are brief examples for most of the classes derived from Pattern. These examples all rely on the patterns assigned to the Interpreter variable p, q, and r in the first block of code.

code::
s.boot;

(
SynthDef(\cfstring1, { arg i_out, freq = 360, gate = 1, pan, amp=0.1;
	var out, eg, fc, osc, a, b, w;
	fc = LinExp.kr(LFNoise1.kr(Rand(0.25, 0.4)), -1, 1, 500, 2000);
	osc = Mix.fill(8, {LFSaw.ar(freq * [Rand(0.99, 1.01), Rand(0.99, 1.01)], 0, amp) }).distort * 0.2;
	eg = EnvGen.kr(Env.asr(1, 1, 1), gate, doneAction:2);
	out = eg * RLPF.ar(osc, fc, 0.1);
	#a, b = out;
	Out.ar(i_out, Mix.ar(PanAz.ar(4, [a, b], [pan, pan+0.3])));
}).add;

SynthDef("sinegrain2",
	{ arg out=0, freq=440, sustain=0.05, pan;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.3), doneAction:2);
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;

p = Pbind(
	[\degree, \dur], Pseq([[0, 0.1], [2, 0.1], [3, 0.1], [4, 0.1], [5, 0.8]], 1),
	\amp, 0.05, \octave, 6, \instrument, \cfstring1, \mtranspose, 0);

q = Pbindf(p, \instrument, \default );

r = Pset(\freq, Pseq([500, 600, 700], 2), q);

)
::

subsection::EVENT PATTERNS - patterns that generate or require event streams

code::
// Pbind( ArrayOfPatternPairs )

p = Pbind(
	[\degree, \dur], Pseq([[0, 0.1], [2, 0.1], [3, 0.1], [4, 0.1], [5, 0.8]], 1),
	\amp, 0.05, \octave, 6, \instrument, \cfstring1, \mtranspose, 0);

p.play;

//Ppar(arrayOfPatterns, repeats) - play in parallel

Ppar([Pseq([p], 4), Pseq([Pbindf(q, \ctranspose, -24)], 5)]).play

//Ptpar(arrayOfTimePatternPairs, repeats) - play in parallel at different times

Ptpar([1, Pseq([p], 4), 0, Pseq([Pbindf(q, \ctranspose, -24)], 5)]).play

// Pbindf( pattern, ArrayOfNamePatternPairs )

q = Pbindf(p, \instrument, \default );
q.play;

//Pfset(function, pattern)
// function constructs an event that is passed to the pattern.asStream

Pfset({ ~freq = Pseq([500, 600, 700], 2).asStream }, q).play;

//Pset(name, valPattern, pattern)
// set one field of the event on an event by event basis (Pmul, Padd are similar)

Pset(\freq, Pseq([500, 600, 700], 2), q).play;

//Psetp(name, valPattern, pattern)
// set once for each iteration of the pattern (Pmulp, Paddp are similar)

r = Pset(\freq, Pseq([500, 600, 700], 2), q);

Psetp(\legato, Pseq([0.01, 1.1], inf), r).play;

//Psetpre(name, valPattern, pattern)
// set before passing the event to the pattern (Pmulpre, Paddpre are similar)

r = Psetpre(\freq, Pseq([500, 600, 700], 2), q);

Psetp(\legato, Pseq([0.01, 1.1], inf), r).play;

//Pstretch(valPattern, pattern)
// stretches durations after

r = Psetpre(\freq, Pseq([500, 600, 700], 2), q);

Pstretch(Pn(Env([0.5, 2, 0.5], [10, 10])), Pn(r)).play;

Pset(\stretch, Pn(Env([0.5, 2, 0.5], [10, 10]) ), Pn(r)).play

//Pstretchp(valPattern, pattern)
// stretches durations after

r = Psetpre(\freq, Pseq([500, 600, 700], 2), q);

Pstretchp(Pn(Env([0.5, 2, 0.5], [10, 10])), r).play;

// Pfindur( duration, pattern ) - play pattern for duration

Pfindur(2, Pn(q, inf)).play;

// PfadeIn( pattern, fadeTime, holdTime, tolerance )
PfadeIn(Pn(q), 3, 0).play(quant: 0);

// PfadeOut( pattern, fadeTime, holdTime, tolerance )
PfadeOut(Pn(q), 3, 0).play(quant: 0);

// Psync( pattern, quantization, dur, tolerance )
// pattern is played for dur seconds (within tolerance), then a rest is played so the next pattern

Pn(Psync(
	Pbind(\dur, Pwhite(0.2, 0.5).round(0.2),
		\db, Pseq([-10, -15, -15, -15, -15, -15, -30])
	), 2, 3
)).play

//Plag(duration, pattern)

Ppar([Plag(1.2, Pn(p, 4)), Pn(Pbindf(q, \ctranspose, -24), 5)]).play
::

subsection::GENERAL PATTERNS that work with both event and value streams

code::
//Ptrace(pattern, key, printStream) - print the contents of a pattern

r = Psetpre(\freq, Pseq([500, 600, 700], 2), q);

Ptrace(r).play;
Ptrace(r, \freq).play;

(
{ var printStream;
	printStream = CollStream.new;
	Pseq([Ptrace(r, \freq, printStream), Pfunc({printStream.collection.dump; nil }) ]).play;
}.value;
)

//Pseed(seed, pattern) - set the seed of the random number generator
// to force repetion of pseudo-random patterns

Pn(Pseed(44, Pbindf(q, \ctranspose, Pbrown(-3.0, 3.0, 10) ) ) ).play;

//Proutine(function) - on exit, the function must return the last value returned by yield
// (otherwise, the pattern cannot be reliably manipulated by other patterns)

Proutine({ arg inval;
	inval = p.embedInStream(inval);
	inval = Event.silent(4).yield;
	inval = q.embedInStream(inval);
	inval = r.embedInStream(inval);
	inval;
}).play

//Pfunc(function) - the function should not have calls to embedInStream, use Proutine instead.

Pn(Pbindf(q, \legato, Pfunc({ arg inval; if (inval.at(\degree)== 5) {4} {0.2}; })) ).play



// the following patterns control the sequencing and repetition of other patterns

//Pseq(arrayOfPatterns, repeats) - play as a sequence

Pseq([Pseq([p], 4), Pseq([Pbindf(q, \ctranspose, -24)], 5)]).play

//Pser(arrayOfPatterns, num) - play num patterns from the arrayOfPatterns

Pser([p, q, r], 5).play

//Place(arrayOfPatterns, repeats) - similar to Pseq
// but array elements that are themselves arrays are iterated
// embedding the first element on the first repetition, second on the second, etc

Place([[p, q, r], q, r], 5).play

// Pn( pattern, patternRepetitions ) - repeat the pattern n times

Pn(p, 2).play;

// Pfin( eventcount, pattern ) - play n events from the pattern

Pfin(12, Pn(p, inf)).play;

// Pstutter( eventRepetitions, pattern ) - repeat each event from the pattern n times

Pstutter(4, q).play

//Pwhile(function, pattern)

Pwhile({coin(0.5).postln;}, q).play

// Pswitch( patternList, selectPattern ) - when a pattern ends, switch according to select

Pswitch([p, q, r], Pwhite(0, 100)).play

// Pswitch1( patternList, selectPattern ) - on each event switch according to select

Pn(Pswitch1([p, q, r], Pwhite(0, 2))).play

// Prand( patternList, repeats ) - random selection from list
Prand([p, q, r], inf).play

// Pxrand( patternList, repeats ) - random selection from list without repeats
Pxrand([p, q, r], inf).play

// Pwrand( patternList, weights, repeats ) - weighted random selection from list
Pwrand([p, q, r], #[1, 3, 5].normalizeSum, inf).play

// Pwalk( patternList, stepPattern, directionPattern ) - walk through a list of patterns

Pwalk([p, q, r], 1, Pseq([-1, 1], inf)).play

// Pslide(list, repeats, length, step, start)

Pbind(\degree, Pslide(#[1, 2, 3, 4, 5], inf, 3, 1, 0), \dur, 0.2).play

// Pshuf( patternList, repeats ) - random selection from list
Pn(Pshuf([p, q, r, r, p])).play

// Ptuple(list, repeats)

Pbind(\degree, Ptuple([Pwhite(1, -6), Pbrown(8, 15, 2)]),
	\dur, Pfunc({ arg ev; ev.at(\degree).last/80 round: 0.1}),
	\db, Pfunc({ if (coin(0.8)) {-25} {-20} })
).play



// the following patterns can alter the values returned by other patterns

//Pcollect(function, pattern)

Pcollect({ arg inval; inval.use({ ~freq = 1000.rand }); inval}, q).play

//Pselect(function, pattern)

Pselect({ arg inval; inval.at(\degree) != 0 }, q).play(quant: 0)

//Preject(function, pattern)

Preject({ arg inval; inval.at(\degree) != 0 }, q).play(quant: 0)

//Ppatmod(pattern, function, repeats) -
// function receives the current pattern as an argument and returns the next pattern to be played

Ppatmod(p, { arg oldPat; [p, q, r].choose }, inf).play
::

subsection::VALUE PATTERNS: these patterns define or act on streams of numbers

code::
// Env as a pattern

Pbindf(Pn(q, inf), \ctranspose, Pn(Env.linen(3, 0, 0.3, 20), inf) ).play;

// Pwhite(lo, hi, length)

Pbindf(Pn(q, inf), \ctranspose, Pwhite(-3.0, 3.0) ).play;

// Pbrown(lo, hi, step, length)

Pbindf(Pn(q, inf), \ctranspose, Pbrown(-3.0, 3.0, 2) ).play;

// Pseries(start, step, length)

Pbindf(Pn(q, inf), \ctranspose, Pseries(0, 0.1, 10) ).play;

// Pgeom(start, step, length)

Pbindf(Pn(q, inf), \ctranspose, Pgeom(1, 1.2, 20) ).play;

// Pwrap(pattern, lo, hi)

Pbind(\note, Pwrap(Pwhite(0, 128), 10, 20).round(2), \dur, 0.05).play;

// PdegreeToKey(pattern, scale, stepsPerOctave)
// this reimplements part of pitchEvent (see Event)

Pbindf(Pn(q, inf), \note, PdegreeToKey(Pbrown(-8, 8, 2), [0, 2, 4, 5, 7, 9, 11]) ).play;

// Prewrite(pattern, dict, levels) - see help page for details.
// (notice use of Env to define a chord progression of sorts...

Pbind(\degree,
	Prewrite(0, ( 0: #[2, 0],
			1: #[0, 0, 1],
			2: #[1, 0, 1]
		), 4
	) + Pn(Env([4, 0, 1, 4, 3, 4], [6.4, 6.4, 6.4, 6.4, 6.4], 'step')),
	\dur, 0.2).play

// PdurStutter( repetitionPattern, patternOfDurations ) -
Pbindf(Pn(q), \dur, PdurStutter(
	Pseq(#[1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 4, 5, 7, 15], inf),
	Pseq(#[0.5], inf)
	)
).play;


// Pstep2add( pat1, pat2 )
// Pstep3add( pat1, pat2, pat3 )
// PstepNadd(pat1, pat2, ...)
// PstepNfunc(function, patternArray )
// combine multiple patterns with depth first traversal

Pbind(
	\octave, 4,
	\degree, PstepNadd(
		Pseq([1, 2, 3]),
		Pseq([0, -2, [1, 3], -5]),
		Pshuf([1, 0, 3, 0], 2)
	),
	\dur, PstepNadd(
		Pseq([1, 0, 0, 1], 2),
		Pshuf([1, 1, 2, 1], 2)
	).loop * (1/8),
	\legato, Pn(Pshuf([0.2, 0.2, 0.2, 0.5, 0.5, 1.6, 1.4], 4), inf),
	\scale, #[0, 1, 3, 4, 5, 7, 8]
).play;
::
** class:: PatternConductor
summary:: Simple interactive control for playing patterns
related:: Classes/Pattern
categories:: Streams-Patterns-Events>Patterns

description::

PatternConductor provides a simple interactive control (supporting play, pause, resume, stop) for playing pattern, much like link::Classes/Pattern#-play::. However, PatternConductor creates its own clock and directly controls the release of sounding notes as well as their initiation by the pattern.

InstanceMethods::

private::prPlay

method::tempo
Sets the tempo of the PatternConductor

method::play
Play the pattern. A link::Classes/TempoClock:: is created, its tempo is set to the PatternConductor tempo, and the pattern is played using that clock. If quant is non-zero, this is synchronized with TempoClock.default at the specified quantization.

method::pause
Pause the pattern, sustaining notes indefinitely. A subsequent link::#-resume:: will return to the original tempo (so the notes will end as scheduled). A subsequent link::#-play:: will cut-off any sounding notes and resume play at the original tempo.

method::stop
can cut-off or shorten sounding notes, depending on the value of tempo. If stopTempo is nil, all notes are cut-off immediately. Otherwise, notes end at the specified tempo.

Examples::

code::
(
// a pattern with long notes
p = Pbind(
	\freq, Pwhite(0,log(32)).exp.round(1) * 36.midicps,
	\detune, Pfunc({ | ev | ev[\freq]  * rand(0.01) }),
	\sustain, Pwhite(log(0.1), log(20)).exp,
	\dur, Prand([0.1,0.1,0.1,0.1,0.2,1,2],inf),
	\db, Pstep(Pseq([-20,-30,-25,-30], inf),0.2)
);

// unrelated cluster pattern running on TempoClock.default
Pbind(\dur,2, \midinote, Pseq([(48..60)],20), \db, -30).play;

// make a conductor
a = PatternConductor(p, quant: 2);
a.play;
)


// now try some interactive control options line by line:
a.quant = 0;
a.pause;
a.resume;
a.stop;
a.play;
a.pause;
a.play;
a.stop(1000);
::
** class:: PatternProxy
summary:: stream reference
categories:: Libraries>JITLib>Patterns
related:: Classes/Pdefn

description::
Keeps a reference to a stream that can be replaced while playing. Multiple streams are thus handled without creating dependancies.

ClassMethods::

method::new
create a new instance with a pattern (the source). the pattern should be a emphasis::value pattern:: (see link::Classes/Pdefn::).

for event pattern proxy, see: link::Classes/EventPatternProxy::. instead of a pattern, a strong::function:: can be passed in, creating a routine.

method::default
a default source, if none is given. the default is 1.0 (it is not 0.0 in order to make it safe for durations)

method::defaultQuant
set the default quantization value for the class. (default: nil)

InstanceMethods::

method::source
set the source. If a quantization is given, schedule this change to the next beat

method::clear
set the source to nil

method::quant
set or get the quantization value

method::condition
provide a condition under which the pattern is switched when a new one is inserted. the stream value and a count is passed into the function. the methods strong::count_(n):: simply counts up to n and switches the pattern then

method::embedInStream
just like any pattern, embeds itself in stream

subsection::extra methods

PatternProxy implements some methods for the benefits of its subclasses link::Classes/Pdefn:: / link::Classes/Pdef:: / link::Classes/Tdef:: which are not useful for link::Classes/PatternProxy:: and link::Classes/TaskProxy::.

method::envir
provide a default environment for the proxy. If given, it is used as an environment for the routine function. When set for the first time, the routine pattern is rebuilt.

method::set
set arguments in the environment. If there is none, it is created and the pattern is rebuilt.

method::endless
returns a Proutine that plays the proxy endlessly, replacing strong::nil:: with a strong::default:: value (1). This allows to create streams that idle on until a new pattern is inserted.

Examples::

code::
a = PatternProxy(Pseq([1, 2, 3], inf));

x = Pseq([0, 0, a], inf).asStream;

t = Task({ loop({ x.next.postln; 0.3.wait }) }).play;


a.source = Pseq([55, 66, 77], inf);
a.source = Pseq([55, 66, 77], 1);

t.stop;
::

code::
// PatternProxy, like Pdefn can be accessed in multiple streams

(
SynthDef("Pdefhelp", { arg out, freq, sustain=1, amp=1, pan;
	var env, u=1;
	env = EnvGen.kr(Env.perc(0.03, sustain), 1, doneAction:2);
	5.do { var d; d = exprand(0.01, 1); u = SinOsc.ar(d * 300, u, rrand(0.1,1.2) * d, 1) };
	Out.ar(out, Pan2.ar(SinOsc.ar(u + 1 * freq, 0, amp * env), pan));

}).add;
s.boot;
)

(
x = PatternProxy.new;
x.source = Pseq([0, 3, 2], inf);

Pset(\instrument, \Pdefhelp,
	Ppar([
	Pbind(\degree, x),
	Pbind(\degree, x, \dur, 1/3)
])
).play;
)

x.source = Prand([0, 3, [1s, 4]], inf);

x.source = Pn(Pshuf([0, 3, 2, 7, 6], 2), inf);



// if quant is set, the update is done at the next beat or whatever is specified:

x.quant = 4;
x.source = Pn(Pseries(0, 1, 8), inf);

x.quant = nil; // reactivate immediacy

(
x.source = Prout {
	loop {
	4.do { |i|
		#[2, 3, 4].choose.yield;
		#[5, 0, 11].choose.yield;
		#[6, 3, 4].choose.do { |j| (i % j).yield };
	}
	}
}
)
::
** class:: Pause
summary:: When triggered, pauses a node.
related:: Classes/Free
categories::  UGens>Synth control


Description::

When triggered, pauses a node.


classmethods::

method::kr

argument::gate

When gate is 0, node is paused, when 1 it runs.


argument::id

Node to be paused.


Examples::

code::

s.boot;

SynthDef("a", { Out.ar(0, SinOsc.ar(800, 0, 0.2)) }).send(s);

SynthDef("b", { arg gate=1; Out.ar(1, PinkNoise.ar(0.3)); Pause.kr(gate, 1001); }).send(s);

s.sendMsg(\s_new, \a, 1001, 0, 0);

s.sendMsg(\s_new, \b, 1002, 0, 0);

s.sendMsg(\n_set, 1002, \gate, 0);

s.sendMsg(\n_set, 1002, \gate, 1);

::

** class:: PauseSelf
summary:: When triggered, pause enclosing synth.
related:: Classes/FreeSelf
categories::  UGens>Synth control


Description::

Pause enclosing synth when input signal crosses from non-positive to
positive.


classmethods::

method::kr

argument::in

The input signal.


Examples::

code::

(
SynthDef("pauseSelf-help", { arg out, t_trig;
	PauseSelf.kr(t_trig);
	Out.ar(out, SinOsc.ar(400,0,0.2));
}).send(s);
)

s.sendMsg("/s_new", "pauseSelf-help", 1731);
s.sendMsg("/n_set", 1731, \t_trig, 1);
s.sendMsg("/n_run", 1731, 1);
s.sendMsg("/n_set", 1731, \t_trig, 1);
s.sendMsg("/n_free", 1731);

::

** class:: PauseSelfWhenDone
summary:: FIXME: PauseSelfWhenDone purpose.
related:: Classes/Done, Classes/FreeSelfWhenDone
categories::  UGens>Synth control, UGens>Undocumented


Description::

FIXME: PauseSelfWhenDone description.


classmethods::

method::kr

argument::src

FIXME: explain parameter src.


** class:: Pavaroh
summary:: applying ascending and descending scales to event stream
categories:: Streams-Patterns-Events>Patterns>Math

description::

Basic classical indian scale pattern. Allowing to apply an ascending scale (aroh) and a descending scale (avaroh).

Note that no special pakads (movements) or vakras (twists) are applied.

The pakad is often a natural consequence of the notes of arohana / avarohana (ascending and descending structures). This is the purpose of this pattern.

Examples::

code::
(
Pbind(\note, Pavaroh(
			Pseq([1, 2, 3, 2, 5, 4, 3, 4, 2, 1], 2),
			#[0, 2, 3, 6, 7, 9],
			#[0, 1, 3, 7, 8, 11]
		),
	\dur, 0.25
).play;
)


//___indian video game (1)
(
SynthDef("ivg", { arg out, freq=900, pan;
	var trig, snd;
	trig = Impulse.kr(LFClipNoise.kr(4, 3, LFClipNoise.kr(0.2, 2, 7)));
	snd = RLPF.ar(
		SinOsc.ar(freq, 0, Decay.kr(trig, 1.8)).distort
		, 554, 0.3)
	* 0.1;
	Out.ar(out, Pan2.ar(snd, pan))
 }).send(s);
)

(
	var aroh, avaroh, synth, str, pat;

	//gandhari raga.  vadi: dha (7) samvadi: ga (3)

	aroh = #[0, 2, 5, 7, 10];
	avaroh =  #[0, 1, 3, 5, 7, 9, 10];

	synth = Synth.head(s, \ivg);
	pat = Prand([0, 2, 3, 4, 2, 1, 0, -1, -2], inf);
	str = Pavaroh(pat, aroh, avaroh).asStream;
	Routine({

		loop({
			synth.set(\freq, midicps(str.next + 60) );
			rrand([0.1,1.0].choose, 0.5).wait;
		});

	}).play;
)
::
** class:: Pbeta
summary:: random values that follow a Eulerian Beta Distribution
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::prob1
The probability that a value will occur near lo. <1, probability of a value near lo increases. =1, uniform dist. >1 will create a bounded Gaussian-like distribution.

argument::prob2
The probability that a value will occur near hi. <1, probability of a value near lo increases. =1, uniform dist. >1 will create a bounded Gaussian-like distribution.

argument::length
number of values produced (default: inf).

Examples::

code::
(
var a, c, w;
a = Pbeta(0.0, 1.0, 0.1, 0.1, inf);
c = a.asStream.nextN(500);
w = Window.new("Pbetarand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

(
var a, c, w;
a = Pbeta(0.0, 1.0, 1, 1, inf);
c = a.asStream.nextN(500);
w = Window.new("Pbetarand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);(discrete: true);
)

(
var a, c, w;
a = Pbeta(0.0, 1.0, 3, 3, inf);
c = a.asStream.nextN(500);
w = Window.new("Pbetarand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pbeta(0.0, 1.0, 0.1, 0.1, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)

(
var a;
a = Pbeta(0.0, 1.0, 1.0, 1.0, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)

(
var a;
a = Pbeta(0.0, 1.0, 3.0, 3.0, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::
** class:: Pbind
summary:: combine several value patterns to one event stream by binding keys to values
related:: Classes/Pattern, Classes/Event, Classes/Pmono, Classes/Rest
categories:: Streams-Patterns-Events>Patterns>Event

description::

Pbind combines several value streams into one event stream. Each value stream is assigned to one or more keys in the resulting event stream. It specifies a stream of strong::Events:: in terms of different patterns that are strong::bound:: to different keys in the Event.
The patterns bound to keys are referred to as emphasis::value patterns:: and the Pbind itself is termed an event pattern.

The keys used in a Pbind are usually determined by link::Classes/Event::'s default mechanism and the controls defined for the link::Classes/SynthDef:: to be played. (See link::#SynthDef and Event:: below for a brief discussion of both in relation to Pbind.)

ClassMethods::

method::new
The arguments to Pbind are an alternating sequence of keys and patterns. A pattern can also be bount to an array of keys. In this case, the pattern must specify a sequence whose elements are arrays with at least as many elements as there are keys.

Examples::

code::
(
a = Pbind(\x, Pseq([1, 2, 3]), \y, Prand([100, 300, 200], inf), \zzz, 99);
x = a.asStream;
)

x.next(()); // pass in an event ()
x.next(());
x.next(());
x.next(()); // end: nil
::

code::
// sound examples

// using the default synth def
Pbind(\freq, Prand([300, 500, 231.2, 399.2], inf), \dur, 0.1).play;
Pbind(\freq, Prand([300, 500, 231.2, 399.2], inf), \dur, Prand([0.1, 0.3], inf)).play;

Pbind(\freq, Prand([1, 1.2, 2, 2.5, 3, 4], inf) * 200, \dur, 0.1).play;
::

code::
(
// a SynthDef
SynthDef(\test, { | out, freq = 440, amp = 0.1, nharms = 10, pan = 0, gate = 1 |
	var audio = Blip.ar(freq, nharms, amp);
	var env = Linen.kr(gate, doneAction: 2);
	OffsetOut.ar(out, Pan2.ar(audio, pan, env) );
}).add;
)

Pbind(\instrument, \test, \freq, Prand([1, 1.2, 2, 2.5, 3, 4], inf) * 200, \dur, 0.1).play;



// standard syntax, arguments alternate symbols and patterns
(
Pbind(
	\instrument,		\test,
	\nharms,		Pseq([4, 10, 40], inf),
	\dur,			Pseq([1, 1, 2, 1]/10, inf),
	#[freq, sustain],	Ptuple([ // assignment to multiple keys
					Pseq( (1..16) * 50, 4),
					Pseq([1/10, 0.5, 1, 2], inf)
				])
).play;
)
::

It is possible to specify a Pbind with an link::Classes/Array:: preceded by *. Arrays treat identifiers ending with a colon as link::Classes/Symbol::s, making the syntax of the Pbind specification a bit more concise:

code::
(
// Alternative syntax, using a key/pattern array:
Pbind(*[
	instrument:		\test,
	nharms:			Pseq([4, 10, 40], inf),
	dur:			Pseq([1, 1, 2, 1]/10, inf),
	#[freq, sustain],	Ptuple([
					Pseq( (1..16) * 50, 4),
					Pseq([1/10, 0.5, 1, 2], inf)
				])
]).play;
)
::

subsection::SynthDef and Event

The keys used in a Pbind are determined by the link::Classes/SynthDef:: used and the structure of the extensive default mechanism provided by link::Classes/Event::. This section provides a brief review of both.

A link::Classes/SynthDef:: assigns a name to an interconnection of unit generators to be run as a synth on a server. It also assigns strong::control names:: to the synth's control inputs. In the following example the SynthDef \test has control inputs strong::out::, strong::freq::, strong::amp::, strong::nharms::, strong::pan::, and strong::gate::.

code::
SynthDef(\test, { | out, freq = 440, amp = 0.1, nharms = 10, pan = 0, gate = 1 |
	var audio = Blip.ar(freq, nharms, amp);
	var env = Linen.kr(gate, doneAction: 2);
	OffsetOut.ar(out, Pan2.ar(audio, pan, env) );
}).add;
::

The SynthDef needs to be downloaded to the server upon which it is to be run. Use strong::.add:: instead of .send to ensure that any patterns using this SynthDef have information about the available control inputs (see link::Classes/SynthDesc::). Alternately, strong::.store:: may be used to save the SynthDef to disk and add the SynthDesc to the library.

An link::Classes/Event:: is a Dictionary that specifies an action to be taken in response to strong::play:: and a time increment to be returned in response to strong::delta::. Events can be written as a series of key value pairs enclosed in parentheses. Empty parentheses create an empty event.

By default, Events play synths on a server. Such emphasis::note events:: use the following keys:

definitionList::
## instrument (\default) || The synthdef to be played
## variant (nil, optional) || The set of variant control defaults to use (see link::Classes/SynthDef::)
## server (Server.default) || The server that plays the synth
## group (1) || The new synth's or the synth the new synth is placed before or after
## addAction (0) || How the synth is placed relative to the target specified by strong::group::
definitionList::
## 0 || head of group
## 1 || tail of group
## 2 || before group (could be a Synth)
## 3 || after group (could be a Synth)
::
## delta (function) || The time until the next event in a sequence of events, generally specified indirectly through strong::dur::
::

When the Event is played, it creates an OSC command to play a synth. It uses the name assigned to strong::instrument:: to the select the SynthDef to be played. The SynthDef's control names (found in its link::Classes/SynthDesc::) are looked up in the event and the corresponding values included in the command.

Playing a synth is the normal action taken by an Event. The default event structure defines several other event types that can perform a wide variety of server actions. See the link::Classes/Event:: help file for a list of event types.

There are a number of coventional names typically used to identify controls in a synth.

definitionList::
## out || output bus index
## in || input bus index (for filters, modulators, etc)
## gate || envelope gate (not level!) - should default to 1.0, deletes synth when released
## trig || envelope gate (not level!) - should default to 1.0, does not delete synth when released
## pan || panning position
## bufnum || buffer number (used in synths that utilize link::Classes/PlayBuf::, link::Classes/DiskIn::, etc)
## sustain || duration of the synth
## amp || amplitude of the synth
## freq || base pitch of the synth
::

Event implements a layered specification scheme for some of these controls. In the following list, the first and leftmost name is the actual control name, names below and indented are more abstract ways to specify the control.

definitionList::
## delta || The time until the next event. Generally determined by:
definitionList::
## dur || The time until next event in a sequence of events
## stretch || Scales event timings (i.e. stretch == 2 => durations are twice as long)
::
## sustain || Duration of the synth, typically determined (in stretched time units) by:
definitionList::
## legato || The ratio of the synth's duration to the event's duration
::
## amp || synth amplitude (typically ranging from 0 to 1), often determined by
definitionList::
## db || Amplitude in decibels
::
## detunedFreq || actual "pitch" of a synth, determined by:
definitionList::
## freq + detune; || freq is determined by:
definitionList::
## (midinote + ctranspose).midicps * harmonic; || midinote is determined by:
definitionList::
## (note + gtranspose + root)/stepsPerOctave * octave * 12; || note is determined by:
definitionList::
## (degree + mtranspose).degreeToKey(scale, stepsPerOctave) ||
::
::
::
::
::

code::
(
// the SynthDef
SynthDef(\test, { | out, freq = 440, amp = 0.1, nharms = 10, pan = 0, gate = 1 |
	var audio = Blip.ar(freq, nharms, amp);
	var env = Linen.kr(gate, doneAction: 2);
	OffsetOut.ar(out, Pan2.ar(audio, pan, env) );
}).add;

// Events are written as parantheses enclosing key/value pairs
(instrument: \test).play;
(instrument: \test, freq: 20, nharms: 50).play;
)
::

subsection::Rests

See link::Classes/Rest:: for a discussion of marking events as rests in Pbind.

subsection::The Play Method

While the play method is actually defined in the class link::Classes/Pattern::, it is useful to review it here:

definitionList::
## play (clock, protoEvent, quant) || returns an link::Classes/EventStreamPlayer::.
## clock || The clock that schedules the EventStreamPlayer, defaults to TempoClock.default. Patterns that change graphics must use link::Classes/AppClock::.
## protoEvent || The initial event modified by Pbind, defaults to Event.default.
## quant || A quantization value used by clock. When a number, the pattern will start at the next even multiple of that number. May also be a link::Classes/Quant::, which specifies quantization, time position within that quantization, and a timingOffset. See link::Classes/Quant:: for details.
::

subsection::Realtime Control with EventStreamPlayer

The link::Classes/EventStreamPlayer:: provides realtime control through strong::mute::, strong::unmute::, strong::stop::, strong::play:: and strong::reset::.

code::
(
SynthDef(\cfstring1, { arg i_out, freq = 360, gate = 1, pan, amp=0.1;
	var out, eg, fc, osc, a, b, w;
	fc = LinExp.kr(LFNoise1.kr(Rand(0.25, 0.4)), -1, 1, 500, 2000);
	osc = Mix.fill(8, {LFSaw.ar(freq * [Rand(0.99, 1.01), Rand(0.99, 1.01)], 0, amp) }).distort * 0.2;
	eg = EnvGen.kr(Env.asr(1, 1, 1), gate, doneAction:2);
	out = eg * RLPF.ar(osc, fc, 0.1);
	#a, b = out;
	Out.ar(i_out, Mix.ar(PanAz.ar(4, [a, b], [pan, pan+0.3])));
}).add;

e = Pbind(
	\degree, Pseq((0..12), inf),
	\dur, 0.2,
	\instrument, \cfstring1
).play; // returns an EventStream
)

( // an interactive session
e.stop
e.play
e.reset

e.mute; // keeps playing, but replaces notes with rests

e.unmute;

e.reset; // reset the stream.
e.reset; // reset the stream.
e.reset; // reset the stream.
e.reset; // reset the stream.

e.pause; // will resume where paused.

e.play;

e.stop; // will reset before resume.

e.play;
)
::

In addition, the stream the EventStreamPlayer plays can be altered while it is running through the method
strong::stream_(aStream)::.

code::
(
e.stream = Pbind(
	\degree, Pseq([0, 1, 2, 4, 6, 3, 4, 8], inf),
	\dur, Prand([0.2, 0.4, 0.8], inf),
	\amp, 0.05, \octave, 5,
	\instrument, \cfstring1, \ctranspose, 0
).asStream;
)

(
e.stream = Pbind(
	\degree, Pseq([0, 1, 2, 4, 6, 3, 4, 8], inf),
	\dur, Prand([0.2, 0.4, 0.8], inf),
	\amp, 0.05, \octave, 5,
	\instrument, \cfstring1, \ctranspose, 0
).asStream;
)

(
e.stream = Pbind(
	\degree, Pxrand([0, 1, 2, 4, 6, 3, 5, 7, 8], inf),
	\dur, Prand([0.2, 0.4, 0.8], inf), \amp, 0.05,
	\octave, 5, \instrument, \cfstring1
).asStream;
)
::

subsection::Additional arguments

Here is an example with more bindings. Here we have added a filter with cutoff and resonance arguments.
You will need to hit command '.' before executing the next few pbind ex. without having them stack up.
also, due to the synthdef's and synthdeclib, if the server is shut down you will have to reload the
synthdef and re-read the synthdesclib.

code::
(
SynthDef(\acid, { arg out, freq = 1000, gate = 1, pan = 1, cut = 4000, rez = 0.8, amp = 1;
	Out.ar(out,
		Pan2.ar(
			RLPF.ar(
				Pulse.ar(freq, 0.05),
			cut, rez),
		pan) * EnvGen.kr(Env.linen(0.01, 1, 0.3), gate, amp, doneAction:2);
	)
}).add;
)

(
Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], inf), \root, -12,
	\degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf), \pan, Pfunc({1.0.rand2}),
	\cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, 0.2).play;
)
::

The link::Classes/ListPattern::s can be put around Event Streams to create sequences of Event Streams.

code::
(
Pseq([
	Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], 4), \root, -24,
		\degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf), \pan, Pfunc({1.0.rand2}),
		\cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, 0.2),

	Pbind(\instrument, \acid, \dur, Pseq([0.25], 6), \root, -24, \degree, Pseq([18, 17, 11, 9], inf),
		\pan, Pfunc({1.0.rand2}), \cut, 1500, \rez, Pfunc({0.7.rand +0.3}), \amp, 0.16)

], inf).play;
)
::

'Pseq' in the above ex. can be any pattern object:

code::
(
Prand([
	Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], 4), \root, -24,
		\degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf), \pan, Pfunc({1.0.rand2}),
		\cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}),
		\amp, 0.2),

	Pbind(\instrument, \acid, \dur, Pseq([0.25], 6), \root, -24, \degree, Pseq([18, 17, 11, 9], inf),
		\pan, Pfunc({1.0.rand2}), \cut, 1500, \rez, Pfunc({0.7.rand +0.3}), \amp, 0.16)

], inf).play;
)
::

subsection::Multichannel Expansion

If we supply an array for any argument, the synth node will automatically replicate to handle the additional arguments. When we give the 'root' argument an array, we should hear a chord....

code::
(
Pbind(
	\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], inf),
	\root, [-24, -17],
	\degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf),
	\pan, Pfunc({1.0.rand2}), \cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}),
	\amp, 0.2).play;
)
::

Using link::Classes/Pdef:: (provided by link::Overviews/JITLib::) makes it easy to replace patterns on the fly:

code::
(
Pdef(\buckyball).play;
)

(
Pdef(\buckyball, Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], inf), \root, [-24, -17],
	\degree, Pseq([0, 3, 5, 7, 9, 11, [5, 17], 1], inf), \pan, Pfunc({[1.0.rand2, 1.0.rand2]}),
	\cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, [0.15, 0.22]));
)
(
Pdef(\buckyball, Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], inf), \root, [-24, -17],
	\degree, Pseq([0b, 3b, 5b, 7b, 9b, 11b, 5b, 0b], inf), \pan, Pfunc({1.0.rand2}), //notice the flats
	\cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, 0.2));
)

//stop the Pdef
Pdef(\buckyball).stop;

//start the Pdef
Pdef(\buckyball).resume;

//removing the Pdef
Pdef.remove(\buckyball);
::

subsection::Sending to effects

Assignment to effect processors can be achieved by setting the 'out' argument to the desired efx's input bus. The effect Synth must also be created. Synth.new is one way of doing this.

code::
(
// efx synthdef- dig the timing on the delay and the pbind. :-P
SynthDef(\pbindefx, { arg out, in, time1=0.25, time2=0.5;
	var audio, efx;
	audio = In.ar([20, 21], 2);
	efx=CombN.ar(audio, 0.5, [time1, time2], 10, 1, audio);
	Out.ar(out, efx);
}).add;

// create efx synth
a = Synth.after(1, \pbindefx);

// if you don't like the beats change to 0.4, 0.24
// a.set(\time1, 0.4, \time2, 0.24);

SynthDef(\acid, { arg out, freq = 1000, gate = 1, pan = 0, cut = 4000, rez = 0.8, amp = 1;
	Out.ar(out,
		Pan2.ar(
			RLPF.ar(
				Pulse.ar(freq, 0.05),
			cut, rez),
		pan) * EnvGen.kr(Env.linen(0.02, 1, 0.3), gate, amp, doneAction:2);
	)
}).add;
)

(
Pbind(\instrument, \acid, \out, 20, \dur, Pseq([0.25, 0.5, 0.25], inf), \root, [-24, -17],
	\degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf), \pan, Pfunc({1.0.rand2}),
	\cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, 0.12).play;
)
::

subsection::Additional examples

code::
(
SynthDef(\berlinb, { arg out=0, freq = 80, amp = 0.01, pan=0, gate=1;
	var synth, env;
	env = Decay2.kr(gate, 0.05, 8, 0.0003);
	synth = RLPF.ar(
		LFPulse.ar(freq, 0, SinOsc.kr(0.12, [0, 0.5pi], 0.48, 0.5)),
		freq * SinOsc.kr(0.21, 0, 18, 20),
		0.07
	);
	#a, b = synth*env;
	DetectSilence.ar(a, 0.1, doneAction: 2);
	Out.ar(out, amp * Mix.ar(PanAz.ar(4, [a, b], [pan, pan+1])));
}).add;
)

(
f = Pbind(
	\degree, Pseq([0, 1, 2, 4, 6, 3, 4, 8], inf),
	\dur, 0.5, \octave, 3, \instrument, \berlinb
).play;
)

(
f.stream = Pbind(
	\degree, Pseq([0, 1, 2, 4, 6, 3, 4, 8], inf),
	\dur, 0.5, \octave, [2, 1],
	\instrument, \berlinb,
	\pan, Pfunc({1.0.rand2})
).asStream;
)
::
** class:: PbindProxy
summary:: incremental event pattern reference
categories:: Libraries>JITLib>Patterns
related:: Classes/Pbindef, Classes/Pdef

description::
keeps a reference to a link::Classes/Pbind:: in which single keys can be replaced. It plays on when the old stream ended and a new stream is set and schedules the changes to the beat.

ClassMethods::

method::new
create a new instance of PbindProxy with the given patternpairs

InstanceMethods::

method::source
returns the wrapper for the Pbind

method::set
set the given patternpairs.

method::at
return a pattern at that key. this can be used to set quant value individually, so different elementary patterns can be quantized differently.
code::
x.at(\freq).quant = 2;
::

method::quant
set the quant of all elementary patterns, or return the quant value of the source pattern.

Examples::

code::
(
SynthDef("Pdefhelp", { arg out, freq, sustain=1, amp=1, pan;
	var env, u=1;
	env = EnvGen.kr(Env.perc(0.03, sustain), 1, doneAction:2);
	5.do { var d; d = exprand(0.01, 1); u = SinOsc.ar(d * 300, u, rrand(0.1,1.2) * d, 1) };
	Out.ar(out, Pan2.ar(SinOsc.ar(u + 1 * freq, 0, amp * env), pan));
}).add;
)
s.boot;


x = PbindProxy.new;
x.set(\instrument, \Pdefhelp);

x.play;

x.set(\degree, Pseq([0, 2, 5b, 1b], inf));
x.set(\dur, 0.1);
x.set(\degree, Pseq([1b, 5, 3, 1b, 6, 2, 5, 0, 3, 0, 2], inf));
x.set(\legato, Prand([1.0, 2.4, 0.2], inf), \mtranspose, -3);
x.set(\mtranspose, nil); // remove key

x.set(\degree, Pseq([1, 2, 3, 4, 5, 6], 1));
x.play;

x.set( \degree, Pseq([1, 2, 3, 4, 5, 6], 3), \dur, 0.02);
x.play;

x.set(\degree, Pseq([1, 2, 3, 4, 5, 6], 3), \dur, 0.1);
x.play;


// embed in other patterns:
(
x.set(\degree, Pseq([1b, 5, 3, 1b, 6, 2, 5, 0, 3, 0, 2], inf));
Ppar([
x,
Pbindf(x, \ctranspose, 4)
]).play;
)


x.set(\degree, Pseq([1b, 5, 1b, 4, 0], inf), \dur, 0.4);
::
** class:: Pbindef
summary:: incremental event pattern reference definition
categories:: Libraries>JITLib>Patterns
related:: Classes/Pdef, Classes/Pbind

description::
Pbindef keeps a reference to a Pbind in which single keys can be replaced, combining link::Classes/PbindProxy:: and link::Classes/Pdef::. It plays on when the old stream ended and a new stream is set and schedules the changes to the beat.

the difference to Pdef is that it allows to incrementally change the elementary patterns (patternpairs) of a Pbind - also of an already existing Pbind inside a Pdef. 

Pbindef and Pdef use the same global collection, while Pdef and Pdefn use separate ones.

Pbindef inherits most methods from link::Classes/Pdef::. Overview: link::Overviews/JITLib::

ClassMethods::

method::new
store the pattern in the global dictionary of link::Classes/Pdef:: under key. (if there is already a Pdef there, replace its pattern with the new one. If there is already a strong::Pbindef:: there, set the parameters only, or add a new one (the whole pattern is replaced).

Using strong::*new(key):: you can access the pattern at that key (if none is there, a default pattern is created). see link::Classes/Pdef::.

Examples::

code::
(
SynthDef("Pdefhelp", { arg out, freq, sustain=1, amp=1, pan;
	var env, u=1;
	env = EnvGen.kr(Env.perc(0.01, sustain), 1, doneAction:2);
	5.do { var d; d = exprand(0.01, 1); u = SinOsc.ar(d * 300, u, rrand(0.1,1.2) * d, 1) };
	Out.ar(out, Pan2.ar(SinOsc.ar(u + 1 * freq, 0, amp * env), pan));
}).add;
)
s.boot;


Pbindef(\a, \instrument, \Pdefhelp).play;
Pbindef(\a, \degree, Pseq([0, 2, 5b, 1b], inf));
Pbindef(\a, \dur, 0.1);
Pbindef(\a, \degree, Pseq([1b, 5, 3, 1b, 6, 2, 5, 0, 3, 0, 2], inf));
Pbindef(\a, \legato, Prand([1.0, 2.4, 0.2], inf), \mtranspose, -3);
Pbindef(\a, \mtranspose, nil); // remove key

Pbindef(\a, \degree, Pseq([1, 2, 3, 4, 5, 6], 1));
Pbindef(\a, \degree, Pseq([1, 2, 3, 4, 5, 6], 3), \dur, 0.02);
Pbindef(\a, \degree, Pseq([1, 2, 3, 4, 5, 6], 3), \dur, 0.1);

// apart from this Pbindef behaves like Pdef:

Pbindef(\a).quant = 0.0;
Pbindef(\a, \degree, Pseq([1, 2, 3, 4, 5, 6], 1));

Pbindef(\a).stop;
Pbindef(\a, \degree, Pseq([1, 2, 3, 4, 5, 6], 1)); // does not resume now

Pbindef(\a).playOnce; // play single instance
Pseq([Pbindef(\a), Pdef(\a)]).play; // same here (Pdef(\a) is the same pattern as Pbindef))

Pbindef(\a) === Pdef(\a) // identical.



// an already existing Pdef can be incrementally changed

Pdef(\x, Pbind(\instrument, \Pdefhelp, \dur, 0.3));
Pdef(\x).play;

Pbindef(\x, \degree, 7.rand);
Pbindef(\x, \degree, Pseq([0, 7, 3, 7, 4], inf), \dur, Pn(Pseries(0.2, -0.02, 10)));
Pbindef(\x, \stretch, 2);
::
** class:: Pbindf
summary:: bind several value patterns to one existing event stream by binding keys to valueskeys to values
related:: Classes/Pattern, Classes/Event, Classes/Pbind, Classes/Pchain
categories:: Streams-Patterns-Events>Patterns>Composition

description::

Pbindf adds several value streams into one existing event stream. Each value stream is assigned to one or more keys in the resulting event stream, overriding any values from the input stream.

The patterns bound to keys are referred to as value patterns and the Pbindf itself is termed an emphasis::event pattern::.

ClassMethods::

method::new
The arguments to Pbindf is the initial pattern followed by an alternating sequence of keys and patterns. A pattern can also be bound to an array of keys. In this case, the pattern must specify a sequence whose elements are arrays with at least as many elements as there are keys.

Examples::

code::
(
a = Pbind(\x, Pseq([1, 2, 3]), \zzz, 9000); // input stream
b = Pbindf(a, \y, Prand([100, 300, 200], inf), \zzz, 99);
x = b.asStream;
)

x.next(()); // pass in an event ()
x.next(());
x.next(());
x.next(()); // end: nil



// sound examples

// using the default synth def
a = Pbind(\dur, 0.1);
Pbindf(a, \freq, Prand([300, 500, 231.2, 399.2], inf)).play;
Pbindf(a, \freq, Prand([1, 1.2, 2, 2.5, 3, 4], inf) * 200).play;


(
// a SynthDef
SynthDef(\test, { | out, freq = 440, amp = 0.1, nharms = 10, pan = 0, gate = 1 |
	var audio = Blip.ar(freq, nharms, amp);
	var env = Linen.kr(gate, doneAction: 2);
	OffsetOut.ar(out, Pan2.ar(audio, pan, env) );
}).add;
)

a = Pbind(\instrument, \test, \dur, 0.1);

Pbindf(a, \freq, Prand([1, 1.2, 2, 2.5, 3, 4], inf) * 200).play;
::
** class:: Pbinop
summary:: binary operator pattern
related:: Classes/Pnaryop, Classes/Punop, Classes/BinaryOpFunction
categories:: Streams-Patterns-Events>Patterns>Math

description::

Returns a stream that applies the binary operator to the stream values of the receiver. Usually, this is the result of applying a binary operator (i.e. a method with one argument) to a pattern.

Examples of binary operators are: +, -, /, *, min, max, hypot ...

ClassMethods::

method::new

argument::operator
operator to be applied

argument::a
a pattern (or compatible pattern input)

argument::b
a pattern (or compatible pattern input)

argument::adverb

Examples::

code::
(
var a;
a = Pbinop(\hypot, Pseries(0, 1, 12), Pseries(3, -1, 12));
a.asStream.all;
)

// this is the same as:
(
var a;
a = Pseries(0, 1, 12).hypot(Pseries(3, -1, 12));
a.asStream.all;
)

// also written as:
(
var a;
a = Pseries(0, 1, 12) hypot: Pseries(3, -1, 12);
a.asStream.all;
)

// some common cases:
Pseq([1, 2, 3]) + 2;
Pseq([1, 2, 3]) / Pseq([3, 4, 5, 6]);
max(Pwhite(-10, 10, inf), Pseq([0, 2, 3, 4]));
::

code::
// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, amp=0.1;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2, amp), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pn(Pbinop(\hypot, Pseries(0, 1, 34), Pseries(3, -1, 34)), inf).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, a * 200 + 300].postln);
		0.05.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.01,
	\instrument, \help_sinegrain,
	\note, Pn(Pbinop(\hypot, Pwhite(0, 12, 13), Pseries(3, -1, 12)))
).play;
)



// these are the same as:

(
var a;
a = Pn(Pseries(0, 1, 34) hypot: Pseries(3, -1, 34), inf).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, a * 200 + 300].postln);
		0.05.wait;
	}
}.fork;
)


(
Pbind(
	\dur, 0.01,
	\instrument, \help_sinegrain,
	\note, Pn(Pwhite(0, 12, 13) hypot: Pseries(3, -1, 12))
).play;
)
::
** class:: Pbrown
summary:: brownian motion pattern
related:: Classes/BrownNoise, Classes/Pgbrown
categories:: Streams-Patterns-Events>Patterns>Random

description::

Returns a stream that behaves like a brownian motion.

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::step
maximum change per step - the distribution is xrand2.

argument::length
number of values produced.

Examples::

code::
(
var a;
a = Pbrown(0.0, 1.0, 0.1, inf);
c = a.asStream.nextN(500);
w = Window.new("Pbrown", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

(
var a;
a = Pbrown(0.0, 1.0, 0.2, inf);
a.asStream.nextN(1000).plot2;
)
::

code::
// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pbrown(0.0, 1.0, 0.1, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)



// parallel browninan motions
(
var a, x, f;
a = Pbrown(0.0, 1.0, 0.1, inf);

f = { |pattern, dt=0.02, min=300, max=900|
	{
		var x = pattern.asStream;
		loop {
			Synth.grain(\help_sinegrain, [\freq, x.next.linexp(0, 1, min, max), \sustain, dt]);
			dt.wait;
		}
	}.fork;
}.flop;

// 3 parallel motions
f.(a, [0.02, 0.08, 0.16]);
)
::
** class:: Pbus
summary:: isolate a pattern by restricting it to a bus
related:: Classes/Pfx, Classes/Pfxb, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Server Control

description::

Starts a new group and plays the pattern in this group, on a private bus. The group and the bus is released when the stream has ended.

This is useful in order to isolate a link::Classes/Pfx::.

ClassMethods::

method::new

argument::pattern

argument::dur
delay to allow inner patterns to decay.

argument::fadeTime
fading out the inner pattern after dur over this time.

argument::numChannels
number of channels of the bus (should match the synthdef).

argument::rate
bus rate.

Examples::

code::
(
SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
}, [\ir, \ir, 0.1, 0.1, 0]).add;

SynthDef(\distort, { arg out=0, pregain=40, amp=0.2, gate=1;
	var env;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	XOut.ar(out, env, (In.ar(out, 2) * pregain).distort * amp);
}, [\ir, 0.1, 0.1, 0]).add;

SynthDef(\wah, { arg out=0, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.4, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, RLPF.ar(in, LinExp.kr(LFNoise1.kr(0.3), -1, 1, 200, 8000), 0.1).softclip * 0.8);
}, [\ir, 0]).add;
)

(
var p, q, r, o;
p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);

q = Pfx(p, \echo, \dtime, 0.2, \decay, 3);

r = Pfx(q, \distort, \pregain, 20, \amp, 0.25);

o = Pfx(r, \wah);

Ppar(
	[p, q, r, o].collect(Pbus(_)); // play each in a different bus.
).play;
)



// compare to playing them together on one bus.
(
var p, q, r, o;
p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);

q = Pfx(p, \echo, \dtime, 0.2, \decay, 3);

r = Pfx(q, \distort, \pregain, 20, \amp, 0.25);

o = Pfx(r, \wah);

Ppar([p, q, r, o]).play;
)
::
** class:: Pcauchy
summary:: random values that follow a Cauchy Distribution
related:: Classes/BrownNoise, Classes/Pbrown
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::mean
The mean of the distribution.

argument::spread
The horizontal dispersion of the random values. The distribution is unbounded.

argument::length
Number of values produced.

Examples::

code::
(
var a, c, w;
a = Pcauchy(0.0, 1.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Pcauchy", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

(
var a, c, w;
a = Pcauchy(0.0, 10.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Pbetarand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pcauchy(0.0, 1.0,inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::
** class:: Pchain
summary:: pass values from stream to stream
related:: Classes/Pbindf
categories:: Streams-Patterns-Events>Patterns>Composition

description::

definitionList::
## Pchain(pattern1, pattern2, ... patternN) || pattern1 <- pattern2 <- ...patternN
::

Values produced by the stream of strong::pattern2:: are used as inval to the stream of strong::pattern1::. Therefore pattern1 overrides (or filters) the output of pattern2, and so forth. This is an equivalent to the composite pattern: emphasis::pattern1 <> pattern2 <> ... patternN::

ClassMethods::

method::new

argument:: ... patterns
The patterns to be chained up.

InstanceMethods::

method::<>
Add another pattern to the chain.

Examples::

code::
(
Pchain(
	Pbind(\detune, Pseq([-30, 0, 40], inf), \dur, Prand([0.2, 0.4], inf)),
	Pbind(\degree, Pseq([1, 2, 3], inf), \dur, 1)
).trace.play;
)


// also events can be used directly:
(
Pchain(
	Pbind(\degree, Pseq([1, 2, 3], inf)),
	(detune: [0, 4])
).trace.play;
)

// compose some more complicated patterns:
(
var a, b;
a = Prand([
	Pbind(\degree, Pseq([0, 1, 3, 5, 6])),
	Pbind(\dur, Pshuf([0.4, 0.3, 0.3]), \degree, Pseq([3, -1]))
], inf);
b = Prand([
	Pbind(\ctranspose, Pn(1, 4)),
	Pbind(\mtranspose, Pn(2, 7))
], inf);
c = Prand([
	Pbind(\detune, Pfuncn( { [0, 10.0].rand }, 5), \legato, 0.2, \dur, 0.2),
	Pbind(\legato, Pseq([0.2, 0.5, 1.5], 2), \dur, 0.3)
], inf);
Pchain(a, b, c).trace.play;
)
::

section::pattern composition

pattern <> pattern <> pattern

code::
// implicitly, the composition operator <> returns a Pchain when applied to a pattern.
// so that a <> b creates a Pchain (a, b).
// as seen above, in Pchain(a, b), a specifies (and overrides) b: b is the input to a.

// the above example is equivalent to:

(Pbind(\degree, Pseq([1, 2, 3], inf)) <> (detune: [0, 4])).trace.play;

(
a = Pbind(\degree, Pseq([1, 2, 3], inf), \dur, Prand([0.2, 0.4], inf));
b = Pbind(\detune, Pseq([-30, 0, [0, 40]], inf), \dur, 0.1);
c = b <> a;
c.play; // see that the \dur key of a is overridden by b
)

// also value streams can be composed
(
a = Pfunc { |x| x + 1.33 };
b = Pfunc { |x| x * 3 };
c = Pseries(1, 2, inf);
)

// post some values from the composite streams:

t = (a <> b).asStream;
10.do { t.value(10).postln };

t = (a <> b <> c).asStream;
10.do { t.value(10).postln };

t = (b <> c <> a).asStream;
10.do { t.value(10).postln };
::
** class:: Pclutch
summary:: sample and hold a pattern
related:: Classes/StreamClutch, Classes/Pstutter, Classes/Latch
categories:: Streams-Patterns-Events>Patterns>Repetition

ClassMethods::

method::new

argument::pattern
any pattern.

argument::connected
a pattern that returns either a series of link::Classes/Boolean::s or the equivalent 0 and 1. If true (or 1), the pattern plays as usual, if false (or 0), the previous value is kept.

Examples::

code::
Pclutch(Pseq([1, 2, 3, 4, 5], 3), Pseq([0, 0, 1, 0, 0, 0, 1, 1])).asStream.nextN(10);

// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pclutch(
		Pseq([1, 2, 3, 4, 5], inf),
		Pseq([0, 0, 1, 0, Pn(0, {30.rand}), 0, 1, 1], inf)
	).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 200 + 200]);
		0.02.wait;
	}
}.fork;
)
::
** class:: Pcollect
summary:: Apply a function to a pattern
categories:: Streams-Patterns-Events>Patterns>Filter
related:: Classes/Pselect, Classes/Preject

description::
Modifies each value by passing it to the function.


classmethods::

method:: new
argument:: func
A link::Classes/Function::. Receives values from code::pattern::.
argument:: pattern
A link::Classes/Pattern::.


examples::
code::
(
var a, b;
a = Pcollect({ arg item; item * 3 }, Pseq(#[1, 2, 3],inf));
x = a.asStream;
9.do({ x.next.postln; });
)
::

The message code::collect:: returns a Pcollect when passed to a pattern. Note that because the pattern is converted to a link::Classes/Stream:: (more precisely a link::Classes/FuncStream::) the collect function is evaluated for one item each time the message code::next:: is passed.
code::
(
var a, b;
a = Pseq(#[1, 2, 3],inf).collect({ arg item; item * 3 });
a.postln;
x = a.asStream;
9.do({ x.next.postln; });
)
::
** class:: Pconst
summary:: constrain the sum of a value pattern
related:: Classes/Pfindur, Classes/Pfin, Classes/Pfinval
categories:: Streams-Patterns-Events>Patterns>Repetition

description::

Similar to link::Classes/Pfindur::, but works with the value directly.

note::
Be careful if this is used, directly or indirectly, for a note-length parameter! The difference may be very small and this could result in zombie nodes, due to a bug in link::Classes/EnvGen:: for very short sustain times.
::

ClassMethods::

method::new
Embeds elements of the strong::pattern:: into the stream until the sum comes close enough to strong::sum::. At that point, the difference between the specified sum and the actual running sum is embedded.

Examples::

code::
(
var a, x;
a = Pconst(5, Prand([1, 2, 0.5, 0.1], inf));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)


//Pconst used as a sequence of pitches

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
Pn(
	Pbind(
		\dur, Pconst(1, Prand([1, 0.02, 0.2], inf)),
		\instrument, \help_sinegrain,
		\degree, Pseries(0, 1, inf),
		\octave, 6
	)
).play;
)
::
** class:: Pdef
summary:: stream reference definition
categories:: Libraries>JITLib>Patterns
related:: Classes/Pdefn, Classes/PdefGui

description::
Pdef is a class that provides an interface to its superclass link::Classes/EventPatternProxy::, keeping a reference to a stream that can be replaced while playing. One pattern may be used in many streams in different places. A change in the pattern definition propagates through all streams.

Pdef and Pdefn use separate global collections.

code::
Pdef(key)	//returns the instance
Pdef(key, pat)	//stores the pattern and returns the instance, like Tdef and Ndef.
::

It can be used to store event Patterns globally. Changes in this global library have immediate effect.

For strong::non-event patterns:: link::Classes/Pdefn:: is used instead. For another use of Pdef see also link::Tutorials/JITLib/recursive_phrasing::. Graphical overview over all current Pdefs: link::Classes/PdefAllGui::. Overview: link::Overviews/JITLib::.

subsection::First Example

code::
s.boot;

Pdef(\x, Pbind(\note, Pbrown(0, 6, 0.1, inf)));
Pdef(\x).quant = 0; // no waiting.
Pbindf(Pdef(\x), \dur, 0.03).play;
Pbindf(Pdef(\x), \dur, 0.1, \ctranspose, 15).play;
Pbindf(Pdef(\x), \dur, 0.3, \ctranspose, 2).play;
// now change the definition
Pdef(\x, Pbind(\note, Pseq([0, 3, 5, 7, 9, 11], inf)));
Pdef(\x, Pbind(\freq, Pseq([1000, 1923, 245.2, 1718] / 1.2 + 0.1, inf)));
::

ClassMethods::

private::initClass

subsection::Creation

method::new
Store the pattern in a global dictionary under key, replacing its pattern with the new one. If the pattern is a strong::function::, Pdef creates a link::Classes/PlazyEnvir:: internall that dynamically creates the pattern returned from the function, applying the arguments from the inevent.

Using strong::*new(key):: you can access the pattern at that key (if none is given, a default silent event is created)

method::default
Default source, if none is given. The default is an Event.silent of 1.0 beat duration.

method::removeAll
Remove all proxies from the global dictionary ( link::#*all:: )

method::clear
Clear all proxies, setting their source to silence.

method::all
Set or return the environment ( link::Classes/IdentityDictionary:: ) that stores all Pdefs.

method::defaultQuant
Set the default quantisation for new instances (default: 1.0). This can be an array [quant, phase, timingOffset, outset]

InstanceMethods::

subsection::Changing the definition / setting the source

One pattern may have many streams in different places. A change in the pattern definition Pdef propagates through all streams. The change does not have to be immediate - there is a scheme to schedule when the change becomes effective: a strong::quant:: and strong::clock:: (like elsewhere) and a strong::condition::.

method::quant
Set the quantisation time for beat accurate scheduling.

argument::val
can be an array strong::[quant, phase, timingOffset, outset] ::, or just strong::[quant, phase]:: etc.

method::condition
Provide a condition under which the pattern is switched when a new one is inserted. The stream value and a count value is passed into the function.

method::count
Create and update condition that simply counts up to n and switches the pattern then

method::reset
Switch the pattern immediately (stuck conditions can be subverted by this).

method::fadeTime
When the synthdefs that are used contain an code::\amp:: control, the patterns are replaced by crossfading the previous with the new over this time (in beats)

method::envir
Set the event for the Pdef. It is used to filter the incoming stream before it is passed to the source pattern. This is similar to link::Classes/NodeProxy#-nodeMap::. When set for the first time, the pattern is rebuilt.

method::set
Set arguments in the default event. If there is none, it is created and the pattern is rebuilt.

method::map
Map Pdefn to the keys in the event.

method::clear
Set the source to nil

method::endless
Returns a link::Classes/Prout:: that plays the proxy endlessly, replacing strong::nil:: with a strong::default:: value (silent event). This allows to create streams that idle on until a new pattern is inserted.

subsection::Pdef as stream reference

A single Pdef may serve as a definition for multiple streams. These methods show how to fork off separate streams from one instance. Even if they run in different contexts, their definition may still be changed.

method::fork
Play an independent stream in parallel.

argument::quant
can be an array of [quant, phase, offset], or a link::Classes/Quant:: value.

method::embed
Pass a value (typically an link::Classes/Event::) into the pattern inval, and embed the Pdef in the stream.

embedInStream
just like any pattern, embeds itself in stream

subsection::Pdef as EventStreamPlayer

For live coding, each Pdef also may control one instance that plays one stream off it. This is an link::Classes/EventStreamPlayer::, accessible in the instance variable link::#-player::.

method::play
Starts the Pdef and creates a player.

argument::quant
can be an array of [quant, phase, offset] or a link::Classes/Quant:: value.

method::stop
Stops the player

method::player
Return the current player (if the Pdef is simply used in other streams this is nil)

method::pause, resume, reset
Perform this method on the player.

method::isPlaying
Returns true if player is running. If a Pdef is playing and its stream ends, it will schedule a stream for playing strong::as soon as a new one is assigned to it::. If it is stopped by strong::stop::, it won't.

Examples::

subsection::Pdef as stream reference

code::
(
SynthDef("Pdefhelp", { arg out, freq, sustain=1, amp=1, pan;
	var env, u=1;
	env = EnvGen.kr(Env.perc(0.03, sustain), 1, doneAction:2);
	3.do { var d; d = exprand(0.01, 1); u = SinOsc.ar(d * 300, u, rrand(0.1,1.2) * d, 1) };
	Out.ar(out, Pan2.ar(SinOsc.ar(u + 1 * freq, 0, amp * env), pan));

}).add;
)
s.boot;

Pdef(\metronom, Pbind(\instrument, \Pdefhelp, \dur, 1, \degree, 16, \legato, 0.1)).play;

x = Pseq([Pdef(\a), Pdef(\b), Pdef(\c)], inf).play;

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 5, 4, 3])));
Pdef(\b, Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[7, 8, 7, 8])));
Pdef(\c, Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 1, 2], 2)));




Pdef(\c, Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[4, 3, 1, 2]*3)));


// infinite loops are scheduled (to ths clock's next beat by default) and released:

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.753, \degree, Pseq(#[0, 5, 4, 3, 2], inf)));
Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[0, 5, 4, 3] + 1, 1)));
Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.25, \degree, Pseq(#[0, 5, 4, 3] - 4, 1)));

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.125, \degree, Pseq(#[0, 5] - 1, 1)));
Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.753, \degree, Pshuf(#[0, 5, 4, 3, 2], inf)));

x.stop;
Pdef(\metronom).stop;

// Pdef can be used in multiple patterns:

(
x = Ppar([
	Pbindf(Pn(Pdef(\a), inf),
		\gtranspose, Pstutter(8, Pseq(#[0, 2, 0, 3],inf))
	),
	Pbindf(Pn(Pdef(\a), inf),
		\gtranspose, Pstutter(8, Pseq(#[7, 4, 0, 3],inf)),
		\dur, 0.6
	),
	Pbindf(Pn(Pdef(\a), inf),
		\degree, Pseq(#[0, 5, 4, 3, 2, 3, 2], 1)
	)
]).play;
)

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.1, \degree, Pseq(#[0, 1, 0, 1, 2], inf)));

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.2, \degree, Pseq([0, 4], inf)));

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 1, \degree, Pseq([0, 4], inf)));

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.2, \degree, Pseq([0, 4, Prand([6, 8b],2)], inf)));

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.1, \degree, Pseq(#[0, 1b, 1, 2b, 2, 3, 4b, 4, 5], inf)));

// using a fade time, the above changes are crossfaded
Pdef(\a).fadeTime = 2;

Pdef(\a, Pbind(\instrument, \Pdefhelp, \dur, 0.2, \degree, Pseq([0, 4, Prand([6, 8b],2)], inf)));

// ...

Pdef(\a).set(\detune, -50); // set environment
Pdef(\a).set(\detune, 0);

x.stop;
::

subsection::Pdef as EventStreamPlayer

code::
(
// load a synthdef
s.boot;
SynthDef("gpdef",
	{ arg out=0, freq=440, sustain=0.05, amp=0.1, pan;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain), doneAction:2) * amp;
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;
)


Pdef(\x); // creates a Pdef with a default pattern.


Pdef(\x).play; // play it. A silent resting pattern is used.
Pdef(\y).play; // play a second one (automatically instantiated)


// assign various patterns to it:

Pdef(\x, Pbind(\dur, 0.25, \instrument, \gpdef));
Pdef(\x, Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6], inf), \instrument, \gpdef));
Pdef(\x, Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6]+1, inf), \instrument, \gpdef));
Pdef(\y, Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6]-1, inf), \instrument, \gpdef));
Pdef(\y, Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b]-2, inf), \instrument, \gpdef));

// using fadeTime:

Pdef(\y).fadeTime = 8.0;
Pdef(\y, Pbind(\dur, 0.125, \degree, Pseq([3, 4, 5b, 6]+4.rand, inf), \instrument, \gpdef));
Pdef(\y, Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5b, 6]-2, inf), \instrument, \gpdef));

(
Pdef(\x, Pbind(
		\dur, 1 / 6,
		\degree, Pseq([3, 4, Prand([8, 2, 3, 9, 10],1) - 5, 6]+1, inf),
		\instrument, \gpdef
		)
	);
)
(
Pdef(\x, Pbind(
		\dur, 0.25,
		\degree, Pseq([3, 4, Prand([8, 2, 3, 9, 10],1), 6], inf),
		\instrument, \gpdef)
	);
)
Pdef(\x).stop;

Pdef(\x).play;

// tempo change
TempoClock.default.tempo = 1.3;
Pdef(\y, Pbind(\dur, 0.25, \degree, Pseq([3, 4, 5, 6]+1, inf), \instrument, \gpdef));

// drop in ending patterns

Pdef(\x, Pbind(\dur, 0.25, \degree, Pseq([3, [7,4], 5, 6]-2), \instrument, \gpdef));
Pdef(\x, Pbind(\dur, 0.125, \degree, Pseq([3, [7,4], 5, 4]-3), \instrument, \gpdef));
Pdef(\x, Pbind(\dur, 0.35, \degree, Pseq([3, [7,4], 5, 4, 3]-3), \instrument, \gpdef));
Pdef(\x, Pbind(\dur, 0.25, \degree, Pshuf([3, [7,4], 5, 6]-2), \instrument, \gpdef));


// clear all.
Pdef(\x).clear;
Pdef(\y).clear;
TempoClock.default.tempo = 1.0;


// GUI example: see also
PdefAllGui(18);
::

subsection::Recursion

Pdefs can be used recursively under the condition that the stream call structure allows it. a structure like the following works:

code::
Pdef(\x, Pseq([Pbind(\instrument, \gpdef), Pdef(\x)], inf));
Pdef(\x).play;
::

but the following would crash, because code::.embedInStream:: is called recursively with no limit:

code::
// Pdef(\y, Pseq([Pdef(\y), Pbind(\instrument, \gpdef)], inf));
::

subsection::Quantizing and outset

When quantizing to a larger number of beats, the changes become very slow if one has to wait for the next beat. Providing an strong::outset:: quant value is a way to make the change so that it appears as if it had been done at the previous grid point already. The stream is fast forwarded to the current position relative to the quant grid. Providing a number larger than zero, the next possible quant point is used as outset.

For example, if quant is 32, and one has just missed the first beat when changing the pattern,
one has to wait for 32 beats until the change happens. Using an outset of 1, it is assumed that you had already
changed the pattern at the first beat, the stream is fast forwarded to the time it would be at now if you had done so. The new pattern is inserted at the next beat (outset=1).

quant can be: strong::[quant, phase, timingOffset, outset]::

note::
This fast forwarding might create a cpu peak if the pattern is very complex/fast or quant is very long. This is hard to avoid, so it simply has to be taken into account.
::

code::
(
Pdef(\x).quant_([8, 0, 0, 1]);
Pdef(\y).quant_([8, 0.5, 0, 1]); // phase: half a beat
Pdef(\x).play;
Pdef(\y).play;
)

Pdef(\x, Pbind(\degree, Pseq((0..7)+2, inf)));
Pdef(\y, Pbind(\degree, Pseq((0..7)-2, inf)));
Pdef(\x, Pbind(\degree, Pseq((0..7)+2, inf), \dur, 0.5));
Pdef(\y, Pbind(\degree, Pseq((0..7).scramble-2, inf), \dur, 0.25, \legato, 0.3));
Pdef(\x, Pbind(\degree, Pseq((0..7), inf)));

Pdef(\x, Pbind(\degree, Pseq([ 1, 5, 6, 7, 0, 3, 2, 4 ], inf), \dur, 1));
Pdef(\x, Pbind(\degree, Pseq([ 0, 2, 2, 4, 0, 4, 0, 4 ], inf), \dur, 1));

Pdef(\x).quant_([8, 1/3, 0, 1]); // phase: 1/6 beat relative to y
Pdef(\x, Pbind(\degree, Pseq([ 1, 1, 1, 7, 0, 2, 2, 4 ], inf), \legato, 0.1));
Pdef(\x, Pbind(\degree, Pseq([ 3, 3, 3, 4b ], inf), \legato, 0.1));
Pdef(\y, Pbind(\degree, Pseq((0..7).scramble-4, inf), \dur, 0.25, \legato, 0.3));




// some testing
(
var quant = #[8, 0, 0, 1]; // quantise to 8 beats, no phase, insert quant to 1 beat
Pdef(\x).quant_(quant);
Pdef(\x).play;
Routine { loop { 8.do { |i| ("uhr:"+i).postln; 1.wait } } }.play(quant:quant);
Pbind(\degree, Pseq((0..7), inf)).play(quant:quant);
)

Pdef(\x, Pbind(\degree, Pseq((0..7)+2, inf)).trace(\degree));
Pdef(\x, Pbind(\degree, Pseq((0..7), inf) + [0, 3]).trace(\degree));
Pdef(\x, Pbind(\degree, Pseq((0..7), inf) + [0, 6], \dur, 0.5).trace(\degree));


Pdef(\x).fadeTime = 8;

Pdef(\x, Pbind(\degree, Pseq((0..7), inf)).trace(\degree));
Pdef(\x, Pbind(\degree, Pseq((0..7).reverse, inf) + [0, 6], \dur, 0.5));

Pdef(\x).fadeTime = nil;
Pdef(\x).quant = 1;

Pdef(\x, Pbind(\degree, Pseq((0..7), inf)).trace(\degree));

Pdef(\x).quant = 8;
Pdef(\x, Pbind(\degree, Pseq((0..7), inf)).trace(\degree));
::

subsection::Update condition

In order to be able to switch to a new pattern under a certain link::#-condition::, the instance variable condition can be set to a function that returns a boolean. Value and a count index are passed to the function. The condition is always valid for the strong::next pattern:: inserted. For stuck conditions, the link::#-reset:: message can be used.

As counting up (such as emphasis::"every nth event, a swap can happen"::) is a common task, there is a method for this, called link::#-count::(n).

code::
Pdef(\x).play;
Pdef(\x).quant = 0; // we don't want quant here.
Pdef(\x, Pbind(\degree, Pseq((0..5), inf), \dur, 0.3)).condition_({ |val, i| i.postln % 6 == 0 });
Pdef(\x, Pbind(\degree, Pseq((0..7) + 5.rand, inf), \dur, 0.3)).condition_({ |val, i| (i % 8).postln == 0 });

// the above is equivalent to:
Pdef(\x, Pbind(\degree, Pseq((0..7) + 5.rand, inf), \dur, 0.3)).count(8);

// the value that is sent in is the event, so decisions can be made dependent on the event's fields
::

subsection::reset

code::
// reset to change immediately:
Pdef(\x).reset;
::
** class:: PdefAllGui
summary:: see all Pdefs and their state
categories:: Libraries>JITLib>GUI
related:: Classes/TdefAllGui, Classes/PdefGui

description::

PdefAllGui uses link::Classes/PdefGui:: views to display all Pdefs, or a selection. Overview: link::Overviews/JITLib::

ClassMethods::

subsection::Creation

method::new

argument::numItems
the maximum number of Pdefs that can be shown.

argument::parent
a parent view on which to display. If nil, a new window is created; strong::parent:: can also be an existing window or a composite view.

argument::bounds
a desired size and position where to display a JITGui. can be nil, a link::Classes/Point::, or a link::Classes/Rect::. JITGuis know their minimum size ( strong::minSize:: ), and if bounds is nil, minSize is used. if bounds is a point or rect, it will be set to at least minSize. With a rect one can also supply a position where to display. If a point,shown size is the maximum of bounds and minSize.

argument::makeSkip
///// Not Done Yet, but on the list

A flag whether to make a skipjack.

argument::options
///// Not Done Yet, but on the list

the only option for PdefAllGui will be [\makeEdit]. adding a "front" PdefGui that also shows the front Pdef's envir.

Examples::

code::
(
Pdef(\a, { |e| 100.do { |i| i.postln; 0.5.wait } });
Pdef(\b, { |e| 100.do { |i| Pdef(\a).set(\otto, 8.rand); exprand(0.1, 3.0).wait } });
t = PdefAllGui(8);
)

	// if you have too many Pdefs, an ezscroller lets you select
"abcdefghijk".do { |ch| Pdef(ch.asSymbol) };

	// you can also filter which ones you see:
Pdef(\a_otti);
Pdef(\a_annerl);
Pdef(\a_bebe);

	// or better from gui
t.prefix_("a_");
t.filtering_(true);

	// if prefix is "", it will filter anything with "_" in it.
t.prefix_("");
t.filtering_(false);
::
** class:: PdefEditor
summary:: will be replaced - please use PdefGui now!
categories:: Libraries>JITLib>GUI
related:: Classes/PdefGui

description::

warning::
has been rewritten and renamed link::Classes/PdefGui::, which has largely the same functionality, but is more consistent and more flexible. There are some changes to the strong::*new:: method:

definitionList::
## instead of || *new(px, nVars, height, width, parent, makeWatcher)
## PdefGui uses || *new (object, numItems, parent, bounds, extras)
::

strong::px:: is now strong::object::, strong::nVars:: is now strong::numItems::, strong::width & height:: can be put as strong::bounds: height @ width ::, strong::parent:: is still strong::parent::, strong::makeWatcher:: is now strong::makeSkip:: .

Please see link::Classes/PdefGui:: for more details.
::
** class:: PdefGui
summary:: a line of editing controls for a Pdef, and optionally its envir
categories:: Libraries>JITLib>GUI
related:: Classes/PdefAllGui, Classes/TdefGui, Classes/TdefAllGui

description::

A gui showing the link::Classes/Pdef::'s name, playing state, source state, and envir state. Optionally, its envir can also be edited.

subsection::First example

code::
g = PdefGui();			// make a PdefGui
g.object = Pdef(\a);		// show when a Pdef is put in
Pdef(\a, Pbind(\note, 12)); 	// show whether it has a source
Pdef(\a).play; 			// show whether playing, stopped, or ended, and pausable
Pdef(\a).set(\dur, 0.25); 	// show whether the Pdef has an envir
g.close;

g = PdefGui(Pdef(\a), 3);	// with an envirgui for 3 items
Pdef(\a).set(\lofreq, [1, 10], \str, "someString", \oops, \oneSymbolTooMany);
Pdef(\a).clear;
Pdef(\a).envir.clear;
g.close;

(				// put it in an existing window - margin is 0@0
w = Window("my win", Rect(200, 200, 300, 200)).front;
w.addFlowLayout;
PdefGui(Pdef(\a), 0, w);
PdefGui(Pdef(\a), 3, w);
)
::

subsection::Details on the GUI elements

definitionList::
## name button
|| when selected, typing the delete key will delete its Pdef.
## play/stop button
|| indicates whether the Pdef is playing:
table::
## " >" || if stopped,
## " _" || if playing and active,
## " |" || if it is playing, but the stream has ended.
::
## pause/resume button
|| only visible if one can pause or resume the Pdef, i.e. while it is playing.
table::
## "paus" || shown when you can pause it,
## "rsum" || shown when you can resume it.
::
## src button
|| opens a document to edit the source (function) of the Pdef.
table::
## green || a source exists,
## white || the source is nil.
::
## env button
|| opens a document to edit the environment of the Pdef, which is where one can keep all variables the Pdef uses for easy access.
table::
## green || the Pdef has an envir,
## white || the envir is nil.
::
::

ClassMethods::

subsection::Creation Methods

method::new
Create a new link::Classes/JITGui:: that will be watching an object and display its state.

argument::object
the object to watch

argument::numItems
the number of display items to use, e.g. how many fields for text, or how many EZSliders for single-number parameters.

argument::parent
a parent view on which to display. If nil, a new window is created; strong::parent:: can also be an existing window or a composite view.

argument::bounds
a desired size and position where to display a JITGui. can be nil, a link::Classes/Point::, or a link::Classes/Rect::. JITGuis know their minimum size ( strong::minSize:: ), and if bounds is nil, minSize is used. if bounds is a link::Classes/Point:: or link::Classes/Rect::, it will be set to at least minSize. With a rect one can also supply a position where to display. If a point,shown size is the maximum of bounds and minSize.

argument::makeSkip
A flag whether to make a skipjack.

argument::options
a list of additional information, e.g. flags about optional buttons. (this is used is some subclasses)

InstanceMethods::

method::object
a link::Classes/Pdef::, or nil

method::numItems
the number of items in the envirGui

method::parent
the parent view

method::bounds
the bounds of the link::#-zone::

method::zone
the link::Classes/CompositeView:: within which the PdefGui is shown

method::nameBut, playBut, pauseBut, srcBut, envBut
the buttons

method::envirGui
the gui for the Pdef's envir - nil if numItems is 0.

method::object
put an object in the gui.

method::moveTo
(if the jitGui is in its own window)

move it to some specific location.

method::clear
(if the jitGui is in its own window)

set the PdefGui's object to nil

method::close
(if the jitGui is in its own window)

and close its window.

subsection::Internal methods

method::srcString
a compileString that recreates the Pdef.

code::
// assume g from above is still there
g.srcString;
::

method::editString
a compileString that recreates the Pdef's envir at edKey.

method::editStrings
a compileString that recreates the Pdef's envir at edKeys.

argument::edKey
Default value is nil.

code::
// assume g from above is still there
g.editString;
Pdef(\a).set(\foo, \bar);
g.editString(\foo);

g.editStrings;
::

method::getUsedKeys
the keys in use in the envir

code::
g.getUsedKeys;
::

method::openDoc
open a document with some strings at some location

code::
g.openDoc(g.editStrings);
::

method::makeEnvirGui
make an envirGui within zone - called internally.

Examples::

code::
Pdef(\a, Pbind(\freq, Prand((1..16) * 55, inf)));
Pdef(\a).play;
t = PdefGui(Pdef(\a), 4);
Pdef(\a).set(\dur, 0.125, \amp, 0.05);

Pdef(\a).stop;
Pdef(\a).play;
Pdef(\a).pause;
Pdef(\a).resume;

t.object_(nil);
t.object_(Pdef(\a));

(
w = Window("put it in a selfmade window").front;
w.addFlowLayout;
w.view.decorator.shift(50, 50);
PdefGui(Pdef(\a), 12, w);
)

Pdef(\b, Pbind(\note, Pxrand((0..7), inf), \dur, 0.125));
Pdef(\b).play;
PdefGui(Pdef(\b));

	// see all Pdefs:
PdefAllGui(16);
::
** class:: Pdefn
summary:: non event stream reference definition
categories:: Libraries>JITLib>Patterns
related:: Classes/Pdef

description::
Pdefn provides an interface to its superclass link::Classes/PatternProxy::, keeping a reference to a stream that can be replaced while playing. One pattern may be used in many streams in different places. A change in the pattern definition propagates through all streams.

Pdef and Pdefn use separate global collections.

code::
Pdefn(key)	//returns the instance
Pdefn(key, pat)	//defines the pattern and returns the instance, like Pdef, Tdef and Ndef.
::

It is very similar to link::Classes/PatternProxy::.

Pdefn can be used to store value patterns globally (for strong::event patterns::, see link::Classes/Pdef::). Overview: link::Overviews/JITLib::

subsection::First Example

code::
s.boot;

Pdefn(\x, Pbrown(0, 6, 0.1, inf));
Pbind(\note, Pdefn(\x), \dur, 0.3).play;
Pbind(\note, Pdefn(\x), \dur, 0.1, \ctranspose, 15).play;
// now change the definition
Pdefn(\x, Pseq([0, 3, 5, 7, 9, 11], inf));
Pdefn(\x, Pseq([0, 3, 3, 7], inf) + Pseq([0, [0, 3], [0, 5, 7]], inf));
::

ClassMethods::

private::initClass

subsection::Creation

method::new
Store the pattern in a global dictionary under key, replacing its pattern with the new one. If the pattern is a strong::function::, Pdefn creates a link::Classes/Prout:: with this function, passing in the envir, if given(see below).

Using strong::*new(key):: you can access the pattern at that key (if none is given, a default silent event is created)

method::default
Default source, if none is given. The default is a Pattern that returns 1.0 (This is 1 and not 0 to avoid deadlocks when used as a duration pattern. In a sense, 1 is just as generic as 0).

method::removeAll
Remove all proxies from the global dictionary ( link::#*all::)

method::clear
Clear all proxies, setting their source to silence.

method::all
Set or return the environment ( link::Classes/IdentityDictionary:: ) that stores all Pdefns.

InstanceMethods::

private::prAdd

Examples::

subsection::Pdefn in expressions

code::
Pdefn(\c, Pdefn(\a) + Pdefn(\b));

t = Pdefn(\c).asStream; // create a stream from Pdefn(\c)

t.value; // default value for a Pdefn is 1, so that it is a good time value default.

Pdefn(\a, 100); // (re)define Pdefn(\a) as 100

t.value;

Pdefn(\b, Pseq([1, 2, 3], inf)); // (re)define Pdefn(\b) as Pseq([1, 2, 3], inf)

3.do { t.value.postln };

Pdefn(\c, Pdefn(\a) * Pdefn(\b) - Pdefn(\a)); // (re)define Pdefn(\c)

8.do { t.value.postln };

Pdefn(\a, Prand([1, 4, 2], inf)); // (re)define Pdefn(\a)
::

subsection::Embedding Pdefn in other patterns

code::
Pdefn(\x, Pseq([1, 2, 3], inf));

x = Pseq([0, 0, Pdefn(\x)], inf).asStream;

t = Task({ loop({ x.next.postln; 0.3.wait }) }).play;


Pdefn(\x, Pseq([55, 66, 77],inf));
Pdefn(\x, Pseq([55, 66, 77],1));

t.stop;



// Pdefn can be accessed in multiple streams

(
SynthDef("Pdefhelp", { arg out, freq, sustain=1, amp=1, pan;
	var env, u=1;
	env = EnvGen.kr(Env.perc(0.03, sustain), 1, doneAction:2);
	5.do { var d; d = exprand(0.01, 1); u = SinOsc.ar(d * 300, u, rrand(0.1,1.2) * d, 1) };
	Out.ar(out, Pan2.ar(SinOsc.ar(u + 1 * freq, 0, amp * env), pan));

}).add;
s.boot;
)

(
Pdefn(\deg, Pseq([0, 3, 2],inf));

Pset(\instrument, \Pdefhelp,
	Ppar([
		Pbind(\degree, Pdefn(\deg), \pan, -0.8),
		Pbind(\degree, Pdefn(\deg), \dur, 1/3, \pan, 0.8)
])
).play;
)

Pdefn(\deg, Prand([0, 3, [1s, 4]],inf));

Pdefn(\deg, Pn(Pshuf([0, 3, 2, 7, 6],2),inf));

(
Pdefn(\deg, Plazy { var pat;
	pat = [Pshuf([0, 3, 2, 7, 6],2), Pseries(0, 1, 11), Pseries(11, -1, 11)].choose;
	Pn(pat, inf)
});
)
::

subsection::Timing

When does the definition change?

If quant is set, the update is done at the next beat or whatever is specified:

code::
Pdefn(\deg).quant = 4;
Pdefn(\deg, Pn(Pseries(0, 1, 8),inf));

Pdefn(\deg).quant = nil; // activate immediately again

(
Pdefn(\deg, {
	loop {
	5.do { |i|
		#[1, 3, 4].choose.yield;
		#[5, 0, 12].choose.yield;
		#[14, 3, 4].choose.do { |j| (i % j).postln.yield };
	}
	}
})
)
::

subsection::update condition

In order to be able to switch to a new pattern under a certain condition, the instance variable strong::condition:: can be set to a function that returns a boolean. Value and a count index are passed to the function. The condition is always valid for the strong::next pattern:: inserted. For stuck conditions, the strong::reset:: message can be used.

As counting up (such as emphasis::"every nth event, a swap can happen"::) is a common task, there is a method for this, called strong::count(n)::.

code::
z = Pbind(\degree, Pdefn(\x, \), \dur, 0.25).play;
Pdefn(\x, Pseq((0..5), inf)).condition_({ |val, i| i.postln % 6 == 0 });
Pdefn(\x, Pseq((7..0), inf)).condition_({ |val, i| i.postln % 8 == 0 });


// the above is equvalent to:
Pdefn(\x, Pseq((7..0), inf)).count(8);
::

subsection::Reset

code::
// reset to change immediately:
Pdefn(\x).reset;

Pdefn(\x).stop;
::

subsection::Functions as arguments to Pdefn

code::
Pdefn(\deg, { loop { yield(0.1.rand.round(0.01) + [2, 3, 9].choose) } });

// equivalent to:

Pdefn(\deg, Proutine { loop { yield(0.1.rand.round(0.01) + [2, 3, 9].choose) } });

// this is not exactly true, see below..
::

subsection::The (inner) environment

code::
// set() creates a local environment that overrides the outer currentEnvironment

Pdefn(\z).set(\a, 1, \b, 5);
(
Pdefn(\z, { |e|
	loop { yield((e.a + e.b) + 0.1.rand.round(0.01)) }
})
); // [1]

t = Pdefn(\z).asStream;

t.nextN(3);

(
Pdefn(\z, { |e|
	//(e.a + e.b) + 0.1.rand.round(0.01) 1
	Pseq([1, 2, e.a], 1)
})
);

Pdefn(\z, Pseq([1, 2, 3], 1));

e = Pdefn(\z).envir


Pdefn(\z).set(\a, 3);

t.next;

Pdefn(\z).set(\a, Pseq([1, 2, 3], inf));

t.reset;
t.nextN(3);

Pdefn(\z).envir; // post the envir



// if you want to keep using the currentEnvironment at the same time,
// assign the currentEnvironment to the envir's parent (or proto) field
// (this shouldn't be a proxy space of course.)

Pdefn(\z).envir.parent = currentEnvironment;
~a = 9;
~b = 10;

t.nextN(3);
::
** class:: PdegreeToKey
summary:: index into a scale
related:: Classes/Scale
categories:: Streams-Patterns-Events>Patterns>Math

description::

Returns a series of notes derived from an index into a scale.

ClassMethods::

method::new

argument::pattern
integer index into the scale.

argument::scale
an array or pattern. If a pattern, it streams the scales accordingly.

argument::stepsPerOctave
the number of steps per octave in the scale.

Examples::

code::
(
Pbind(\note, PdegreeToKey(
			Pseq([1, 2, 3, 2, 5, 4, 3, 4, 2, 1], 2),
			#[0, 2, 3, 6, 7, 9],
			12
		),
	\dur, 0.25
).play;
)


(
var scales;
scales = #[[0, 2, 3, 6, 7, 9], [0, 1, 5, 6, 7, 9, 11], [0, 2, 3]];
Pbind(\note, PdegreeToKey(
			Pseq([1, 2, 3, 2, 5, 4, 3, 4, 2, 1], 4),
			Pstutter(3, Prand(scales, inf)),
			12
		),
	\dur, 0.25
).play;
)
::
** class:: Pdfsm
summary:: deterministic finite state machine
related:: Classes/Pfsm
categories:: Streams-Patterns-Events>Patterns>List>Indexing

description::

Pdfsm is a deterministic finite state machine with signal input (written by by ccos).

ClassMethods::

method::new

argument::list
a list consisting of the stream which gives input signals to determine state transitions, and then dictionary entries, one for each state, mapping the destinattion state and yield streams to those input signals.

argument::startState
an integer index for the state to start with.

argument::repeats
an integer giving the number of times the pattern should cycle. A cycle ends when the strong::signal stream:: ends or nil is given for the destination state to a signal value, see below.

Examples::

definitionList::
## list structure:
|| [
definitionList::
## signal stream || can be a stream of anything which can serve as a key for an associative collection. integers, symbols, etc... asStream is called on this for each repeat.
## states || states should be an instance of link::Classes/IdentityDictionary::, link::Classes/Event:: or some other associative collection.
::
## ] ||
## list syntax:
|| [
definitionList::
## signal stream, ||
## ( // state 0, ||
definitionList::
## signal value : [destination state, return stream or pattern], ||
## signal value : [destination state, return stream or pattern] ||
::
## ), ||
## ... // state 1 ... N ||
::
## ] ||
::

Any number of states can be given, and are indexed by the order in which they are given.

If the fsm is in state x and it receives a strong::signal value:: y it looks up y in the state dictionary supplied for x, if there is no y entry, it looks for a \default entry and uses that.

The next state is then set to strong::destination state::, and the stream yielded is given by strong::return stream or pattern::. That is unless the strong::destination state:: is given as nil, or if a strong::destination state:: is given for which you have not supplied a dictionary - in both cases the current cycle ends and any remaining repeats are executed. If there is no strong::signal value:: given for a particular signal, and no \default is supplied then one will get a runtime error.

code::
(
	p = Pdfsm(
		[
			Pseq( [\foo,\bar], 2 ), // foobar signals
			( // state 0
				\foo : [ 1, Pseq([ 0, 1 ], 2 ) ]
			),
			( // state 1
				\bar : [ 0, 3 ]
			)
		],
		0,
		2
	).asStream;

	11.do({ p.next.postln });
)

(
SynthDef(\help_Pdfsm1,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar([freq, freq + 0.1.rand2], 0, env))
	}).add;
)

(
var p;
p = Pdfsm(
	[
		Prand([0,1,2],inf),	// signalStream

		IdentityDictionary[	// state 0
			0 -> [ 2, Pseq([67,68,69], 2) ],
			1 -> [ 0, 66 ],
			2 -> [ 1, 65 ]
		],
		IdentityDictionary[	// state 1
			1 -> [ 1, Pseq([69,68,67],2) ],
			\default -> [ 0, 70 ]
		],
		IdentityDictionary[
			0 -> [ 0, 71 ],
			1 -> [ 0, 72 ],
			2 -> [ nil ]	// signalStream is infinitely long,
					// so the fsm only ends because of this nil
					// 2 -> [nil, nil] is also fine
		]
	],
	1, 				// startState
	1 				// repeats
).asStream;

Routine({
	var freq;
	while({ (freq = p.next.postln).notNil },{
		Synth(\help_Pdfsm1, [ \freq, freq.midicps ]);
		0.1.wait;
	})
}).play;
)

(
SynthDef(\help_Pdfsm2,
	{ arg freq, gate=1;
		var n=8, env, osc;
		env = Linen.kr( gate, 0.01, 1, 0.03, 2 );
		osc = {Mix.fill( n, { arg i;
			FSinOsc.ar(freq + Rand(-2.0,2.0), Rand(0, 0.05pi)) ring4:
			FSinOsc.ar(freq * (i+1));
		})}.dup * FSinOsc.kr(Rand(1.5,4.5),{Rand(-0.1pi,0.1pi)}.dup,0.6,env*0.4);
		Out.ar(0, env * osc / (n*4) )
	}).add;
)

(
var n=3, base, penult;

base = [3,4,4,0];

for( 1, n, { arg i;
	penult = Pbind( \degree, Pshuf(base - (i*5), 2), \dur, Pseq([0.2],2) );
	Pset(
		\instrument, \help_Pdfsm2,
		Pdfsm(
			[
				Pseq([	// signalStream
					Pn(1,22 + i),
					Pn(0,4),
					Pn(1,8),
					Pseq([
						Pn(0,3),
						Prand([0,1],8),
						Pn(1,8)
					], 3 ),
					Pn(2,2)
				], 1 ),
				(	// state 0
					0 : [ 0, Pbind( \degree, Pseq(base - i, 1), \dur, Pxrand([0.2,0.3],4) ) ],
					1 : [ 1, Pbind(
							\degree, Pseq(base.reverse - (i*2), 2),
							\dur, Pseq([0.2,0.21],1)
							)
						],
					2 :	[ 2, penult ]
				),
				(	// state 1
					0 : [ 0, Pbind( \degree, Pshuf(base * i.neg, 8), \dur, Pseq([0.08],8) ) ],
					1 : [ 0, Pbind( \degree, Pseq(base - (i*3),3+i), \dur, Pseq([0.11],3+i) ) ],
					2 : [ 2, penult ]
				),
				(	// state 2
					\default : [ 2, Pbind(
									\degree, Prand(base - (i*7), 5),
									\dur, Prand([0.6,0.8],5)
								)
							]
				)
			],
			i % 2 		// startState
		)
	).play;
})
)
::
** class:: Pdict
summary:: pattern that embeds patterns from a dictionary
categories:: Libraries>JITLib>Patterns
related:: Classes/Pbind

description::
A general purpose lookup stream.

Examples::

code::
SynthDescLib.read;

(
e = (
	a: Pbind(\dur, 0.1, \degree, Pseq([0, 5, 4, 3, 2])),
	b: Pbind(\dur, 0.06, \degree, Pseq([7, 8, 7, 8])),
	c: Pbind(\dur, 0.3, \degree, Pseq([0, 1, 2], 2))
);

x = Pdict(e, Pseq([
			\a, \b,
			Prand([\a, \c])
		], 4)
	);
x.play;
)
::
** class:: PdurStutter
summary:: partition a value into n equal subdivisions
related:: Classes/Pstutter
categories:: Streams-Patterns-Events>Patterns>Repetition

description::

A filter pattern designed for a stream of float durations.

Subdivides each duration by each stutter and yields that value stutter times. A stutter of 0 will skip the duration value, a stutter of 1 yields the duration value unaffected.

Examples::

code::
(
a = PdurStutter(
	Pseq(#[1,1,1,1,1,2,2,2,2,2,0,1,3,4,0],inf),
	Pseq(#[0.5, 1, 2, 0.25,0.25],inf)
);
x = a.asStream;
100.do({ x.next.postln; });
)


(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = PdurStutter(
	Pseq(#[1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4],inf),
	Pseq(#[0.5, 1, 2, 0.25,0.25],inf)
);
x = a.asStream;

Routine({
	loop({
		Synth.grain(\help_sinegrain, [\freq, 440]);
		x.next.wait;
	})
}).play(TempoClock.default);
)


(
a = PdurStutter(
	Pseq(#[1,1,1,1,1,2,2,2,2,2,3,3,3,3,4,4,0,4,4],inf),
	Pseq(#[0.5, 1, 2, 0.25,0.25],inf)
);
x = a.asStream;
Routine({
	loop({
		Synth.grain(\help_sinegrain, [\freq, 440]);
		x.next.wait;
	})
}).play(TempoClock.default);
)
::

Frequencies like being divided too.

code::
(
a = PdurStutter(
	Pseq(#[1,1,1,1,1,2,2,2,2,2,3,3,3,3,4,4,0,4,4],inf),
	Pseq((80 + [ 0, 2, 3, 5, 7, 9, 10 ]).midicps ,inf)
);
x = a.asStream;
Routine({
	loop({
		Synth.grain(\help_sinegrain, [\freq, x.next.postln]);
		0.25.wait
	})
}).play(TempoClock.default);
)
::
** class:: Peak
summary:: Track peak signal amplitude.
related:: Classes/PeakFollower
categories::  UGens>Analysis>Amplitude


Description::

Outputs the peak amplitude of the signal received at the input. When
a trigger occurs at the  code::reset::  input, the maximum
output value is reset to the current value.


Internally, the absolute value of the signal is used, to prevent
underreporting the peak value if there is a negative DC offset. To obtain
the minimum and maximum values of the signal as is, use the
link::Classes/RunningMin::  and  link::Classes/RunningMax::  UGens.


classmethods::

method::ar, kr

argument::in

The input signal.

argument::trig

Trigger. Resets the output value to the current input value. A trigger happens when the signal changes from non-positive to positive.


Examples::

code::

(
{
	SinOsc.ar(
			Peak.ar(Dust.ar(20), Impulse.ar(0.4)) * 500 + 200,
			0, 0.2
	)

}.play;
)

// follow a sine lfo, reset rate controlled by mouse x
(
{
	SinOsc.ar(
			Peak.kr(SinOsc.kr(0.2), Impulse.kr(MouseX.kr(0.01, 2, 1))) * 500 + 200,
			0, 0.2
	)

}.play;
)

::

** class:: PeakFollower
summary:: Track peak signal amplitude.
related:: Classes/Peak
categories::  UGens>Analysis>Amplitude


Description::

Outputs the peak amplitude of the signal received at the input. If level
is below maximum, the level decreases by the factor given in
code::decay:: .


Internally, the absolute value of the signal is used, to prevent
underreporting the peak value if there is a negative DC offset. To obtain
the minimum and maximum values of the signal as is, use the
link::Classes/RunningMin::  and  link::Classes/RunningMax::  UGens.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::decay

Decay factor.


Examples::

code::

s.boot;

// no decay
(
{
	SinOsc.ar(
			PeakFollower.ar(Dust.ar(20, Line.kr(0, 1, 4)), 1.0) * 1500 + 200,
			0, 0.2
	)

}.play;
)

// a little decay
(
{
	SinOsc.ar(
			PeakFollower.ar(Dust.ar(20, Line.kr(0, 1, 4)), 0.999) * 1500 + 200,
			0, 0.2
	)

}.play;
)

// mouse x controls decay, center of the
(
{
	var decay;
	decay = MouseX.kr(0.99, 1.00001).min(1.0);
	SinOsc.ar(
			PeakFollower.ar(Dust.ar(20), decay) * 1500 + 200,
			0, 0.2
	);

}.play;
)




// follow a sine lfo, decay controlled by mouse x
(
{
	var decay;
	decay = MouseX.kr(0, 1.1).min(1.0);
	SinOsc.ar(
			PeakFollower.kr(SinOsc.kr(0.2), decay) * 200 + 500,
			0, 0.2
	)

}.play;
)

::

** class:: Pen
summary:: Draw custom graphics
redirect:: implClass
categories:: GUI>Accessories
related:: Classes/QPenPrinter

description::
A class which allows you to draw custom graphics on a UserView or Window.

The following methods must be called within a link::Classes/Window#-drawFunc:: or a link::Classes/UserView#-drawFunc:: function, and will only be visible once the window or the view is refreshed. Each call to link::Classes/Window#-refresh:: or link::Classes/UserView#-refresh:: will 'overwrite' all previous drawing by executing the currently defined function, unless link::Classes/UserView#-clearOnRefresh:: is set to code::false::

classmethods::
private:: key

subsection:: Construct path
The following methods define paths. You will need to call link::#*stroke:: or link::#*fill:: to actually draw them.

method:: moveTo
Move the Pen to point.
argument:: point
An instance of link::Classes/Point::

method:: lineTo
Draw a line (define a path) from the current position to point.
argument:: point
An instance of link::Classes/Point::

method:: line
Draw a line (define a path) from p1 to p2. Current position will be p2.
argument:: p1
An instance of link::Classes/Point::
argument:: p2
An instance of link::Classes/Point::

method:: curveTo
Draws a cubic bezier curve from the current position to point. 
strong::cpoint1:: and strong::cpoint2:: are control points determining the curve's curvature.
argument:: endPoint
An instance of link::Classes/Point::
argument:: cPoint1
An instance of link::Classes/Point::
argument:: cPoint2
An instance of link::Classes/Point::

method:: quadCurveTo
Draws a quad bezier curve from the current position to point. 
strong::cpoint1:: is a control point determining the curve's curvature.
argument:: endPoint
An instance of link::Classes/Point::
argument:: cPoint1
An instance of link::Classes/Point::

method:: arcTo
Draws an arc of a circle using a radius and tangent points.
argument:: point1
The end point of the first tangent line. Its start point is the current position. An instance of link::Classes/Point::
argument:: point2
The end point of the second tangent line. Its start point is point1. An instance of link::Classes/Point::
argument:: radius
The radius of the arc.
discussion::
example:
code::
(
var w = Window("arcTo", Rect(100, 200, 300, 300)).front;
var r= 15;
w.drawFunc = { |v|
    Pen.fillColor = Color.blue;
    Pen.strokeColor = Color.red;
    Pen.moveTo(150@150);
    Pen.arcTo(200@150, 200@225, r);
    Pen.arcTo(200@225, 100@225, r);
    Pen.arcTo(100@225, 100@150, r);
    Pen.arcTo(100@150, 150@150, r);
    Pen.lineTo(150@150);
    Pen.fillStroke;
};
)
::

method:: addArc
Draw an arc around the link::Classes/Point:: strong::center::, at strong::radius:: number of pixels. strong::startAngle:: and strong::arcAngle:: refer to the starting angle and the extent of the arc, and are in radians [0..2pi].
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    Pen.translate(100, 100);
    10.do{
        // set the Color
        Pen.color = Color.red(rrand(0.0, 1), rrand(0.0, 0.5));
        Pen.addArc((100.rand)@(100.rand), rrand(10, 100), 2pi.rand, pi);
        Pen.perform([\stroke, \fill].choose);
    }
};
w.refresh;
)
::

method:: addWedge
Draw a wedge around the link::Classes/Point:: strong::center::, at strong::radius:: number of pixels. strong::startAngle:: and strong::sweepLength:: refer to the starting angle and the extent of the arc, and are in radians [0..2pi].
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    Pen.translate(100, 100);
    10.do{
        // set the Color
        Pen.color = Color.blue(rrand(0.0, 1), rrand(0.0, 0.5));
        Pen.addWedge((100.rand)@(100.rand), rrand(10, 100), 2pi.rand, 2pi.rand);
        Pen.perform([\stroke, \fill].choose);
    }
};
w.refresh;
)
::

method:: addAnnularWedge
Draw an annular wedge around the link::Classes/Point:: strong::center::, from strong::innerRadius:: to strong::outerRadius:: in pixels. strong::startAngle:: and strong::sweepLength:: refer to the starting angle and the extent of the arc, and are in radians [0..2pi].
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    Pen.translate(100, 100);
    1000.do{
        // set the Color
        Pen.color = Color.green(rrand(0.0, 1), rrand(0.0, 0.5));
        Pen.addAnnularWedge(
            (100.rand)@(100.rand),
            rrand(10, 50),
            rrand(51, 100),
            2pi.rand,
            2pi.rand
        );
        Pen.perform([\stroke, \fill].choose);
    }
};
w.refresh;
)
::

method:: addRect
Adds a link::Classes/Rect:: to the drawing.
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    80.do{
        // set the Color
        Pen.color = Color.green(rrand(0.0, 1), rrand(0.0, 0.5));
        Pen.addRect(
            Rect(20, 20, (w.bounds.width-40).rand, (w.bounds.height-40).rand)
        );
        Pen.perform([\stroke, \fill].choose);
    }
};
w.refresh;
)
::

method:: addOval
Adds an Oval shape that fits inside the link::Classes/Rect:: to the current path.


subsection:: Draw the path

method:: stroke
Outline the previous defined path.
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    // set the Color
    Pen.strokeColor = Color.red;
    Pen.moveTo(200@100);

    Pen.lineTo(250@200);
    Pen.lineTo(300@200);
    Pen.lineTo(200@250);
    Pen.lineTo(100@200);
    Pen.lineTo(150@200);
    Pen.lineTo(200@100);

    Pen.stroke
};
w.refresh;
)
::

method:: fill
Fill the previous defined path. 
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    // set the Color
    Pen.fillColor = Color.red;
    Pen.moveTo(200@100);

    Pen.lineTo(250@200);
    Pen.lineTo(300@200);
    Pen.lineTo(200@250);
    Pen.lineTo(100@200);
    Pen.lineTo(150@200);
    Pen.lineTo(200@100);

    Pen.fill
};
w.refresh;
)
::

method:: draw
Draw the previous defined path using any of the following options:
argument:: style
table::
## 0 || fill
## 1 || fill using even-odd rule
## 2 || stroke
## 3 || fill and stroke the current path
## 4 || fill and stroke using even-odd rule
::
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    // set the Color
    Pen.fillColor = Color.red;
    Pen.moveTo(200@100);

    Pen.lineTo(250@200);
    Pen.lineTo(300@200);
    Pen.lineTo(200@250);
    Pen.lineTo(100@200);
    Pen.lineTo(150@200);
    Pen.lineTo(200@100);

    Pen.draw(4); // fill and then stroke
};
w.refresh;
)
::

method:: fillStroke
Fill and stroke the current path. Shortcut to the draw(3) method.


subsection:: Construct and draw
These methods do not require separate calls to link::#*stroke:: or link::#*fill::.

method:: strokeRect
Strokes a link::Classes/Rect:: into the window.

method:: fillRect
Draws a filled link::Classes/Rect:: into the window.

method:: strokeOval
Strokes an oval into the window.

method:: fillOval
Draws a filled oval into the window.

subsection:: Gradients

method:: fillAxialGradient
Fills an Axial gradient.
discussion::
example:
code::
(
w = Window.new.front;
w.drawFunc = {
    // fill the gradient
    Pen.addRect(w.view.bounds.insetBy(30));
    Pen.fillAxialGradient(w.view.bounds.leftTop, w.view.bounds.rightBottom, Color.rand, Color.rand);
};
w.refresh;
)
::

method:: fillRadialGradient
Fills a Radial gradient.
discussion::
example:
code::
(
w = Window.new.front;
w.drawFunc = {
    // fill the gradient
    Pen.addOval(w.view.bounds.insetBy(30));
    Pen.fillRadialGradient(w.view.bounds.center,
        w.view.bounds.center, 0, w.bounds.width, Color.rand, Color.rand);
};
w.refresh;
)
::

subsection:: Graphics State Methods

The following commands transform the graphics state, i.e. they effect all subsequent drawing commands. These transformations are cumulative, i.e. each command applies to the previous graphics state, not the original one.

method:: translate
Translate the coordinate system to have its origin moved by x,y
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    Pen.strokeColor = Color.blue;
    Pen.translate(200,100); // 0@0 is now 200@100
    Pen.moveTo(0@0);
    Pen.lineTo(50@100);
    Pen.lineTo(100@100);
    Pen.lineTo(0@150);
    Pen.lineTo(-100@100);
    Pen.lineTo(-50@100);
    Pen.lineTo(0@0);
    Pen.stroke
};
w.refresh;
)
::
Cumulative translations:
code::
(
w = Window.new.front;
w.view.background_(Color.clear);
w.drawFunc = {
    Pen.strokeColor = Color.black;
    35.do { // draw 35 lines
        Pen.moveTo(0@0);
        Pen.lineTo(50@350);
        Pen.translate(10, 0); // shift 10 to the right every time
        Pen.stroke
    }
};
w.refresh;
)
::

method:: scale
Scales subsequent drawing. x and y are scaling factors (i.e. 1 is normal, 2 is double size, etc.).
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    Pen.strokeColor = Color.green;
    Pen.translate(200,100);
    Pen.scale(0.5, 2);
    Pen.moveTo(0@0); // you have to set a starting point...
    Pen.lineTo(50@100);
    Pen.lineTo(100@100);
    Pen.lineTo(0@150);
    Pen.lineTo(-100@100);
    Pen.lineTo(-50@100);
    Pen.lineTo(0@0);
    Pen.stroke
};
w.refresh;
)
::

method:: skew
Skews subsequent drawing. x and y are skewing factors (i.e. 1 is normal).
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    Pen.fillColor = Color.green(0.5, 0.8);
    Pen.translate(200,100);
    Pen.skew(0.5, 0.2);
    Pen.moveTo(0@0); // you have to set a starting point...
    Pen.lineTo(50@100);
    Pen.lineTo(100@100);
    Pen.lineTo(0@150);
    Pen.lineTo(-100@100);
    Pen.lineTo(-50@100);
    Pen.lineTo(0@0);
    Pen.fill
};
w.refresh;
)
::

method:: rotate
Rotates subsequent drawing around the link::Classes/Point:: code::x@y:: by the amount strong::angle:: in radians [0..2pi].
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
c = 0;
w.drawFunc = {
    Pen.translate(220, 200);
    10.do({
        Pen.translate(0,10);
        Pen.fillColor = Color.hsv(c.fold(0, 1), 1, 1, 0.5);
        Pen.moveTo(0@0); // you have to set a starting point...
        Pen.lineTo(50@100);
        Pen.lineTo(100@100);
        Pen.lineTo(0@150);
        Pen.lineTo(-100@100);
        Pen.lineTo(-50@100);
        Pen.lineTo(0@0);
        Pen.fill;
        Pen.rotate(0.2pi);
        c = c + 0.1;
    });
};
w.refresh;
)
::

method:: matrix
Gets or sets the coordinate system transformation matrix.
note::Getter only available in Qt GUI::

See link::#Matrix example:: for an example.

argument:: matrixArray
An array of the form code::[ zoomX, shearingY, shearingX, zoomY, translateX, translateY ]::

method:: width
Sets the width of the Pen for the whole stroke

method:: use
Draw function, and then revert to the previous graphics state. This allows you to make complex transformations of the graphics state without having to explicitly revert to get back to 'normal'.
discussion::
example:
code::
(
// modified by an example of Stefan Wittwer
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    //paint origin
    Pen.fillColor = Color.gray(0, 0.5);
    Pen.addArc(0@0, 20, 0, 2pi);
    Pen.fill;
    Pen.width = 10;

    Pen.use { // draw something complex...
        Pen.width = 0.5;
        Pen.translate(100,100);
        Pen.fillColor = Color.blue;
        Pen.addArc(0@0, 10, 0, 2pi);
        Pen.fill;
        20.do{
            Pen.moveTo(0@0);
            Pen.lineTo(100@0);
            Pen.strokeColor = Color.red(0.8, rrand(0.7, 1));
            Pen.stroke;
            Pen.skew(0, 0.1);
        };
    };

    // now go on with all params as before
    // translation, skewing, width, and color modifications do not apply
    Pen.line(10@120, 300@120);
    Pen.stroke;
};
w.refresh
)
::

method:: path
Make a path, consisting of the drawing made in function.
note::
Unfortunately not working for now... 
(there's no Pen.endPath which currently is used in this method)
::

method:: beginPath
Discard any previous path.

method:: beginTransparencyLayer
Begins a new transparency layer. Transparency layers are useful when you want to apply an effect to a group of objects or create a composite graphic. See link::#Transparency layer example::.

method:: endTransparencyLayer
Ends the current transparency layer.

method:: clip
Use the previously defined path as a clipping path.
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
    // outline the clipping path
    Pen.moveTo(110@110);
    Pen.lineTo(290@110);
    Pen.lineTo(290@240);
    Pen.lineTo(110@240);
    Pen.lineTo(110@110);
    // now clip
    Pen.clip;

    // everything else we draw is now clipped
    Pen.fillColor = Color.yellow;
    Pen.fillRect(Rect(0,0,400,400));
    Pen.fillColor = Color.red;
    Pen.moveTo(200@100);

    Pen.lineTo(250@200);
    Pen.lineTo(300@200);
    Pen.lineTo(200@250);
    Pen.lineTo(100@200);
    Pen.lineTo(150@200);

    Pen.fill;
};
w.refresh;
)
::

method:: smoothing
Turns on/off anti-aliasing.
discussion::
example:
code::
(
var w = Window("smoothing", Rect(100, 200, 500, 300)).front;
w.view.background_(Color.white);
w.drawFunc = { |v|
    Pen.strokeColor = Color.grey(0.25);
    Pen.smoothing_(false); //no anti-aliasing
    50.do{|i|
        Pen.moveTo(50@50.rrand(250));
        Pen.lineTo(250@50.rrand(250));
    };
    Pen.stroke;
    Pen.smoothing_(true); //anti-aliasing (default)
    50.do{|i|
        Pen.moveTo(250@50.rrand(250));
        Pen.lineTo(450@50.rrand(250));
    };
    Pen.stroke;
};
)
::

method:: setShadow
Will fill the current path with a shadow.
You should use this option between Pen.push / Pen.pop (or Pen.use)

method:: joinStyle
Set the lines joining style according to the defined options:
table::
## 0 || miter
## 1 || round
## 2 || bevel
::

method:: capStyle
Set the lines joining style according to the defined options:
table::
## 0 || butt
## 1 || round
## 2 || square
::
discussion::
example:
code::
(
w = Window.new.front;
w.view.background_(Color.white);
StaticText(w, Rect(0,0,180,20))
    .string_(" Change Line Cap & Join Styles: ");
y = PopUpMenu(w, Rect(180,0,130,20))
    .items_(["Butt - Miter", "Round - Round", "Square - Bevel"])
    .action_({w.refresh});
w.drawFunc = {
    Pen.strokeColor = Color.red;
    Pen.width_(8.0);
    Pen.capStyle_(y.value);
    Pen.joinStyle_(y.value);
    Pen.moveTo(200@100);
    Pen.lineTo(250@200);
    Pen.lineTo(300@200);
    Pen.lineTo(200@250);
    Pen.lineTo(100@200);
    Pen.lineTo(150@200);
    Pen.lineTo(200@100);
    Pen.stroke;
};
w.refresh;
)
::

method:: alpha
Set the opacity level.

method:: blendMode
Set the blending mode to use.
See link::#Blending modes:: for more information.

method:: lineDash
Set the line dash pattern. 
pattern should be a link::Classes/FloatArray:: of values that specify the lengths of the painted segments and not painted segments.

examples::
Simple rotating and scaling:
code::
(
	w = Window("Pen Rotation and Scaling", Rect(128, 64, 360, 360));
	w.drawFunc = {
		Pen.use {
			// use the same rect for everything, just scale and rotate
			var r = Rect(0,0,200,80);
			Pen.fillColor = Color.black;
			// offset all subsequent co-ordinates
			Pen.translate(80,20);
			Pen.fillRect(r);
			Pen.fillColor = Color.red;
			// scale all subsequent co-ordinates
			Pen.scale(0.8, 0.8);
			Pen.translate(8,10);
			// rotate all subsequent co-ordinates
			Pen.rotate(0.1pi);
			Pen.fillRect(r);
			Pen.strokeColor = Color.blue;
			// lather, rinse, repeat
			Pen.scale(0.8, 0.8);
			Pen.rotate(0.1pi);
			Pen.width = 3;
			Pen.strokeRect(r);
			Pen.fillColor = Color.yellow(1,0.5);
			Pen.scale(0.8, 0.8);
			Pen.rotate(0.1pi);
			Pen.translate(20,-20);
			Pen.fillOval(r);
		}
	};

	w.front;
)
::
Redraw at random interval, different every time:
code::
(
var w, run = true;
w = Window("my name is... panel", Rect(128, 64, 800, 800));
w.view.background = Color.white;
w.onClose = { run = false; };
w.front;
w.drawFunc = {
	Pen.use {
		Pen.width = 0.2;
		400.do {
			Pen.beginPath;
			Pen.moveTo(Point(10.rand * 80 + 40, 10.rand * 80 + 40));
			Pen.lineTo(Point(10.rand * 80 + 40, 10.rand * 80 + 40));
			Pen.stroke;
		};
	};
};

{ while { run } { w.refresh; 1.0.rand.wait } }.fork(AppClock)

)
::
code::
(
var w, run = true;
w = Window("my name is... panel", Rect(128, 64, 800, 500));
w.view.background = Color.white;
w.onClose = { run = false; };
w.front;
w.drawFunc = {
	Pen.use {
		Pen.width = 2;
		80.do {
			Pen.width = rrand(0,4) + 0.5;
			Pen.beginPath;
			Pen.moveTo(Point(800.rand, 500.rand));
			Pen.lineTo(Point(800.rand, 500.rand));
			Pen.stroke;
		};
	};
};

{ while { run } { w.refresh; 1.0.rand.wait } }.fork(AppClock)

)
::

subsection:: Animation

Uses random seed to 'store' data
By reseting the seed each time the same random values and shapes are generated for each 'frame'
These can then be subjected to cumulative rotation, etc., by simply incrementing the phase var.
code::
(
// By James McCartney
var w, h = 700, v = 700, seed, run = true, phase = 0;
w = Window("wedge", Rect(40, 40, h, v), false);
w.view.background = Color.rand(0,0.3);
w.onClose = { run = false }; // stop the thread on close
w.front;
// store an initial seed value for the random generator
seed = Date.seed;
w.drawFunc = {
	Pen.width = 2;
	Pen.use {
		// reset this thread's seed for a moment
		thisThread.randSeed = Date.seed;
		// now a slight chance of a new seed or background color
		if (0.006.coin) { seed = Date.seed; };
		if (0.02.coin) { w.view.background = Color.rand(0,0.3); };
		// either revert to the stored seed or set the new one
		thisThread.randSeed = seed;
		// the random values below will be the same each time if the seed has not changed
		// only the phase value has advanced
		Pen.translate(h/2, v/2);
		// rotate the whole image
		// negative random values rotate one direction, positive the other
		Pen.rotate(phase * 1.0.rand2);
		// scale the rotated y axis in a sine pattern
		Pen.scale(1, 0.3 * sin(phase * 1.0.rand2 + 2pi.rand) + 0.5 );
		// create a random number of annular wedges
		rrand(6,24).do {
			Pen.color = Color.rand(0.0,1.0).alpha_(rrand(0.1,0.7));
			Pen.beginPath;
			Pen.addAnnularWedge(Point(0,0), a = rrand(60,300), a + 50.rand2, 2pi.rand 
				+ (phase * 2.0.rand2), 2pi.rand);
			if (0.5.coin) {Pen.stroke}{Pen.fill};
		};
	};
};

// fork a thread to update 20 times a second, and advance the phase each time
{ while { run } { w.refresh; 0.05.wait; phase = phase + 0.01pi;} }.fork(AppClock)

)
::
code::
(
var w, phase = 0, seed = Date.seed, run = true;
w = Window("my name is... panel", Rect(128, 64, 800, 800));
w.view.background = Color.blue(0.4);
w.onClose = { run = false; };
w.front;
w.drawFunc = {
	Pen.use {
		if (0.02.coin) { seed = Date.seed; };
		thisThread.randSeed = seed;
		Pen.strokeColor = Color.white;
		200.do {
			var a = 4.rand;
			var b = 24.rand;
			var r1 = 230 + (50 * a);
			var a1 = 2pi / 24 * b + phase;
			var r2 = 230 + (50 * (a + 1.rand2).fold(0,3));
			var a2 = 2pi / 24 * (b + (3.rand2)).wrap(0,23) + phase;
			Pen.width = 0.2 + 1.0.linrand;
			Pen.beginPath;
			Pen.moveTo(Polar(r1, a1).asPoint + Point(400,400));
			Pen.lineTo(Polar(r2, a2).asPoint + Point(400,400));
			Pen.stroke;
		};
		thisThread.randSeed = Date.seed;
		40.do {
			var a = 4.rand;
			var b = 24.rand;
			var r1 = 230 + (50 * a);
			var a1 = 2pi / 24 * b + phase;
			var r2 = 230 + (50 * (a + 1.rand2).fold(0,3));
			var a2 = 2pi / 24 * (b + (3.rand2)).wrap(0,23) + phase;
			Pen.width = 0.2 + 1.5.linrand;
			Pen.beginPath;
			Pen.moveTo(Polar(r1, a1).asPoint + Point(400,400));
			Pen.lineTo(Polar(r2, a2).asPoint + Point(400,400));
			Pen.stroke;
		};
	};
};

{ while { run } { w.refresh; 0.1.wait; phase = phase + (2pi/(20*24)) } }.fork(AppClock)

)
::

code::
(
var w, h = 800, v = 600, seed = Date.seed, phase = 0, zoom = 0.7, zoomf = 1, run = true;
w = Window("affines", Rect(40, 40, h, v));
w.view.background = Color.blue(0.4);
w.onClose = { run = false };
w.front;
w.drawFunc = {
	thisThread.randSeed = Date.seed;
	if (0.0125.coin) { seed = Date.seed; phase = 0; zoom = 0.7; zoomf = exprand(1/1.01, 1.01); }
	{ phase = phase + (2pi/80); zoom = zoom * zoomf; };
	thisThread.randSeed = seed;
	Pen.use {
		var p1 = Point(20.rand2 + (h/2), 20.rand2 + (v/2));
		var p2 = Point(20.rand2 + (h/2), 20.rand2 + (v/2));
		var xscales = { exprand(2** -0.1, 2**0.1) } ! 2;
		var yscales = { exprand(2** -0.1, 2**0.1) } ! 2;
		var xlates = { 8.rand2 } ! 2;
		var ylates = { 8.rand2 } ! 2;
		var rots = { 2pi.rand + phase } ! 2;
		var xform;
		xscales = (xscales ++ (1/xscales)) * 1;
		yscales = (yscales ++ (1/yscales)) * 1;
		xlates = xlates ++ xlates.neg;
		ylates = ylates ++ xlates.neg;
		rots = rots ++ rots.neg;
		xform = {|i| [xlates[i], ylates[i], rots[i], xscales[i], yscales[i]] } ! 4;
		Pen.strokeColor = Color.grey(1,0.5);
		Pen.width = 8.linrand + 1;
		Pen.translate(400, 400);
		Pen.scale(zoom, zoom);
		Pen.translate(-400, -400);
		1200.do {
			var p, rot, xlate, ylate, xscale, yscale;
			Pen.width = 8.linrand + 1;
			Pen.beginPath;
			#rot, xlate, ylate, xscale, yscale = xform.choose;
			Pen.translate(xlate, ylate);
			Pen.rotate(rot, h/2, v/2);
			Pen.scale(xscale, yscale);
				Pen.moveTo(p1);
				Pen.lineTo(p2);
			Pen.stroke;
		};
	};
};

{ while { run } { w.refresh; 0.05.wait; } }.fork(AppClock)

)
::

subsection:: Matrix example
code::
(
var controlWindow, w;
var r, a, b, c, d, matrix = [1, 0, 0, 1, 10, 10];
var sliders, spex, name;

w = Window.new.front;
w.view.background_(Color.white);

// create a controller-window 
controlWindow = Window("matrix controls", Rect(400,200,350,120));
controlWindow.front;

// determine the rectangle to be drawn
r = Rect.fromPoints(a = 0 @ 0, c = 180 @ 180);
b = r.leftBottom;
d = r.rightTop;

// the drawFunc
w.drawFunc = {
    Pen.strokeColor = Color.red;
    Pen.matrix = matrix;
    Pen.width = 5;
    Pen.strokeRect(r);
    Pen.strokeOval(r);
    Pen.color = Color.blue;
    Pen.width = 0.1;
    Pen.line(a, c);
    Pen.line(b, d);
    Pen.stroke;

    Pen.font = Font( "Helvetica-Bold", 12 );
    Pen.stringAtPoint( "A", a - 6 );
    Pen.stringAtPoint( "B", b - 6 );
    Pen.stringAtPoint( "C", c - (0@6) );
    Pen.stringAtPoint( "D", d - (0@6) );

    Pen.font = Font( "Helvetica", 10 );
    Pen.stringInRect( "a matrix test", r.moveBy( 50, 50 ));
};

controlWindow.view.decorator = sliders = FlowLayout(controlWindow.view.bounds);
spex = [
    [0, 2.0].asSpec,
    [0, 2.0].asSpec,
    [0, 2.0].asSpec,
    [0, 2.0].asSpec,
    [0, 200.0].asSpec,
    [0, 200.0].asSpec
];
name = #[zoomX, shearingY, shearingX, zoomY, translateX, translateY];
6.do { |i|
    EZSlider(controlWindow, 300 @ 14, name[i], spex[i], { |ez| var val;
            val = ez.value;
            [i, val.round(10e-4)].postln;
            matrix.put(i, val);
            w.refresh; // reevaluate drawFunc function
    }, matrix[i]);
    sliders.nextLine;
};
w.refresh;
)
::

subsection:: Transparency layer example
code::
(
w = Window.new("Transparency Layer test", Rect(400,400,430,450)).front;
w.drawFunc = {
    Color.blue.setStroke;

    Pen.use {
    Pen.setShadow(2@2, 10, Color.black);
    Pen.beginTransparencyLayer;

    Color.red.setFill;
    Pen.addOval(Rect(20,40,100,100));
    Pen.fill;

    Color.green.setFill;
    Pen.addOval(Rect(30,70,100,100));
    Pen.fill;

    Color.blue.setFill;
    Pen.addOval(Rect(60,40,100,100));
    Pen.fill;

    "With Transparency Layer".drawCenteredIn(Rect(30, 40, 100, 100), Font.default, Color.white);
    Pen.endTransparencyLayer;
    };

    Pen.use {
    Pen.translate(200, 0);
    Pen.setShadow(2@2, 10, Color.black);


    Color.red.setFill;
    Pen.addOval(Rect(20,40,100,100));
    Pen.fill;

    Color.green.setFill;
    Pen.addOval(Rect(30,70,100,100));
    Pen.fill;

    Color.blue.setFill;
    Pen.addOval(Rect(60,40,100,100));
    Pen.fill;

    "Without Transparency Layer".drawCenteredIn(Rect(30, 40, 100, 100), Font.default, Color.white);
    };

    Pen.use {
        Pen.translate(0, 200);
        Pen.setShadow(2@2, 10, Color.black);
        Pen.beginTransparencyLayer;

        Pen.push;
        Pen.addOval(Rect(20,40,170,170));
        Pen.fillAxialGradient(w.view.bounds.leftTop, w.view.bounds.rightBottom, Color.rand, Color.rand);
        Pen.pop;

        "With Transparency Layer".drawCenteredIn(Rect(20,40,170,170), Font.default, Color.white);

        Pen.endTransparencyLayer;
    };

    Pen.use {
        Pen.translate(200, 200);
        Pen.setShadow(2@2, 10, Color.black);
        Pen.addOval(Rect(20,40,170,170));
        Pen.fillAxialGradient(w.view.bounds.leftTop, w.view.bounds.rightBottom, Color.rand, Color.rand);

        "Without Transparency Layer".drawCenteredIn(Rect(20,40,170,170), Font.default, Color.white);
    };
};
w.refresh;
)
::

subsection:: Blending modes
code::
/*
different blend modes:
OS X 10.4 and > Only
--------------------
0 - Normal
1 - Multiply
2 - Screen
3 - Overlay
4 - Darken
5 - Lighten
6 - ColorDodge
7 - ColorBurn
8 - SoftLight
9 - HardLight
10 - Difference
11 - Exclusion
12 - Hue
13 - Saturation
14 - Color
15 - Luminosity

OS 10.5 and > Only
--------------------
16 - Clear
17 - Copy
18 - SourceIn
19 - SourceOut
20 - SourceATop
21 - DestinationOver
22 - DestinationIn
23 - DestinationATop
24 - XOR
25 - PlusDarker
26 - PlusLighter
*/

(
	var blendMode=0, blendString="Normal";
	w = Window.new.front;
	m = SCPopUpMenu(w, Rect(10, w.view.bounds.height - 30, 150, 20));
	m.items = [
		"0 - Normal",
		"1 - Multiply",
		"2 - Screen",
		"3 - Overlay",
		"4 - Darken",
		"5 - Lighten",
		"6 - ColorDodge",
		"7 - ColorBurn",
		"8 - SoftLight",
		"9 - HardLight",
		"10 - Difference",
		"11 - Exclusion",
		"12 - Hue",
		"13 - Saturation",
		"14 - Color",
		"15 - Luminosity"
	];
	
	m.action_({|view|
		blendMode = view.value;
		blendString = view.items.at(blendMode);
		w.refresh;
	});
	w.drawFunc = {
		80.do{|i|
			Pen.use {
			Pen.blendMode_(blendMode);
			Pen.color = Color.green(0.6, 0.10);
			Pen.addRect(
				Rect(20, 20, 20 + (i*4), 20 + (i*4));
			);
			Pen.fill;
			};
		}
	};
	w.refresh;
)
::
** class:: Penvir
summary:: use an environment when embedding the pattern in a stream
related:: Classes/Pkey
categories:: Streams-Patterns-Events>Patterns>Data Sharing

ClassMethods::

method::new

argument::envir
an environment with objects to embed.

argument::pattern
pattern or stream, ususally a link::Classes/Pfunc::, link::Classes/Prout::.

argument::independent
if true streams can write to the environment without influencing other streams created from this pattern. if false, the streams write to a common namespace.

Examples::

code::
(
x = (a:8);
y = Penvir(
	x,
	Pfunc { ~a * 2 }
);

t = y.asStream;
)

t.next;



(
x = (a:8);
y = Penvir(
	x,
	Pfunc { ~a = ~a * 2 }
);

t = y.asStream;
z = y.asStream;
)

t.next;
t.next;
x.postln;	// x stays unchanged
::
** class:: Pexprand
summary:: random values that follow a Exponential Distribution
related:: Classes/Pkey
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new
note::
lo and hi should both be positive or negative (their range should not cross 0).
::

argument::lo
lower boundary of values.

argument::hi
upper boundary of values

argument::length
number of values produced.

Examples::

code::
(
var a;
a = Pexprand.new(0.0001, 1, inf);
c = a.asStream.nextN(500);
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pexprand(0.0001, 1.0,inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::
** class:: Pfin
summary:: limit number of events embedded in a stream
related:: Classes/Pfinval, Classes/Pfindur, Classes/Pconst
categories:: Streams-Patterns-Events>Patterns>Repetition

description::

Limits the number of output values from the given pattern or stream. If the stream is able to output more values, Pfin will terminate it early.

The number may be given as a constant, or calculated on the fly from a function or stream. See the "sequence of pitches" example below.

ClassMethods::

method::new
embeds strong::count:: elements of the strong::pattern:: into the stream.

Examples::

code::
(
var a, b;
a = Pfin(5, Pseq(#[1, 2, 3],inf));
b = a.asStream;
9.do({ b.next.postln; });
)


//Pfin used as a sequence of pitches

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var c, b;
c = Pn(Pfin({ rrand(3, 5) }, Pseq([1, 2, 3, 4, 5, 6], inf) * 4 + 65), inf);
b = c.asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, b.next.midicps]);
		0.12.wait;
	})
}).play;
)

// or, more concisely:

p = Pbind(
	\instrument, \help_sinegrain,
	\midinote, Pn(Pfin({ rrand(3, 5) }, Pseq([1, 2, 3, 4, 5, 6], inf) * 4 + 65), inf),
	\dur, 0.12
).play;

p.stop;
::
** class:: Pfindur
summary:: limit total duration of events embedded in a stream
related:: Classes/Pfinval, Classes/Pfin, Classes/Pconst
categories:: Streams-Patterns-Events>Patterns>Repetition

ClassMethods::

method::new
Embeds elements of the strong::pattern:: into the stream until the duration comes close enough to strong::dur::.

Examples::

code::
(
var a, b;
a = Pfindur(5, Pbind(\dur, Prand([1, 2, 0.5, 0.1], inf)));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)


//Pfindur used as a sequence of pitches

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var c;
c = Pbind(
	\dur, Prand([1, 0.02, 0.2], inf),
	\instrument, \help_sinegrain,
	\degree, Pseries(0, 1, inf),
	\octave, 6
);

Pn(
	Pfindur(1, c)
).play;
)
::
** class:: Pfinval
summary:: limit number of items embedded in a stream
related:: Classes/Pfindur, Classes/Pfin, Classes/Pconst
categories:: Streams-Patterns-Events>Patterns>Repetition

description::

note::
Pfinval is not appropriate for wrapping link::Classes/Pmono::, link::Classes/Pfx:: etc. For these types of event patterns, you should use link::Classes/Pfin::.
::

ClassMethods::

method::new
Embeds strong::count:: elements of the strong::pattern:: into the stream.

Examples::

code::
(
var a, b;
a = Pfinval(5, Pseq(#[1, 2, 3],inf));
b = a.asStream;
9.do({ b.next.postln; });
)


//Pfinval used as a sequence of pitches

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var c, b;
c = Pn(Pfinval({ rrand(3, 5)}, Pseq([1, 2, 3, 4, 5, 6],inf)*4+65),inf);
b = c.asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, b.next.midicps]);
		0.12.wait;
	})
}).play;
)
::
** class:: Pfset
summary:: Insert an environment into the event prototype before evaluating the supplied pattern
related:: Classes/Pset
categories:: Streams-Patterns-Events>Patterns>Data Sharing

description::
Good for setting default values or loading server objects.


classmethods::

method:: new

argument:: func
Use environment variable syntax (e.g., code:: ~x = 0 ::) to store values in the internal environment. These values are copied into the event prototype before running the supplied pattern. 
argument:: pattern
An event pattern (such as link::Classes/Pbind::). 
argument:: cleanupFunc
Optional. A function to evaluate when the pattern is stopped, or when the supplied pattern runs out of values. For example, if you loaded a link::Classes/Buffer:: in the initializer function, you could free it in the code::cleanupFunc::.


examples::
code::
(
var a, b;
a = Pfset({
	~legato = 0.3;
	~detune = rrand(0, 30);
}, Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

Pfset does not override values placed into the event by the inner pattern:
code::
(
var a, b;
a = Pfset({
	~dur = 0.3;
}, Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

Sound example
code::
(
SynthDef(\sinegrain,
	{ arg out = 0, freq = 440, sustain = 0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain, \x, Pfunc { rrand(500, 600) });
a = Pfset({ ~freq = { ~x.postln * 2 }; ~legato = 3; },  a);
a.play;
)
::
** class:: Pfsm
summary:: Finite State Machine
related:: Classes/Pdfsm
categories:: Streams-Patterns-Events>Patterns>List>Indexing

description::

Every state consists of an item and an array of integer indices of possible strong::next states::. The initial state is chosen at random from the array of strong::entry states::. That chosen state's item is returned, and the next state is chosen from its array of possible strong::next states::. When the end state is chosen, the stream ends.

Examples::

definitionList::
## list:
|| [
definitionList::
## [ entry states ], ||
## item, [ next states ], ||
## item, [ next states ], ||
## ... ||
## end item (or nil), nil ||
::
## ] ||
::

next states: nil is terminal

code::
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
a = Pfsm([
		#[0,1],
		67, #[0, 0, 3],
		72, #[2],
		73, #[0, 2],
		Pseq([74, 75, 76, 77]), #[2, 3, 3],
		nil, nil
	], inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next.midicps]);
		0.1.wait;
	})
}).play;
)

(
Pfsm([
	#[5, 6, 7], // entry states

	//e1 (== state 0)
	Pbind( \dur, Pseq([ 1/8, 3/8 ]), \midinote, Pseq([ 86, 75 ]) ),
	//#[1],	// as given in CMJ
	// my de-boredom-ated version..
	#[1, 1, 1, 1, 1, 1, 1, 8],
	//e2 (== state 1)
	Pbind( \dur, 1/2, \midinote, Pseq([ 69 ]) ),
	#[0, 1],
	//e3 (== state 2)
	Pbind( \dur, 1/3, \midinote, Pseq([ 55, 60, 66 ]) ),
	#[0, 1, 2, 2, 2, 2, 3, 3, 3, 3],
	//e4 (== state 3)
	Pbind( \dur, 1/4, \midinote, Pseq([ 81, 80, 77, 76 ]) ),
	#[1, 4, 4, 4, 4],
	//e5 (== state 4)
	Pbind( \dur, Pseq([1, 2/3, 2/3, 2/3, 1]), \midinote, Pseq([ \, 70, 70, 70, \ ]) ),
	#[2, 3],
	//e6 (== state 5)
	Pbind( \dur, 1/4, \midinote, Pseq([ 59, 61 ]) ),
	#[0, 2, 4, 5, 5, 5, 5, 5, 5, 5],
	//e7 (== state 6)
	Pbind( \dur, 1/4, \midinote, Pseq([ 87, 88 ], 2) ),
	#[4, 4, 4, 4, 6, 6, 6, 7, 7, 7],
	//e8 (== state 7)
	Pbind( \dur, 1, \midinote, Pseq([ 56 ]) ),
	#[1, 3, 6, 6, 6],
	// terminal state
	nil, nil
]).play;
)
::class:: Pfunc
summary:: Function pattern
categories:: Streams-Patterns-Events>Patterns>Function
related:: Classes/Pfuncn

description::
Returns a link::Classes/Stream:: that returns values from the code::nextFunc::.


classmethods::

method:: new
argument:: nextFunc
Stream function. In an event stream receives the current link::Classes/Event:: as argument.
argument:: resetFunc
Function that is called when the stream is reset. In an event stream receives the current link::Classes/Event:: as argument.


examples::
code::
(
var a, x;
a = Pfunc({ exprand(0.1, 2.0) + #[1, 2, 3, 6].choose }, { \reset.postln });
x = a.asStream;
x.nextN(20).postln;
x.reset;
)
::

Sound example
code::
(
SynthDef(\help_sinegrain,
	{ arg out = 0, freq = 440, sustain = 0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pfunc({ exprand(0.1, 0.3) + #[1, 2, 3, 6, 7].choose }).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, val * 100 + 300]);
		0.02.wait;
	}
}.fork;
)
::
** class:: Pfuncn
summary:: Function pattern of given length
categories:: Streams-Patterns-Events>Patterns>Function
related:: Classes/Pfunc

description::
Returns a stream that returns values from the code::func::.


classmethods::

method:: new
argument:: func
Stream function. In an event stream receives the current link::Classes/Event:: as argument.
argument:: repeats
End after this number of times.


examples::
code::
(
var a, b, c;
a = Pfuncn({ exprand(0.1, 2.0) + #[1, 2, 3, 6].choose }, 2);
b = Pfuncn({ #[-2, -3].choose }, 2);
Pseq([a, b], inf).asStream.nextN(20).postln;
)
::

Sound example
code::
(
SynthDef(\help_sinegrain,
	{ arg out = 0, freq = 440, sustain = 0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a, b, c;
a = Pfuncn({ exprand(0.1, 2.0) + #[1, 2, 3, 6].choose }, 2);
b = Pfuncn({ #[-2, -3].choose }, 7);
c = Pseq([a, b], inf).asStream;
{
	c.do { |val|
		Synth(\help_sinegrain, [\freq, val * 100 + 300]);
		0.02.wait;
	}
}.fork;
)
::
** class:: Pfx
summary:: add an effect synth to the synths of a given event stream
related:: Classes/Pfxb, Classes/Pbus, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Server Control

description::

Puts an effect node on the tail of the current group and releases it when the contained pattern finishes. If a bus is given, it is used as an effect bus. Name value pairs are inserted into the event for starting the effect node. The effect parameters are set from the event.

Examples::

code::
(
SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
}, [\ir, \ir, 0.1, 0.1, 0]).add;

SynthDef(\distort, { arg out=0, pregain=40, amp=0.2, gate=1;
	var env;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	XOut.ar(out, env, (In.ar(out, 2) * pregain).distort * amp);
}, [\ir, 0.1, 0.1, 0]).add;

SynthDef(\wah, { arg out=0, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.4, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, RLPF.ar(in, LinExp.kr(LFNoise1.kr(0.3), -1, 1, 200, 8000), 0.1).softclip * 0.8);
}, [\ir, 0]).add;
)

(
var p, q, r, o;
p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);

q = Pfx(p, \echo, \dtime, 0.2, \decay, 3);

r = Pfx(q, \distort, \pregain, 20, \amp, 0.25);

o = Pfx(r, \wah);

Pseq([p, q, r, o], 2).play;
)
::
** class:: Pfxb
summary:: add an effect synth to the synths of a given event stream
related:: Classes/Pfx, Classes/Pbus, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Server Control

description::

Puts an effect node on the tail of the current group and releases it when the contained pattern finishes. Name value pairs are inserted into the event for starting the effect node. The effect parameters are set from the event.

In difference to link::Classes/Pfx::, a strong::private effect bus:: is provided according to the number of channels in the effect synth def.

Examples::

code::
(
SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
}, [\ir, \ir, 0.1, 0.1, 0]).add;

SynthDef(\distort, { arg out=0, pregain=40, amp=0.2, gate=1;
	var env;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	XOut.ar(out, env, (In.ar(out, 2) * pregain).distort * amp);
}, [\ir, 0.1, 0.1, 0]).add;

SynthDef(\wah, { arg out=0, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.4, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, RLPF.ar(in, LinExp.kr(LFNoise1.kr(0.3), -1, 1, 200, 8000), 0.1).softclip * 0.8);
}, [\ir, 0]).add;
)

(
var p, q, r, o;
p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);

q = Pfxb(p, \echo, \dtime, 0.2, \decay, 3);

r = Pfxb(q, \distort, \pregain, 20, \amp, 0.25);

o = Pfxb(r, \wah);

Pseq([p, q, r, o], 2).play;
)


// test order of effect chain
(
SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
}, [\ir, \ir, 0.1, 0.1, 0]).add;

SynthDef(\addbeeps, { arg out=0, gate=1;
	var env;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	XOut.ar(out, env, (In.ar(out, 2) + (LFPulse.kr(1, 0, 0.3) * SinOsc.ar(1000) * 0.4) ));
}, [\ir, 0.1, 0.1, 0]).add;
)

(
var a;
a = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);
a = Pfxb(a, \echo, \dtime, 0.2, \decay, 3);
a = Pfxb(a, \addbeeps);
a.play;
)

(
var a;
a = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);
a = Pfxb(a, \addbeeps);
a = Pfxb(a, \echo, \dtime, 0.2, \decay, 3);
a.play;
)
::
** class:: Pgate
summary:: gated stream advances only when an event key is true
related:: Classes/Pn
categories:: Streams-Patterns-Events>Patterns>Repetition

description::

Pgate advances its subpattern whenever strong::key:: is true. Pgate must be used within an Event pattern.

Examples::

code::
// Pn advances Pgate each time its subpattern is repeated
(
Pbind(

	\degree,	Pn(Pseq((0..7)), inf, \step),
	\mtranspose,	Pgate(Pwhite(0,5), inf, \step),
	\dur, 0.2
).play
)


// Two different Pgates advanced at two different rates
(
Pbind(

	\scale,		Scale.minor,

	\foo,		Pn(Pseq((0..2)),inf,  \step1),
	\degree,	Pn(Pseq((0..7).mirror), inf, \step),
	\ctranspose,	Pgate(Pwhite(0,5), inf, \step) +
				Pgate(Pseq([0,7,0,-7], inf), inf, \step1),
	\dur, 0.2
).play
)
::
** class:: Pgauss
summary:: random values that follow a Gaussian Distribution
related:: Classes/Ppoisson
categories:: Streams-Patterns-Events>Patterns>Random

description::

This pattern uses the Box-Muller transform to generate a gaussian distribution from uniformly distributed values: code::sqrt(-2 * log(1.0.rand)) * sin(2pi.rand)::

ClassMethods::

method::new

argument::mean
The mean of the distribution.

argument::dev
The spread of values around the mean (standard deviation).

argument::length
Number of values produced.

Examples::

code::
(
var a;
a = Pgauss(0.0, 100, inf);
c = a.asStream.nextN(500);
w = Window.new("Pgauss", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

(
var a, c, w;
a = Pgauss(0.0, 10.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Pgauss", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pgauss(0.0, 1.0,inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::
** class:: Pgbrown
summary:: geometric brownian motion pattern
related:: Classes/BrownNoise, Classes/Pbrown
categories:: Streams-Patterns-Events>Patterns>Random

description::

Returns a stream that behaves like a geometric brownian motion.

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::step
maximum multiplication factor per step (omega) - the distribution is xrand2.

argument::length
number of values produced.

Examples::

code::
(
var a, b;
a = Pgbrown(0.0, 1.0, 0.2, inf);
b = a.asStream;
7.do({ b.next.postln; });
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pgbrown(1.0, 2.0, 0.1, inf).asStream;
Routine({
	loop({
	Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
	0.02.wait;
	})
}).play;
)

// compare with normal brownian motion:

(
var a;
a = Pbrown(1.0, 2.0, 0.1, inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	})
}).play;
)
::
** class:: Pgeom
summary:: geometric series pattern
related:: Classes/Pseries
categories:: Streams-Patterns-Events>Patterns>List

description::

Returns a stream that behaves like a geometric series.

ClassMethods::

method::new

argument::start
start value.

argument::grow
multiplication factor.

argument::length
number of values produced.

Examples::

code::
(
var a;
a = Pgeom(1.0, 1.1, inf);
a.asStream.nextN(100).plot;
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, amp=0.1;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2, amp), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pgeom(300, 1.03, 70).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, val]);
		0.02.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.01,
	\instrument, \help_sinegrain,
	\freq, Pgeom(800, Pbrown(0.99, 1.01, 0.01, inf), inf)
).play;
)
::
** class:: Pgpar
summary:: embed event streams in parallel and put each in its own group
related:: Classes/Ppar, Classes/Pbus, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Parallel

description::

Embeds several event streams so that they form a single output stream with all their events in temporal order. When one stream ends, the other streams are further embedded until all have ended.

note::
In order to fully separate these layers from other synths, use link::Classes/Pbus::.
::

See link::Classes/Pgroup:: for a description of the code::\groupReleaseTime:: event key.

ClassMethods::

method::new

argument::list
list of patterns or streams.

argument::repeats
repeat the whole pattern n times.

Examples::

code::
// an example analogous to the one in the Pfx helpfile

(
SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
}, [\ir, \ir, 0.1, 0.1, 0]).add;

SynthDef(\distort, { arg out=0, pregain=40, amp=0.2, gate=1;
	var env;
	env = Linen.kr(gate, 0.05, 1, 0.1, 2);
	XOut.ar(out, env, (In.ar(out, 2) * pregain).distort * amp);
}, [\ir, 0.1, 0.1, 0]).add;

SynthDef(\wah, { arg out=0, gate=1, rate=0.3;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 0.4, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, RLPF.ar(in, LinExp.kr(LFNoise1.kr(rate), -1, 1, 200, 8000), 0.1).softclip * 0.8);
}, [\ir, 0]).add;
)


(
var p, q, r, o;
Pbus(
	Pgpar([
		Pbind(\degree, Prand((0..7), inf), \dur, 0.3, \legato, 0.2),
		Pbind(\instrument, \echo, \dur, 3, \legato, 1.1,
			\dtime, Pwhite(0.01, 0.1, inf), \decay, 3),
		Pbind(\instrument, \distort, \dur, 1.2, \legato, 1.1,
			\pregain, Pwhite(1, 20, inf), \amp, 0.25),
		Pbind(\instrument, \wah, \dur, 4.0, \legato, 1.1,
			\rate, Pwhite(0.1, 3, inf))
	])
).play
)
::

code::
// synthdefs
(
SynthDef(\gap, { arg out, sustain=1.0, attack=0.0001, decay=0.01, leak;
	var level;
	level = EnvGen.ar(Env.linen(attack, sustain, decay, 1-leak), doneAction:2);
	XOut.ar(out, level, Silent.ar ! 2)
}).add;

SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
}).add;
)


// play a layered pattern with gaps and overlays
(
x = Pbind(
	\instrument, \help_sinegrain,
	\degree, Pn(Plazy({ Prand([0, 4, 5], 16) + 5.rand })) + Prand(#[0, [0, 3], [0, 7]], inf),
	\dur, Prand([0.25, 0.5, 1.0], inf),
	\scale, #[0, 3, 5, 9, 10]
);
y = Pbind(
	\instrument, \gap,
	\dur, Prand([0.25, 0.5, 1.0], inf) * Pstutter(inf, Prand([0.25, 1, 2],1)),
	\legato, Prand([0.25, 0.5, 1.0], inf),
	\leak, 0.25
);
a = Pbus(Pgpar([x, y, x, y, x, y]));
a.play;
)
::
** class:: Pgroup
summary:: Starts a new Group and plays the pattern in this group
related:: Classes/Group, Classes/Pbus
categories:: Streams-Patterns-Events>Patterns>Server Control

description::

The group is released when the stream has ended. The group's strong::release:: is delayed (default 0.1 beats) until after the last note releases. But, Pgroup does not know how long the synths' envelopes last. You can extend the lag by putting the number of beats into the event prototype's code::\groupReleaseTime:: key:
code::
Pgroup(...).play(protoEvent: Event.default.put(\groupReleaseTime, releaseLag));
::

Examples::

code::
(
var p, q, r, o;
p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);

Pgroup(p).play;

// post the node structure:
fork {
	s.queryAllNodes;
	3.wait;
	s.queryAllNodes;
	2.wait;
	s.queryAllNodes;
}
)
::
** class:: Phasor
summary:: A resettable linear ramp between two levels.
categories::  UGens>Triggers, UGens>Buffer


Description::

Phasor is a linear ramp between start and end values. When its trigger
input crosses from non-positive to positive, Phasor's output will jump to
its reset position. Upon reaching the end of its ramp Phasor will wrap
back to its start.


note::
N.B. Since end is defined as the wrap point, its value is never
actually output.
::

Phasor is commonly used as an index control with  link::Classes/BufRd::
and  link::Classes/BufWr:: .


classmethods::

method::ar, kr

argument::trig

When triggered, jump to resetPos (default: 0, equivalent to
start).


argument::rate

The amount of change per sample, i.e at a rate of 1 the value of
each sample will be 1 greater than the preceding sample.


argument::start

Start point of the ramp.


argument::end

End point of the ramp.


argument::resetPos

The value to jump to upon receiving a trigger.


Examples::

code::

// phasor controls sine frequency: end frequency matches a second sine wave.

(
{ var trig, rate, x, sr;
	rate = MouseX.kr(0.2, 2, 1);
	trig = Impulse.ar(rate);
	sr = SampleRate.ir;
	x = Phasor.ar(trig, rate / sr);
	SinOsc.ar(
		[
			LinLin.kr(x, 0, 1, 600, 1000), // convert range from 0..1 to 600..1000
			1000 // constant second frequency
		], 0, 0.2)

}.play;
)


// two phasors control two sine frequencies: mouse y controls resetPos of the second
(
{ var trig, rate, x, sr;
	rate = MouseX.kr(1, 200, 1);
	trig = Impulse.ar(rate);
	sr = SampleRate.ir;
	x = Phasor.ar(trig, rate / sr, 0, 1, [0, MouseY.kr(0, 1)]);
	SinOsc.ar(x * 500 + 500, 0, 0.2)
}.play;
)


// use phasor to index into a sound file

// allocate a buffer with a sound file
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

// simple playback (more examples: see BufRd)
// Start and end here are defined as 0 and the number of frames in the buffer.
// This means that the Phasor will output values from 0 to numFrames - 1 before looping,
// which is perfect for driving BufRd. (See note above)
{ BufRd.ar(1, b.bufnum, Phasor.ar(0, BufRateScale.kr(b.bufnum), 0, BufFrames.kr(b.bufnum))) }.play;


// two phasors control two sound file positions: mouse y controls resetPos of the second
(
{ var trig, rate, framesInBuffer;
	rate = MouseX.kr(0.1, 100, 1);
	trig = Impulse.ar(rate);
	framesInBuffer = BufFrames.kr(b.bufnum);
	x = Phasor.ar(trig, BufRateScale.kr(b.bufnum), 0, framesInBuffer,
		[0, MouseY.kr(0, framesInBuffer)]);
	BufRd.ar(1, b.bufnum, x);
}.play;
)

::
** class:: Phid
summary:: pattern that polls values from an OSX hid device
related:: Classes/PhidKey, Classes/PhidSlot
categories:: Streams-Patterns-Events>Patterns>User Input

description::

note::
This class is OSX specific. Please use the cross platform versions (based on link::Classes/GeneralHID::), link::Classes/PhidKey:: or link::Classes/PhidSlot::, instead.
::

ClassMethods::

method::new

argument::element
one element of the interface of the device, like a button or an axis. Can be an index or, if the devicespec is present, also a symbol.

argument::locID
the index of the device, defaults to 0 (first device).

argument::repeats
number of values to return.

Examples::

code::
// while this is running, test your device
(
a = Phid(0,0);
x = a.asStream;

Routine({ loop({
	x.next.postln;
	0.2.wait;
}) }).play;
)

// using devicespecs:
// for example wingman. for other specs see HIDDeviceService
(
HIDDeviceService.deviceSpecs.put('WingMan Action Pad',
	IdentityDictionary[
		// buttons
		\a -> 0, \b-> 1, \c-> 2,
		\x-> 3, \y-> 4, \z-> 5,
		\l-> 6,			//front left
		\r-> 7,			//front right
		\s-> 8,
		\mode-> 9,
		\xx-> 10,		//analog controller x axis
		\yy-> 11,		//analog controller y axis
		\slider-> 12,
		\hat-> 13
	])
)


// then you can use the named key:
(
a = Phid(\x, 0, inf);
x = a.asStream;

Routine({ loop({
	x.next.postln;
	0.2.wait;
}) }).play;
)


// 'musical' example:
(
	Pbind(
		\freq, Pseq([Phid(\x,0,8),Phid(\y,0,8)],inf) * 500 + 200,
		\dur, Phid(\slider) + 0.02,
		\pan, Phid(\hat) * 2 - 1
	).play;
)
::
** class:: PhidKey
summary:: pattern that polls values from a human device interface, based on a named slot
related:: Classes/Phid, Classes/PhidSlot, Classes/GeneralHID
categories:: Streams-Patterns-Events>Patterns>User Input

ClassMethods::

method::new

argument::key
key defined in the link::Classes/Spec:: of the device, pointing to a slot like a button or an axis.

argument::device
a link::Classes/GeneralHIDDevice::, or an element from the code::GeneralHID.deviceList::, which will then be opened by the pattern.

argument::repeats
number of values to return.

Examples::

code::
// build the device list and start the event loop:
GeneralHID.buildDeviceList;
GeneralHID.startEventLoop;

// find an Impact game device and open it:
a = GeneralHID.open( GeneralHID.findBy( 1973 ) );

// define a spec:
(
a.add( \lx, [3,0]);	// left x
a.add( \ly, [3,1]);	// left y
a.add( \rx, [3,2]);	// right x
a.add( \ry, [3,5]);	// right y
);
// or find a spec defined previously for this device:
c = a.findSpec;
// set it:
a.setSpec( c[0] );
// inspect the spec
a.spec.map
a.caps;

// boot the server
s.boot;
// simple example:
(
p = Pbind(
	\degree, ( PhidKey( \lx, a, inf )*12 ).round(1),
	\dur, 0.25
).play;
)
p.stop;

// more complex example, showing multichannel expansion and sequences of slots:
(
p = Pbind(
	\degree, ( PhidKey( Pseq([[\lx,\ly],\rx,\ry],inf), a, inf )*12 ).round(1),
	\dur, 0.25
).play;
)
p.stop;
// clean up: close the device and stop the eventloop
a.close;
GeneralHID.stopEventLoop;
::
** class:: PhidSlot
summary:: pattern that polls values from a human device interface, based on an indexed slot
related:: Classes/Phid, Classes/PhidKey, Classes/GeneralHID
categories:: Streams-Patterns-Events>Patterns>User Input

ClassMethods::

method::new

argument::slot
index pointing to a slot like a button or an axis.

argument::type
index pointing to the type of slot (see link::Classes/GeneralHID:: for a description of this).

argument::device
a link::Classes/GeneralHIDDevice::, or an element from the code::GeneralHID.deviceList::, which will then be opened by the pattern.

argument::repeats
number of values to return.

Examples::

code::
// build the device list and start the event loop:
GeneralHID.buildDeviceList;
GeneralHID.startEventLoop;

// find an Impact game device and open it:
a = GeneralHID.open( GeneralHID.findBy( 1973 ) );

// inspect the capabilities of this device:
a.caps;

// boot the server
s.boot;
// simple example:
(
p = Pbind(
	\degree, ( PhidSlot( 0, 3, a, inf )*12 ).round(1),
	\dur, 0.25
).play;
)
p.stop;

// more complex example, showing multichannel expansion and sequences of slots:
(
p = Pbind(
	\degree, ( PhidSlot( Pseq([[0,1],2,5],inf), 3, a, inf )*12 ).round(1),
	\dur, 0.25
).play;
)
// the type argument can also be replaced by an Array or pattern.
p.stop;
// clean up: close the device and stop the eventloop
a.close;
GeneralHID.stopEventLoop;
::
** class:: Phprand
summary:: random values that tend toward hi
related:: Classes/Plprand
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::length
number of values produced.

Examples::

code::
(
var a, c, w;
a = Phprand(0.0, 1.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Phprand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Phprand(0.0, 1.0, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)

// this is equivalent to:
(
{
	loop {
		Synth(\help_sinegrain, [\freq, max(rrand(0.0, 1.0), rrand(0.0, 1.0)) * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::
** class:: Pif
summary:: Pattern-based conditional expression
related:: Classes/Pwhile
categories:: Streams-Patterns-Events>Patterns>Language Control

ClassMethods::

method::new

argument::condition
A pattern or stream returning a link::Classes/Boolean:: value.

argument::iftrue
This stream is evaluated if the link::Classes/Boolean:: is true.

argument::iffalse
This stream is evaluated if the link::Classes/Boolean:: is false.

argument::default
This value (not stream) is returned if "iftrue" or "iffalse" return nil at any time.

Examples::

code::
p = Pif(Pfunc({ 0.3.coin }), Pwhite(0, 9, inf), Pwhite(100, 109, inf)).asStream;
p.nextN(20);

// 7 of the 20 values, or roughly 30%, are in the 0-9 range:

[ 105, 107, 107, 8, 100, 3, 105, 5, 107, 106, 1, 104, 8, 102, 102, 4, 108, 8, 109, 101 ]


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pif(Pfunc({ 0.3.coin }), Pn(Pseries(0.5, 0.1, 10)), Pn(Pseries(6, -0.1, 10))).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.2.wait;
	}
}.fork;
)
::
** class:: Pindex
summary:: pattern that indexes into an array
related:: Classes/Pswitch
categories:: Streams-Patterns-Events>Patterns>List>Indexing

description::

This allows an link::Classes/ArrayedCollection:: to be accessed within patterns.

ClassMethods::

method::new

argument::listPat
the array. Can be a link::Classes/Pattern::.

argument::indexPat
the value to retrieve. Can be a link::Classes/Pattern::.

argument::repeats
specifies the number of repeats.

Examples::

code::
(
SynthDef(\help_pindex, { | out, amp=0.1, freq=440, gate=1 |
	var son = Saw.ar(freq * [0.99, 1, 1.01]).mean;
	son = son * EnvGen.ar(Env.adsr, gate: gate, doneAction:2);
	Out.ar(out, son.dup * amp);
}).add;
)

(
var data = [7, 13, 12, 2, 2, 2, 5];
var indices = [0, 0, 2, 0, 4, 6, 7];
Pbind(
	\instrument, \help_pindex,
	\choice, Prand(indices, inf),
	\degree, Pindex(data, Pkey(\choice), inf),
	\dur, 0.7
).play
)
::
** class:: PingPong
summary:: Stereo ping-pong delay.
related:: Classes/SinOsc
categories::  UGens>Delays>Buffer


Description::

Bounces sound between two outputs…  Like a ping-pong ball. PingPong is
actually a compound built upon  link::Classes/RecordBuf::  and
link::Classes/PlayBuf:: .


classmethods::

method::ar

argument::bufnum
First index of a multi channel buffer.

argument::inputs
An array of audio inputs, the same size as your buffer.

argument::delayTime
Delay time in seconds.

argument::feedback
Feedback coefficient.

argument::rotate

Which rotates the inputArray by one step. (left → right, right →
left). Rotation of 0 (or 2) would result in no rotation to the
inputArray.


Examples::

code::

(
s = Server.local;
s.waitForBoot({

b = Buffer.alloc(s,44100 * 2, 2);

SynthDef("help-PingPong",{ arg out=0,bufnum=0,feedback=0.5,delayTime=0.2;
	var left, right;
	left = Decay2.ar(Impulse.ar(0.7, 0.25), 0.01, 0.25,
		SinOsc.ar(SinOsc.kr(3.7,0,200,500)));
	right = Decay2.ar(Impulse.ar(0.5, 0.25), 0.01, 0.25,
		Resonz.ar(PinkNoise.ar(4), SinOsc.kr(2.7,0,1000,2500), 0.2));

	Out.ar(0,
		PingPong.ar(bufnum, [left,right], delayTime, feedback, 1)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum,\feedback,0.5,\delayTime,0.1]);
});
)


(
s = Server.local;
s.waitForBoot({

b = Buffer.alloc(s,44100 * 2, 2);

SynthDef("help-PingPong",{ arg out=0,bufnum=0;
	var left, right;
	left = Decay2.ar(Impulse.ar(0.7, 0.25), 0.01, 0.25,
		SinOsc.ar(SinOsc.kr(3.7,0,200,500)));
	right = Decay2.ar(Impulse.ar(0.5, 0.25), 0.01, 0.25,
		Resonz.ar(PinkNoise.ar(4), SinOsc.kr(2.7,0,1000,2500),
0.2));

	Out.ar(0,
		PingPong.ar(bufnum, [left,right] *  EnvGen.kr(Env([1, 1, 0], [2, 0.1])),
			0.1, 0.8, 1)
	)
}).play(s,[\out, 0, \bufnum, b.bufnum]);
});
)





(

Patch({ arg buffer,feedback=0.5,delayTime=0.2;
	var left, right;
	left = Decay2.ar(Impulse.ar(0.7, 0.25), 0.01, 0.25,
		SinOsc.ar(SinOsc.kr(3.7,0,200,500)));
	right = Decay2.ar(Impulse.ar(0.5, 0.25), 0.01, 0.25,
		Resonz.ar(PinkNoise.ar(4), SinOsc.kr(2.7,0,1000,2500), 0.2));

	PingPong.ar(buffer.bufnumIr, [left,right], delayTime, feedback, 1)

}).gui

)

::

** class:: PinkNoise
summary:: Pink Noise.
related:: Classes/BrownNoise, Classes/GrayNoise, Classes/ClipNoise, Classes/WhiteNoise
categories::  UGens>Generators>Stochastic


Description::

Generates noise whose spectrum falls off in power by 3 dB per octave.
This gives equal power over the span of each octave.
This version gives 8 octaves of pink noise.


classmethods::

method::ar, kr

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::

(
SynthDef("help-PinkNoise", { arg out=0;
	Out.ar(out,
		PinkNoise.ar(0.4)
	)
}).play;
)

::

** class:: Pipe
summary:: pipe stdin to, or stdout from, a unix shell command
related:: Classes/UnixFILE
categories:: Files

description::
Pipe stdin to, or stdout from, a unix shell command. Pipe treats the shell command as if it were a UnixFILE, and returns nil when done. See link::Classes/UnixFILE:: for details of the access methods. Pipe must be explicitly closed. Do not rely on the garbage collector to do this for you!

ClassMethods::

method::new

argument::commandLine
A link::Classes/String:: representing a valid shell command.

argument::mode
A link::Classes/String:: representing the mode. Valid modes are "w" (pipe to stdin) and "r" (pipe from stdout).

InstanceMethods::

private::prClose, prOpen

method::open
Open the file.

argument::commandLine
A command line link::Classes/String:: passed to popen.

argument::mode
A link::Classes/String:: passed to popen, so should be one of: "r","w"

method::close
Closes the pipe, waiting for the command to finish. You must do this explicitly before the Pipe object is garbage collected.

returns:: The exit status of the command (an Integer).

Examples::

note::
For anyone still using OS X 10.3, unix commands like pipe do not work when the server is booted; quit the server, otherwise sc crashes. More recent OS X is not affected.
::

code::
// this pipes in stdout from ls
(
var p, l;
p = Pipe.new("ls -l", "r");			// list directory contents in long format
l = p.getLine;					// get the first line
while({l.notNil}, {l.postln; l = p.getLine; });	// post until l = nil
p.close;					// close the pipe to avoid that nasty buildup
)
::

A more time-intensive request:
code::
(
var p, l;
p = Pipe.new("ping -c10 sourceforge.net", "r");	// list directory contents in long format
l = p.getLine;					// get the first line
while({l.notNil}, {l.postln; l = p.getLine; });	// post until l = nil
p.close;					// close the pipe to avoid that nasty buildup
)
::
** class:: Pitch
summary:: Autocorrelation pitch follower
categories:: UGens>Analysis>Pitch

description::
This is a better pitch follower than link::Classes/ZeroCrossing::, but more costly of CPU. For most purposes the default settings can be used and only code::in:: needs to be supplied. Pitch returns two values (via an link::Classes/Array:: of OutputProxys, see the link::Classes/OutputProxy:: help file), a code::freq:: which is the pitch estimate and code::hasFreq::, which tells whether a pitch was found. Some vowels are still problematic, for instance a wide open mouth sound somewhere between a low pitched short 'a' sound as in 'sat', and long 'i' sound as in 'fire', contains enough overtone energy to confuse the algorithm.

classmethods::
private:: categories
method:: kr
argument::in
argument::initFreq
argument::minFreq
argument::maxFreq
argument::execFreq
argument::maxBinsPerOctave
argument::median
argument::ampThreshold
argument::peakThreshold
argument::downSample
argument::clar

discussion::
The pitch follower executes periodically at the rate specified by code::execFreq:: in cps. code::execFreq:: is clipped to be between code::minFreq:: and code::maxFreq::. First it detects whether the input peak to peak amplitude is above the code::ampThreshold::.
If it is not then no pitch estimation is performed, code::hasFreq:: is set to zero and code::freq:: is held at its previous value. It performs an autocorrelation on the input and looks for the first peak after the peak around the lag of zero that is above code::peakThreshold:: times the amplitude of the peak at lag zero.

If the code::clar:: argument is greater than zero (it is zero by default) then code::hasFreq:: is given additional detail. Rather than simply being 1 when a pitch is detected, it is a "clarity" measure in the range between zero and one. (Technically, it's the height of the autocorrelation peak normalised by the height of the zero-lag peak.)
It therefore gives a kind of measure of "purity" of the pitched signal.

Using a code::peakThreshold:: of one half does a pretty good job of eliminating overtones, and finding the first peak above that threshold rather than the absolute maximum peak does a good job of eliminating estimates that are actually multiple periods of the wave.

The autocorrelation is done coarsely at first using a maximum of code::maxBinsPerOctave:: lags until the peak is located. Then a fine resolution search is performed until the peak is found. (Note that maxBinsPerOctave does NOT affect the final pitch resolution; a fine resolution search is always performed.
Setting maxBinsPerOctave larger will cause the coarse search to take longer, and setting it smaller will cause the fine search to take longer.)

The three values around the peak are used to find a fractional lag value for the pitch. If the pitch frequency is higher than code::maxFreq::, or if no peak is found above code::minFreq::, then code::hasFreq:: is set to zero and code::freq:: is held at its previous value.

It is possible to put a median filter of length code::median:: on the output estimation so that outliers and jitter can be eliminated. This will however add latency to the pitch estimation for new pitches, because the median filter will have to become half filled with new values before the new one becomes the median value.
If median is set to one then that is equivalent to no filter, which is the default.

When an in range peak is found, it is inserted into the median filter, a new pitch is read out of the median filter and output as code::freq::, and code::hasFreq:: is set to one.

It is possible to down sample the input signal by an integer factor code::downSample:: in order to reduce CPU overhead. This will also reduce the pitch resolution.

Until Pitch finds a pitch for the first time, it will output code::initFreq::.

None of these settings are time variable.

instancemethods::
private:: init

examples::
(use headphones!)

code::
s = Server.local;

(
SynthDef("pitchFollow1",{
    var in, amp, freq, hasFreq, out;
    in = Mix.new(SoundIn.ar([0,1]));
    amp = Amplitude.kr(in, 0.05, 0.05);
    # freq, hasFreq = Pitch.kr(in, ampThreshold: 0.02, median: 7);
    //freq = Lag.kr(freq.cpsmidi.round(1).midicps, 0.05);
    out = Mix.new(VarSaw.ar(freq * [0.5,1,2], 0, LFNoise1.kr(0.3,0.1,0.1), amp));
    6.do({
        out = AllpassN.ar(out, 0.040, [0.040.rand,0.040.rand], 2)
    });
    Out.ar(0,out)
}).play(s);
)
::

code::
(
SynthDef("pitchFollow2",{
    var in, amp, freq, hasFreq, out;
    in = Mix.new(SoundIn.ar([0,1]));
    amp = Amplitude.kr(in, 0.05, 0.05);
    # freq, hasFreq = Pitch.kr(in, ampThreshold: 0.02, median: 7);
    out = CombC.ar(LPF.ar(in, 1000), 0.1, (2 * freq).reciprocal, -6).distort * 0.05;
    6.do({
        out = AllpassN.ar(out, 0.040, [0.040.rand,0.040.rand], 2)
    });
    Out.ar(0,out);
}).play(s);
)
::

** class:: PitchShift
summary:: Time domain pitch shifter.
categories::  UGens>Filters>Pitch


Description::

A time domain granular pitch shifter. Grains have a triangular amplitude
envelope and an overlap of 4:1.


classmethods::

method::ar

argument::in

The input signal.


argument::windowSize

The size of the grain window in seconds. This value cannot be
modulated.


argument::pitchRatio

The ratio of the pitch shift. Must be from 0 to 4.


argument::pitchDispersion

The maximum random deviation of the pitch from the

code::pitchRatio:: .


argument::timeDispersion

A random offset of from zero to

code::timeDispersion::  seconds is added to the
delay of each grain. Use of some dispersion can alleviate a hard
comb filter effect due to uniform grain placement. It can also be
an effect in itself.
code::timeDispersion::  can be
no larger than
code::windowSize:: .


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

(
play({
	z = Blip.ar(800, 6, 0.1);
	PitchShift.ar(z, 0.02, Line.kr(0.1,4,20), 0, 0.0001)
}))

(
// pitch shift input - USE HEADPHONES to prevent feedback.
play({
	PitchShift.ar(
		AudioIn.ar([1,2]),	// stereo audio input
		0.1, 			// grain size
		MouseX.kr(0,2),	// mouse x controls pitch shift ratio
		0, 				// pitch dispersion
		0.004			// time dispersion
	)
}))

(
// use PitchShift to granulate input - USE HEADPHONES to prevent feedback.
// upper left corner is normal playback. x = pitch dispersion, y = time dispersion
var grainSize;
grainSize = 0.5;
play({
	PitchShift.ar(
		AudioIn.ar([1,2]),
		grainSize,
		1,						// nominal pitch rate = 1
		MouseX.kr(0,1), 			// pitch dispersion
		MouseY.kr(0, grainSize)	// time dispersion
	)
}))

::
** class:: Pkey
summary:: access a key in an event stream
related:: Classes/Penvir
categories:: Streams-Patterns-Events>Patterns>Data Sharing

description::

Pkey simplifies backward access to values in an event being processed by link::Classes/Pbind:: or another event pattern.

ClassMethods::

method::new

argument::key
The name of the event variable to read from.

Examples::

code::
// \b should thus take twice the value of \a in each event:
p = Pbind(\a, Pwhite(1, 10, inf), \b, Pkey(\a) * 2).asStream;


p.next(())	// for Pbind, must pass in a default event even if empty

( 'a': 10, 'b': 20 )
( 'a': 2, 'b': 4 )
( 'a': 5, 'b': 10 )
( 'a': 4, 'b': 8 )
( 'a': 2, 'b': 4 )
::
** class:: Place
summary:: interlaced embedding of subarrays
related:: Classes/Ppatlace
categories:: Streams-Patterns-Events>Patterns>List

description::

Returns elements in the list. If an element is an array itself, it embeds the first element when it comes by first time, the second element when it comes by the second time... The nth when it comes by the nth time.

Examples::

code::
(
var a, b;
a = Place(#[1, [2,5], [3, 6]], inf);
x = a.asStream;
8.do({ x.next.postln; });
)

1
2
3
1
5
6
1
2



//Place used as a sequence of pitches

(
SynthDef("help-sinegrain",
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
c = Place(#[0, 0, [0, 4, 7], [1, 5, 8], [2, 6, 9]], inf) + 67;
x = c.asStream;
Routine({
	loop({
		Synth("help-sinegrain", [\freq, x.next.midicps]);
		0.17.wait;
	})
}).play;
)
::
** class:: Plambda
summary:: create a scope (namespace) for enclosed streams
related:: Classes/Penvir, Classes/Pkey
categories:: Streams-Patterns-Events>Patterns>Data Sharing

ClassMethods::

method::new

argument::pattern
an event stream.

argument::scope
an event with default bindings (can be nil).

Examples::

code::
// Plet, Pget and Plambda.
// Plet(key, stream, return)
// Pget(key, default, repeats)

(
SynthDef(\sine,
	{ arg out=0, freq=440, sustain=0.05, pan=0, amp=0.1;
		var env;
		env = EnvGen.kr(Env.perc(Rand(0.001, 0.02), sustain, AmpCompA.kr(freq)*amp), doneAction:2);
		Out.ar(out, Pan2.ar(SinOsc.ar(freq), pan, env))
	}).add;
)

(
a = Plambda(
	Pseq([
	Pfindur(5,
		Ppar([
			Pbind(\note, Plet(\x, Prand([1, 5, 1, [10, 14]], inf)), \dur, 8/3, \pan, -1),
			Pbind(\note, Plet(\y, Pseq([5, 3, 2, 0, [0, 5, 6, 9]], inf)), \dur, 0.5, \pan,1),
			Pbind(\note, Pseq([Pget(\x), Pget(\y)], inf) + 12, \pan, 0, \dur, 2/3)
		])
	),
	Pbind(\note, Pget(\x, 0, 6) + [0, 5], \dur, Pstutter(inf, Prand([2/3, 1/6])))
	], inf).trace(\eventScope) // internally, the values are shared via \eventScope
);
b = Pbindf(a, \instrument, \sine, \legato, 0.1);
b.play
)

// this structure remains parallelizable

Ppar([b, Pbindf(b, \ctranspose, 24, \dur, Pkey(\dur) * 0.25)]).play;
::
** class:: Platform
summary:: handle cross-platform differencies
categories:: Platform

description::
The Platform class (along with its subclasses) handles things which differ between operating systems (mac/linux/windows/...), to simplify cross-platform aspects of SuperCollider.

Platform is an abstract class encapsulating various platform dependent constants and properties, such as directories, primitive features and startup files. The platform object is accessible through the code::platform:: method of the main process instance:
code::
thisProcess.platform
::

Currently implemented platforms include: OSXPlatform, LinuxPlatform, WindowsPlatform, UnixPlatform.

classmethods::
Most of Platforms class methods are simply wrappers to code::thisProcess.platform.method::.

subsection:: Platform name and platform dependent actions

method:: case
Perform actions depending on the current platform (name), just like Object:switch:
code::
Platform.case(
    \osx,       { "OSX".postln },
    \linux,     { "Linux".postln },
    \windows,   { "Windows".postln }
);
::

method:: ideName
returns a String indicating which IDE the language believes it is running in. (Often this is determined via the "-i" option to the sclang executable.) This is determined when sclang starts and cannot be changed dynamically.

The main purpose of this is to include/exclude folders from the class search patch depending on which IDE is in use: for example, if the value of ideName is "scapp" then folders named "scide_scapp" are included and all other folders beginning with "scide_" are excluded. The default value of this is "none".

Known IDE names in use are "scapp" (SuperCollider.app on Mac), "scvim" (vim), "scel" (emacs). Others may be used.

subsection:: Directories and filesystem stuff
method:: classLibraryDir
location of the bundled class library

method:: helpDir
location of the bundled help files

method:: systemAppSupportDir
system application support directory

method:: userAppSupportDir
user application support directory

method:: userConfigDir
directory for configuration files

method:: systemExtensionDir
system extension directory (see link::Guides/UsingExtensions::)

method:: userExtensionDir
user extension directory (see link::Guides/UsingExtensions::)

method:: platformDir
platform specific directory for class files (see link::Guides/UsingExtensions::)

method:: pathSeparator
platform specific path separator

method:: resourceDir
platform specific resource directory

method:: defaultTempDir
default directory for temporary files

subsection:: Features

method:: when
Evaluate ifFunction if all features are present, otherwise evaluate elseFunction.
code::
Platform.when(#[\Document, \SCWindow], { "yeehah!".postln });
::

instancemethods::

private:: shutdown, startup

method:: name
returns the platform name

method:: recompile
recompile class library


subsection:: Directories and filesystem stuff
method:: classLibraryDir
location of the bundled class library

method:: helpDir
location of the bundled help files

method:: systemAppSupportDir
system application support directory

method:: userAppSupportDir
user application support directory

method:: userConfigDir
directory for configuration files

method:: systemExtensionDir
system extension directory (see link::Guides/UsingExtensions::)

method:: userExtensionDir
user extension directory (see link::Guides/UsingExtensions::)

method:: platformDir
platform specific directory for class files (see link::Guides/UsingExtensions::)

method:: pathSeparator
platform specific path separator

method:: resourceDir
platform specific resource directory

method:: recordingsDir
recording directory

method:: defaultTempDir
default directory for temporary files



subsection:: Startup files

method:: startupFiles
files to be loaded on startup

method:: loadStartupFiles
(re)load startup files

subsection:: Features

Features are abstract symbols that can be declared by extension authors and be checked during runtime in user code. Apart from explicitly declared features, class and primitive names are implicitly declared.

method:: declareFeature
Declare aSymbol to be a feature present in the runtime. Class names and primitive names cannot be declared as features.

method:: hasFeature
Return true if the feature aSymbol is present in the runtime system. aSymbol can refer to explicitly declared features as well as class and primitive names.
code::
thisProcess.platform.hasFeature(\Object);
thisProcess.platform.hasFeature('_SCWindow_BeginFullScreen');
thisProcess.platform.hasFeature('_myFuncyPrimitive');

thisProcess.platform.declareFeature('superCrazyCompositionSystem');
thisProcess.platform.hasFeature('superCrazyCompositionSystem');
::

method:: when
Evaluate ifFunction if all features are present, otherwise evaluate elseFunction.
code::
thisProcess.platform.when(#[\Document, \SCWindow], { "yeehah!".postln });
::
** class:: PlayBuf						    :playbuf:
summary:: Sample playback oscillator.
related:: Classes/RecordBuf, Classes/DiskIn, Classes/BufRd
categories::  UGens>Buffer


Description::
Plays back a sample resident in memory.

classmethods::

method::ar, kr

argument::numChannels
Number of channels that the buffer will be. This must be a fixed
integer. The architechture of the SynthDef cannot change after it
is compiled.

argument::bufnum
The index of the buffer to use.
warning::
If you supply a bufnum of a buffer with a differing number of channels
than the one specified in this PlayBuf, it will fail silently.
::

argument::rate
1.0 is the server's sample rate, 2.0 is one octave up, 0.5 is one
octave down -1.0 is backwards normal rate… etc. Interpolation
is cubic.


argument::trigger
A trigger causes a jump to the startPos. A trigger occurs when a
signal changes from negative value to positive value.

argument::startPos
Sample frame to start playback.

argument::loop
1 means true, 0 means false. This is modulateable.

argument:: doneAction
an integer representing an action to be executed when the buffer is finished playing. This can be used to free the enclosing synth, etc. See link::Reference/UGen-doneActions:: for more detail. code::doneAction:: is only evaluated if loop is 0.

Examples::

code::
#+BEGIN_SRC sclang

s.boot // Boot the server, if you need to

// read a whole sound into memory
// note: not *that* columbia, the first one
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav"); // remember to free the buffer later.

SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
	Out.ar(out,
		PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), doneAction:2)
	)
}).play(s, [\out, 0, \bufnum, b]);
#+END_SRC
::

In the above example, note how the code::doneAction:2:: causes the synth to free itself when the buffer reaches its end.

Note again that the number of channels must be fixed for the SynthDef. It cannot vary depending on which buffer you use.

code::
#+BEGIN_SRC sclang

  // loop is true
  SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
          Out.ar(out,
                  PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), loop: 1.0)
          )
  }).play(s, [\out, 0, \bufnum, b]);


  // trigger one shot on each pulse
  SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
          var trig;
          trig = Impulse.kr(2.0);
          Out.ar(out,
                  PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), trig, 0, 0)
          )
  }).play(s, [\out, 0, \bufnum, b]);


  // trigger one shot on each pulse
  SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
          var trig;
          trig = Impulse.kr(XLine.kr(0.1, 100, 30));
          Out.ar(out,
                  PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), trig, 5000, 0)
          )
  }).play(s, [\out, 0, \bufnum, b]);


  // mouse control of trigger rate and startpos
  SynthDef(\help_PlayBuf, { arg out=0, bufnum=0;
          var trig;
          trig = Impulse.kr(MouseY.kr(0.5, 200, 1));
          Out.ar(out,
                  PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum), trig, MouseX.kr(0, BufFrames.kr(bufnum)), 1)
          )
  }).play(s, [\out, 0, \bufnum, b]);


  // accelerating pitch
  SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
          var rate;
          rate = XLine.kr(0.1, 100, 60);
          Out.ar(out,
                  PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum)*rate, 1.0, 0.0, 1.0)
          )
  }).play(s, [\out, 0, \bufnum, b]);


  // sine wave control of playback rate. negative rate plays backwards
  SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
          var rate;
          rate = FSinOsc.kr(XLine.kr(0.2, 8, 30), 0, 3, 0.6);
          Out.ar(out,
                  PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum) * rate, 1, 0, 1)
          )
  }).play(s, [\out, 0, \bufnum, b]);


  // zig zag around sound
  SynthDef(\help_PlayBuf, {| out = 0, bufnum = 0 |
          var rate;
          rate = LFNoise2.kr(XLine.kr(1, 20, 60), 2);
          Out.ar(out,
                  PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum) * rate, 1, 0, 1)
          )
  }).play(s, [\out, 0, \bufnum, b]);

  b.free;
#+END_SRC
::

** class:: Plazy
summary:: instantiate new patterns from a function
related:: Classes/PlazyEnvir, Classes/PlazyEnvirN, Classes/Pfunc
categories:: Streams-Patterns-Events>Patterns>Function

description::

Plazy evaluates a function that returns a pattern and embeds it in a stream.

ClassMethods::

method::new

argument::func
A link::Classes/Function:: that returns a pattern or any other valid pattern input.

Examples::

code::
(
a = Plazy({
	var x, y;
	x = Array.series(rrand(2, 4), [1, 100].choose, 1);
	Pshuf(x,1);
});
x = Pn(a, inf).asStream;
30.do({ x.next.postln });
)


//Plazy used to produce a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Plazy({
	var x, y;
	x = Array.series(rrand(2, 4), [1, 5].choose, 1);
	x.put(x.size.rand, 8+0.1.rand2);
	Pseq(x,1);
});
x = Pn(a, inf).asStream;

Routine({
	loop({
		Synth(\help_sinegrain, [\freq, (x.next*5+70).midicps]);
		0.13.wait;
	})
}).play;
)


// using event streams

(
a = Plazy({
	var x, y;
	x = Array.series(rrand(2, 4), [1, 5].choose, 1);
	x.put(x.size.rand, 8+0.1.rand2);
	Pbind(
		\instrument, \help_sinegrain,
		\dur, 0.12,
		\degree, Pseq(x, 2)
	)
});

Pn(a, inf).play;
)
::
** class:: PlazyEnvir
summary:: instantiate new patterns from a function
related:: Classes/Plazy, Classes/PlazyEnvirN, Classes/Pfunc
categories:: Streams-Patterns-Events>Patterns>Function

description::

Evaluates a function that returns a pattern and embeds it in a stream. In difference to link::Classes/Plazy::, the function is evaluated using the environment passed in by the stream.

ClassMethods::

method::new

argument::func
A link::Classes/Function:: that returns a pattern or any other valid pattern input.

Examples::

code::
(
a = PlazyEnvir({ arg a=0, b=1; Pshuf([a, a, b], 2) }); // a, b default to 0,1
x = Pn(a, inf).asStream;

10.do { x.next.postln }; Post.nl;
e = (a:100);
10.do { x.next(e).postln }; Post.nl;
e = (a:100, b:200);
10.do { x.next(e).postln };
)


//PlazyEnvir used to produce a Pbind:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, pan=0;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;

a = PlazyEnvir({ arg g=0, h=0, dur=1;
	postf("g: %, h: %, dur: %\n", g, h, dur);
	Pbind(
		\instrument, \help_sinegrain,
		\dur, dur,
		\degree, Pseq([g, g, h, g, h], 2)
	)
});
)

// different variants
(a <> (g: 0, h: 3, dur:0.2)).play; // single stream
(a <> (g: [0, 4], h: [3, -1], dur:0.2)).play; // same durations, two streams
::

For more about the composition operator code::<>:: see: link::Classes/Pchain::.

Some parameters, like duration, cannot be used in the form of an array in the link::Classes/Pbind::. For full parallel expansion see link::Classes/PlazyEnvirN::.
** class:: PlazyEnvirN
summary:: instantiate new patterns from a function
related:: Classes/Plazy, Classes/PlazyEnvir, Classes/Pfunc
categories:: Streams-Patterns-Events>Patterns>Function

description::

Evaluates a function that returns a pattern and embeds it in a stream. In difference to link::Classes/Plazy::, the function is evaluated using the environment passed in by the stream. In difference to link::Classes/PlazyEnvir::, PlayzEnvirN expands to strong::multiple parallel patterns:: if the function arguments receive multiple channels. In difference to link::Classes/PlazyEnvir::, this works only with event streams.

ClassMethods::

method::new

argument::func
A link::Classes/Function:: that returns a pattern or any other valid pattern input.

Examples::

code::
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, pan=0;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;

a = PlazyEnvirN({ arg g=0, h=0, dur=1;
	postf("g: %, h: %, dur: %\n", g, h, dur);

	Pbind(
		\instrument, \help_sinegrain,
		\dur, dur,
		\degree, Pseq([g, g, h, g, h], 2)
	)
});
)

// different variants
(a <> (g: 0, h: 3, dur:0.2)).play; // single stream
(a <> (g: [0, 4], h: [3, -1], dur:0.2)).play; // same durations, two streams
(a <> (g: [0, 4], h: [3, -1], dur: [0.2, 0.3])).play; // different durations, two streams
::

For more about the composition operator code::<>:: see: link::Classes/Pchain::.
** class:: Plotter
summary:: Plot numerical data on a window or view
categories:: GUI>Accessories
related:: Reference/plot

description::
Plot data of up to three dimensions on a link::Classes/Window:: or link::Classes/UserView::.

subsection:: Keyboard shortcuts

When the plotter window has focus, the following keyboard shortcuts can be used to change the display:
table::
## + / - || vertical zoom
## = || compare plot channels
## n || toggle normalize display (0..1) / (-1..1), or fit range
## s || toggle superposition (see: superpose)
## m || switch plot mode (see: link::Classes/Plotter#plotMode::)
## e || toggle editing (see: link::Classes/Plotter#editMode::)
## g || toggle horizontal (domain) grid
## G || toggle vertical (codomain) grid
## ctrl-+ / - || zoom font
## alt-click || post value
::

subsection:: Method extensions
Plotter extends other classes with methods. To see what classes implements plot, see link::Overviews/Methods#plot::

method:: plot (args)

code::
// plot array
[1, 6, 2, -5, 2].plot;
(0..100).normalize(0, 8pi).sin.plot;

// nested arrays
{ (0..100).normalize(0, 15.0.rand).sin }.dup(3).plot;
{ { (0..17).normalize(0, 15.0.rand).sin }.dup(4) }.dup(3).plot;

// UGen functions
{ SinOsc.ar([700, 357]) * SinOsc.ar([400, 476]) * 0.2 }.plot;

// Buffer
Buffer.read(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff").plot;

// Env
Env.perc(0.4, 0.6).plot;
::

method:: plotGraph (n,from,to,...)

code::
{ |x| sin(x) }.plotGraph(300,0,2*pi);
{ |x| sin(1/x)*x }.plotGraph(from:0.0001,to:0.2);
::

section:: Changing global defaults

The default styles are kept (and may be overridden) in code::GUI.skin.at(\plot)::. See also link::Classes/GUI:: help.

code::
// specify plot layout
(
GUI.skin.plot.gridLinePattern = FloatArray[1, 0];
GUI.skin.plot.fontColor = Color(0.5, 1, 0);
GUI.skin.plot.gridColorX = Color.yellow(0.5);
GUI.skin.plot.gridColorY = Color.yellow(0.5);
GUI.skin.plot.background = Color.black;
GUI.skin.plot.plotColor = (10..0).normalize(0.1, 1).collect { |i| Color.rand(i) };
GUI.skin.plot.labelX = "X";
GUI.skin.plot.labelY = "Y";
);

(
x = { |i| (0..60).scramble.clump(8) * (3.5 ** i) }.dup(3);
x.plot("ARRAY:PLOT", Rect(200, 300, 600, 500));
)

GUI.skin.plot.put(\plotColor, { Color.rand(0.0, 0.8) } ! 8);
[(0..100), (20..120), (40..140)].squared.flop.bubble.plot;

// reset the defaults:
Plot.initClass;
::

classmethods::

method:: new
argument:: name
Plot window title.
argument:: bounds
The window bounds (a link::Classes/Rect::).
argument:: parent
Either a link::Classes/Window:: / link::Classes/View:: may be passed in - then the plot is embedded. Otherwise a new link::Classes/Window:: is created.
discussion::
code::
(
a = Plotter("the plot", Rect(600, 30, 800, 250));
a.value = (0..1000).normalize(0, 14pi).curdle(0.01).scramble.flat.sin;
)
::

instancemethods::

subsection:: Accessing Instance Variables

method:: makeWindow
Open given plotter in a new window or within a given composite view.
argument:: argParent
Either a link::Classes/Window:: or link::Classes/View:: may be passed in - then the plot is embedded. Otherwise a new link::Classes/Window:: is created.
argument:: argBounds
The window bounds (a link::Classes/Rect::).

method:: plotMode
Set the style of data display.
argument:: symbol
Available modes:
table::
## code::\linear:: || connecting data points with linear interpolation
## code::\points:: || draw data points only
## code::\plines:: || combination of lines and points
## code::\levels:: || horizontal lines
## code::\steps:: || connecting data points with step interpolation
::
discussion::
code::
a = (0..20).scramble.plot;
a.plotMode = \points; a.refresh;
a.plotMode = \plines; a.refresh;
a.plotMode = \levels; a.refresh;
a.plotMode = \steps; a.refresh;
a.plotMode = \linear; a.refresh;
::

method:: setProperties
Set properties of all plot views. Defaults are taken from code::GUI.skin.at(\plot);::
argument:: ... pairs
A list of symbol,value pairs. Supported properties:
list::
## font
## fontColor
## gridColorX
## gridColorY
## plotColor (an link::Classes/Array::)
## backgroundColor
## gridLinePattern
## gridLineSmoothing ( link::Classes/Boolean:: )
## labelX
## labelY
## gridOnX ( link::Classes/Boolean:: )
## gridOnY ( link::Classes/Boolean:: )
::
discussion::
Example:
code::
(
a = { (0..30).scramble }.dup(2).plot;
a.setProperties(
	\fontColor, Color.red,
	\plotColor, Color.blue,
	\backgroundColor, Color.black,
	\gridColorX, Color.white,
	\labelX, "Humidity"
);
a.refresh;
);

GUI.skin.at(\plot); // defaults
::

method:: editMode
If the edit mode is set to true, the data may be edited via cursor.
code::
a = (0..20).plot;
a.editMode = true; // now edit the data by clicking into the plot..
a.value; // the value
::

method:: resolution
Set the number of data points displayed maximally per pixel (default: 1)
code::
a = (0..200).scramble.plot;
a.resolution = 8; a.refresh; // resizing the window shows interpolation
a.resolution = 1; a.refresh;
::

method:: findSpecs
If true (default: code::true::), specs are derived from new data (using min and max values) automatically.

method::superpose
If set to true, plotter displays channels on top of each other (keyboard shortcut: s)
code::
a = { (0..30).scramble }.dup(2).plot;
a.superpose = true; a.refresh;
::

method:: value
Return or set the data values. Data may be numerical arrays of up to 3 dimensions.
code::
a = [1, 4, 2, 7, 4].dup(2).plot;
a.value;
::

method:: data
Reference to the current internal data.

method:: cursorPos
Returns:: the last cursorPos (a link::Classes/Point::).

method:: plots
Returns:: the single subplots (a link::Classes/Plot::).


method:: specs
Set or get the spec for the y-axis (codomain).
code::
a = { (40..3000).scramble }.dup(2).plot;
a.specs = \freq.asSpec; a.refresh;
::

method:: domainSpecs
Set or get the spec for the x-axis (domain).
code::
a = { (40..300).scramble }.dup(2).plot;
a.domainSpecs = \freq.asSpec; a.refresh;
::

method:: editFunc
Supply a function which is evaluated when editing data. The function is called with the arguments: code::plotter::, code::plotIndex::, code::index::, code::val::, code::x::, code::y::.
discussion::
Example:
code::
(
a = { (0..10).scramble.normalize }.dup(2).plot;
a.editMode = true;
a.editFunc = { |...args| args.postln };
);

// using plotter as a control interface
(
a = (0..10).scramble.normalize(300, 400).plot;
a.specs = \freq; a.plotMode = \points;
a.editMode = true;
x = { SinOsc.ar(\freq.kr(a.value)).mean * 0.1 }.play;
a.editFunc = { |plotter, plotIndex, i, val|
	x.setn(\freq, a.value)
};
a.parent.onClose = { x.release };
);

(
a = { (0..10).scramble.normalize(300, 400) }.dup.plot;
a.specs = \freq; a.plotMode = \levels;
a.editMode = true;
x = {
	var phase = SinOsc.ar(\rate.kr(a.value[1]));
	SinOsc.ar(\freq.kr(a.value[0]), phase).mean * 0.1
}.play;
a.editFunc = { |plotter, plotIndex, i, val|
	x.setn(\freq, a.value[0]);
	x.setn(\rate, a.value[1]);
};
a.parent.onClose = { x.release };
);
::

examples::

code::
// embedding in another GUI
(
w = Window("plot panel", Rect(20, 30, 520, 250));
Slider.new(w, Rect(10, 10, 490, 20)).resize_(2).action_ { |v|
	a.value = (0..(v.value * 80).asInteger).scramble;
	w.refresh;
};
z = CompositeView(w, Rect(10, 35, 490, 200)).background_(Color.rand(0.7)).resize_(5);
a = Plotter("plot", parent: z).value_([0, 1, 2, 3, 4].scramble * 100);
w.front;
)


(
a = Plotter("the plot", Rect(600, 30, 600, 400));
a.value = (0..100).normalize(0, 8pi).sin;
)

a.value = { |i| (0..90) % (i + 12) + ( (0..90) % (i + 2 * 1) ) }.dup(3);
a.value = (0..12).squared;
a.plotMode = \points; a.refresh;
a.plotMode = \levels; a.refresh;
a.plotMode = \plines; a.refresh;

a.domainSpecs = [[0, 115, \lin, 1]]; a.refresh;

a.parent.close; // close window
a.makeWindow;	// open it again

a.value = { (0..70).scramble }.dup(3);
a.plotMode = \linear; a.refresh;
a.value = { |i| (0..2000).normalize(0, 4pi + i).sin } ! 4; // lots of values, test efficiency
a.value = { |i| (0..10000).normalize(0, 8pi + i).sin } ! 3; // lots of values, test efficiency
a.value = { (0..140).scramble } ! 7;

a.value = { |i| (0..90).normalize(0, 8pi + (i*2pi)).sin } ! 2 * [400, 560] + 700;
a.value = { |i| (_ + 2.0.rand).dup(100).normalize(0, 8pi + i).sin } ! 2 * 400 + 700;


// multi channel expansion of single values
a.value = { |i| (_ + 2.0.rand).dup(100).normalize(0, 8pi + i).sin *.t [1, 2, 3] } ! 2 * 400 + 700;
a.value = { |i| (0..10) **.t [1, 1.2, 1.3, 1.5] * (3.5 ** i) }.dup(3);

a.parent.bounds = Rect(400, 100, 500, 700);
a.parent.bounds = Rect(600, 30, 500, 300);

a.superpose = true;
a.value = { |i| (0..20) * (3.5 ** i) }.dup(5);
a.superpose = false;

// specs

a.value = (50..90).midicps.scramble;
a.specs = \freq; a.refresh;
a.value = (1..60).scramble.neg;
a.specs = \db; a.refresh;

a.value = { |i| { exprand(1e3, (10 ** (i + 8))) }.dup(90) }.dup(3);
a.value = { { exprand(1e3, 1e9) }.dup(90) }.dup(3);
a.specs = [[1e3, 1e10, \exp], [1e3, 1e20, \exp], [1e3, 1e30, \exp]]; a.refresh;
a.domainSpecs = [[0, 5], [-8, 100], [-1, 1]]; a.refresh;


// Array:plot
(
a = (4 ** (-5..0)).postln.plot;
a.specs = \delay; a.refresh;
a.domainSpecs = [0, 10, \lin, 0, 0, " Kg"].asSpec; a.refresh;
);

a.domainSpecs = [0.1, 10, \exponential, 0, 0, " Kg"].asSpec; a.refresh;
a.domainSpecs = [-10, 10, \lin, 0, 0, " Kg"].asSpec; a.refresh;


a = [(0..100) * 9, (200..1300) * 2, (200..1000)/ 5].plot;
a.superpose = true;

a = [[0, 1.2, 1.5], [0, 1.3, 1.5, 1.6], [0, 1.5, 1.8, 2, 6]].midiratio.plot;
a.plotMode = \levels; a.refresh;
a.superpose = false;


// Function:plot
a = { SinOsc.ar([700, 357]) * SinOsc.ar([400, 476]) * 0.2 }.plot;
a = { SinOsc.ar([700, 357] *0.02) * SinOsc.ar([400, 476]) * 0.3 }.plot(0.2, minval: -1);
a = { SinOsc.ar(440) }.plot(1);


// Env:plot
Env.perc(0.4, 0.6).plot;
Env.new({ 1.0.rand2 }! 8, { 1.0.rand } ! 7, \sin).plot;

// Buffer:plot
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff");
		// Platform.resourceDir +/+ "sounds/SinedPink.aiff" contains SinOsc on left, PinkNoise on right
b.plot;
b.free;
::

** class:: Plprand
summary:: random values that tend toward lo
related:: Classes/Phprand
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::length
number of values produced.

Examples::

code::
(
var a, c, w;
a = Plprand(0.0, 1.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Plprand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Plprand(0.0, 1.0, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)

// this is equivalent to:
(
{
	loop {
		Synth(\help_sinegrain, [\freq, min(rrand(0.0, 1.0), rrand(0.0, 1.0)) * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::
** class:: Pluck
summary:: A Karplus-Strong UGen
categories:: UGens>Delays

description::
A Karplus-Strong UGen

classmethods::
method:: ar

argument:: in
an excitation signal.
argument:: trig
upon a negative to positive transition, the excitation signal will be fed into the delay line.
argument:: maxdelaytime
the max delay time in seconds (initializes the internal delay buffer).
argument:: delaytime
delay time in seconds.
argument:: decaytime
time for the echoes to decay by 60 decibels. Negative times emphasize odd partials.
argument:: coef
the coef of the internal OnePole filter. Values should be between -1 and +1 (larger values will be unstable... so be careful!).
argument:: mul
argument:: add

examples::
code::
s.boot;

// excitation signal is WhiteNoise, triggered twice a second with varying OnePole coef
(
	{Pluck.ar(WhiteNoise.ar(0.1), Impulse.kr(2), 440.reciprocal, 440.reciprocal, 10,
		coef:MouseX.kr(-0.999, 0.999))
	}.play(s)
)
s.quit;
// a group of angry fretless mandolin players
(
	{
		var freq, numparts;
		numparts = 50;
		freq = SinOsc.kr(Array.fill(numparts, {Rand(0.05, 0.2)}),
			Array.fill(numparts, {Rand(0, 1.0)})).range(1000, 3000);
		LeakDC.ar(
			Pan2.ar(
				Pluck.ar(
					WhiteNoise.ar(0.1).dup(numparts),
					Impulse.kr(Array.fill(numparts, {Rand(10, 12)})),
					100.reciprocal, freq.reciprocal, 2, Rand(0.01, 0.2), mul: 1),
				Array.fill(numparts, {Rand.new(-1.0, 1.0)}))
			.sum
			);
		}.play(s);
)
::
** class:: Pmeanrand
summary:: random values that tend toward ((lo + hi) / 2)
related:: Classes/Plprand, Classes/Phprand
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::length
number of values produced.

Examples::

code::
(
var a, c, w;
a = Pmeanrand(0.0, 1.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Pmeanrand", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pmeanrand(0.0, 1.0, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)

// this is equivalent to:
(
{
	loop {
		Synth(\help_sinegrain, [\freq, (rrand(0.0, 1.0) + rrand(0.0, 1.0) * 0.5) * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::
** class:: Pmono
summary:: monophonic event stream
related:: Classes/Pbind, Classes/PmonoArtic
categories:: Streams-Patterns-Events>Patterns>Event

description::

Plays one instance of a link::Classes/Synth::. The pattern pairs define changes in that one synth's controls. This node is created when entering a Pmono, and released when the Pmono terminates. There is just one node for the duration of the entire pattern, and it will sustain through each event. If a monophonic phrase requires staccato notes or re-articulation between some notes, see link::Classes/PmonoArtic::.

If event[\id] is not nil, Pmono simply directs its pattern changes to that node and does not create an extra synth.

Examples::

code::
p = Pmono(\default, \dur, 0.2, \freq, Pwhite(1,8) * 100 ).play

p.stop

// multi channel expansion is supported:
p = Pmono(\default, \dur, 0.2, \freq, Pwhite(1,8) * 100, \detune, [0,2,5,1]).play

p.stop


// the following example will end after 5 seconds
// or you can stop it sooner with a stop message
(
p = Pfindur(5,
	Pset(\detune,Pwhite(0,1.0) * [0,1,3,7],
		Ppar([
			Pmono(\default, \dur, 0.2, \freq, Pwhite(1,8) * 100 ),
			Pmono(\default, \dur, 0.1, \freq, Pwhite(1,8) * 300)
		])
	)
).play;
)
p.stop;
::

subsection::A related approach

A related approach is to instantiate a Synth yourself and then set its values by using an link::Classes/Event:: whose "type" is code::\set::, as illustrated here. The user is responsible for ensuring proper synchronization between between link::Classes/Synth:: creation and pattern execution.

code::
// First we create something to control
x = {|freq=440, amp=0.6| MoogFF.ar(PinkNoise.ar(amp), freq).dup}.play;

// In the following pattern, the first two keys are the ones that create the monophonic behaviour:
(
p = Pbind(
	\type, \set,	// This tells it we'll be setting parameters of an existing node...
	\id, x.nodeID,	// ...this tells it whose parameters we'll be setting
	\args, #[\freq, \amp],  // and this tells it which parameters to set
	\freq, Pwhite(100, 1000),
	\dur, 0.2,
	\amp, Pseq((1,0.99 .. 0.1), inf)
).play;
)

p.stop
x.free
::

For more details on the code::\set:: event type, see its description in Chapter 8, link::Tutorials/A-Practical-Guide/PG_08_Event_Types_and_Parameters##Event Types and Parameters:: of the Practical Guide To Patterns.

subsection::SynthDef variant support

SynthDefs allow alternate sets of default values to be defined (see "Variants" in link::Classes/SynthDef:: help). Most event patterns, such as Pbind, specify the variant using the variant key in the output events. (Note that variants are always optional.) In Pmono, the mechanism is different because the the SynthDef name, including variant suffix, must be known before evaluating the first event. So, the variant suffix is provided in the first Pmono argument:

code::
Pmono('synthDefName.variant', pairs...)
::
** class:: PmonoArtic
summary:: partly monophonic event stream
related:: Classes/Pbind, Classes/Pmono
categories:: Streams-Patterns-Events>Patterns>Event

description::

Like link::Classes/Pmono::, PmonoArtic plays one synth at a time (where successive events change the parameters of the existing synth node). PmonoArtic, however, allows events to re-articulate and supports staccato in the middle of a monophonic phrase.

If an event specifies a 'sustain' value shorter than the event delta, it means the synth should not sustain all the way through to the next event. In that case, the node will be released according to 'sustain' and the next event will start a new synth.

If sustain >= delta, the synth will play through and its parameters will change (just like link::Classes/Pmono::).

Since sustain is calculated as code::~dur * ~legato::, this means code::~legato < 1.0:: causes re-articulation while code::~legato >= 1.0:: causes a slur.

Examples::

code::
// This SynthDef has a harder attack than the default, illustrating rearticulation more clearly.
(
SynthDef(\sawpulse, { |out, freq = 440, gate = 0.5, plfofreq = 6, mw = 0, ffreq = 2000, rq = 0.3, freqlag = 0.05, amp = 1|
	var sig, plfo, fcurve;
	plfo = SinOsc.kr(plfofreq, mul:mw, add:1);
	freq = Lag.kr(freq, freqlag) * plfo;
	fcurve = EnvGen.kr(Env.adsr(0, 0.3, 0.1, 20), gate);
	fcurve = (fcurve - 1).madd(0.7, 1) * ffreq;
	sig = Mix.ar([Pulse.ar(freq, 0.9), Saw.ar(freq*1.007)]);
	sig = RLPF.ar(sig, fcurve, rq)
		* EnvGen.kr(Env.adsr(0.04, 0.2, 0.6, 0.1), gate, doneAction:2)
		* amp;
	Out.ar(out, sig ! 2)
}).add;
)

p = PmonoArtic(\sawpulse, \dur, 0.2, \freq, Pwhite(1,8) * 100, \legato, Pwrand(#[0.5, 1.0], #[0.1, 0.9], inf) ).play;

p.stop;
::
** class:: Pmul
summary:: multiply with value of a key in event stream
related:: Classes/Padd, Classes/Pmulp
categories:: Streams-Patterns-Events>Patterns>Math

ClassMethods::

method::new

argument::value
can be a pattern or a stream. The resulting stream ends when that incoming stream ends.

Examples::

code::
(
var a, b;
a = Pmul(\freq, 801, Pbind(\freq, 100));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
(
var a, b;
a = Pmul(\freq, Pseq([3, 4, 6], 2), Pbind(\freq, 100));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
//sound example
(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, gate=1;
		var env;
		env = EnvGen.kr(Env.asr(0.001, 1, 0.2), gate, doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain, \freq, 440);
b = Pmul(\freq, Pseq([1, 2, 3, 4, 5, 6, 7], inf), a);
b.play;
)
::
** class:: Pmulp
summary:: multiply with each value of a pattern to value of a key in event stream
related:: Classes/Pmul, Classes/Paddp
categories:: Streams-Patterns-Events>Patterns>Math

description::

Multiplies a value in an event stream until it ends, repeats this with new values until the value stream ends.

ClassMethods::

method::new

argument::value
can be a pattern, a stream or an array. The resulting stream ends when that incoming stream ends.

Examples::

code::
(
var a, b;
a = Pmulp(\freq, Pseq([2, 3, pi],inf), Pbind(\freq, Pseq([100, 200, 300])));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
//sound example
(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\freq, Pseq([500, 600, 700]), \instrument, \sinegrain);
a = Pmulp(\freq, Pseq([0.5, 0.9, 0.8], inf), a);
a.play;
)
::
** class:: Pmulpre
summary:: multiplies with value of a key in event stream, before it is passed up
related:: Classes/Pmul, Classes/Pmulp
categories:: Streams-Patterns-Events>Patterns>Math

description::

Multiplies with a value in an event, strong::before it is passed up:: the stream. To multiply with the value after it has been passed down, use link::Classes/Pmul::.

code::
(
var a, b;
a = Pmulpre(\note, 2, Pbind(\note, Pseq([1, 2, 3])));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)
::

Pmulpre does not override incoming values:
code::
(
var a, b;
a = Pmulpre(\freq, 801, Pset(\freq, 500, Pbind(\dur, 0.2)));
x = a.asStream;
9.do({ x.next(Event.default).postln; });
)
::

ClassMethods::

method::new

argument::value
can be a pattern or a stream. The resulting stream ends when that incoming stream ends.

Examples::

code::
(
var a, b;
a = Pmulpre(\freq, Pseq([401, 801], 2), Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

code::
//sound example
(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain);
b = Pmulpre(\freq, Pseq([1, 2, 3], inf), a);
b.play;
)
::
** class:: Pn
summary:: repeatedly embed a pattern
related:: Classes/Pstutter
categories:: Streams-Patterns-Events>Patterns>Repetition

ClassMethods::

method::new

argument::pattern
the pattern to repeat

argument::repeats
Repeats the enclosed pattern strong::repeats:: times.

argument::key
If strong::key:: is non-nil, it sets the value of that key to true whenever it restarts the pattern. This can be used to advance Patterns enclosed by link::Classes/Pgate::.

Examples::

code::
(
var a, b;
a = Pn(Pseq(#[1, 2, 3], 1), 4);	// repeat pattern four times
b = a.asStream;
16.do({ b.next.postln; });
)

// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pn(Pshuf([1, 2, 2, 3, 3, 3], 4)).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.2.wait;
	}
}.fork;
)
::
** class:: Pnaryop
summary:: n-ary operator pattern
related:: Classes/Pbinop, Classes/Punop, Classes/NAryOpFunction
categories:: Streams-Patterns-Events>Patterns>Math

description::

Returns a stream that applies the n-ary operator to the stream values of the receiver, taking n-1 streams as arguments. Usually, this is the result of applying an n-ary operator (i.e. a method with more than one argument) to a pattern.

Examples of n-ary operators are: blend, linlin, linexp, explin, expexp, clip, fold, wrap.

ClassMethods::

method::new

argument::operator
operator to be applied

argument::a
a pattern (or compatible pattern input)

argument::arglist
a list of patterns (or compatible pattern inputs)

Examples::

code::
(
var a;
a = Pnaryop(\wrap, Pseries(0, 1, 12), [3, 7]);
a.asStream.all;
)

// this is the same as:
(
var a;
a = Pseries(0, 1, 12).wrap(3, 7);
a.asStream.all;
)

// the scale argument can also be a pattern:

(
var a;
a = Pnaryop(\wrap, Pseries(0, 1, 12), [Pseq([3, 4, 5], inf), Pseq([9, 7], inf)]);
a.asStream.all;
)


// common cases:
Pwhite(0, 1, inf).linexp(0, 1, 200, 1000);
Pwhite(0, 1, inf).degreeToKey([0, 1, 3, 5, 7, 9, 11], 10);
blend(Pseq([1, 2, 3], inf), Pseq([3, 2, 1, 0], inf), Pseries(0, 0.01, inf));
::

code::
// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, amp=0.1;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2, amp), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pnaryop(\wrap, Pseries(0, 1, 12), [3, 7]).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, (val + 72) .midicps.postln]);
		0.5.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.1,
	\instrument, \help_sinegrain,
	\note, Pnaryop(\wrap, Pseries(0, 1, 12), [3, 7]);
).play;
)



// these are the same as:

(
var a;
a = Pseries(0, 1, 12).wrap(3, 7).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, (val + 72) .midicps.postln]);
		0.5.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.1,
	\instrument, \help_sinegrain,
	\note, Pwhite(0, 12, inf).wrap(3, 7);
).play;
)
::
** class:: Pnsym
summary:: use a pattern of symbols to embed Pdefns
categories:: Libraries>JITLib>Patterns
related:: Classes/Pdefn

description::
for event patterns see link::Classes/Psym::. Overview: link::Overviews/JITLib::.

ClassMethods::

method::new

argument::pattern
a pattern that returns symbols or characters. Arrays are converted to parallel patterns ( link::Classes/Ptuple:: ).

argument::dict
the dictionary to be used for lookup. By default, this is code::Pdefn.all::, so one can embed Pdefns by name.

InstanceMethods::

method::dict
set the dictionary to be used.

Examples::

code::
(
// load a synthdef
s.boot;
SynthDef("gpdef",
	{ arg out=0, freq=440, sustain=0.05, amp=0.1, pan;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain), doneAction:2) * amp;
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;
)

Pdefn(\x, Pn(1, 3));
Pdefn(\y, Prand([5, 9, 1], 2));
Pdefn(\z, Pdefn(\y) * 2);

(
Pdef(\play,
	Pbind(
		\instrument, \gpdef,
		\harmonic, Pnsym(Pseq([\x, \x, Prand([\x, \y]), [\z, \y], \y], inf)).trace,
		\dur, 0.2, \note, 10
	)
).play;
)

// change root pattern:
Pdefn(\x, Pn(2, 3));
Pdefn(\x, Pseq([1, 3, 1, 2, 1, 4, 5]));
Pdefn(\x, Pseq([1, 3, 1, 2, [1, 3], 4, 5]));
::
** class:: Point
summary:: Cartesian point
related:: Classes/Polar, Classes/Complex
categories:: Geometry

description::
Defines a point on the Cartesian plane.

classmethods::

method::new
Defines a new point.

instancemethods::

subsection:: Accessing

method::x
Get or set the x coordinate value.

method::y
Get or set the y coordinate value.

method::set
Sets the point x and y values.

subsection:: Testing

method::==
Answers a Boolean whether the receiver equals the argument.

method::hash
Returns a hash value for the receiver.

subsection:: Math

method::+
Addition.

method::-
Subtraction.

method::*
Multiplication.

method::/
Division.

method::translate
Addition by a Point.

method::scale
Multiplication by a Point.

method::rotate
Rotation about the origin by the angle given in radians.

method::abs
Absolute value of the point.

method::rho
Return the polar coordinate radius of the receiver.

method::theta
Return the polar coordinate angle of the receiver.

method::dist
Return the distance from the receiver to aPoint.

method::transpose
Return a Point whose x and y coordinates are swapped.

method::round
Round the coordinate values to a multiple of quantum.

method::trunc
Truncate the coordinate values to a multiple of quantum.

subsection:: Conversion

method::asPoint
Returns the receiver.

method::asComplex
Returns a complex number with x as the real part and y as the imaginary part.

method::asString
Return a string representing the receiver.
** class:: Polar
summary:: Polar coordinates
related:: Classes/Point, Classes/Complex
categories:: Math

description::
Represents polar coordinates.

classmethods::

method:: new
Create a new polar coordinate with the given radius, rho, and angle in radians, theta.



instancemethods::

subsection:: Math
method:: +, -, *, /
The math operations of addition, subtraction, multiplication and division are accomplished by
first converting to complex numbers.

method:: scale
Scale the radius by some value.

method:: rotate
Rotate the angle by some value.

method:: neg
Rotate by pi.


subsection:: Conversion

method:: magnitude
Answer the radius.

method:: angle
Answer the angle in radians

method:: phase
Answer the angle in radians

method:: real
Answer the real part.

method:: imag
Answer the imaginary part.

method:: asComplex
Convert to Complex

method:: asPoint
Convert to Point

** class:: Poll
categories:: UGens>Info
summary:: Print the current output value of a UGen
related:: Classes/SendTrig, Classes/OSCFunc

description::

Print the current output value of a UGen, useful for debugging SynthDefs.

WARNING:: Printing values from the Server in intensive for the CPU. Poll should be used for debugging purposes.::

classmethods::
private:: categories, new, new1

method:: ar, kr
argument::trig
a non-positive to positive transition telling Poll to return a value
argument::in
the signal you want to poll
argument::label
a string or symbol to be printed with the polled value
argument::trigid
if greater then 0, a '/tr' message is sent back to the client (similar to SendTrig)

returns:: its in signal (and is therefore transparent).

instancemethods::
private:: checkInputs, init

examples::
code::
s.boot;

{ Poll.kr(Impulse.kr(10), Line.kr(0, 1, 1), \test) }.play(s);

// multichannel expansion:

{ Poll.kr(Impulse.kr([10, 5]), Line.kr(0, [1, 5], [1, 2]), [\test, \test2]) }.play(s);



// using the poll message:

{ SinOsc.ar(375, 0, 1).poll(Impulse.ar(20), \test2) }.play(s);

// if no arguments are given, the poll is done every 0.1 sec.
{  Line.kr(0, 1, 1).poll }.play(s);


// send a '/tr' message back to the client. This can be useful if the server runs on another
// computer than the client, i.e. the post messages by the server cannot be read locally.

o = OSCFunc({arg msg; msg.postln;}, '/tr', s.addr);

{Poll.ar(Impulse.ar(5), Line.ar(0, 1, 1), \test2, 1234)}.play(s);
{SinOsc.ar(220, 0, 1).poll(Impulse.ar(15), "test", 1234)}.play(s);

o.free;
s.quit;




// This example will kill the server (by outputting NaN).
// Poll.ar will help us spot why it's happening.
// Warning: You may need to reboot your server after running this.
(
{
var cutoff, son;
cutoff = LFPar.kr(0.2, 0, 500, 500);
son = LPF.ar(WhiteNoise.ar, cutoff);

// Using Poll to debug by spitting out a value if the output hits NaN
Poll.ar(if((son<=0)||(son>=0), 0, 1), cutoff, "Cutoff value which causes NaN:");

son;

}.play(s);
)


// This example polls when someone hits the trigger
(
x = {|t_poll=0|
var minfreq, maxfreq, son;
minfreq = LFNoise2.ar(0.25, 100, 110);
maxfreq = LFNoise2.ar(0.25, 200, 220);

son = Gendy1.ar(minfreq: minfreq, maxfreq: maxfreq, mul: 0.1);

Poll.kr(t_poll, [minfreq, maxfreq], ["minfreq", "maxfreq"]);

son;

}.play(s);
)

x.set(\t_poll, 1); // Hit this whenever you want to know what the parameters are
::

** CLASS:: PopUpMenu
redirect:: implClass
summary:: A view displaying a text item selectable from a drop-down menu.
categories:: GUI>Views

DESCRIPTION::

When clicked, this view opens a menu containing several text items, then closes the menu and displays one of the items after it is selected.

CLASSMETHODS::

PRIVATE:: key




INSTANCEMETHODS::



SUBSECTION:: Data

METHOD:: items
	The list of items displayed in a menu when the view is clicked.

	argument::
		An Array of Strings or Symbols.

METHOD:: clear
    note:: Only available in Qt GUI ::
    Removes all items.

METHOD:: item
	The currently selected item.

	returns::
		A String.

METHOD:: value
	The index of the currently selected item.

	argument::
		An integer, or nil meaning no selected item.

METHOD:: valueAction
	Sets link::#-value:: and triggeres link::#-action::.

	argument::
		An integer, or nil meaning no selected item.



SUBSECTION:: Appearance

METHOD:: stringColor
	The color used to display text.

	argument::
		A Color.

METHOD:: background
	Setting this variable colors the area of the view under the text with the given color.

	argument::
		A Color.



SUBSECTION:: Interaction

METHOD:: allowsReselection
	Determines whether the action is triggered when selecting already selected item. Defaults to false.

	argument::
		A Boolean.



SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user changes the selected item from the menu. See link::#-allowsReselection:: for customization.



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The link::#-value::.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a number.

METHOD:: defaultReceiveDrag
	Sets link::#-valueAction:: to the current drag data.



EXAMPLES::

subsection:: Basic Example

code::
(
w = Window.new("The Eightfold Path").front;
m = PopUpMenu(w,Rect(10,10,180,20));

m.items = [
    "right view","right thinking","right mindfulness","right speech",
    "right action","right diligence","right concentration","right livelihood"
];

m.background_(Color.green(0.7));        // only changes the look of displayed item
m.stringColor_(Color.white);            // only changes the look of displayed item
m.font_(Font("Courier", 13));           // only changes the look of displayed item
m.action = { arg menu;
    [menu.value, menu.item].postln;
};
)

m.value;            // returns the index of the current item;
m.item;             // returns the String or Symbol of the current item

m.value_(2);        // changes the displayed item, but does not evaluate the action
m.valueAction_(3);  // evaluates the action.
::

subsection:: Sound Example

Play different functions:

code::
(
s.waitForBoot({

    var w,menu,snd,funcs,b;

    w=Window.new.front;

    menu=PopUpMenu(w,Rect(10,10,90,20))
        .items_(["Sine" , "Saw" , "Noise" , "Pulse"]);

    funcs=[
        {SinOsc.ar(440,0,0.3)},
        {Saw.ar(440,0.3)},
        {WhiteNoise.ar(0.3)},
        {Pulse.ar(440,0.2,0.3)}
    ];

    b=Button(w,Rect(110,10,180,20))
        .states_([["play",Color.black,Color.green]])
        .mouseDownAction_({
                snd = funcs.at(menu.value).play;
            })
        .action_({ arg butt, mod;
                snd.free;
            });

    w.front;

    p=CmdPeriod.add({b.value_(0)}); // set button to 0 on hitting Cmd-period
    w.onClose_{ snd.free; CmdPeriod.removeAll }; // clean up when window is closed

})
)
::
** CLASS::Post
summary::posts text to the post window
categories:: Files

DESCRIPTION::
The class Post is a stream destination. Its main use is that it can sometimes make code more readable and execution slightly more efficient.
code::
Post <<< a << " " <<< b << " " <<< c << " " <<< d << Char.nl;
::
vs
code::
(a.asCompileString + b.asCompileString + c.asCompileString + d.asCompileString).postln;
::

warning::
<< also means object left shift.
::

CLASSMETHODS::

method::<<
Post as string
code::
Post << "string";
::

method::<<<
Post as compile string
code::
Post <<< "string";
::

method::comma
Prints a comma
code::
Post.comma;
::

method::space
Prints a space
code::
Post.space;
::

method::nl
Prints a newline
code::
Post.nl;
::

method::ff
Prints the char $\f
code::
Post.ff;
::

method::tab
Prints a tab
code::
Post.tab;
::

EXAMPLES::

code::
a = "a string";
b = 'a symbol';
c = 4;
d = [1,2,3,4,a,b];

// post as string
Post << a << Char.nl;
// post as compile string
Post <<< a << Char.nl;

// post as string
Post << d << Char.nl;
// post as compile string
Post <<< d << Char.nl;

//This is the equivalent of :
d.postln;
//or
d.asCompileString.postln;
::
** class:: Ppar
summary:: embed event streams in parallel
related:: Classes/Pgpar, Classes/Pbus, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Parallel

description::

Embeds several event streams so that they form a single output stream with all their events in temporal order. When one stream ends, the other streams are further embedded until all have ended.

ClassMethods::

method::new

argument::list
list of patterns or streams.

argument::repeats
repeat the whole pattern n times.

Examples::

code::
// see the delta values in the resulting events
(
var a, b, c, t;
a = Pbind(\x, Pseq([1, 2, 3, 4]), \dur, 1);
b = Pbind(\x, Pseq([10, 20, 30, 40]), \dur, 0.4);
c = Ppar([a, b]);
t = c.asStream;
20.do({ t.next(Event.default).postln; });
)

// sound example
(
var a, b;
a = Pbind(\note, Pseq([7, 4, 0], 4), \dur, Pseq([1, 0.5, 1.5], inf));
b = Pbind(\note, Pseq([5, 10, 12], 4), \dur, 1);
Ppar([ a, b ]).play;
)
::
** class:: PparGroup
summary:: Starts a new ParGroup and plays the pattern in this group
related:: Classes/ParGroup, Classes/Pgroup
categories:: Streams-Patterns-Events>Patterns>Server Control

description::

The class has a semantics similar to link::Classes/Pgroup::, but instead of a Group, it creates a ParGroup on the
server.

Examples::

code::
(
var p, q, r, o;
p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);

PparGroup(p).play;

// post the node structure:
fork {
	s.queryAllNodes;
	3.wait;
	s.queryAllNodes;
	2.wait;
	s.queryAllNodes;
}
)
::
** class:: Ppatlace
summary:: interlace streams
related:: Classes/Place
categories:: Streams-Patterns-Events>Patterns>List

description::

Similar to link::Classes/Place::, but the list is an array of streams or patterns. The results of each stream will be output in turn.

Examples::

code::
p = Ppatlace([Pwhite(1, 5, 5), Pgeom(10, 1.01, 10)], inf);
x = p.asStream;
x.all;


5		// from Pwhite
10		// from Pgeom
4		// from Pwhite
10.1		// etc....
5
10.201
4
10.30301
2
10.4060401
10.510100501
10.61520150601
10.72135352107
10.828567056281
10.936852726844
nil
::

Note that the Ppatlace has an infinite number of repeats, but the resulting stream is finite because the member streams are all finite. When the first stream (Pwhite) comes to an end, it is skipped and you see only the second stream until it stops.

If even one member stream is infinite and Ppatlace has infinite repeats, the Ppatlace stream will also be infinite.


code::
//Ppatlace as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


// interlace two streams
(
var c = Ppatlace([
		Pseq([0, 0, 0, 0, 8, 0, 8], inf),
		Pseries(1, 1, 32)
	], inf) + 67;
x = c.asStream;

Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.midicps, \dur, 0.2]);
		0.17.wait;
	})
}).play;
)




// a more complicated example:
(
c = Ppatlace([
	Pxrand([
		Pseq(#[0, -2, -3, -5, -7], 1), Pwhite(-12, 4, 3), Pshuf(#[0, -2, -3, -5, -7], 1)
	], inf),
	Pxrand([
		Pseq(#[0, 2, 4, 5, 7], 1), Pwhite(-4, 12, 3), Pshuf(#[0, 2, 4, 5, 7], 1)
	], inf)
], inf) + 67;
x = c.asStream;

Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.midicps, \dur, 0.2]);
		0.17.wait;
	})
}).play;
)
::
** class:: Ppatmod
summary:: modify a given pattern before passing it into the stream
related:: Classes/Plazy
categories:: Streams-Patterns-Events>Patterns>Filter

ClassMethods::

method::new

argument::pattern
the pattern.

argument::func
A link::Classes/Function:: that modifies the enclosed pattern and embeds it in the stream.

argument::repeats
the number of repeats.

Examples::

code::
(
a = Ppatmod(
	Pseq([0, 0, 0, 0],1),
	{ arg pat, i;
		var list;
		list = pat.list;
		pat.list = list.put(list.size.rand, 2);
	}, inf);

x = a.asStream;
30.do({ x.next.postln });
)


//Ppatmod used to modify a pattern that produces a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pn(
	Ppatmod(
		Pseq([0, 0, 0, 0],1),
		{ arg pat, i;
			var list;
			list = pat.list;
			pat.list = list.put(list.size.rand, 2);
		}, 15),
inf).asStream;

Routine({
	loop({
		Synth(\help_sinegrain, [\freq, (a.next*5+77).midicps]);
		0.13.wait;
	})
}).play;
)
::
** class:: Ppoisson
summary:: random values that follow a Poisson Distribution (positive integer values)
related:: Classes/Pgauss
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::mean
The mean of the distribution.

argument::length
Number of values produced.

Examples::

code::
(
var a, c, w;
a = Ppoisson(1.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Ppoisson", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

(
var a, c, w;
a = Ppoisson(10.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Ppoisson", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Ppoisson(1.0,inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, (a.next + 72).midicps]);
		0.02.wait;
	}
}.fork;
)

(
var a;
a = Ppoisson(7.0,inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, (a.next + 72).midicps]);
		0.02.wait;
	}
}.fork;
)
::
** class:: Pprob
summary:: random values with arbitrary probability distribution
related:: Classes/Ppoisson
categories:: Streams-Patterns-Events>Patterns>Random

description::

Creates an integral table on instantiation (cpu intensive) which is then used by the streams to generate random values efficiently.

ClassMethods::

method::new

argument::distribution
desired probability distribution (histogram).

argument::lo
lower bound of the resulting values.

argument::hi
upper bound of the resulting values.

argument::length
number of values to repeat.

argument::tableSize
resample table to this size. If the size of the distribution is smaller than 64, it is (linearly) resampled to this minimum size.

argument::distribution
set the distribution, the table is recalculated.

argument::tableSize
set the resample size, the table is recalculated.

Examples::

code::
// a consistency test
(
var a = Pprob([0,0,0,0,1,1,1,1,3,3,6,6,9].scramble);
var b = a.asStream;
b.nextN(800).sort.plot("sorted distribution");
b.nextN(800).sort.plot("sorted distribution, again");
)


// comparison: emulate a linrand
(
var a, b, x, y;
a = Pprob([1, 0]);
x = Pfunc({ 1.0.linrand });

b = a.asStream;
y = x.asStream;

postf("Pprob mean: % linrand mean: % \n", b.nextN(800).mean, y.nextN(800).mean);

b.nextN(800).sort.plot("this is Pprob");
y.nextN(800).sort.plot("this is linrand");
)


// compare efficiency

bench { Pprob([0, 1]) } // this is fairly expensive
bench { 16.do { Pseq([0, 1] ! 32) } }

x = Pprob([0, 1]).asStream;
y = Pseq([0, 1], inf).asStream;

bench { 100.do { x.next } }; // this very efficient
bench { 100.do { y.next } };



// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var t;
a = Pprob([0, 0, 1, 0, 1, 1, 0, 0], 60, 80);
t = a.asStream;
Routine({
	loop({
	Synth(\help_sinegrain, [\freq, t.next.midicps]);
	0.01.wait;
	})
}).play;
)

a.distribution = [0, 1];
a.distribution = [1, 0];
a.distribution = [0, 0, 0, 0, 1, 0];
a.distribution = [0, 1, 0, 0, 0, 0];

// higher resolution results in a more accurate distribution:
a.tableSize = 512;
a.tableSize = 2048;
::
** class:: Pprotect
summary:: evaluate a function when an error occured in the thread
related:: Classes/Ptrace
categories:: Streams-Patterns-Events>Patterns>Language Control

ClassMethods::

method::new

argument::pattern
any pattern

argument::func
a link::Classes/Function:: to be evaluated when an error occurs. The error and the thread are passed as arguments to the function.

Examples::

code::
(
var x;
var func = { "an error happened".postln };
a = Pprotect(Pseq([1, 3, 3, Pfuncn({ Error.throw }), 2]), func);
x = Pbind(\degree, a, \dur, 0.5).play;
)
::
** class:: Pproto
summary:: provide a proto event for an event stream
related:: Classes/Pattern
categories:: Streams-Patterns-Events>Patterns>Server Control

description::

Pproto uses the strong::makeFunction:: to allocate resources (buffers, buses, groups) and create a protoEvent that makes those resources available to a pattern. It is fully compatible with non-realtime synthesis using strong::render::.

The strong::makeFunction:: "makes" the protoEvent (i.e. protoEvent is code::currentEnvironment::). Typically, it defines and yields a sequence of events that create the needed resources using the following eventTypes:

definitionList::
## \allocRead || load a file from ~path, starting at ~firstFileFrame, reading ~numFrames sample frames
## \cue || cue a file for DiskIn, with ~bufferSize frames
## \table || load ~amps directly into a buffer
## \sine1 || generate a buffer from ~amps
## \sine2 || generate a buffer from ~freqs, ~amps
## \sine3 || generate a buffer from ~freqs, ~amps, ~pahses
## \cheby || generate a waveshape buffer from ~amps
## \audioBus || allocate ~channels consecutive audio buses
## \controlBus || allocate ~channels consecutive control buses
## \on || create a synth
::

note::
These eventTypes will allocate their own buffers and buses unless they are specified. To support this, the key code::\bufNum:: is used rather than code::\bufnum:: which has a default value assigned.
::

When Pproto ends, these eventTypes will respond to the strong::cleanup:: call by strong::deallocating any resources they have allocated::. Do not assume your buffers, buses etc. will exist after Pproto stops!

The function yields each event. That event is then performed with possible modifications by enclosing patterns and the player (either an link::Classes/EventStreamPlayer:: or a link::Classes/ScoreStreamPlayer::). The resultant event is returned to the function where it can be assigned to a key within the protoEvent.

The patternarray is played using Pfpar, a variant of Ppar that ends when any of its subpatterns end. In this way,
you can use Pproto to create effects that can be controlled by a pattern that runs in parallel with the note generating pattern and ends together with that note generating pattern (see example 0 below).

A strong::cleanupFunction:: that deallocates resources when the pattern ends or is stopped is automatically created. It can be replaced with a user defined cleanup if needed. This function receives two arguments: strong::proto::, the prototype event, and strong::flag::, which is set false if all nodes have been freed already by link::Classes/CmdPeriod::.

Examples::

subsection::Example 0, using an effect with parallel control.

code::
(
SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 5, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, CombL.ar(in * env, maxdtime, Lag.kr(dtime, 4), decay, 1, in));
}, [\ir, \ir, 0.1, 0.1, 0]).add;

SynthDef(\fm, { arg out=0, freq, index, decay=2, gate=1;
	var env, in;
	env = Linen.kr(gate, 0.05, 1, 5, 2);
	in = In.ar(out, 2);
	XOut.ar(out, env, SinOsc.ar(freq, in * index));
}).add;

Pproto({
	~fsynth = ( type: \on, instrument: \fm, freq: 4, index: 1, addAction: 1, db: -30).yield;
	~fControl = [\set, ~fsynth[\id], ~fsynth[\msgFunc] ];

	~synth = ( type: \on, instrument: \echo, addAction: 1).yield;
	~sControl = [\set, ~synth[\id], ~synth[\msgFunc] ];

	}, [
	Pbind(*[
		#[type, id, msgFunc],	Pkey(\fControl),

		freq:	Pseg([0,1], 10).linexp(0,1, 0.1, 1000),
		index:	Pseg([0,1], 10).linexp(0,1, 0.1, 100),
		dur:	0.1
	]),
	Pbind(*[
		#[type, id, msgFunc],	Pkey(\sControl),

		dtime:	Pwhite(0,0.2),
		decay:	Pwhite(0.1,2),
		dur:	1
	]),
	Pbind(*[
		instrument: \default,
		freq: Pwhite(1,16) * 100,
		dur: 0.2,
		db:	0
	])
	]
).play
)
::

subsection::Example 1, loading and granulating a sound file.

code::
(
SynthDef(\help_playbuf, { | out=0, bufnum = 0, rate = 1, startPos = 0, amp = 0.1, sustain = 1, pan = 0, loop = 1|
	var audio;
	rate = rate * BufRateScale.kr(bufnum);
	startPos = startPos * BufFrames.kr(bufnum);

	audio = BufRd.ar(1, bufnum, Phasor.ar(0, rate, startPos, BufFrames.ir(bufnum)), 1, 1);
	audio = EnvGen.ar(Env.sine, 1, timeScale: sustain, doneAction: 2) * audio;
	audio = Pan2.ar(audio, pan, amp);
	OffsetOut.ar(out, audio);
}).add;

a = Pproto({
	~newgroup = (type: \group).yield;
	~sf1 = SoundFile(Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff").asEvent.yield;
//	(type: \on).yield
},
	Pbind(*[
		instrument:	\help_playbuf,
		dur:		Pseg([0,0,0.25,0.5, 0.75, 1],10).linexp(0,1,0.01,2),
		legato:		4,
		startPos:	Pn(Pseg([0,1], 20), inf),
		rate:		Pwhite(1, 1).midiratio,
		loop:		0,
		group:		Pkey(\newgroup),
		bufnum:		Pkey(\sf1)
	])
);
a.play;
)

//a.render("sounds/test.aif", 40)
//SoundFile.openRead("sounds/test.aif").play
::

subsection::Example 2, loading a waveform buffer and modifying it in performance.

code::
(
SynthDef(\osc,{ arg out=0, bufnum=0, numbufs = 8, sustain = 1, freq = 500, amp = 0.1, pan = 0;
	var audio;
	audio = Osc.ar(bufnum, freq);
	audio = EnvGen.ar(Env.linen(0.01, 0.90,0.9), 1, timeScale: sustain, doneAction: 2) * audio;
	audio = Pan2.ar(audio, pan, amp);
	OffsetOut.ar(out, audio);
}).add;

b = Pproto({
	~bufnum = (type: \sine1, amps: 1.0/[1,2,3,4,5,6] ).yield;
	},
	Ppar([
		Pbind(*[
			instrument: 	\osc,
			freq:		Pwhite(1, 16) * 100,
			detune:		Pfunc { Array.fill(3.rand + 1, {3.0.rand}) },
			dur:		Prand([2,2,2.5,1],10),
			db:		Pn(Pstep([-10, -20, -20, -15, -20, -20, -20], 0.5) ),
			legato:		Pwhite(0.0,1).linexp(0,1,0.1, 3)
		]),
		Pbind(*[
			type:		\sine1,
			amps:		Pseg(Pfunc{ | ev | Array.fill(10, {1.0.rand}) }, 1),
			numOvertones:	Pseg(Pwhite(0, 9), 10).asInteger,
			amps:		Pfunc{ | ev | ev[\amps].copyRange(0, ev[\numOvertones]) },
			dur: 		0.05,
			bufNum:		Pkey(\bufnum)
		])
	])
);
b.play
)

//b.render("sounds/test.aif", 40)
//SoundFile.openRead("sounds/test.aif").play
::

subsection::Example 3, loading a waveshaper buffer and modifying it in performance.

code::
(
SynthDef(\shaper,{ arg out=0, bufnum=0, numbufs = 8, sustain = 1, freq = 500, amp = 0.1, pan = 0;
	var audio;
	audio = SinOsc.ar(freq);
	audio = EnvGen.ar(Env.linen(0.4, 0.50,0.9), 1, timeScale: sustain, doneAction: 2) * audio;
	audio = Shaper.ar(bufnum, audio);
	audio = Pan2.ar(audio, pan, amp);
	OffsetOut.ar(out, LeakDC.ar(audio));
}).add;

c = Pproto({
	~bufnum = (type: \cheby, amps: 1.0/[1,2,3,4,5,6] ).yield;
	},
	Ppar([
		Pbind(*[
			instrument: 	\shaper,
			freq:		Pwhite(1, 16) * 100,
			detune:		Pfunc { Array.fill(3.rand + 1, {3.0.rand}) },
			dur:		Prand([2,2,2.5,1],inf),
			db:		Pn(Pstep([-10, -20, -20, -15, -20, -20, -20], 0.5) ),
			legato:		Pwhite(0.0,1).linexp(0,1,1.1, 5)
		]),
		Pbind(*[
			type:		\cheby,
			amps:		Pseg(Pfunc{ | ev | Array.fill(10, {1.0.rand}) }, 4),
			dur: 		0.05
		])
	])
);
c.play
)
//c.render("sounds/test.aif", 40)
//SoundFile("sounds/test.aif").play
//
::
** class:: Prand
summary:: embed values randomly chosen from a list
related:: Classes/Pxrand, Classes/Pwrand
categories:: Streams-Patterns-Events>Patterns>List

description::

Embed one item from the list at random for each repeat.

Examples::

code::
(
var a, b;
a = Prand([1, 2, 3, 4, 5], 6);	// return 6 items
b = a.asStream;
7.do({ b.next.postln; });
)

// return also a subpattern:
(
var a, b;
a = Prand([1, Pseq([10, 20, 30]), 2, 3, 4, 5], 6);	// return 6 items
b = a.asStream;
7.do({ b.next.postln; });
)

//Prand used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Prand(#[60, 61, 63, 65, 72], inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next.midicps]);
		0.2.wait;
	})
}).play;
)
::
** class:: Preject
summary:: Reject values from a pattern
categories:: Streams-Patterns-Events>Patterns>Filter
related:: Classes/Pselect, Classes/Pcollect

description::
Rejects values for which the function returns true. The value is passed to the function.


classmethods::

method:: new
argument:: func
A link::Classes/Function::. Receives values from code::pattern::.
argument:: pattern
A link::Classes/Pattern::.


examples::
code::
(
var a, b;
a = Preject({ arg item; item == 1 }, Pseq(#[1, 2, 3],inf));
x = a.asStream;
9.do({ x.next.postln; });
)
::

The message reject returns a Preject when passed to a pattern
code::
(
var a, b;
a = Pseq(#[1, 2, 3],inf).reject({ arg item; item == 1 });
a.postln;
x = a.asStream;
9.do({ x.next.postln; });
)
::
** class:: Prewrite
summary:: rewriting system
related:: Classes/Pfsm
categories:: Streams-Patterns-Events>Patterns>List>Indexing

description::

Lindenmayer system pattern for selfsimilar structures. Its strong::dictionary (or event):: maps one element to an array of child elements. The algorithm replaces iteratively (strong::levels:: deep) elements by arrays of elements starting with the values in the strong::pattern::.

ClassMethods::

method::new

argument::pattern
starting value

argument::dict
a dictionary or an event.

argument::levels
number of levels

code::
IdentityDictionary[
	elem1 -> [ otherElements ],
	elem2 -> [ otherElements ],
	elem2 -> [ otherElements ]
]
::

Examples::

The examples use the code::():: shortcut for link::Classes/Event::.

code::
(
a = Prewrite(0, // start with 0
		(	0: #[2,0],
			1: #[0,0,1],
			2: #[1,0,1]
		), 4);
x = a.asStream;
30.do({ x.next.postln });
)


//Prewrite used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Prewrite(0,	(
	0: #[2,0],
	1: #[0,0,1],
	2: #[1,0,1]
), 4).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, (a.next * 5 + 70).midicps]);
		0.1.wait;
	})
}).play;
)
::
** CLASS::PriorityQueue
summary:: Priority queue data structure
categories:: Collections>Ordered

DESCRIPTION::
PriorityQueue implements a priority queue data structure, which is used to build schedulers. It allows you to put in items at some arbitrary time and pop them in
time order.

INSTANCEMETHODS::
private::prInternalArray


method::put
Puts the item in the queue at the given time.

method::topPriority
Returns the time of the earliest item in the queue.

method::pop
Returns the earliest item in the queue.

method::clear
Empty the queue.

method::isEmpty
Return a link::Classes/Boolean:: whether the queue is empty.

method::notEmpty
Return a link::Classes/Boolean:: whether the queue is not empty.

method::removeValue
Remove all instances of value from the queue.


EXAMPLES::

code::
(
var p;
p = PriorityQueue.new;

p.put(0.1, \a);
p.put(2.0, \b);
p.put(0.5, \c);
p.put(0.2, \d);
p.put(1.0, \e);

while ({ p.notEmpty },{
	[p.topPriority, p.pop].postln;
});


p.pop.postln;
p.pop.postln;
p.pop.postln;

)

[ 0.1, a ]
[ 0.2, d ]
[ 0.5, c ]
[ 1, e ]
[ 2, b ]
nil
nil
nil
::
** class::Process
categories::Core>Kernel
summary:: Runtime environment for the virtual machine and interpreter.

description::
A Process is the runtime environment for the virtual machine and interpreter.
It has a subclass named link::Classes/Main:: which is where you should override the methods
of Process. There are two methods of interest. One is named code::startup:: and is
called after the class library has been compiled. The other is named code::run:: and
is called when the user chooses the Run menu command.

classMethods::

method::tailCallOptimize
Get or set tail call optimization. The default is on. Setting this to code::false:: can help with debugging by including intermediate levels in an error backtrace.

instanceMethods::

method::startup

called after the class library has been compiled. Override this in class link::Classes/Main:: to do whatever you want.

method::run

called when the user chooses the Run menu command. Override this in class link::Classes/Main:: to do whatever you want.

method::mainThread

The top-level link::Classes/Thread::, i.e the link::Classes/Thread#-parent#parent:: of all
other Threads. This instance of Thread always exists and is created with the Process when
SuperCollider starts.

discussion::

All SuperCollider code initially runs in the context of the main Thread:

list::
## Code evaluated in code editor
## Code evaluated on command line
## Tasks scheduled on any link::Classes/Clock::
## Functions evaluated in response to incoming OSC and MIDI messages
::

This means that link::Classes/Thread#.thisThread#thisThread:: will always initially point
to the main Thread. However, when some code starts a link::Classes/Routine::, the Routine
becomes the current Thread, with the main Thread as its parent.
** class:: ProgramChangeResponder
summary:: allow functions to be registered to respond to MIDI program change events
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIResponder, Classes/CCResponder
categories:: External Control>MIDI

Description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::. They still lack some features of the MIDIresponder classes.::
ClassMethods::

method::new

argument::function
A link::Classes/Function:: to be evaluated. Arguments passed to the function are: src, chan, value.

argument::src
The src number may be the system UID (obtained from code:: MIDIClient.sources[index].uid ::) or the index of the source in the code:: MIDIClient.sources :: array. nil matches all.

argument::chan
An link::Classes/Integer:: between 0 and 15 that selects which MIDI channel to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 2 }

argument::num
An link::Classes/Integer:: between 0 and 127 that selects which program change number to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val >= 4 }

argument::install
If true, then if the midi event is matched, cease testing any further responders. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

Examples::

code::
(
	c = ProgramChangeResponder({ |src,chan,val|
		[src,chan,val].postln;
		},
		nil, // any source
		nil, // any channel
		nil // any value
	)
)

c.remove
::

code::
(
	c = ProgramChangeResponder({ |src,chan,val|
		[src,chan,val].postln;
		},
		nil, // any source
		nil, // any channel
		(50..60) // within this value range
	)
)

c.remove
::
** class:: Prorate
summary:: divide stream proportionally
related:: Classes/Pattern
categories:: Streams-Patterns-Events>Patterns>Math

ClassMethods::

method::new

argument::proportion
a pattern that returns either numbers (divides the pattern into pairs) or arrays of size n which are used to split up the input into n parts.

argument::pattern
a numerical pattern.

Examples::

code::
// divide 1 into various proportions
(
a = Prorate(Pseq([0.35, 0.5, 0.8]), 1);
x = a.asStream;
x.nextN(8)
)

// divide a pattern into various proportions
(
a = Prorate(Pseq([0.35, 0.5, 0.8]), Prand([20, 1], inf));
x = a.asStream;
x.nextN(8)
)


// divide 1 into several parts
(
a = Prorate(Pseq([[1, 2], [5, 7], [4, 8, 9]]).collect(_.normalizeSum), 1);
x = a.asStream;
x.nextN(8)
)


// sound example

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a, x;
a = Prorate(
	Prand([2/3, 1/3, [0.3, 0.3, 0.4], [0.6, 0.4]], inf),
	Pseq([1, 2, 1, 3, 12], inf)
);

3.do {
	{
	var x = a.asStream;
	var freq = rrand(72, 84).midicps;
		loop {
			Synth(\help_sinegrain, [\freq, freq]);
			(0.25 * x.next).wait;
		}
	}.fork;
};
)
::
** class:: Prout
summary:: routine pattern
related:: Classes/Proutine, Classes/Routine
categories:: Streams-Patterns-Events>Patterns>Function

description::

note that there is a shortcut to create a Prout:

code::p(func)::

ClassMethods::

method::new
Returns a routine from the function.

argument::routineFunc
routine function.

Examples::

code::
(
var a;
a = Prout({ loop { 1.yield; 2.yield; 7.yield; 10.do { 1.0.rand.yield } }});
a.asStream.nextN(100).plot;
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.1), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Prout({ loop { 1.yield; 2.yield; 7.yield; 10.do { 1.0.rand.yield } }}).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, val * 100 + 300]);
		0.02.wait;
	}
}.fork;
)

// shortcut:
(
Pbind(
	\instrument, \help_sinegrain,
	\freq, p { loop { ([1000, 2000].choose + [100, 200].choose + [10, 20].choose).postln.yield } },
	\dur, 0.1
).play;
)
::
** class:: Proutine
summary:: pattern that embeds a routine function
related:: Classes/Prout, Classes/Routine
categories:: Streams-Patterns-Events>Patterns>Function

description::

Proutine is similar to link::Classes/Prout::, it only simply embeds the function instead of creating a separate routine. This can be more efficient when used within other patterns.

ClassMethods::

method::new
embeds the routine function.

argument::routineFunc
routine function.
** class:: ProxyMixer
summary:: mix control for a proxyspace
categories:: Libraries>JITLib>GUI
related:: Classes/ProxySpace, Classes/NdefGui, Classes/JITGui, Classes/MonitorGui, Classes/NdefParamGui

description::

warning::
ProxyMixer has been updated - some little adaptations to existing uses may be needed. If you like, you can also replace "ProxyMixer" with "ProxyMixerOld" to keep using the old style of ProxyMixer.

table::
## strong::Old:: || strong::New::
## ProxyMixerOld || ProxyMixer
## *new( || *new(
## space, || object,
## nProxies, || numItems,
## title, //is inferred from ProxySpace.asCode || parent, // a view to display proxymixer on, if nil, a new window is made.
## where // can be set in bounds || bounds, // can be nil for default size, or a point for a specific location onscreen, or a Rect
##  || [makeSkip,
##  || options]
## ) || )
::
::

ProxyMixer provides controls for handling and editing the node proxies in a proxyspace and their monitors (cross-platform graphics). It replaces the earlier ProxyMixer class. For Ndefs, use link::Classes/NdefMixer::.

Overview: link::Overviews/JITLib::

ClassMethods::

subsection::Creation

method::new

argument::obj
the proxyspace to show and control

argument::numItems
how many ar and kr proxies can be shown

argument::parent
by default nil, so a window is made automatically. if a parent is supplied, the ProxyMixer will be shown there.

argument::bounds
window bounds - default is nil, so it determines it size.

argument::makeSkip
a flag whether to make make a skijack

argument::options
additional settings - currently none provided.

Examples::

code::
(
p = ProxySpace.push(s.boot, p);
"abcde".do { |k| p[k.asSymbol].ar };
m = ProxyMixer(p, 8, options: [\playN]);
p.do(_.play(0));
)

m.object_(nil);
m.object_(p);

"abcdefghijk".do { |k| p[k.asSymbol].ar };

"lmnopqrtuvw".do { |k| p[k.asSymbol].kr };

"abcdefghijk".do { |k| p[k.asSymbol].playN };



	// the top left menu sets which proxies will be shown.

		// existingProxies: even an empty proxy is shown
~test.ar;

(		// activeProxies: proxy appears when it is alive
~test = { |freq=250, intv=19, timescale=1, curve=0, loopnode=0|
	var env = EnvGen.kr(
		Env({ 1.0.rand2 }!11, {1.0.rand}!10, curve, releaseNode: 9, loopNode: loopnode),
		timeScale: timescale);
	var pitch = (env * [1, 0.33, -1] * intv).midiratio * freq;
	Splay.ar(Formant.ar(pitch, pitch.scramble * 2, pitch.scramble)) * 0.1;
};
)
~test.lag(\freq, 4);

		// playingProxies : only those that really play are shown.
~test.playN(vol: 1);

// switch back to active proxies...
		// the reduce button removes all proxies that are not playing
		// and that are not used as sources in other proxies:
~otto = { |dens=12| Dust.ar(dens) };

~otto.clear;		// remove it
p.reduce;

		// doc and docSel post the current proxyspace as code
p.document;

		// ProxyMixer has three preset widths:
m.switchSize(0);	// ar zone only
m.switchSize(1);	// ar + kr
m.switchSize(2);	// ar = kr + edit zone

		// R opens a Record utility, see below.

	// the line of controls for one proxy and its monitor is
	// a ProxyMonitorGui, so for full details see ProxyMonitorGui.help.

	// it displays current volume,
~test.vol_(0.05);
~test.vol_(0.1);

	// proxy name; play/stop/end control:
~test.playN;		// playN as is
~test.stop;		// stop
~test.end;		// option-click on stop : end the monitor and the proxy itself.
~test.playN(vol: 0);	// option-click on play : start playing with volume zero.

~test.vol_(0.1);

s.scope(8);
~test.playN(4);	// set proxy's first output channel:
~test.playN(0);

	// the "-=" / "-<" button supports multichannel monitoring,
	// see ProxyMonitorGui.help

	//	paus/rsum toggles pause and resume:
~test.pause;
~test.resume;

	// send button resends the proxy,
	// option-click on send rebuilds the proxy
	// (e.g. for lookup in client-site state)
~test.send;
~test.send;
~test.send;
~test.rebuild;
~test.rebuild;
~test.rebuild;


	// the ed button sends this proxy to the editor - see below

		// kr proxies show up in the middle
~lfo = { SinOsc.kr(2) };
~lfnoyz0 = { |lofreq = 0.5, mul=1, add| LFDNoise0.kr(lofreq, mul, add) };

		// the editor zone is a NodeProxyEditor
		// open it and set some params
m.switchSize(2);
m.editGui.object_(~test);
~test.set(\freq, exprand(80, 1250));	// set ~tests parameters
~test.set(\intv, 1.0.linrand);

	//	if you declare global specs for the range of a parameter,
	//	they can be used in the editor:
Spec.add(\intv, [0, 36, \lin]);
Spec.add(\timescale, [0.001, 10, \exp]);
Spec.add(\loopnode, [0, 7, \lin, 1]);
Spec.add(\curve, [-10, 10]);

m.editGui.object_(~test);

		// you can map a kr proxy to a control param;
~test.map(\intv, ~lfnoyz0);
~test.unmap(\intv);
		// this also works by dragging the kr proxy name
		// the field left of the param name.


	//	some more tests :
	// if there are too many ar proxies, a scroller appears
(		// test too many
10.do { |i| p[("test" ++ i).asSymbol] = {
	Pan2.ar(Ringz.ar(Impulse.ar(exprand(0.5, 4)), exprand(300, 3000), 0.02), 1.0.rand2, 0.2) };
};
)

10.do { |i| p[("test" ++ i).asSymbol].playN(vol: linrand(1.0), fadeTime: exprand(0.01, 5)) };

	// and the same for kr proxies
10.do { |i| p[("kr" ++ i).asSymbol] = { LFNoise0.kr(exprand(5, 50)) }; };

p.krProxyNames.do { |key| p.removeAt(key) };

p.reduce(method: \clear);

p.clean;
::
** class:: ProxyMixerOld
summary:: mix control for a proxyspace
categories:: Libraries>JITLib>GUI
related:: Classes/ProxySpace, Classes/NodeProxyEditor

description::

warning::
ProxyMixer has been updated - some little adaptations to existing uses may be needed. If you like, you can also replace "ProxyMixer" with "ProxyMixerOld" to keep using the old style of ProxyMixer.
::

ProxyMixer provides controls for handling and editing the node proxies in a proxyspace and their monitors (cross-platform graphics).

Overview: link::Overviews/JITLib::

ClassMethods::

private::initClass

subsection::Creation

method::new

argument::proxyspace
a link::Classes/ProxySpace::

argument::nProxies
the maximum number of proxies you plan to use

argument::title
window title

argument::where
window bounds

Examples::

code::
p = ProxySpace.push(s.boot, \p);
m = ProxyMixer(p, 8, \p, Rect(20, 500, 0,0));

m = ProxyMixer(p, 8)

	// the top left menu sets which proxies will be shown.

		// existingProxies: even an empty proxy is shown
~test.ar;

(		// activeProxies: proxy appears when it is alive
~test = { |freq=250, intv=19, timescale=1, curve=0, loopnode=0|
	var env = EnvGen.kr(
		Env({ 1.0.rand2 }!11, {1.0.rand}!10, curve, releaseNode: 9, loopNode: loopnode),
		timeScale: timescale);
	var pitch = (env * [1, 0.33, -1] * intv).midiratio * freq;
	Splay.ar(Formant.ar(pitch, pitch.scramble * 2, pitch.scramble)) * 0.1;
};
)
~test.lag(\freq, 4);

		// playingProxies : only those that really play are shown.
~test.playN(vol: 1);

// switch back to active proxies...

		// the reduce button removes all proxies that are not playing
		// and that are not used as sources in other proxies:
~otto = { |dens=12| Dust.ar(dens) };

~otto.clear;		// remove it
p.reduce;

		// doc and docc post the current proxyspace as code
p.document;

		// openEdit opens the editor zone, see below;
m.openEditZone(1);

		// R opens a Record utility, see below.

	// the line of controls for one proxy and its monitor is
	// a ProxyMonitorGui, so for full details see ProxyMonitorGui.help.

	// it displays current volume,
~test.vol_(0.05);
~test.vol_(0.1);

	// proxy name; play/stop/end control:
~test.playN;		// playN as is
~test.stop;		// stop
~test.end;		// option-click on stop : end the monitor and the proxy itself.
~test.playN(vol: 0);	// option-click on play : start playing with volume zero.

~test.vol_(0.1);

s.scope(8);
~test.playN(4);	// set proxy's first output channel:
~test.playN(0);

	// the "-=" / "-<" button supports multichannel monitoring,
	// see ProxyMonitorGui.help

	//	paus/rsum toggles pause and resume:
~test.pause;
~test.resume;

	// send button resends the proxy,
	// option-click on send rebuilds the proxy
	// (e.g. for lookup in client-site state)
~test.send;
~test.send;
~test.send;
~test.rebuild;
~test.rebuild;
~test.rebuild;


	// the ed button sends this proxy to the editor - see below

		// kr proxies show up in the middle
~lfo = { SinOsc.kr(2) };
~lfnoyz0 = { |lofreq, mul=1, add| LFDNoise0.kr(lofreq, mul, add) };

		// the editor zone is a NodeProxyEditor
		// open it and set some params
m.openEditZone(1);
m.editor.proxy_(~test);
~test.set(\freq, exprand(80, 1250));	// set ~tests parameters
~test.set(\intv, 1.0.linrand);

	//	if you declare global specs for the range of a parameter,
	//	they can be used in the editor:
Spec.add(\intv, [0, 36, \lin]);
Spec.add(\timescale, [0.001, 10, \exp]);
Spec.add(\loopnode, [0, 7, \lin, 1]);
Spec.add(\curve, [-10, 10]);

m.editor.proxy_(~test);

		// you can map a kr proxy to a control param;
~test.map(\intv, ~lfnoyz0);
~test.unmap(\intv);
		// this also works by dragging the kr proxy name
		// the field left of the param name.


	//	some more tests :
	// if there are too many ar proxies, a scroller appears
(		// test too many
10.do { |i| p[("test" ++ i).asSymbol] = {
	Pan2.ar(Ringz.ar(Impulse.ar(exprand(0.5, 4)), exprand(300, 3000), 0.02), 1.0.rand2, 0.2) };
};
)

10.do { |i| p[("test" ++ i).asSymbol].playN(vol: linrand(1.0), fadeTime: exprand(0.01, 5)) };

	// and the same for kr proxies
10.do { |i| p[("kr" ++ i).asSymbol] = { LFNoise0.kr(exprand(5, 50)) }; };

p.krProxyNames.do { |key| p.removeAt(key) };

p.reduce(method: \clear);

p.clean;
::
** class:: ProxyMonitorGui
summary:: controls the top-level of a nodeproxy and its monitor
categories:: Libraries>JITLib>GUI
related:: Classes/ProxyMixer, Classes/NodeProxyEditor

description::

is a GUI for controlling the top-level of a nodeproxy and its monitor. It is e.g. used in ProxyMixer, and NodeProxyEditor, and it is cross-platform.

Examples::

code::
(
Server.default = s = Server.internal;
s.boot;
)

	// make a proxy space and a test proxy
(
s.scope(8);
p = ProxySpace.push;

~test = { |freq=1000, dens=5, amp=1, lev=3|
	var freqline = { exprand(0.3, 3) } ! 3 * XLine.kr(0.125, 1, 2);
	Ringz.ar(Dust.ar(dens ! 3, dens.reciprocal.sqrt), freq * freqline, 0.1)
};
~test.playN(0, vol: 0.1);
)

	// make a ProxyMonitorGui
z = ProxyMonitorGui();

	// switching between proxies: drag-view displays proxy key
z.proxy = ~otto12345;	// up to 9 letters or so on OSX
z.proxy = ~test;		// make audio controls available if proy is audio
z.proxy = nil;
z.proxy = ~otto; ~otto.kr;	//
z.proxy = ~test;



	// configuration variants

	// pudgier
ProxyMonitorGui(~test, bounds: 300@30);

	// place it in an existing window:
ProxyMonitorGui(~test, Window("ProxyMonitor", Rect(200, 200, 400, 100)).front);

ProxyMonitorGui(~test, Window("ProxyMonitor").front, bounds: 350@40);

ProxyMonitorGui(~test, Window("ProxyMonitor").front, bounds: Rect(20, 20, 360, 20));


	// show level in dB - off by default
ProxyMonitorGui(~test, showLevel: true, showPlayN: false);

	// without multichan out button - then uses proxy.play. true = playN by default.
ProxyMonitorGui(~test, showPlayN: false);

	// show proxy name or not. on by default.
ProxyMonitorGui(~test, showName: false);

	// show proxy pause and send buttons - true by default
ProxyMonitorGui(~test, showPauseSend: true, showPlayN: false);


	// turn off SkipJack view updates - updates are on by default.
ProxyMonitorGui(~test, makeWatcher: false);

	// minimal:
ProxyMonitorGui.new(~test, bounds: 300@40, showPlayN: false, showPauseSend: false);


	// the GUI functions:

ProxyMonitorGui(~test);
	// left slider is vol
~test.vol_(0.1);
~test.vol_(0.25);

~test.stop;	// play / stop button:
~test.playN;	//
~test.end;	// alt-stop fully ends the proxy.
~test.playN(vol: 0);	// alt-playN starts with volume 0.

	// number box sets first output channel
	// when you want to play out of adjacent channels.
~test.playN(0);
~test.out_(1);

	// playing out to multiple channels
~test.playN([0, 2, 5]);
~test.playN([1, 2, 5]);
	// switches the button next to it to show a different output shape:
	// ("-<" is multiple outs, "-=" is directly adjacent outs.
	// clicking on that button opens an editing dialog:
~test.playNDialog;		// needs testing with SwingOSC.

~test.out_(0);

	// the pause button pauses and resumes
~test.pause;
~test.resume;

	// snd button re-sends proxy's sound as compiled,
~test.send;
	// or with option-click, it rebuilds the proxy's sound function,
	// so e.g. normal random numbers or lookups in the lang get remade.
~test.rebuild;


//	ProxyMonitorGui gets its look from GUI.skin, so you could customize it there,
//	or pass your own look in:

ProxyMonitorGui(skin: <your look here>)


// 	Quick SwingOsc tests.

g = SwingOSC.default;
g.boot;
GUI.swing;

y = ProxyMonitorGui(~test);

GUI.cocoa;
y = ProxyMonitorGui(~test);
::
** class:: ProxySpace
summary:: an environment of references on a server
categories:: Libraries>JITLib>Environments
related:: Classes/NodeProxy, Classes/ProxyMixer, Overviews/JITLib

description::
Generally a strong::proxy:: is a placeholder for something. A node proxy is a placeholder for something strong::playing on a server:: that writes to a limited number of busses (e.g. a synth or an event stream). NodeProxy objects can be replaced and recombined while they play. Also they can be used to build a larger structure which is used and modified later on. Overview: link::Overviews/JITLib::

When accessed, ProxySpace returns a link::Classes/NodeProxy::. A similar class without environment: link::Classes/Ndef::

For more examples see: link::Tutorials/JITLib/proxyspace_examples::, link::Tutorials/JITLib/jitlib_basic_concepts_01::

For GUI overview, see link::Classes/ProxyMixer::. See link::Classes/NodeProxy:: for many relevant methods.

subsection::First Example

code::
s.boot;

p = ProxySpace.new;
p.fadeTime = 2; // fadeTime specifies crossfade
p[\out].play; // monitor an empty placeholder through hardware ouput
// set its source
p[\out] = { SinOsc.ar([350, 351.3], 0, 0.2) };
p[\out] = { Pulse.ar([350, 351.3] / 4, 0.4) * 0.2 };
p[\out] = Pbind(\dur, 0.03, \freq, Pbrown(0, 1, 0.1, inf).linexp(0, 1, 200, 350));

// route one proxy through another:
p[\out] = { Ringz.ar(p[\in].ar, [350, 351.3] * 8, 0.2) * 4 };
p[\in] = { Impulse.ar([5, 7]/2, [0, 0.5]) };

a.clear(3); // clear after 3 seconds
b.clear(3);
::

ClassMethods::

private::initClass

subsection::Creation

method::new

argument::server
a link::Classes/Server:: object. Note that on remote computers the clock must be in sync.

argument::name
a link::Classes/Symbol::. If a name is given, the proxy space is strong::stored:: in code::ProxySpace.all:: under this name.

argument::clock
for event-based or beat-sync playing use a link::Classes/TempoClock::.

method::push
replace the currentEnvironment with a new ProxySpace and strong::clear:: the current one, if it is a ProxySpace (this is to avoid piling up proxy spaces).

In order to move to another ProxySpace while keeping the current, use strong::pop:: and then strong::push:: a new one. To have multiple levels of proxy spaces, use strong::.new.push;::

method::pop
restore the previous currentEnvironment

method::clearAll
clear all registered spaces

InstanceMethods::

subsection::Play back and access

method::play
returns a group that plays the link::Classes/NodeProxy:: at that strong::key::.

argument::key
a link::Classes/Symbol::

argument::out
output channel offset

argument::numChannels
play this number of channels.

method::record
returns a link::Classes/RecNodeProxy:: that records the NodeProxy at that key.

method::ar, kr
returns a NodeProxy output that plays the NodeProxy at that key, to be used within a function used as input to a node proxy

method::wakeUp
when the proxyspace is created without a running server this method can be used. To run it (internally this is done by link::#-play:: as well).

method::fadeTime
set the fadetime of all proxies as well as the default fade time

method::clock
set the clock of all proxies as well as the default clock.

method::quant
set the quant of all proxies as well as the default quant.

method::free
free all proxies (i.e. free also the groups, do not stop the monitors)

method::release
release all proxies (i.e. keep the groups running)

method::stop
stop all proxies (stop only monitors, do not stop synths)

method::end
end all proxies (free and stop the monitors)

method::clear
clear the node proxy and remove it from the environment. this frees all buses. If a fadeTime is given, first fade out, then clear.

method::add
add the ProxySpace to the repository (name required)

method::remove
remove the ProxySpace from the repository

subsection::Setting the sources

The strong::rate:: and strong::numChannels:: of the link::Classes/NodeProxy:: determined in a lazy way from the first object put into this environment (see helpfile). Once it is created it can only be set to a function that returns the same rate and a number of channels equal to the intial one or smaller. For details, see link::Tutorials/JITLib/the_lazy_proxy::.

method::put
Gets the NodeProxy at strong::key:: (if none exists, returns a new one) and sets its source to strong::obj::. For how this works, see also link::Classes/LazyEnvir:: and link::Classes/NodeProxy::.

method::at
Return the proxy source object at that key.

subsection::"garbage collecting"

method::clean
free and remove all proxies that are not needed in order to play the ones passed in with 'exclude'. if none are passed in, all proxies that are monitoring (with the .play message) are kept as well as their parents etc.

method::reduce
free all proxies that are not needed in order to play the ones passed in with 'to'. if none are passed in, all proxies that are monitored (with the play message) are kept as well as their parents etc.

subsection::Coding

method::document
creates a new document with the current proxyspace state. This does not allow open functions as proxy sources. see: link::Tutorials/JITLib/jitlib_asCompileString::.

argument::keys
list of keys to document a subset of proxies

argument::onlyAudibleOutput
a boolean.

argument::includeSettings
a boolean.

Examples::

code::
// ProxySpace returns instances of NodeProxy:
a = NodeProxy(s) 	is equivalent to ~a;
a.source = ...		is equivalent to ~a = ...
a[3] = ...		is equivalent to ~a[3] = ...

// the two expressions are equivalent:
~out = something;
currentEnvironment.put(\out, something);
::

code::
// examples

p = ProxySpace.push(s.boot); // use ProxySpace as current environment.

~out.play;

~out = { SinOsc.ar([400, 407] * 0.9, 0, 0.2) };

~out = { SinOsc.ar([400, 437] * 0.9, 0, 0.2) * LFPulse.kr([1, 1.3]) };

~out = { SinOsc.ar([400, 437] * 0.9, 0, 0.2) * ~x.kr(2) };

~x = { LFPulse.kr([1, 1.3] * MouseX.kr(1, 30, 1)) };

~out = { SinOsc.ar([400, 437] * Lag.kr(0.1 + ~x, 0.3), 0, 0.2) * ~x };

p.fadeTime = 5;

~out = { SinOsc.ar([400, 437] * 1.1, 0, 0.2) * ~x.kr(2) };

p.clear(8); // end and clear all in 8 sec.


p.pop; // move out.
::
** class:: ProxySynthDef
summary:: synth def that wraps ugen graph
categories:: Libraries>JITLib>NodeProxy
related:: Classes/NodeProxy

description::
(used internally by link::Classes/NodeProxy::)

for inner workings see link::Tutorials/JITLib/jitlib_fading::

ClassMethods::

method::new

argument::name
like in link::Classes/SynthDef::. todo: add variants.

argument::func
like in link::Classes/SynthDef::. todo: add variants.

argument::rates
like in link::Classes/SynthDef::. todo: add variants.

argument::prependArgs
like in link::Classes/SynthDef::. todo: add variants.

argument::makeFadeEnv
if true it constructs a fader envelope and adds controls for gate and fadeTime

argument::channelOffset
a constant offset that is added to the out number

argument::chanConstraint
max numChannels for the synthdef. If ugenfunc returns a larger array, it wraps

argument::rateConstraint
a symbol like \audio, \control or \scalar.

method::sampleAccurate
always use link::Classes/OffsetOut::, if set to true (default: false)

Examples::

code::
a = ProxySynthDef("xtest", { SinOsc.ar(400) * 0.1 });

a.send(s);

x = Synth("xtest");
x.release;


/*

	if the resulting number of channels is larger than a given channelConstraint,
	it behaves according to the rate: audio rate signals are wrapped around
	a smaller channel size, control rate signals are not (the exceeding channels are left out)

*/
::
** class:: Pseed
summary:: set the random seed in subpattern
related:: Reference/randomSeed
categories:: Streams-Patterns-Events>Patterns>Language Control

description::

Set the random generator seed of the resulting stream.

ClassMethods::

method::new

argument::randSeed
integer number, pattern or stream that return an integer number.

note::
randSeed is always treated as a pattern/stream. If you provide a single, constant seed value, it will behave as an infinite-length stream. This will cause the subpattern to be embedded an infinite number of times. Compare:

code::
// Pwhite repeats its three values forever
Pseed(1000, Pwhite(1, 10, 3)).asStream.nextN(10);

// Pwhite runs once:
// the output stream consists of three values, then 'nil' ad infinitum
Pseed(Pn(1000, 1), Pwhite(1, 10, 3)).asStream.nextN(10);
::
::

argument::pattern

Examples::

code::
a = Pseed(1972, Prand([1,2,3], inf));

b = a.asStream;
10.do({ b.next.post });

c = a.asStream;
10.do({ c.next.post });


// using a seed pattern as input:

a = Pseed(Pseq([1812, 1912], inf), Prand([1,2,3], 5));

b = a.asStream;
2.do({ 5.do({ b.next.post });"".postln;  });

c = a.asStream;
2.do({ 5.do({ c.next.post });"".postln;  });


// outer thread is independant:

a = Pseed(Prand([1534, 1600, 1798, 1986, 2005], inf), Pshuf([1, Prand([7, 9], 2), 1, 2, 3], 1));

// returns random streams
b = a.asStream;
2.do({ 5.do({ b.next.post });"".postln;  });

c = a.asStream;
2.do({ 5.do({ c.next.post });"".postln;  });
::
** class:: Pseg
summary:: timed embedding of values
related:: Classes/Ptime, Classes/Pstep, Classes/Env
categories:: Streams-Patterns-Events>Patterns>Time

description::

Pseg defines a function of time as a breakpoint envelope using the same parameters as link::Classes/Env::. These patterns can be used to describe tempo or dynamic variations independent of the rhythmic patterns that express them.

ClassMethods::

method::new

argument::levels
A link::Classes/Pattern:: that returns the levels. The first level is the initial value of the envelope, all subsequent values are interpolated.

argument::durs
A link::Classes/Pattern:: that returns segments durations in beats.

argument::curves
a link::Classes/Symbol::, link::Classes/Float::, or an link::Classes/Array:: of those. Determines the shape of the segments.

argument::repeats
a number.

The possible values are:
table::
## code::\step:: || || flat segments.
## code::\linear:: || code::\lin:: || linear segments, the default.
## code::\exponential:: || code::\exp:: || natural exponential growth and decay. In this case, the levels must all be nonzero and the have the same sign.
## code::\sine:: || code::\sin:: || sinusoidal S shaped segments.
## code::\welch:: || code::\wel:: || sinusoidal segments shaped like the sides of a Welch window.
## code::\squared::  || code::\sqr:: || squared segment.
## code::\cubed:: || code::\cub:: || cubed segment.
## a link::Classes/Float:: || || a curvature value for all segments. 0 means linear, positive and negative numbers curve the segment up and down.
## an link::Classes/Array:: of symbols or floats || || curvature values for each segment.
::

Examples::

code::
// change a parameter
(
Pbind(
	\note,  Pseg( Pseq([1, 5],inf), Pseq([4, 1],inf), \linear),
	\dur, 0.1
).play;
)

(
Pbind(
	\freq,  Pseg( Pseq([400, 1500], inf), Pseq([4, 4],inf), Pseq([\linear, \exp],inf)),
	\dur, 0.1
).play;
)
::
** class:: Pselect
summary:: Select values from a pattern
categories:: Streams-Patterns-Events>Patterns>Filter
related:: Classes/Pcollect, Classes/Preject

description::
Returns values for which the function returns true. The value is passed to the function.


classmethods::

method:: new
argument:: func
A link::Classes/Function::. Receives values from code::pattern::.
argument:: pattern
A link::Classes/Pattern::.


examples::
code::
(
var a, b;
a = Pselect({ arg item; item != 2 }, Pseq(#[1, 2, 3],inf));
x = a.asStream;
9.do({ x.next.postln; });
)
::

The message code::select:: returns a Pselect when passed to a pattern.
code::
(
var a, b;
a = Pseq(#[1, 2, 3],inf).select({ arg item; item != 2 });
a.postln;
x = a.asStream;
9.do({ x.next.postln; });
)
::
** class:: Pseq
summary:: sequentially embed values in a list
related:: Classes/Pser
categories:: Streams-Patterns-Events>Patterns>List

description::

Cycles over a list of values. The repeats variable gives the number of times to repeat the entire list.

Examples::

code::
(
var a, b;
a = Pseq([1, 2, 3], 2);	// repeat twice
b = a.asStream;
7.do({ b.next.postln; });
)
::

Pseq also has an offset argument which gives a starting offset into the list.
code::
(
var a, b;
a = Pseq([1, 2, 3, 4], 3, 2);	// repeat 3, offset 2
b = a.asStream;
13.do({ b.next.postln; });
)
::

You can pass a function for the repeats variable that gets evaluated when the stream is created.
code::
(
var a, b;
a = Pseq([1, 2], { rrand(1, 3) });	// repeat 1,2, or 3 times
b = a.asStream;
7.do({ b.next.postln; });
)
::

If you specify the value inf for the repeats variable, then it will repeat indefinitely.
code::
(
var a, b;
a = Pseq([1, 2, 3], inf);	// infinite repeat
b = a.asStream;
10.do({ b.next.postln; });
)
::


Pseq used as a sequence of pitches:
code::
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pseq(#[60, 61, 63, 65, 72], inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next.midicps]);
		0.2.wait;
	})
}).play;
)
::
** class:: Pser
summary:: sequentially embed values in a list
related:: Classes/Pseq
categories:: Streams-Patterns-Events>Patterns>List

description::

is like link::Classes/Pseq::, however the repeats variable gives strong::the number of items:: returned instead of the number of complete cycles.

Examples::

code::
(
var a, b;
a = Pser([1, 2, 3], 5);	// return 5 items
b = a.asStream;
6.do({ b.next.postln; });
)

//Pser used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pser([Pser(#[60, 61, 63, 65, 72], 3)], inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next.midicps]);
		0.2.wait;
	})
}).play;
)
::
** class:: Pseries
summary:: artithmetic series pattern
related:: Classes/Pgeom
categories:: Streams-Patterns-Events>Patterns>List

description::

Returns a stream that behaves like an arithmetric series.

ClassMethods::

method::new

argument::start
start value.

argument::step
addition factor.

argument::length
number of values produced.

Examples::

code::
(
var a;
a = Pgeom(1.0, 1.1, inf);
a.asStream.nextN(100).plot;
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pseries(300, 20, 70).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, val]);
		0.02.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.01,
	\instrument, \help_sinegrain,
	\freq, Pseries(800.0, Pbrown(-1.0, 3.0, 0.1, inf), inf)
).play;
)
::
** class:: Pset
summary:: event pattern that sets values of one key
related:: Classes/Pbindf, Classes/Psetp
categories:: Streams-Patterns-Events>Patterns>Filter

description::

Pset sets a value in an event stream. It acts like one key in a link::Classes/Pbindf::.
code::
(
var a, b;
a = Pset(\freq, 801, Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

ClassMethods::

method::new

argument::name
the key.

argument::value
can be a pattern or a stream. The resulting stream ends when that incoming stream ends.

argument::pattern
the pattern.

Examples::

code::
//Pset overrides incoming values:

(
var a, b;
a = Pset(\freq, 801, Pbind(\freq, 108));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)


(
var a, b;
a = Pset(\freq, Pseq([401, 801], 2), Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)


//sound example

(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain);
a = Pset(\freq, Pseq([500, 600, 700], inf), a);
a = Pset(\legato, Pseq([0.01, 1],inf), a);
a.play;
)
::
** class:: Psetp
summary:: event pattern that sets values of one key
related:: Classes/Pbindf, Classes/Pset
categories:: Streams-Patterns-Events>Patterns>Filter

description::

Sets a value in an event stream until it ends, repeats this with new values until the value stream ends.

ClassMethods::

method::new

argument::value
can be a pattern, a stream or an array. The resulting stream ends when that incoming stream ends.

Examples::

code::
(
var a, b;
a = Psetp(\freq, Pseq([801, 1008],inf), Pbind(\dur, Pseq([0.5, 0.111, 0.22])));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)

//Psetp overrides incoming values:

(
var a, b;
a = Psetp(\freq, 801, Pbind(\freq, 108));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)


//sound example

(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, Pseq([0.5, 0.3, 0.1]), \instrument, \sinegrain);
a = Psetp(\freq, Pseq([500, 600, 700], inf), a);
a.play;
)
::
** class:: Psetpre
summary:: set values of one key in an event before it is passed up
related:: Classes/Pset, Classes/Psetp
categories:: Streams-Patterns-Events>Patterns>Filter

description::

Sets a value in an event, before it is passed up the stream. To set the value after it has been passed to the stream, use link::Classes/Pset::.
code::
(
var a, b;
a = Psetpre(\freq, 801, Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)
::

ClassMethods::

method::new

argument::name
the key

argument::value
can be a pattern or a stream. The resulting stream ends when that incoming stream ends.

argument::pattern
the pattern

Examples::

code::
//Psetpre does not override incoming values:

(
var a, b;
a = Psetpre(\freq, 801, Pbind(\freq, 108));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)


(
var a, b;
a = Psetpre(\freq, Pseq([401, 801], 2), Pbind(\dur, 0.5));
x = a.asStream;
9.do({ x.next(Event.new).postln; });
)


//sound example

(
SynthDef(\sinegrain,
	{ arg out=0, freq=440, sustain=0.02;
		var env;
		env = EnvGen.kr(Env.perc(0.001, sustain), 1, doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env * 0.1))
	}).add;
)

(
a = Pbind(\dur, 0.5, \instrument, \sinegrain);
a = Psetpre(\freq, Pseq([500, 600, 700], inf), a);
a = Psetpre(\legato, Pseq([0.01, 1],inf), a);
a.play;
)
::
** class:: Pshuf
summary:: sequentially embed values in a list in constant, but random order
related:: Classes/Prand
categories:: Streams-Patterns-Events>Patterns>List

description::

Returns a shuffled version of the strong::list:: item by item, with n strong::repeats::.

Examples::

code::
(
var a, b;
a = Pshuf([1, 2, 3, 4, 5], 3);	// repeat 3 times
b = a.asStream;
16.do({ b.next.postln; });
)

//Pshuf used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pn(Pshuf(#[60, 60, 60, 61, 63, 65, 72], 4), inf).asStream;
Routine({
	loop({
	Synth(\help_sinegrain, [\freq, a.next.midicps]);
	0.15.wait;
	})
}).play;
)
::
** class:: Pslide
summary:: slide over a list of values and embed them
related:: Classes/Ptuple
categories:: Streams-Patterns-Events>Patterns>List

ClassMethods::

method::new

argument::list

argument::repeats
number of segments.

argument::len
length of each segment.

argument::step
how far to step the start of each segment from previous. step can be negative.

argument::start
what index to start at.

argument::wrapAtEnd
if true (default), indexing wraps around if goes past beginning or end. If false, the pattern stops if it hits a nil element or goes outside the list bounds.

Examples::

code::
(
var a, b;
a = Pslide([1, 2, 3, 4, 5], inf, 3, 1, 0);
x = a.asStream;
13.do({ x.next.postln; });
)

//Pslide used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
c = Pslide(#[1, 2, 3, 4, 5], inf, 3, 1, 0) * 3 + 67;
x = c.asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.midicps]);
		0.17.wait;
	})
}).play;
)
::
** class:: Pspawn
summary:: Spawns sub-patterns based on parameters in an event pattern
related:: Classes/Pspawner
categories:: Streams-Patterns-Events>Patterns>Parallel

description::

Pspawn is a pattern-based version of link::Classes/Pspawner::. Where Pspawner uses a Routine-style function to determine when and how to spawn child patterns into the result stream, Pspawn uses an event pattern to determine the actions to take.

Recommended to read the link::Classes/Pspawner:: help file to become familiar with pattern spawning capabilities.

note::
Important: There are two kinds of events involved in Pspawn:

definitionList::
## strong::parent:: events
|| which specify the pattern to embed, how to embed it (in parallel or sequence), and how long to wait until the next action;
## strong::child:: events
|| which produce the resulting notes (or take other actions on the server).
::
::

Of these, only the child events are returned to the event stream player during play. The parent events are used strictly internally to control spawning behavior. The parent and child event streams do not mix together. Thus pattern composition ( link::Classes/Pchain:: ) and parallelization ( link::Classes/Ppar:: ) may be used without special handling. It is up to the user to be aware of whether the parent or child stream should be subject to further manipulation, and put that manipulation in the right place. If it is to affect the child stream, it should enclose the entire Pspawn; for the parent stream, it should be inside Pspawn. (See the link::#Examples:: below.)

Pspawn uses the following items in the parent pattern:
definitionList::
## method
|| The action to call on the spawner object. Currently supported: wait, seq, par, suspendAll.
## delta
|| How long to wait until the next action.
## dict
|| If 'pattern' is given as a symbol (see below), this is the dictionary in which the pattern will be looked up. If not specified, the link::Classes/Pdef:: collection will be used.
## pattern
|| If 'method' is seq or par, this is a pattern or function to be embedded, according to the following rules.
::

table::
## strong::'pattern' in the event:: || strong::Resulting behavior::
## A link::Classes/Function:: : code:: { ... } :: || The function should return a pattern; this pattern is spawned.
## A link::Classes/Ref:: to a pattern: code::`Pbind(...):: || The referenced pattern is spawned.
## A link::Classes/Symbol:: : code::\scaleUp:: || The pattern is looked up in the event's 'dict'.
::

subsection::Using references to protect patterns from embedding

Normally, when a pattern appears inside another pattern, the subpattern is embedded in the main output stream. It is not visible to the outside world as a pattern in itself; only its values appear.

code::
Pseq([Pwhite(0, 9, 5), Pwhite(10, 19, 5)], 1).asStream.all;
::

When using Pspawn, a sub pattern must be returned directly into the event. To accomplish this, every such pattern should be wrapped in a link::Classes/Ref:: :

code::
Pseq([`Pwhite(0, 9, 5), `Pwhite(10, 19, 5)], 1).asStream.all;
::

Hint: link::Classes/Pfunc:: is another good way to wrap patterns, because it simply returns its result values without further embedding. See the first example.

ClassMethods::

method::new

argument::pattern
An event pattern (typically link::Classes/Pbind::) encapsulating the desired spawning behavior. Parameters in this event are described below.

argument::spawnProtoEvent
The event prototype against which the pattern is evaluated. Good for giving default values that should apply to all spawning (parent) events.

Examples::

code::
// Play overlapping major scales, up and down
(
p = Pspawn(Pbind(
		// Pbind returned by Pfunc is not embedded, just placed in the event
		// So, it can be spawned
	\pattern, Pfunc { Pbind(\degree, Pseries(rrand(0, 10), #[-1, 1].choose, rrand(4, 10)), \dur, 0.125) },
	\delta, Pwhite(1, 5, inf) * 0.125,
	\method, \par
)).play;
)

p.stop;


// Same, using a dictionary of patterns, changing dur rhythm also
(
var	patternChoices = (
	up: { Pbind(\degree, Pseries(rrand(-4, 5), 1, rrand(4, 10)), \dur, 0.125) },
	down: { Pbind(\degree, Pseries(rrand(4, 11), -1, rrand(4, 10)), \dur, 0.125 * 4/3) }
);

p = Pspawn(Pbind(
	\pattern, Prand([\up, \down], inf),
	\delta, Pwhite(1, 5, inf) * 0.125,
	\method, \par
), (dict: patternChoices)).play;
)

p.stop;


// Using pattern composition (perhaps gratuitously) to build the parent events
(
var	patternChoices = (
	up: { Pbind(\degree, Pseries(rrand(-4, 5), 1, rrand(4, 10)), \dur, 0.125) },
	down: { Pbind(\degree, Pseries(rrand(4, 11), -1, rrand(4, 10)), \dur, 0.125 * 4/3) }
);

p = Pspawn(Pchain(
	Pbind(
		\pattern, Prand([\up, \down], inf),
		\method, \par
	),
	Pbind(
		\delta, Pwhite(1, 5, inf) * 0.125
	)
), (dict: patternChoices)).play;
)

p.stop;


// Play parallel scales in the left channel and sequentially-arranged scales in the right
// This means parallelizing (Ppar) the child streams; thus Ppar surrounds a pair of Pspawns

// Handling of \pan is interesting: \pan needs to be a property of the patternChoices items
// It is NOT a property of the spawning events
// To reuse patternChoices, the Pspawns wrap the base patterns in a Pbindf, which adds new values
(
var	patternChoices = (
	up: { Pbind(\degree, Pseries(rrand(-4, 5), 1, rrand(4, 10)), \dur, 0.125) },
	down: { Pbind(\degree, Pseries(rrand(4, 11), -1, rrand(4, 10)), \dur, 0.125 * 4/3) }
);

p = Ppar([
	Pspawn(Pbind(
			// intermediate value
		\patternKey, Prand([\up, \down], inf),
			// pattern is selected and pan applied here
		\pattern, Pfunc { |ev| Pbindf(ev.dict[ev.patternKey].value, \pan, -1) },
		\delta, Pwhite(1, 5, inf) * 0.125,
		\method, \par
	), (dict: patternChoices)),
	Pspawn(Pbind(
		\patternKey, Prand([\up, \down], inf),
		\pattern, Pfunc { |ev| Pbindf(ev.dict[ev.patternKey].value, \pan, 1) },
		\delta, Pwhite(1, 5, inf) * 0.125,
		\method, \seq
	), (dict: patternChoices)),
]).play;
)

p.stop;
::
** class:: Pspawner
summary:: dynamic control of multiple event streams from a Routine
related:: Classes/Pspawn
categories:: Streams-Patterns-Events>Patterns>Parallel

description::

Pspawner allows a routine to dynamically start and stop subpatterns.

ClassMethods::

method::new

argument::function
The function defines a link::Classes/Routine:: that receives a link::Classes/Spawner:: as its sole argument. All control of subpatterns is through the spawner.

link::Classes/Spawner:: responds to the messages:

definitionlist::
## par ||
Begin an event stream in parallel to the routine. If delta is non-zero, the pattern will begin that many beats after 'now', provided that now + delta is later than the next event that the Spawner will generate. The method returns the stream. This may be called from any object.

## seq ||
Run the entire pattern and then return control to the routine.

## wait ||
Wait strong::dur:: seconds and then return control to the routine.

## suspend ||
Find the stream in the Spawner and stop it, returns nil if the stream is not found, the stream otherwise.

## suspendAll ||
Stop all substreams of the Spawner.
::

note::
We should move the documentation of above methods to the link::Classes/Spawner:: helpfile...
::

Examples::

code::
// example 1: a simple Pspawner

(
Pspawner({ | sp |

// parallel in-c'ish pulses will run throughout the example
	sp.par(Pbind(*[ degree: [0,7], octave: 7, dur: 0.2, db: Pseq([-20, -24, -22, -24], inf)]) );

// scales in sequence with pauses
	sp.seq(
		Pbind(*[ degree: Pseq((0..7).mirror), dur: 0.2])
	);
	sp.wait(0.4);
	sp.seq(
		Ppar([
			Pbind(*[ degree: Pseq((0..7).mirror), dur: 0.2, octave: 4]),
			Pbind(*[ degree: Pseq((0..7).reverse.mirror), dur: 0.2])
		])

	);
	sp.wait(3);
	sp.seq(
		Pbind(*[ degree: Pseq((0..7).mirror), dur: 0.2, mtranspose: (0,2..14)])
	);

// scales overlaped at 0.4 second intervals

	10.do {
		sp.par(
			Pbind(*[ degree: Pseq((0..7).mirror), dur: 0.2])
		);

		sp.wait(0.4)
	};
	sp.wait(1.6);
	sp.suspendAll;
}).play
)


(
// example 2: create 5 streams at 4 second intervals
// then delete them in the order they were created

Pspawner({ | sp |
	var streams, stream;
	// start patterns, collect the resultant event streams
	streams = [2, 3, 4, 6, 7, 8].collect { | i |
		stream = sp.par(Pbind(*[
			harmonic: i,
			ctranspose: 	[0, 1, 3]/40,
			octave:	Pbrown(2,8,2), dur: 1/i, db: -30
		]) );
		sp.wait(4);
		stream;
	};

	// now stop those streams one by one
	streams.do { | s | sp.suspend(s); sp.wait(4) };
}).play
)

(
// example 3: define a Pspawner and use Pattern manipulations
p = Pspawner({ | sp |

	sp.par(Pbind(*[octave: 5, degree: Pbrown( -7, 7, 3), dur: 0.2]) );

	sp.wait(2);
	sp.par(Pbind(*[octave: 5, degree: Pbrown( -7, 7, 3), dur: 0.1]) );
	sp.wait(1);
	sp.par(Pbind(*[octave: 6, degree: Pbrown( -7, 7, 3), dur: 0.05]) );
	sp.wait(0.5);

	sp.wait(4);
	sp.par(Pbind(*[octave: 5, degree: Pbrown( -7, 7, 3), dur: 0.2]) );

	sp.wait(4);
	sp.suspendAll;
});
)

// play the basic patten
( p.play )

(
// manipulate it with Pchain
Pchain(
	Pbind(*[ctranspose: 0 + Pwhite(-0.1, 0.1)]),
	Pbind(*[mtranspose: Pkey(\mtranspose) + Pstutter(8, Prand([0,[-3,0,2],[0,2,4,6,8,10]], inf)) ] ),
	Pn(Pseq([p, (type:\rest, dur: 0.4)]) ),
	Pbind(*[
		db: Pstep(Pseq([-10, -13, -13, -11, -13, -13], inf), 0.1) - 10,
		mtranspose: Pstep(Pwhite(-7, 7), Prand([5,4,2],inf) )
 	])
 ).play(protoEvent: Event.default)
)

// example 4: altering the contents of the Pspawner from separate code

(
a = Pspawner({ |sp |
	c = sp; 			// store the Spawner in a global variable
	100.do{ sp.wait(1) }
});
a.play;
)

(					// c will not be valid until the Pspawner has run
b = c.par(				// now start a pattern in spawner
	Pbind(*[degree: Pseq((0..6) ++ (7..1), inf), dur: 0.2])
);
)
c.suspend(b)				// we can suspend and resume the stream
c.par(b)
c.suspend(b)
(
b = c.par(				// or just start up a new pattern
	Pbind(*[degree: Pseq((0..6) ++ (7..1), inf), dur: 0.2])
);
)

// example 5: Spawner can be used directly in the manner of Pspawner.
// This allows external code to access to the spawner whether or not it has run
(
c = Spawner({ |sp |
	100.do{ sp.wait(1) }
});
b = c.par(				// now start a pattern in spawner
	Pbind(*[degree: Pseq((0..6) ++ (7..1), inf), dur: 0.2])
);
c.play;					// in this case, c is always valid
)
c.suspend(b)				// we can suspend and resume the stream
c.par(b)
c.suspend(b)
(
b = c.par(				// or just start up a new pattern
	Pbind(*[degree: Pseq((0..6) ++ (7..1), inf), dur: 0.2])
);
)

(
Pspawner({ | sp |
	(1..5).do { | i |
		sp.par(Pbind(*[
			octave: i + 2,
			degree:	Pwhite(0,7), dur: 1/i, db: -30
		]) );
		sp.wait(4);
	};
	sp.suspendAll;
}).play
)
::
** class:: Pstep
summary:: timed embedding of values
related:: Classes/Pseg
categories:: Streams-Patterns-Events>Patterns>Time

description::

Pstep is good for representing chord progressions, scale progressions, accent patterns, etc.

ClassMethods::

method::new
Levelpattern can return individual values, arrays, or events. The value returned by levelpattern is returned for the duration returned by durpattern.

Examples::

code::
(
// select a chord and duration and repeat it for a random time interval
p = Pstep(
	Pbind(
		\ctranspose, [0, 4, 7],
		\note,	Pwhite(0, 12),
		\dur,	Prand([0.2, 0.4, 0.8], inf)
	),
	Prand([1, 2, 4], inf)/4
);
Ppar([p, p]).play;
)
// change degree independant of number of events that have been playing

(
Pchain(
	Ppar([
		Pbind(
			\degree, Pbrown(0, 12, 1),
			\dur, Pstep( Pseq([0.1, 0.2, 0.4, 0.8, 1.6], inf), 3.2)
		),
		Pbind(
			\degree, Pbrown(0, 20, 1),
			\dur, Pstep( Pseq([0.1, 0.2, 0.4, 0.8, 1.6], inf), 4.5)
		)
	]),
	Pbind(
		\scale, Pstep(Pseq([ [0, 2, 4, 5, 7, 9, 11], [0, 1, 2, 3, 4, 5, 6]], inf), 5),
		\db, Pstep(Pseq([2, -2, 0, -2], inf), 0.25) - 10
	)
).play;
)

// use a simple pattern
(
Pchain(
	Ppar([
		Pbind(
			\octave, [5, 6] + Prand([0, 0, \r], inf),
			\degree, Proutine({ | ev | loop { ev = Pseq(ev[\degree]).embedInStream } }),
			\dur,	Proutine({ loop { Pseq([0.2, 0.2, 0.2, 0.2, 0.3].scramble).embedInStream } })
		),
		Pbind(
			\octave, 4,
			\legato, 1.2,
			\dur, Proutine({ loop { Pseq([0.2, 0.2, 0.2, 0.2, 0.3].scramble * 5).embedInStream }})
		),
	]),
	Pstep(Pbind(
		\db, Pseq([0, -4, -2, -4, -3, -4, -3, -4], inf) - 20
	), 0.2),
	Pstep(
		Pbind(
			\degree, 	Pfunc({ {10.rand}.dup(10) }),
			\scale,	Pfunc({ {rrand(1, 2)}.dup(7).integrate })
		),
		5
	)
).play
)



// change one parameter
(
Pbind(
	\degree, Pstep(Pseq([1, 2, 3, 4, 5]), 1.0).trace,
	\dur, Pseries(0.1, 0.1, 15)
).play;
)


// change degree independant of number of events that have been playing

(
var a, b;
a = Pbind(
	\degree, Pstep(Pseq([0, 2b, 3], 1), 1.0),
	\dur, Prand([0.2, 0.5, 1.1, 0.25, 0.15], inf)
);
b = Pbind(
	\degree, Pseq([0, 2b, 3], 1),
	\dur, 2,
	\ctranspose, -7
);
Pseq([Event.silent(1.25), Ppar([a, b])], inf).play;
)



// test tempo changes

(
var a, b;
a = Pbind(
	\degree, Pstep(Pseq([0, 2b, 3], 1), 1.0),
	\dur, Prand([0.2, 0.5, 1.1, 0.25, 0.15], 9)
);
b = Pbind(
	\degree, Pseq([0, 2b, 3], 1),
	\dur, 2,
	\ctranspose, -7
);

Ppar([a, b], inf).play;
)


SystemClock.sched(0, { TempoClock.default.tempo = [1, 2, 3, 5].choose.postln; 2 });

TempoClock.default.tempo = 1.0;



// timing test:
// parallel streams


(
var a, b, x;
var times, levels;

SynthDef(\pgrain,
	{ arg out = 0, freq=800, sustain=0.001, amp=0.5, pan = 0;
		var window;
		window = Env.sine(sustain, amp);
		Out.ar(out,
			Pan2.ar(
				SinOsc.ar(freq) * EnvGen.ar(window, doneAction:2),
				pan
			)
		)
	}
).add;

times = Pseq([3.4, 1, 0.2, 0.2, 0.2], inf);
levels = Pseq([0, 1, 2, 3, 4], inf);

a = Pstep(levels, times);
b = Pbind(\instrument, \pgrain, \octave, 7, \dur, 0.12, \degree, a);
x = times;

Ppar([b, Pset(\mtranspose, 2, b) ]).play;

b.play;
r {
	var z = x.asStream; // direct times
	0.5.wait;
	loop {
		z.next.wait;
		s.makeBundle(0.2, {
			Synth(\pgrain, [\freq, 3000, \sustain, 0.01]); // signal tone
		})
	}
}.play(quant:1)
)
::
** class:: PstepNadd
summary:: pattern that returns combinatoric sums
related:: Classes/Pstep3add
categories:: Streams-Patterns-Events>Patterns>Time

description::

Combines an arbitrary number of patterns by summing (depth first traversal). When a stream ends it is recreated from its pattern until the top stream ends.

Examples::

code::
// comparing PstepNadd and Pstep3add (test)
(
x = PstepNadd(Pseq([1, 2, 3]), Pseq([10, 20, 30, 40]), Pseq([100, 200, 300])).asStream;
y = Pstep3add(Pseq([1, 2, 3]), Pseq([10, 20, 30, 40]), Pseq([100, 200, 300])).asStream;

50.do({ [x.next, y.next].postln });
)

// pattern return stream until the longest stream ended
(
x = PstepNadd(
		Plazy({ "pattern1.asStream".postln; Pseq([1, 2, 3], 2) }),
		Plazy({ "pattern2.asStream".postln; Pshuf([10, 20, 30, 40]) }),
		Plazy({ "pattern3.asStream".postln; Pseq([100, 200, 300]) }),
		Plazy({  Pseries(1, 1, 4) * 0.01 })
	).asStream;
150.do({ x.next.postln });
)

// if the last pattern loops it the combinatorics loop there:
x = PstepNadd(Pseq([1, 2, 3]), Pseq([10, 20, 30, 40]), Pseq([100, 200, 300], inf)).asStream;
50.do({ x.next.postln });

// if the first pattern loops, the whole iteration loops as if it was used in a Pn(.., inf):
x = PstepNadd(Pseq([1, 2, 3], inf), Pseq([10, 20, 30, 40]), Pseq([100, 200, 300])).asStream;
y = Pn(PstepNadd(Pseq([1, 2, 3]), Pseq([10, 20, 30, 40]), Pseq([100, 200, 300])), inf).asStream;
150.do({ [x.next, y.next].postln });

// sound example
(
Pbind(
	\octave, 4,
	\degree, PstepNadd(
				Pseq([1, 2, 3]),
				Pseq([0, -2, [1, 3], -5]),
				Pshuf([1, 0, 3, 0], 2),
				Pseq([1, -1], 5)
			),
	\dur, PstepNadd(
				Pseq([1, 0, 0, 1], 2),
				Pshuf([1, 1, 2, 1], 2)
		).loop * (1/8),
	\legato, Pn(Pshuf([0.2, 0.2, 0.2, 0.5, 0.5, 1.6, 1.4], 4), inf),
	\scale, #[0, 1, 3, 4, 5, 7, 8]
).play;
)
::
** class:: PstepNfunc
summary:: combinatoric pattern
related:: Classes/PstepNadd
categories:: Streams-Patterns-Events>Patterns>Time

description::

Combines an arbitrary number of patterns by evaluating a function (depth first traversal). When a stream ends it is recreated from its pattern until the top stream ends.

Examples::

code::
(
f = { arg vals;
	vals.postln;
};
x = PstepNfunc(f, [
		Pseq([1, 2, 3]), Pseq([4, 5, 6]), Pseq([7, 8, 9])
	]).asStream;
50.do({ x.next });
)

(
f = { arg vals;
	var r;
	r = vals.copy.removeAt(0);
	vals.do({ arg item;  r = item / r.squared * 10 });
	r
};
x = PstepNfunc(f,
	[
		Pseq([1, 2, 3], inf),
		Pseq([2, pi, 1]),
		Pseq([0.1, 3, 0.2, 3])
	]
	).asStream;

50.do({ x.next.postln });
)

// note that if the last pattern loops it will stick to that one:
(
f = { arg vals;
	vals.postln;
};
x = PstepNfunc(f, [Pseq([1, 2, 3]), Pseq([10, 20, 30, 40]), Pseq([100, 200, 300], inf)]).asStream;
50.do({ x.next });
)


(
f = { arg vals;
	vals.inject(1, { arg x, y; x * y })
};
x = PstepNfunc(f,
	[
		Pseq([1, 2, 3], inf),
		Pseq([2, pi, 1]),
		Pseq([0.1, 3, 0.2, 3])
	]
	).asStream;

50.do({ x.next.postln });
)
::
** class:: Pstutter
summary:: repeat input stream values
related:: Classes/Pn
categories:: Streams-Patterns-Events>Patterns>Repetition

description::

repeat each element n times.

ClassMethods::

method::new

argument::n
may be a pattern, so the number of times can vary each iteration.

argument::pattern
the pattern

Examples::

code::
(
var a, b;
a = Pstutter(2, Pseq([1, 2, 3],inf));
x = a.asStream;
13.do({ x.next.postln; });
)


//Pstutter used as a sequence of pitches

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
c = Pstutter(3, Prand([1, 2, 3],inf)*4+65);
x = c.asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.midicps]);
		0.12.wait;
	})
}).play;
)
::
** class:: Pswitch
summary:: embed values in a list according to a pattern of indices
related:: Classes/Pswitch1
categories:: Streams-Patterns-Events>Patterns>List>Indexing

ClassMethods::

method::new
Pswitch chooses elements from the strong::list:: by a stream of indices ( strong::which:: ) and embeds them in the stream. If the element is itself a pattern, it first completely embeds it before looking for the next index.

Examples::

code::
(
var a, b;
a = Pseq([1, 2, 3], 2);
b = Pseq([65, 76]);
c = Pswitch([a, b, 800], Pseq([2, 2, 0, 1], inf));
x = c.asStream;
24.do({ x.next.postln; });
)


//Pswitch used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pseq([73, 71, 69], 2);
b = Pseq([0, 0, 0, 4, 0]+64);
c = Pswitch([a, b, 75], Pseq([2, 2, 0, 1], inf));
x = c.asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.midicps]);
		0.18.wait;
	})
}).play;
)
::
** class:: Pswitch1
summary:: embed values in a list according to a pattern of indices
related:: Classes/Pswitch
categories:: Streams-Patterns-Events>Patterns>List>Indexing

ClassMethods::

method::new
Pswitch1 chooses elements from the strong::list:: by a stream of indices ( strong::which:: ) and embeds them in the stream. If the element is itself a pattern, it embeds only one of its values for each index, and thus switches between all patterns in the list.

Examples::

code::
(
var a, b;
a = Pseq([1, 2, 3], inf);
b = Pseq([65, 76], inf);
c = Pswitch1([a, b, 800], Pseq([2, 2, 0, 1], inf));
x = c.asStream;
24.do({ x.next.postln; });
)


//Pswitch used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
a = Pseq([73, 71, 69], inf);
b = Pseq([0, 0, 0, 4, 0]+64, inf);
c = Pswitch1([a, b, 75], Pseq([2, 2, 0, 1], inf));
x = c.asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.midicps]);
		0.18.wait;
	})
}).play;
)
::
** class:: Psym
summary:: use a pattern of symbols to embed Pdefs
categories:: Libraries>JITLib>Patterns
related:: Classes/Pdef

description::
for non-event patterns see link::Classes/Pnsym::. Overview: link::Overviews/JITLib::.

ClassMethods::

method::new

argument::pattern
a pattern that returns symbols or characters. Arrays are converted to parallel patterns ( link::Classes/Ppar:: ).

argument::dict
the dictionary to be used for lookup. By default, this is code::Pdef.all::, so one can embed Pdefs by name.

InstanceMethods::

method::dict
set the dictionary to be used.

Examples::

code::
(
// load a synthdef
s.boot;
SynthDef(\gpdef,
	{ |out=0, freq=440, sustain=0.05, amp=0.1, pan|
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain), doneAction:2) * amp;
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;
)

Pdef(\x, Pbind(\dur, Pn(0.25, 3), \instrument, \gpdef));
Pdef(\y, Pchain(Pbind(\degree, Prand([5, 9, 0], inf), \legato, Pseq([0.3, 2.2], inf)), Pdef(\x)));
Pdef(\z, Pchain(Pbind(\degree, Pseq([0, 2, 5, 7, 8, 9], 1)), Pn(Pdef(\y))));

Pdef(\play, Psym(Pseq([\x, \x, Prand([\x, \y]), \z, \y], inf).trace)).play;

// change root pattern:
Pdef(\x, Pbind(\dur, Pn(0.125, 2), \instrument, \gpdef));
Pdef(\x, Pbind(\dur, Pn(0.125, 3), \instrument, \gpdef, \ctranspose, 2));
Pdef(\x, Pbind(\dur, Pn(0.125, 2), \instrument, \gpdef, \ctranspose, 0));

// change sequence:
Pdef(\play, Psym(Prand([Pseq([\x, \y], 5), Pseq([\z, \y], 5)], inf).trace)).play;

// use a sequence of characters:
Pdef(\play, Psym(Pseq("xxyxxzz", inf).trace)).play;

// play in parallel:
(
Pdef(\play, Psym(
	Prand([
		Pseq([[\x, \y], \z], 5),
		Pseq([[\z, \y], \x, \x, \y])
		]
	, inf).trace)
).play
);

Pdef(\z, Pchain(Pbind(\mtranspose, -5), Pdef(\y)));
Pdef(\y, Pchain(Pbind(\degree, Pseq([4, 3, 4, 2, 4, 1, 4, 0], 1)), Pdef(\x)));


Pdef(\play).stop; // stop it
Pdef.clear; // clear all
::
** class:: Psync
summary:: synchronise and limit pattern duration
related:: Classes/Pfindur
categories:: Streams-Patterns-Events>Patterns>Repetition

Description::

Psync behaves somewhat like link::Classes/Pfindur:: -- it has a teletype::maxdur:: argument that limits the total duration of the event stream.

The difference is in what happens if the event pattern stops on its own before teletype::maxdur:: is reached. If the total duration of the event pattern is shorter than the given maximum duration:

list::
## Pfindur simply ends: no further time manipulation.
## Psync inserts a rest to round the total duration up to the nearest multiple of the given teletype::quant::.
::

table::
## strong::Pbind's natural duration:: || code::Pfindur(16, Pbind(....)):: strong::behavior:: || code::Psync(Pbind(....), 4, 16):: strong::behavior::
## 6 beats || Pfindur plays only 6 beats || Psync rounds up to 8 beats (adds a two-beat rest)
## 18 beats || Pfindur cuts off after 16 beats || Psync cuts off after 16 beats
::

teletype::maxdur:: may be omitted. If the Pbind stops by itself, the rest will be inserted according to teletype::quant::, but the total duration will be unlimited.

ClassMethods::

method::new

argument::pattern
a pattern that returns events.

argument::quant
rounding factor for total duration (effectively a "bar length")

argument::maxdur
maximum duration

argument::tolerance
difference threshhold that a pattern must exceed max to be ended.

Examples::

code::
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, pan;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.3), doneAction:2);
		Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
	}).add;
)

(
// a fixed duration pattern:

f = Pbind(
	\dur, 0.5,
	\degree, Pn(4,1),
	\instrument, \help_sinegrain
);

// this pattern has indetermined length:
a = Prand([
	Pbind(
		\dur, Pseq([0.02, 0.002, 0.1, 0.1],2),
		\degree, Pseq([9, 7, 5],inf),
		\instrument, \help_sinegrain
	),
	Pbind(
		\dur, Pseq([1, 0.35],2),
		\degree, Pseq([0, [2b,5b]],inf),
		\instrument, \help_sinegrain
	),
	Pbind(
		\dur, Pseq([0.15, 0.25, 1.3],2),
		\degree, Pseq([2b,4,5b],inf),
		\instrument, \help_sinegrain
	)
]);
)

Pseq([f, f, a, a], inf).play; // play a sequence


// Psync allows to limit the duration of a stream relative to a beat grid

b = Psync(a, 1, 1); // create a sequence of exactly 1 beat elements
Pseq([f, f, b, b], inf).play;


b = Psync(a, 1, 2); // create a sequence of elements of either 1 or 2 beats length
Pseq([f, f, b, b], inf).play;

(
b = Psync(a, 2);	// create a sequence of elements with a minimum of 2 beats,
			// but with undetermined upper limit
Ppar([
	Pseq([f, f, b, b], inf), // sequence
	Pbind(\instrument, \help_sinegrain, \freq, 1000, \sustain, 0.01, \dur, 2) // metronome
]).play;
)
::
** class:: Ptime
summary:: returns time in beats from moment of embedding in stream
related:: Classes/Pkey
categories:: Streams-Patterns-Events>Patterns>Time

Examples::

code::
(
a = Ptime.new;
x = a.asStream;
)

x.next;
x.next;
x.next;

// post time in a playing event stream
(
Pbind(
	\pfunc, Ptime.new.trace,
	\dur, Pseries(0.5, 0.5, 5)
).play;
)


// change degree independant of number of events that have been playing

(
var a, b;
a = Pbind(
	\degree, Pswitch(#[0, 2b, 3], Ptime(8).round(2) / 2),
	\dur, Prand(#[0.2, 0.5, 1.1, 0.25, 0.15], inf)
);
b = Pbind(
	\degree, Pseq(#[0, 2b, 3], 1),
	\dur, 2,
	\ctranspose, -7
);
Pseq([Event.silent(1.25), Ppar([a, b])], inf).play;
)


// test tempo changes

(
var a, b;
a = Pbind(
	\degree, Pswitch(#[0, 2b, 3], Ptime(8).round(2) / 2),
	\dur, Prand(#[0.2, 0.5, 1.1, 0.25, 0.15], 9)
);
b = Pbind(
	\degree, Pseq(#[0, 2b, 3], 1),
	\dur, 2,
	\ctranspose, -7
);
Pn(
	Pfset({ ~tempo = #[1, 2, 4].choose.postln },
		Pseq([
			Event.silent(1.25),
			Ppar([a, b])
		])
	)
).play
)
::
** class:: Ptpar
summary:: embed event streams in parallel, with time offset
related:: Classes/Ppar
categories:: Streams-Patterns-Events>Patterns>Parallel

description::

Embeds several event streams so that they form a single output stream with all their events in temporal order, providing a global strong::offset:: for each. When one stream ends, the other streams are further embedded until all have ended.

ClassMethods::

method::new

argument::list
list of pairs of times and patterns: [time, pat, time, pat .. ].

argument::repeats
repeat the whole pattern n times.

Examples::

code::
// see the delta values in the resulting events
(
var a, b, c, t;
a = Pbind(\x, Pseq([1, 2, 3, 4]), \dur, 1);
b = Pbind(\x, Pseq([10, 20, 30, 40]), \dur, 0.4);
c = Ptpar([0.0, a, 1.3, b]);
t = c.asStream;
20.do({ t.next(Event.default).postln; });
)

// sound example
(
var a, b;
a = Pbind(\note, Pseq([7, 4, 0], 4), \dur, Pseq([1, 0.5, 1.5], inf));
b = Pbind(\note, Pseq([5, 10, 12], 4), \dur, 1);
Ptpar([ 0.0, a, 1.3, b ]).play;
)
::
** class:: Ptuple
summary:: combine a list of streams to a stream of lists
related:: Classes/Ppar
categories:: Streams-Patterns-Events>Patterns>List

description::

At each iteration, Ptuple returns a tuple (array) combining the output of each of the patterns in the list. When any of the patterns returns a nil, Ptuple ends that 'repeat' and restarts all of the streams.

ClassMethods::

method::new

argument::list
an link::Classes/Array:: of patterns.

argument::repeats
an link::Classes/Integer:: or inf.

Examples::

code::
(
var a, b;
a = Pseq([1, 2, 3], inf);
b = Pseq([65, 76], inf);
c = Ptuple([a, a, b], inf);
x = c.asStream;
8.do({ x.next.postln; });
)


(
var a, b;
a = Pseq([1, 2, 3], inf);
b = Pseq([65, 76], 3); // stops after 3 cycles
c = Ptuple([a, a, b], 4); // stops after 4 cycles
x = c.asStream;
8.do({ x.next.postln; });
)


//Ptuple used as a sequence of pitches (chords)

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pseq([73, 71, 69, 69, 65, 64], inf);
b = Pseq([0, 0, 0, 4, 0, 3, 2], inf) + a;
c = Ptuple([a, b], inf);
x = c.asStream;
Routine({
	var chord;
	loop({
		chord = x.next.postln.midicps;
		(instrument: \help_sinegrain, freq: chord).play;
	0.2.wait;
	})
}).play;
)
::
** class:: Pulse
summary:: Band limited pulse wave.
related:: Classes/LFPulse
categories::  UGens>Generators>Deterministic


Description::

Band limited pulse wave generator with pulse width modulation.


classmethods::

method::ar

argument::freq

Frequency in Hertz.


argument::width

Pulse width ratio from zero to one. 0.5 makes a square wave.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

// modulate frequency
{ Pulse.ar(XLine.kr(40,4000,6),0.1, 0.2) }.play;

// modulate pulse width
{ Pulse.ar(200, Line.kr(0.01,0.99,8), 0.2) }.play;

// two band limited square waves thru a resonant low pass filter
{ RLPF.ar(Pulse.ar([100,250],0.5,0.1), XLine.kr(8000,400,5), 0.05) }.play;

::

** class:: PulseCount
summary:: Pulse counter.
related:: Classes/Stepper
categories::  UGens>Triggers


Description::

Each trigger increments a counter which is output as a signal.


classmethods::

method::ar, kr

argument::trig

Trigger. Trigger can be any signal. A trigger happens when the
signal changes from non-positive to positive.


argument::reset

Resets the counter to zero when triggered.


Examples::

code::

SynthDef("help-PulseCount",{ arg out=0;
	Out.ar(out,
		SinOsc.ar(
			PulseCount.ar(Impulse.ar(10), Impulse.ar(0.4)) * 200,
			0, 0.05
		)
	)
}).play;

::

** class:: PulseDivider
summary:: Pulse divider.
categories::  UGens>Triggers


Description::

Outputs one impulse each time it receives a certain number of triggers at
its input.


classmethods::

method::ar, kr

argument::trig

Trigger. Trigger can be any signal. A trigger happens when the
signal changes from non-positive to positive.


argument::div

Number of pulses to divide by.


argument::start

Starting value for the trigger count. This lets you start
somewhere in the middle of a count, or if startCount is negative
it adds that many counts to the first time the output is
triggers.


Examples::

code::

SynthDef("help-PulseDivider",{ arg out=0;
	var p, a, b;
	p = Impulse.ar(8);
	a = SinOsc.ar(1200, 0, Decay2.ar(p, 0.005, 0.1));
	b = SinOsc.ar(600,  0, Decay2.ar(PulseDivider.ar(p, 4), 0.005, 0.5));

	Out.ar(out,(a + b) * 0.4)
}).play;

::
** class:: Punop
summary:: unary operator pattern
related:: Classes/Pbinop, Classes/Pnaryop, Classes/UnaryOpFunction
categories:: Streams-Patterns-Events>Patterns>Math

description::

Returns a stream that applies the unary operator to the stream values of the receiver. Usually, this is the result of applying a unary operator (i.e. a method with one argument) to a pattern.

Examples of unary operators are: squared, sqrt, sin, tan ...

ClassMethods::

method::new

argument::operator
operator to be applied

argument::a
a pattern (or compatible pattern input)

Examples::

code::
(
var a;
a = Punop(\sqrt, Pseries(0, 1, 12));
a.asStream.all;
)

// this is the same as:
(
var a;
a = Pseries(0, 1, 12).sqrt;
a.asStream.all;
)

// some common cases:
Pseq([1, 2, 3]).squared;
Pseq([0.2, 0.5, 0.8]).coin;
Pwhite(-100, 100, inf).abs;



// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05, amp=0.1;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2, amp), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
var a;
a = Pn(Punop(\sqrt, Pseries(0, 1, 12))).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, a * 200 + 300].postln);
		0.5.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.01,
	\instrument, \help_sinegrain,
	\note, Pn(Punop(\sqrt, Pseries(0, 1, 12)))
).play;
)


// these are the same as:

(
var a;
a = Pn(Pseries(0, 1, 12).sqrt).asStream;
{
	a.do { |val|
		Synth(\help_sinegrain, [\freq, a * 200 + 300].postln);
		0.05.wait;
	}
}.fork;
)

(
Pbind(
	\dur, 0.1,
	\instrument, \help_sinegrain,
	\note, Pn(Pseries(0, 1, 12).sqrt)
).play;
)
::
TITLE:: PureUGen
summary:: Pure UGen
categories:: UGens
related:: Classes/UGen

DESCRIPTION::

A Pure UGen is a UGen, which does not access any shared resources like busses, buffers or random number generators. UGen
classes which are derived from PureUGen are candidates for common subexpression elimination and dead code elimination
passes during the SynthDef compilation.

INSTANCEMETHODS::
PRIVATE:: optimizeGraph
** class:: Pwalk
summary:: A one-dimensional random walk over a list of values that are embedded
related:: Classes/Pbrown
categories:: Streams-Patterns-Events>Patterns>List

ClassMethods::

method::new

argument::list
The items to be walked over.

argument::stepPattern
Returns integers that will be used to increment the index into list.

argument::directionPattern
Used to determine the behavior at boundaries. When the index crosses a boundary, the next direction is drawn from this stream: 1 means use stepPattern as is, -1 means go in the reverse direction. Common patterns:
definitionList::
## 1 || always wrap around to the other boundary.
## Pseq([1, -1], inf) || go forward first, then backward, then forward again.
::

argument::startPos
Where to start in the list.

Examples::

code::
(
a = Pwalk(
	Array.series(20, 0, 1),		// integers, 0-19
		// steps up to 2 in either direction, weighted toward positive
	Pwrand([-2, -1, 0, 1, 2], [0.05, 0.1, 0.15, 1, 0.1].normalizeSum, inf),
		// reverse direction at boundaries
	Pseq([1, -1], inf),
	10);	// start in the middle
x = a.asStream;
)

200.do({ x.next.post; ", ".post });

b = a.copy.directionPattern_(1);	// this one will always wrap around
x = b.asStream;

200.do({ x.next.post; ", ".post });



// non-random walk: easy way to do up-and-down arpeggiation
s.boot;
(
a = Pwalk(
	[60, 64, 67, 72, 76, 79, 84].midicps,	// C major
	Pseq([1], inf),
	Pseq([1, -1], inf),	// turn around at either end
	0);
x = a.asStream;

SynthDef(\help_walk, { arg freq;
	Out.ar(0, Saw.ar([freq, freq+1], 0.5) * EnvGen.kr(Env.perc(0.01, 0.1), doneAction:2))
}).add;
)

(
r = Task({
	{
		Synth.new(\help_walk, [\freq, x.next]);
		0.1.wait;
	}.loop;
}).play(SystemClock);
)

r.stop;
::
** class:: Pwhile
summary:: While a condition holds, repeatedly embed stream
categories:: Streams-Patterns-Events>Patterns>Language Control

description::
Repeatedly strong::embed:: a link::Classes/Stream:: while the result of code::func:: is code::true::.


classmethods::

method:: new
argument:: func
Stream function. In an event stream receives the current link::Classes/Event:: as argument.
argument:: pattern
A link::Classes/Pattern::.


examples::
code::
(
z = true;
a = Pwhile({ z }, Pseq(#[1, 2, 3]));
x = a.asStream;
);

7.do({ x.next.postln; }); // while z == true, the values are embedded
z = false; // set z to false
x.next; // the rest of the stream is still embedded
x.next;
x.next; // but then it is not continued.
x.next;
x.next;
x.next;
::
** class:: Pwhite
summary:: random values with uniform distribution
related:: Classes/Pgauss
categories:: Streams-Patterns-Events>Patterns>Random

ClassMethods::

method::new

argument::lo
lower boundary of values.

argument::hi
upper boundary of values.

argument::length
number of values produced.

Examples::

code::
(
var a;
a = Pwhite(0.0, 1.0, inf);
c = a.asStream.nextN(500);
w = Window.new("Pwhite", Rect(10, 10, 540, 800));
// plot the values
c.plot(bounds: Rect(10, 10, 520, 380), discrete: true, parent: w);
// a histogram of the values
c.histo(500).plot(bounds: Rect(10, 410, 520, 380), parent: w);
)

(
var a;
a = Pwhite(0.0, 1.0, inf);
a.asStream.nextN(1000).plot;
)


// sound example
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
var a;
a = Pwhite(0.0, 1.0, inf).asStream;
{
	loop {
		Synth(\help_sinegrain, [\freq, a.next * 600 + 300]);
		0.02.wait;
	}
}.fork;
)

// this is equivalent to:
(
{
	loop {
		Synth(\help_sinegrain, [\freq, rrand(0.0, 1.0) * 600 + 300]);
		0.02.wait;
	}
}.fork;
)
::
** class:: Pwrand
summary:: embed values randomly chosen from a list
related:: Classes/Prand, Classes/Pxrand
categories:: Streams-Patterns-Events>Patterns>List

description::
Returns one item from the list at random for each repeat, the probability for each item is determined by a list of weights which should sum to 1.0.

Examples::

code::
(
var a, b;
a = Pwrand.new([1, 2, 3], [1, 3, 5].normalizeSum, 6);	// return 6 items
b = a.asStream;
7.do({ b.next.postln; });
)

//Prand used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
a = Pwrand([60, 61, 63, 65, 72], [10, 2, 3, 1, 3].normalizeSum, inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next.midicps]);
		0.1.wait;
	})
}).play;
)
::
** class:: Pwrap
summary:: constrain the range of output values by wrapping
related:: Classes/SimpleNumber
categories:: Streams-Patterns-Events>Patterns>Math

description::
Note: this is equivalent to pattern.wrap(lo, hi)

Examples::

code::
(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)

(
a = Pn(
	Pwrap(
		Pgeom(200,1.07,96),
		200,
		1000.0
	),
	inf
);
x = a.asStream;

Routine({
	loop({
		Synth(\help_sinegrain, [\freq, x.next.debug,\dur,0.3]);
		0.12.wait;
	})
}).play;
)
::
** class:: Pxrand
summary:: embed values randomly chosen from a list
related:: Classes/Prand, Classes/Pwrand
categories:: Streams-Patterns-Events>Patterns>List

description::
Like link::Classes/Prand::, returns one item from the list at random for each repeat, but Pxrand never repeats the same element twice in a row.

Examples::

code::
(
var a, b;
a = Pxrand.new(#[1, 2, 3], 10);	// return 10 items
b = a.asStream;
11.do({ b.next.postln; });
)

//Pxrand used as a sequence of pitches:

(
SynthDef(\help_sinegrain,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.2), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)


(
a = Pxrand(#[60, 61, 63, 65, 72], inf).asStream;
Routine({
	loop({
		Synth(\help_sinegrain, [\freq, a.next.midicps]);
		0.1.wait;
	})
}).play;
)
::
** class:: QLayout
summary:: Superclass of all GUI layouts
categories:: GUI>Kits>Qt
related:: Classes/HLayout, Classes/VLayout, Classes/GridLayout, Classes/StackLayout, Guides/GUI-Layout-Management

description::
Layout is the abstract superclass of all layouts. Any layout can be installed on a view with the view's link::Classes/View#-layout#'layout':: setter method. See link::Guides/GUI-Layout-Management:: for details of operation common to all layouts.


InstanceMethods::

Method:: spacing
The amount of empty pixels left between the managed views.

argument:: spacing
An integer representing the spacing in pixels.


Method:: margins
The amount of empty pixels left between the edges of the parent view and the managed children.

argument:: margins
An array of four integers defining margins in the following order: left margin, top margin, right margin, bottom margin; or an array of two integers applied to left/right margin and top/bottom margin respectively; or a single integer applied to all margins.



Examples::

code::
w = Window.new;
w.layout = HLayout( TextView().string_("One"), TextView().string_("Two") );
w.layout.spacing = 20;
w.layout.margins = [10, 30, 10, 30];
w.front;
::CLASS:: QLineLayout
summary:: Superclass of layouts that distribute views in a line
categories:: GUI>Kits>Qt
related:: Classes/HLayout, Classes/VLayout, Classes/GridLayout, Classes/StackLayout, Guides/GUI-Layout-Management

DESCRIPTION::
This is an abstract superclass of link::Classes/HLayout:: and link::Classes/VLayout:: which distribute views in a horizontal or vertical line, respectively.

subsection:: Fine tuning

Each item can be assigned a strong::stretch factor:: and an strong::alignment:: flag to fine tune how its size and position are managed. This can be done at layout link::#*new#construction::, when an item is link::#-add#added:: or link::#-insert#inserted:: or for an already present item with link::#-setStretch:: and link::#-setAlignment:: methods.

The strong::stretch factor:: only affects distribution in the direction of the layout (vertical or horizontal). All items have a stretch factor of 0 by default, so only their own preferences will determine space distribution. As soon as an item is assigned a stretch factor higher than 0, the space will be redistributed according to proportions of stretch factors.

subsection:: Leaving empty space

An empty space with an arbitrary stretch factor may be inserted using nil in place of an item in combination with the stretch factor. Similarily, an empty space of fixed size may be inserted using an integer in place of an item. See link::#*new#constructor:: and link::#-add:: for details.


CLASSMETHODS::

PRIVATE:: layoutClass
PRIVATE:: parse

METHOD:: new

Create a link::Classes/HLayout:: or a link::Classes/VLayout:: and immediately fill it with items given as arguments. (Note that QLineLayout is an abstract class and can not be instantiated, but HLayout and VLayout inherit this constructor).

argument:: ... items
Each item can be a strong::view::, a strong::layout::, strong::nil:: (for stretchable empty space) or an strong::Integer:: (for fixed-size empty space).

discussion::

You can assign a strong::stretch factor:: and/or strong::alignment:: to an item by wrapping it into an array, followed by pairs of ('stretch', factor) and/or ('align', alignment). 'stretch' and 'align' may be abbreviated with 's' and 'a'. Simplified syntax for placing key-value pairs into an array comes handy (see link::Reference/Syntax-Shortcuts#Creating arrays with key-value pairs::, and the example below). For possible alignment values see link::Reference/gui_alignments::.

If the item is a stretchable empty space (nil) alignment will have no effect; if the item is a fixed-size empty space (an Integer), it is unaffected by both the stretch factor and alignment.

Example:
code::
w = Window.new;
w.layout = VLayout(
	[Button().states_([["Foo"]]), stretch:1, align:\bottomLeft],
	20,
	[TextView().string_("Bar\nBar\nBar\n"), s:3],
	[nil, s:1]
);
w.front;
::


INSTANCEMETHODS::

METHOD:: add
Add an item to the right or the bottom end of the line, for HLayout and VLayout respectively.

argument:: item
The item can be a strong::view::, a strong::layout::, an strong::Integer:: (specifying amount in pixels of empty space) or strong::nil:: (for stretchable empty space).

argument:: stretch
An integer stretch factor.

argument:: align
A symbol expressing the alignment. See link::Reference/gui_alignments:: for possible values.

discussion::
If the item is a stretchable empty space (nil) the align argument will have no effect; if the item is a fixed-size empty space (an Integer) both stretch and align arguments will have no effect.


METHOD:: insert
Insert an item at a specific position.

argument:: item
The item can be a strong::view::, a strong::layout::, an strong::Integer:: (specifying amount in pixels of empty space) or strong::nil:: (for stretchable empty space).

argument:: index
The integer position among current items at which to insert the new item. If index is smaller than 0 or larger than the current amount of items, the new item will always be added to the end of the line.

argument:: stretch
An integer stretch factor.

argument:: align
A symbol expressing the alignment. See link::Reference/gui_alignments:: for possible values.

discussion::
If the item is a stretchable empty space (nil) the align argument will have no effect; if the item is a fixed-size empty space (an Integer) both stretch and align arguments will have no effect.



METHOD:: setStretch
Set stretch factor of an item contained in the layout.

argument:: item
A view or layout managed by this layout, or an Integer index of an item.

argument:: stretch
An integer stretch factor.



METHOD:: setAlignment
Set alignment of an item contained in the layout.

argument:: item
A view or a layout managed by this layout, or an Integer index of an item.

argument:: align
A symbol expressing the alignment. See link::Reference/gui_alignments:: for possible values.


EXAMPLES::

Try resizing the window created by the following code.

code::
w = Window.new;
w.layout = VLayout(
	TextView().string_("Foo\nBar\nFoo\nBar\nFoo"),
	HLayout(
		Button().states_([["Foo"]]),
		[TextField().string_("Bar"), stretch:1],
		[TextField().string_("BarBarBar"), stretch:4]
	)
);
w.front;
::
** class:: QPalette
summary:: Set of colors used by the GUI
categories::  GUI>Accessories


Description::

QPalette is a strong::set of colors:: that the GUI system uses to draw the views. The colors are organized into three strong::color groups:: (active, inactive and disabled) used according to the state of the views drawn, and each group containins one color assigned to each of the various strong::color roles:: (window, windowText, button, buttonText, etc.), used to draw distinct elements of the views. See link::Reference/palette_color_roles:: and link::Reference/palette_color_groups:: for details.

A palette can be assigned to the whole GUI using link::Classes/QtGUI#*palette::, or to a particular view using link::Classes/View#-palette::. Views will inherit a palette from their parent, and ultimately QtGUI, unless a palette is explicitely assigned to them. Moreover, when setting a palette on a view, it will be combined with the inherited one, overriding only those colors that have been explicitely set on the palette (see link::#-hasColor::). Hence, assigning a new and unmodified palette will reset all the colors to the inherited ones.

There are also two predefined palettes accessible using link::#*light:: and link::#*dark::. The light palette is assigned to QtGUI by default on startup. Should you wish to use a palette that matches the color scheme used natively on your platform, you can access such palette using link::#*system::.

If you wish to design your own palette, it is most convenient to use link::#*auto::, which will automatically derive a palette from only two colors, and then modify the details as you see fit.

Note that in Qt GUI most color-related methods of views (like link::Classes/Window#-background::, link::Classes/Slider#-knobColor::, etc.) actually modify the view's palette.



CLASSMETHODS::

METHOD:: new
	Instantiates a new palette, equivalent to the global palette assigned to QtGUI. All colors are considered to not be set (see link::#-hasColor::).

METHOD:: auto
	Instantiates a new palette, with colors automatically derived from the given colors for 'button' and 'window' color roles. All colors are considered to be set (see link::#-hasColor::).

	argument:: buttonColor
		The Color assigned to the button role.
	argument:: windowColor
		The Color assigned to the window role.

METHOD:: light
	A predefined palette using light colors. All colors are considered to be set (see link::#-hasColor::).

METHOD:: dark
	A predefined palette using dark colors. All colors are considered to be set (see link::#-hasColor::).

METHOD:: system
	The native system palette. All colors are considered to be set (see link::#-hasColor::).


INSTANCEMETHODS::


PRIVATE:: prInit
PRIVATE:: prAuto
PRIVATE:: prSystem
PRIVATE:: prColor
PRIVATE:: prSetColor
PRIVATE:: prHasColor

METHOD:: color
	Returns the color assigned to a color role within a color group.
	argument:: role
		A symbol among link::Reference/palette_color_roles::.
	argument:: group
		A symbol among link::Reference/palette_color_groups::, or nil, in which case the current color group is used.

METHOD:: setColor
	Assigns a color to a color role within a color group.

	argument:: color
		A Color.
	argument:: role
		A symbol among link::Reference/palette_color_roles::.
	argument:: group
		A symbol among link::Reference/palette_color_groups::, or nil, in which case the color will be assigned to all groups.

METHOD:: hasColor
	Whether the color belonging to a color role and group has been set on this QPalette instance.

	When setting a palette on a view, only colors for which this methods returns true will be changed, others will be inherited from the parent view (or QtGUI if this view has no parent).

	argument:: role
		A symbol among link::Reference/palette_color_roles::.
	argument:: group
		A symbol among link::Reference/palette_color_groups::.

METHOD:: window
	Convenience method to get or set the color for the 'window' role.

METHOD:: windowText
	Convenience method to get or set the color for the 'windowText' role.

METHOD:: button
	Convenience method to get or set the color for the 'button' role.

METHOD:: buttonText
	Convenience method to get or set the color for the 'buttonText' role.

METHOD:: base
	Convenience method to get or set the color for the 'base' role.

METHOD:: baseText
	Convenience method to get or set the color for the 'baseText' role.

METHOD:: highlight
	Convenience method to get or set the color for the 'highlight' role.

METHOD:: highlightText
	Convenience method to get or set the color for the 'highlightText' role.
** CLASS:: QPenPrinter
summary:: QPen PDF export and printing of vector graphics
categories:: GUI>Accessories
related:: Classes/QPen, Classes/Pen

DESCRIPTION::
QPenPrinter allows QPen to operate on a printer device. The graphics can be exported to PDF by using "print to file" as printer device.

CLASSMETHODS::
private:: qtClass


METHOD:: new
Create a new QPenPrinter object.

returns:: an instance of QPenPrinter

METHOD:: print
Convenience function to show a print dialog and print.

argument:: printFunc
A link::Classes/Function:: to be evaluated when the user presses "Print", with the printer object as QPen painter target.
See strong::aPrintFunc:: in link::#-print:: below.

argument:: cancelFunc
An optional link::Classes/Function:: to be evaluated if the user presses "Cancel".


INSTANCEMETHODS::
private:: init

subsection:: Printing

METHOD:: showDialog
Shows a Print Dialog to allow the user to configure the printer object. This is asynchronous and the method will return immediately.
When the user presses the "Print" button, strong::aOkFunc:: is called with this QPenPrinter object as argument.

argument:: aOkFunc
A link::Classes/Function:: to be evaluated when the user presses "Print".

argument:: aCancelFunc
An optional link::Classes/Function:: to be evaluated if the user presses "Cancel".


METHOD:: print
This method does the actual printing or PDF export. It evaluates strong::aPrintFunc:: with the printer object as QPen painter target. This QPenPrinter object is passed as the argument.

All the ordinary link::Classes/QPen:: commands can be used inside the function.

argument:: aPrintFunc
A link::Classes/Function:: to be evaluated to draw the graphics.

discussion::
If this method is called without configuring the printer object first, it will print on the default printer with default settings.

This method is typically called from within the strong::aOkFunc:: of link::#-showDialog:: above. After showDialog has configured the printer once, this method can be called multiple times to reuse the last printer configuration.

The point at (0@0) will coincide with the origin of link::#-pageRect::, which is offset by the page margins. So you don't need to translate the Pen.


METHOD:: newPage
Starts a new page. Typically called within the strong::aPrintFunc:: of link::#-print::.


subsection:: Properties

METHOD:: paperRect
Get the paper bounds.

returns:: a link::Classes/Rect::


METHOD:: pageRect
Get the page bounds, which is the printable area and usually smaller than link::#-paperRect:: due to margins.

returns:: a link::Classes/Rect::

discussion::
The strong::origin:: of the Rect is relative to the paper, and will be non-zero due to margins.


METHOD:: pageSize
Get the page size as a Size.

returns:: a link::Classes/Size::

discussion::
This can be used to scale the graphics to fit the page if the bounds of the graphics is known:
code::
x = penPrinter.pageSize.width / bounds.width;
Pen.scale(x,x);
// ... draw stuff here ...
::

subsection:: Page range
The methods below returns the page range selected by the user. Page number starts at 1. When both methods returns 0 it means "print all pages".

METHOD:: fromPage
Get the start page.

returns:: an link::Classes/Integer::

METHOD:: toPage
Get the end page.

returns:: an link::Classes/Integer::



EXAMPLES::

Simple usage:
code::
QPenPrinter.print {
    // first page
    Pen.moveTo(100@100);
    Pen.lineTo(300@300);
    Pen.stroke;

    // second page
    p.newPage;
    Pen.addRect(p.pageSize.asRect);
    Pen.stroke;
}
::

Keep the QPenPrinter object to save configuration state:
code::
p = QPenPrinter();
::
The code below can then be called multiple times:
code::
p.showDialog {
    p.print {
        // first page
        Pen.moveTo(100@100);
        Pen.lineTo(300@300);
        Pen.stroke;

        // second page
        p.newPage;
        Pen.addRect(p.pageSize.asRect);
        Pen.stroke;
    }
} {
    "Printing cancelled!".postln;
};
::

** CLASS:: QTreeViewItem
summary:: An item in QTreeView
categories:: GUI>Kits>Qt

DESCRIPTION::

An instance of QTreeViewItem represents an item in QTreeView. There may be multiple instances representing the same item, e.g. after calling link::Classes/TreeView#-currentItem:: multiple times.

INSTANCEMETHODS::

PRIVATE:: prValidItem

METHOD:: index
	RETURNS:: An integer position of this item among its siblings.

METHOD:: parent
	RETURNS:: An new instance of QTreeViewItem representing the parent item.

METHOD:: childAt
	RETURNS:: A new instance of QTreeViewItem representing the child item at code::index::.

METHOD:: addChild
	Appends a new child to this item.

	ARGUMENT:: strings
		An array of Strings (or nil), each for the text of one data field.
	RETURNS::
		An instance of QTreeViewItem representing the new item.

METHOD:: insertChild
	Inserts a new child to this item at code::index::.

	ARGUMENT:: index
		The position at which to insert the child.
	ARGUMENT:: strings
		An array of Strings (or nil), each for the text of one data field.
	RETURNS::
		An instance of QTreeViewItem representing the new item.

METHOD:: strings
	The text in the data fields.

	ARGUMENT:: strings
		An array of Strings (or nil), each for the text of one data field.

METHOD:: setString
	Sets the text in the given data field.

	ARGUMENT:: column
		An integer index of a data field.
	ARGUMENT:: string
		A String or nil.

METHOD:: colors
	The background colors of the data fields.

	ARGUMENT:: colors
		An array of Colors, each for the color of one data field.

METHOD:: setColor
	Sets the background color of the given data field.

	ARGUMENT:: column
		An integer index of a data field.
	ARGUMENT:: color
		A Color.

METHOD:: textColors
	The text colors of the data fields.

	ARGUMENT:: textColors
		An array of Colors, each for the color of one data field.

METHOD:: setTextColor
	Sets the text color of the given data field.

	ARGUMENT:: column
		An integer index of a data field.
	ARGUMENT:: color
		A Color.

METHOD:: setView
	Places another view into the given data field. Only one view can be placed into a data field at once. If a view is already present, it will be removed and destroyed.

	If the number of data fields decreases due to a call to link::Classes/TreeView#-columns::, the views contained in removed data fields will also be removed and destroyed.

	ARGUMENT:: column
		An integer index of a data field.
	ARGUMENT:: view
		A View.

METHOD:: removeView
	Removes the view from the given data field, if any.

	ARGUMENT:: column
		An integer index of a data field.

METHOD:: view
	The view in the given data field.

	ARGUMENT:: column
		An integer index of a data field.

METHOD:: ==
	Implements equality comparison between two QTreeViewItem instances. Two instances are equal if they represent the same item in QTreeView.

	RETURNS:: A Boolean.

METHOD:: isNull
	Whether the item is invalid. After an item is removed, all related QTreeViewItem instances become invalid.

	RETURNS:: A Boolean.
** class:: QuadC
summary:: General quadratic map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/QuadN, Classes/QuadL

description::
A cubic-interpolating sound generator based on the difference equation:

code::
	x[n+1] = a * pow(x[n], 2) + b * x[n] + c
::
warning:: revise formulae conversion to c like code ::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: c
Equation variable
argument:: xi
Initial value of x

examples::
code::
// default params
{ QuadC.ar(SampleRate.ir/4) * 0.2 }.play(s);
::

code::
// logistic map
// equation: x1 = -r*x0^2 + r*x0
(
{ var r;
	r = MouseX.kr(3.5441, 4);	// stable range
	QuadC.ar(SampleRate.ir/4, r.neg, r, 0, 0.1) * 0.4;
}.play(s);
)
::

code::
// logistic map as frequency control
(
{ var r;
	r = MouseX.kr(3.5441, 4);	// stable range
	SinOsc.ar(QuadC.ar(40, r.neg, r, 0, 0.1, 800, 900)) * 0.4;
}.play(s);
)
::
** class:: QuadL
summary:: General quadratic map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/QuadC, Classes/QuadN

description::
A linear-interpolating sound generator based on the difference equation:

code::
	x[n+1] = a * pow(x[n], 2) + b * x[n] + c
::
warning:: revise formulae conversion to c like code ::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: c
Equation variable
argument:: xi
Initial value of x

examples::
code::
// default params
{ QuadL.ar(SampleRate.ir/4) * 0.2 }.play(s);
::

code::
// logistic map
// equation: x1 = -r*x0^2 + r*x0
(
{ var r;
	r = MouseX.kr(3.5441, 4);	// stable range
	QuadL.ar(SampleRate.ir/4, r.neg, r, 0, 0.1) * 0.4;
}.play(s);
)
::

code::
// logistic map as frequency control
(
{ var r;
	r = MouseX.kr(3.5441, 4);	// stable range
	SinOsc.ar(QuadL.ar(40, r.neg, r, 0, 0.1, 800, 900)) * 0.4;
}.play(s);
)
::
** class:: QuadN
summary:: General quadratic map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/QuadL, Classes/QuadC

description::
A non-interpolating sound generator based on the difference equation:

code::
	x[n+1] = a * pow(x[n], 2) + b * x[n] + c
::
warning:: revise formulae conversion to c like code ::

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: a
Equation variable
argument:: b
Equation variable
argument:: c
Equation variable
argument:: xi
Initial value of x
argument:: mul
argument:: add

examples::
code::
// default params
{ QuadN.ar(SampleRate.ir/4) * 0.2 }.play(s);
::

code::
// logistic map
// equation: x1 = -r*x0^2 + r*x0
(
{ var r;
	r = MouseX.kr(3.5441, 4);	// stable range
	QuadN.ar(SampleRate.ir/4, r.neg, r, 0, 0.1) * 0.4;
}.play(s);
)
::

code::
// logistic map as frequency control
(
{ var r;
	r = MouseX.kr(3.5441, 4);	// stable range
	SinOsc.ar(QuadN.ar(40, r.neg, r, 0, 0.1, 800, 900)) * 0.4;
}.play(s);
)
::
** CLASS::Quant
categories::Scheduling
summary::encapsulate quantization issues associated with EventStreamPlayer and TempoClock

DESCRIPTION::
Represents the standard scheduling model for Routines, Tasks and Patterns. A Quant object stores the parameters needed to calculate the precise time when a Routine/Task/Pattern will start playing on a specified TempoClock.

The standard scheduling model uses quant and phase to locate the starting time. They are evaluated with reference to the TempoClock's baseBarBeat, which is normally zero but is updated when you change the clock's meter using the clock's setMeterAtBeat method. Thus scheduling still makes sense even after a meter change. See the link::Classes/TempoClock:: help file for details on its representation of time.

CLASSMETHODS::

method::new
Explicitly create an instance of Quant, which may be used and reused. Phase and offset may be nil, in which case they are treated as 0. If quant is nil, it will schedule for the current time exactly.

INSTANCEMETHODS::

method::quant
Quantization granularity. The routine will begin on the next integer multiple of this number after the baseBarBeat. If negative, it indicates the number of bars in the future to schedule (where the bar length is taken from the clock's beatsPerBar variable).

method::phase
An offset to push the scheduling time into the middle of the bar. +1 is one beat later, -1 is one beat earlier. A negative phase is legal, but it might result in a scheduling time that is later than the current time, in which case scheduling will be incorrect. It's your responsibility to take this into account.

method::timingOffset
For use with patterns only -- this enables patterns to run slightly ahead of their sounding time on the clock, giving you control over the order in which threads execute.

EXAMPLES::

definitionlist::
## quant = 1 || schedule for the next whole beat
## quant = 4, phase = -1 || a one beat pick-up to the next 4/4 barline
::
Suppose the clock's meter was 3/4 for 3 bars (starting at 0). Then:
definitionlist::
## quant = 3, phase = 1 || would schedule for 1, 4, or 7 beats
::
During this time, clock.setMeterAtBeat(4, 9) is executed. Then:
definitionlist::
## quant = 4, phase = 0 || would schedule for 9, 13, 17, 21 etc. beats
::
Every point in time can be precisely identified this way, and it can be related back easily to the Western concept of meter or time signature.

subsection::Automatic instantiation

Certain objects convert themselves into Quant objects when used with link::Classes/Routine#-play::, link::Classes/Task#-play:: or link::Classes/Pattern#-play::.

definitionlist::
## link::Classes/SimpleNumber::
|| code:: 4.0 --> Quant(4.0, nil, nil) ::
## link::Classes/Array:: ||
code:: [4.0, 1.0] --> Quant(4.0, 1.0, nil) ::

code:: [4.0, 1.0, 0.1] --> Quant(4.0, 1.0, 0.1) ::
## link::Classes/Nil::
|| code:: nil --> Quant(nil, nil, nil) ::
::
This simplifies the syntax:
code::
Routine({ ... }).play(quant: 4.0):: vs. code::Routine({ ... }).play(quant: Quant(4.0))
::

subsection::Timing offset in Patterns

In some cases, you might want two patterns that are sounding at the same time to evaluate in a specific order -- for instance, the second pattern might depend upon data calculated by the first. If they are scheduled on the clock for exactly the same time, you have no control over the order of execution: the second pattern might evaluate first, in which case it would be using stale data for the pattern that should have run first.

The timing offset is a positive number, usually small, that pushes the scheduling time slightly earlier, guaranteeing that patterns with larger timing offsets will execute earlier than others. The timing offset value is saved in the event prototype, which then delays its messages to the server by exactly that number of beats.

Two patterns, scheduled for the same quant and phase but with different timing offsets, should sound exactly together.

code::
(
// timing offset = 0
p = Pbind(\freq, 440, \pan, -1, \delta, 1.0, \sustain, 0.1).play(quant: [2, 0, 0]);
// timing offest = 0.1
q = Pbind(\freq, 880, \pan, 1, \delta, 0.5, \sustain, 0.1).play(quant: [2, 0, 0.1]);
)

// p's nextBeat is x.0 - q's is x.4 or x.9 (e.g., halves of a beat minus 0.1)
[p.nextBeat, q.nextBeat]

p.stop; q.stop;
::

subsection::Extensibility: adding custom scheduling models

While the standard scheduling model should be sufficient for most uses, the point of using an object to encapsulate scheduling details is that you can use a different object to schedule Routines or Patterns differently. (Users are not forced to use the standard scheduling model in every case.)

If it's a kind of scheduling you expect to use often, you can create a subclass of Quant that implements the following methods:

*new(...): create a new instance, with whatever arguments you need

nextTimeOnGrid(clock): calculate the exact beat number on the clock

Your class should also have methods asQuant, offset and offset_. If your class is a subclass of Quant, it will inherit those methods automatically.

You can also use an Event for one shot scheduling. It should at least have an entry for nextTimeOnGrid, which will usually be a function taking the arguments "self" and "clock" that returns the absolute scheduling time. Any other values needed for that calculation should also be present in the Event.

code::
// schedule for a random number of beats after the next integer
Pfuncn({ thisThread.clock.beats.debug("scheduled for"); nil }, 1)
	.play(quant: (
		nextTimeOnGrid: { |self, clock|
			clock.beats.roundUp(1).debug("clock beats") + rrand(self.lo, self.hi).debug("rand")
		},
		lo: 0, hi: 4
	));
::
** class:: Quark
summary:: Package of SC classes and extensions
categories:: Quarks
related:: Guides/UsingQuarks, Classes/Quarks

description::

A Quark is a package of SC classes, helpfiles and other SC code.

A Quark object is created from the quark file found at code::Quarks.local.path +/+ "DIRECTORY" +/+ nameOfQuark ++ ".quark"::.
These Quark objects are mostly used just by the link::Classes/Quarks:: class, and you usually don't need to deal with them at all. But to publish a quark, you do need to make the quark file.

subsection:: Format of the .quark file

This quarkfile is written in sc code, and should contain a dictionary with basic information about the package.

code::
(
// required:
    \name:           "theName",
    \path:           "foldername", // almost always the same as the quark name
    \summary:        "Human readable summary",
    \author:         "My Name",

// optional:
    \version:        1.0, // must be a float
    \organization:   "My Organization",
    \country:        "My Country",
    \since:          "2004",
    \schelp:         "Classes/MyClass",
    \ext_dependancy: "Information on additional software needed to run this quark properly",
    \url:            "http://www.strangeQuark.de",

// If the quark depends on other quarks, you can specify it as a list containing:
// (1) strings (just the quark name)
    \dependencies:   "nameOfDependantQuark"
// (2) key->value pairs (name->version)
//  \dependencies:   [("nameOfDependantQuark" -> 1.0)]
// or (3) arrays with info in this order: [name, version, repositoryBaseUrl]
//  \dependencies:   [["nameOfDependantQuark", 1.0, "https://svn.weirdserver.be/trunk/weirdquarks"]]

)
::

Of particular importance for the Quarks interface class is the PATH. This is the path relative to the quark directory.
In most cases this is simply the name of the quark and also the name of the folder. However, you may wish to create a parent folder and then keep several quarks inside that, in which case your path would be: parentfolder/quarkname

It may even be possible to nest quarks inside of quarks (a kind of aggregate package), though a better way to do that would be to define an empty quark (the aggregate) and specify the other sub quarks as dependencies.

The value of code::\schelp:: optionally sets the main help file for the quark. It is a help path relative to an included teletype::HelpSource:: folder.
For example, if the quark contains teletype::HelpSource/Reference/MyQuark.schelp:: one could use:
code::
    \schelp: "Reference/MyQuark"
::
It is used by link::#-help::. If no code::\schelp:: is given, it will open the category browser showing all helpfiles for the quark.

note::
The old help system (sc version 3.4) used code::\helpdoc::, and the new help system (link::Classes/SCDoc::) uses code::\schelp:: instead to be able to support both old and new helpfiles during the transition to the new help system.
::

warning:: Please test that you don't have any syntax errors in your quark file before commiting it.::

classmethods::
method:: find
Return the Quark object with specified name, if found.

instancemethods::
method:: name
The name of the quark.
method:: summary
The summary of the quark.
method:: version
The version of the quark.
method:: author
The author of the quark.
method:: path
The path of the quark.
method:: info
The whole info blob as given in the .quark file.
method:: help
Open the main helpfile for this quark as given by the code::\schelp:: key in the directory file,
or the category browser page showing all helpfiles for this quark if no main helpfile was specified.
This method falls back to opening the old help as given by code::\helpdoc:: if above fails.

** class:: Quarks
summary:: Package manager
categories:: Quarks
related:: Classes/Quark, Guides/UsingQuarks, Classes/QuarkSVNRepository, Classes/LocalQuarks

description::
See link::Guides/UsingQuarks:: for more information.

CLASSMETHODS::
private:: initClass

METHOD:: gui
Show GUI to manage quarks.

METHOD:: global
The singleton Quarks instance.

METHOD:: checkoutAll
Check out all quarks (does not install them)

METHOD:: listCheckedOut
List all checked out quarks.

METHOD:: listAvailable
List all available quarks.

METHOD:: listInstalled
List all installed quarks.

METHOD:: updateDirectory
Makes sure you have an up-to-date directory listing.

METHOD:: checkout
Check out a specific quark.

argument:: name
Name of quark to checkout.

argument:: version
A link::Classes/Float:: indicating which version of the quark to checkout.

argument:: sync
A link::Classes/Boolean::

METHOD:: install
Install a specific quark, by linking it into the user extensions folder.

argument:: name
Name of quark.

argument:: includeDependencies
A link::Classes/Boolean::

argument:: checkoutIfNeeded
A link::Classes/Boolean::

METHOD:: uninstall
Uninstall quark.

argument:: name
Name of quark.

METHOD:: update
Update quark to latest revision.

argument:: quarkName
Name of quark.

METHOD:: installed
Get a list of all installed quarks.

METHOD:: isInstalled
Check if a quark is installed.

argument:: name
Name of quark.

METHOD:: local
An instance of link::Classes/LocalQuarks::

METHOD:: help
Open help for specific quark.

argument:: name
Name of quark.


INSTANCEMETHODS::
note:: This document needs updating ::

** class:: RHPF
summary:: A resonant high pass filter.
related:: Classes/Formlet, Classes/RLPF, Classes/Resonz, Classes/Ringz
categories::  UGens>Filters>Linear


Description::

A resonant high pass filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Cuttoff frequency in Hertz.


argument::rq

The reciprocal of Q (bandwidth / cutoffFreq).


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ RHPF.ar(Saw.ar(200,0.1), FSinOsc.kr(XLine.kr(0.7,300,20), 0, 3600, 4000), 0.2) }.play;

(
{ 	var ctl = RHPF.kr(LFSaw.kr(2), SinOsc.kr(XLine.kr(0.07,30,20), 0, 35, 40), 0.05);
	SinOsc.ar(ctl * 200 + 500);
}.play;
)

::

** class:: RLPF
summary:: A resonant low pass filter.
related:: Classes/Formlet, Classes/RHPF, Classes/Resonz, Classes/Ringz
categories::  UGens>Filters>Linear


Description::

A resonant low pass filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Cuttoff frequency in Hertz.


argument::rq

The reciprocal of Q (bandwidth / cutoffFreq).


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ RLPF.ar(Saw.ar(200, 0.1), FSinOsc.kr(XLine.kr(0.7, 300, 20), 0, 3600, 4000), 0.2) }.play;


(
{ 	var ctl = RLPF.ar(Saw.ar(5, 0.1), 25, 0.03);
	SinOsc.ar(ctl * 200 + 400) * 0.1;
}.play;
)

(
{ 	var ctl = RLPF.ar(Saw.ar(5,0.1), MouseX.kr(2, 200, 1), MouseY.kr(0.01, 1, 1));
	SinOsc.ar(ctl * 200 + 400) * 0.1;
}.play;
)

::

** class:: RadiansPerSample
summary:: Number of radians per sample.
related:: Classes/ControlRate, Classes/SampleDur, Classes/SampleRate, Classes/SubsampleOffset
categories::  UGens>Info


Description::

Returns the number of radians per sample.


classmethods::

method::ir

** class:: Ramp
summary:: Break a continuous signal into line segments
related:: Classes/Lag, Classes/VarLag, Classes/Slew
categories::  UGens>Filters>Linear


Description::

Break a continuous signal into linearly interpolated segments with specific durations.

Feeding Ramp with noise is similar to link::Classes/LFNoise1::
code::
Ramp.kr(WhiteNoise.kr(1),0.5)
::
is equal to:
code::
LFNoise1.kr(1 / 0.5)
::

For smoothing out control signals, take a look at link::Classes/Lag:: and link::Classes/VarLag::

classmethods::

method::ar, kr

argument::in

The input signal.


argument::lagTime

segment duration in seconds.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
s.boot;
(
// used to lag pitch
{
	SinOsc.ar(		// sine wave
		Ramp.kr(			// lag the modulator
			LFPulse.kr(4, 0, 0.5, 50, 400),	// frequency modulator
			Line.kr(0, 1, 15)				// modulate lag time
		),
		0,	// phase
		0.3	// sine amplitude
	)
}.scope;
)

// Compare
(
var pulse;
{
	pulse = LFPulse.kr(8.772);
	Out.kr(0,[Ramp.kr(pulse, 0.025), Lag.kr(pulse, 0.025), pulse]);
}.play;
s.scope(3, bufsize: 44100, rate: \control, zoom: 40);
)
::

** class:: Rand
summary:: Single random number generator.
related:: Classes/ExpRand, Classes/IRand, Classes/LinRand, Classes/NRand, Classes/TExpRand, Classes/TIRand, Classes/TRand
categories:: UGens>Random

Description::

Generates a single random float value in uniform distribution from
code::lo::  to  code::hi:: . It generates
this when the SynthDef first starts playing, and remains fixed for
the duration of the synth's existence.


classmethods::

method::new

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

Examples::

code::

(
SynthDef("help-Rand", { arg out=0;
	Out.ar(out,
		FSinOsc.ar(
			Rand(200.0, 400.0),
			0, Line.kr(0.2, 0, 1, doneAction:2))
	)
}).send(s);
)

(
Routine({
	8.do({
		Synth.new("help-Rand"); 1.0.wait;
	})
}).play;
)

::

** class:: RandID
summary:: Set the synth's random generator ID.
related:: Classes/RandSeed
categories::  UGens>Generators>Stochastic, UGens>Random


Description::

Choose which random number generator to use for this synth.
All synths that use the same generator reproduce the same sequence
of numbers when the same seed is set again.


classmethods::

method::kr, ir

argument::id
The random number generator ID.

Examples::

code::

//start a noise patch and set the id of the generator
(
SynthDef("help-RandID", { arg out=0, id=1;
	RandID.ir(id);
	Out.ar(out,
		WhiteNoise.ar(0.05) + Dust2.ar(70)
	)
}).send(s);
)

//reset the seed of my rgen at a variable rate
(
SynthDef("help-RandSeed", { arg seed=1910, id=1;
		RandID.kr(id);
		RandSeed.kr(Impulse.kr(FSinOsc.kr(0.2, 0, 10, 11)), seed);
}).send(s);

)

//start two noise synths on left and right channel with a different randgen id
a = Synth("help-RandID", [\out, 0, \id, 1]);
b = Synth("help-RandID", [\out, 1, \id, 2]);

//reset the seed of randgen 1
x = Synth("help-RandSeed", [\id, 1]);

//change the target randgen to 2 (affects right channel)
x.set(\id, 2);

::

** class:: RandSeed
summary:: Sets the synth's random generator seed.
related:: Classes/RandID
categories::  UGens>Generators>Stochastic, UGens>Random


Description::

When the trigger signal changes from nonpositive to positve, the synth's
random generator seed is reset to the given value. All synths that use
the same random number generator reproduce the same sequence of numbers
again.


See  link::Classes/RandID::  UGen for setting the randgen id and
link::Reference/randomSeed:: for the client side equivalent.


classmethods::

method::kr, ir

argument::trig

The trigger. Trigger can be any signal. A trigger happens when
the signal changes from non-positive to positive.


argument::seed
The random seed.

Examples::

code::

// start a noise patch

(
{
var noise, filterfreq;
noise = WhiteNoise.ar(0.05 ! 2) + Dust2.ar(70 ! 2);
filterfreq = LFNoise1.kr(3, 5500, 6000);
Resonz.ar(noise * 5, filterfreq, 0.5) + (noise * 0.5)
}.play;
)

// reset the seed at a variable rate
(
x = { arg seed=1956;
		RandSeed.kr(Impulse.kr(MouseX.kr(0.1, 100)), seed);
}.play;
)



x.set(\seed, 2001);
x.set(\seed, 1798);
x.set(\seed, 1902);


// above you can see that the sound of the LFNoise1 is not exactly reproduced (filter frequency)
// this is due to interference between the internal phase of the noise ugen and the
// seed setting rate.

// a solution is to start a new synth:

(
SynthDef("pseudorandom", { arg out, sustain=1, seed=1967, id=0;
	var noise, filterfreq;
	RandID.ir(id);
	RandSeed.ir(1, seed);


	noise = WhiteNoise.ar(0.05 ! 2) + Dust2.ar(70 ! 2);
	filterfreq = LFNoise1.kr(3, 5500, 6000);

	Out.ar(out,
		Resonz.ar(noise * 5, filterfreq, 0.5) + (noise * 0.5)
		*
		Line.kr(1, 0, sustain, doneAction:2)
	)

}).send(s);
)

// the exact same sound is reproduced
(
fork {
	loop {
		Synth("pseudorandom");
		1.1.wait; // wait a bit longer than sustain, so sounds don't overlap
	}
}
)

// changing the rand seed changes the sound:

(
fork {
	(1902..2005).do { |seed|
		seed.postln;
		3.do {
			Synth("pseudorandom", [\seed, seed]);
			1.1.wait;
		}
	}
}
)

// cd skipper
(
fork {
	(1902..2005).do { |seed|
		seed.postln;
		rrand(4,10).do {
			Synth("pseudorandom", [\seed, seed, \sustain, 0.05]);
			0.06.wait;
		}
	}
}
)

// if the sounds overlap, this does not work as expected anymore
// sounds vary.

(
fork {
	loop {
		Synth("pseudorandom");
		0.8.wait; // instead of 1.1
	}
}
)

// rand id can be used to restrict the resetting of the seed to each voice:

(
fork {
	var id=0;
	(1902..2005).do { |seed|
		seed.postln;
		3.do {
			Synth("pseudorandom", [\seed, seed, \id, id]);
			id = id + 1 % 16; // there is 16 different random generators
			0.8.wait;
		}
	}
}
)

::

** CLASS:: RangeSlider
redirect:: implClass
summary:: A view consisting of a sliding extendable handle
categories:: GUI>Views

DESCRIPTION::

A view that allows setting two numerical values between 0 and 1, represented by the two ends of a movable and extendable handle. It can have horizontal or vertical orientation, meaning the direction in which the handle moves and extends.

Clicking and moving the mouse pointer within the view will define the two ends of the range. Doing the same while holding down the Ctrl key will move the whole range without changing its size.



CLASSMETHODS::

PRIVATE:: key

METHOD:: new

    When a new RangeSlider is created, its link::#-orientation:: is determined by the initial size: if it is wider than high, the orientation will be horizontal, otherwise it will be vertical.




INSTANCEMETHODS::

SUBSECTION:: Data

METHOD:: lo

	The low end of the range.

	If you attempt to set it higher then the current link::#-hi::, -hi will be set instead, and -lo will become the old -hi.

	When setting -lo the value will always be clipped to the range between 0 and 1.

	argument::
		A Float between 0 and 1.

METHOD:: hi

	The high end of the range. If you attempt to set it lower then the current link::#-lo::, -lo will be set instead, and -hi will become the old -lo.

	When setting -hi the value will always be clipped to the range between 0 and 1.

	argument::
		A Float between 0 and 1.

METHOD:: activeLo

	Sets link::#-lo:: to the argument and triggers link::#-action::.

METHOD:: activeHi

	Sets link::#-hi:: to the argument and triggers link::#-action::.

METHOD:: range

	The difference between link::#-hi:: and link::#-lo::. Setting -range will set -hi to -lo + -range.

METHOD:: activeRange

	Sets link::#-range:: to the argument and triggers link::#-action::.

METHOD:: setSpan

	Sets link::#-lo:: and link::#-hi:: to each of the arguments, respectively.

METHOD:: setSpanActive

	Calls link::#-setSpan::, forwarding the arguments, and triggers link::#-action::.

METHOD:: setDeviation

	Sets link::#-lo:: and link::#-hi:: according to their deviation and their average instead of their absolute values.

	argument:: deviation
		A Float determining the absolute deviation of -lo and -hi from their average.
	argument:: average
		A Float determining the average of -lo and -hi.

METHOD:: increment
	Increments both link::#-lo:: and link::#-hi:: by link::#-step:: multiplied by 'factor'.

	argument:: factor
		A Float.

METHOD:: decrement
	Decrements both link::#-lo:: and link::#-hi:: by link::#-step:: multiplied by 'factor'.

	argument:: factor
		A Float.





SUBSECTION:: Appearance

METHOD:: orientation
	The orientation of the RangeSlider - the direction in which the handle moves and is extendable. The default value depends on the size of the view when created.

	argument::
		One of the two Symbols: \horizontal or \vertical.

METHOD:: knobColor
	The color of the handle.

	argument::
		A Color.




SUBSECTION:: Interaction

METHOD:: step
	The amount by which the range will change when link::#-increment:: or link::#-decrement:: is called, or when related keys are pressed.

	argument::
		A Float.

METHOD:: pixelStep
	The absolute amount by which the range would change if the handle moved by one pixel.

	returns::
		A Float.

METHOD:: shift_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the range by keyboard while the Shift key is pressed.

	argument::
		A Float.

METHOD:: ctrl_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the range by keyboard while the Ctrl key is pressed.

	argument::
		A Float.

METHOD:: alt_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the range by keyboard while the Alt key is pressed.

	argument::
		A Float.



SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user changes the position or size of the handle.

METHOD:: defaultKeyDownAction

	Implements the default effects of key presses as follows:

	table::
	## strong::Key::   || strong::Effect::
	## a               || lo_(0), hi_(1), and triggers action
	## n               || lo_(0), hi_(0), and triggers action
	## x               || lo_(1), hi_(1), and triggers action
	## c               || lo_(0.5), hi_(0.5), and triggers action
	## up arrow        || increment
	## down arrow      || decrement
	## right arrow     || increment
	## left arrow      || decrement
	::



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		A Point of which the x and y coordinates are set to link::#-lo:: and link::#-hi::, respectively.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a Point.

METHOD:: defaultReceiveDrag
	Sets  link::#-lo:: and link::#-hi:: to the two coordinates of the Point stored as the current drag data, respectively, and triggers the link::#-action::.



EXAMPLES::

subsection:: Basic examples

code::
(
w = Window.new.front;
a = RangeSlider(w, Rect(20, 80, 120, 30))
    .lo_(0.2)
    .range_(0.4)
    .action_({ |slider|
        [\sliderLOW, slider.lo, \sliderHI, slider.hi].postln;
    });
)
::

code::
(
w = Window.new.front;
a = RangeSlider(w, Rect(20, 80, 120, 30))
    .lo_(0.2)
    .hi_(0.8)
    .action_({ |slider|
        b.activeLo_(slider.lo); // this will trigger the action of b (and set it's value)
        b.hi_(slider.hi);
    });
b = RangeSlider(w, Rect(220, 80, 20, 130))
    .lo_(0.2)
    .hi_(0.8)
    .knobColor_(HiliteGradient(Color.grey, Color.white,\h))
    .action_({ |slider|
        [\sliderLOW, slider.lo, \sliderHI, slider.hi].postln;
    });

)
::

subsection:: Use of setDeviation

code::
(

w = Window("setDeviation", Rect(300, 300, 300, 150));
a = RangeSlider(w, Rect(10, 10, 200, 30))
    .lo_(0)
    .hi_(1);
b = Slider(w, Rect(10, 50, 200, 30))
    .action_(
        {   arg me;
            a.setDeviation(c.value, b.value);
        });
c = Slider(w, Rect(10, 100, 200, 30))
    .action_(
        {   arg me;
            a.setDeviation(c.value, b.value);
        }
    );
c.valueAction = 0.2;
w.front;
)
::

subsection:: Sound example

Shape a bandpass filter.

In Cocoa GUI, hold down the Ctrl key to move the whole range; in other GUI kits you can simply click within the range and drag it.

code::
(
s.waitForBoot({
    a={arg freq=1800, bw=0.2;
            var r;
            BBandPass.ar(WhiteNoise.ar(0.3), freq, bw);

            }.play;

    w = Window("2DSlider", Rect(100,Window.screenBounds.height-400, 400 ,50));
    t = RangeSlider(w, Rect(10, 10, 380, 30))
            .lo_(0.4)
            .hi_(0.6)
            .action_({|sl|
                a.set(\freq,1800*(sl.lo+sl.lo)+10,\bw, (sl.hi-sl.lo).abs+0.01);
            });
    t.doAction;

    w.front;
    CmdPeriod.doOnce({w.close});
})
)
::
** CLASS::RawArray
categories::Collections>Ordered
summary:: Abstract superclass for arrays holding raw data values

DESCRIPTION::
RawArray is the abstract superclass of a group of array classes that hold raw data values.

INSTANCEMETHODS::

private::archiveAsCompileString, archiveAsObject

method::write
Writes the array as a file.
** class::RawPointer
categories::Core>Kernel
summary:: Hold raw pointers from the host environment

description::

A class used to hold raw pointers from the host environment.
No instance variables, no methods.

** class:: RecNodeProxy
summary:: a NodeProxy that can record
categories:: Libraries>JITLib>NodeProxy
related:: Classes/NodeProxy

description::
this is also created from a link::Classes/NodeProxy::, or an link::Classes/Ndef:: with the message strong::record::.

ClassMethods::

method::new
see superclass

method::audio
see superclass

method::newFrom
instantiate a new proxy that listens to the in proxy.

InstanceMethods::

method::open
open new file and initialize buffer on server

method::record
start the recording synth.

argument::paused
if paused is false start recording immediately.

method::close
stop recording, close file

method::isRecording
see if recording right now

method::wakeUp
until the proxy is not used by any output ( either .play or .ar/.kr ) it is not running on the server. you can wake it up to force it playing.

Examples::

code::
s.boot;

a = RecNodeProxy.audio(s, 2);
a.source = { SinOsc.ar([400,500], 0, 0.1) };
a.play; //monitor;
a.open("xproxySpace.aif");
a.record(false);

a.source = { SinOsc.ar([400,700], 0, 0.1) };
a.source = { SinOsc.ar([410,510], 0, 0.1) };
a.source = { SinOsc.ar([LFNoise1.kr(80, 100, 300),500], 0, 0.1) };

//stop recording and close file
a.close;

//monitor off
a.stop;
::

subsection::recording from some bus

code::
a = Bus.audio(s, 2);

SynthDef("test", { arg out; Out.ar(out, { WhiteNoise.ar(0.1) }.dup(2)) }).send(s);
x = Synth("test", [\out, a]);


n = RecNodeProxy.audio(s, 2);
n.source = { InFeedback.ar(a, 2) };

n.play;//monitor
n.stop;//turn off monitor

n.open("noise.aif");
n.record;
n.unpause;

n.close;
::

subsection::instance creation from an existent node proxy

code::
b = NodeProxy.audio(s, 2);
b.play; //listen to b
b.source = { SinOsc.ar([400,500], 0, 0.1) }; //play something

r = RecNodeProxy.newFrom(b);
r.open("recproxy514.aif"); //open file
r.record; //start recorder (paused)

r.unpause; //start recording

b.source = { SinOsc.ar([430,500], 0, 0.1) };
b.source = { SinOsc.ar([410,510], 0, 0.1) };
b.source = { SinOsc.ar([LFNoise1.kr(80, 100, 300), 500], 0, 0.1) };
r.pause;
b.source = { WhiteNoise.ar(0.01) };
r.unpause;
r.pause;


//stop recording and close file
r.close;
b.stop; //stop listen to b
::

subsection::instance creation from an existent node proxy again

code::
b = NodeProxy.audio(s, 2);
b.play; //listen to b
b.source = { SinOsc.ar([400,500], 0, 0.1) }; //play something

r = b.record("recproxy101.aiff"); //start recorder (paused)
r.unpause; //start recording
r.close; //end recording, close file
b.stop;	//stop listen
::

subsection::recording from other sources

code::
s.boot;

a = RecNodeProxy.audio(s, 2);
b = a.index; //get the bus index;
a.play;		//monitor;
a.open("xproxySpace.aif");
a.record;
a.unpause;

(
Routine({
	var id;
	loop({
		id = s.nextNodeID;
		s.sendMsg("/s_new", "default", id,0,0, \out, b, \freq, rrand(400, 800));
		0.2.wait;
		s.sendMsg("/n_set", id, \gate, 0);
		0.2.wait;
	})
}).play;
)


//stop recording and close file
a.close;

//monitor off
a.stop;
::
** class:: RecordBuf
summary:: Record or overdub into a Buffer.
related:: Classes/PlayBuf
categories::  UGens>Buffer

Description::
Records input into a link::Classes/Buffer::.

If recLevel is 1.0 and preLevel is 0.0 then the new input overwrites the
old data. If they are both 1.0 then the new data is added to the existing
data. (Any other settings are also valid.)

note:: The number of channels must be fixed for the SynthDef, it cannot vary depending on which buffer you use. ::

classmethods::

method::ar, kr

argument::inputArray
An Array of input channels.

argument::bufnum
The index of the buffer to use.

argument::offset
An offset into the buffer in samples.

argument::recLevel
Value to multiply by input before mixing with existing data.

argument::preLevel
Value to multiply to existing data in buffer before mixing with input.

argument::run
If zero, then recording stops, otherwise recording proceeds.

argument::loop
If zero then don't loop, otherwise do. This is modulatable.

argument::trigger
a trigger causes a jump to the start of the Buffer. A trigger
occurs when a signal changes from negative value to positive
value.

argument:: doneAction
an integer representing an action to be executed when the buffer is finished recording. This can be used to free the enclosing synth, etc. See link::Reference/UGen-doneActions:: for more detail. code::doneAction:: is only evaluated if loop is 0.

Examples::

code::
// Execute the following in order
(
// allocate a Buffer
s = Server.local;
b = Buffer.alloc(s, 44100 * 4.0, 1); // a four second 1 channel Buffer
)

// record for four seconds
(
SynthDef(\help_RecordBuf, { arg out = 0, bufnum = 0;
	var formant;
	formant = Formant.ar(XLine.kr(400,1000, 4), 2000, 800, 0.125);
	RecordBuf.ar(formant, bufnum, doneAction: 2, loop: 0);
}).play(s,[\out, 0, \bufnum, b]);
)

// play it back
(
SynthDef(\help_RecordBuf_overdub, { arg out = 0, bufnum = 0;
	var playbuf;
	playbuf = PlayBuf.ar(1,bufnum);
	FreeSelfWhenDone.kr(playbuf); // frees the synth when the PlayBuf is finished
	Out.ar(out, playbuf);
}).play(s, [\out, 0, \bufnum, b]);
)

// overdub
(
SynthDef(\help_RecordBuf_overdub, { arg out=0, bufnum=0;
	var formant;
	formant = Formant.ar(XLine.kr(200, 1000, 4), 2000, 800, 0.125);
	// mixes equally with existing data
	RecordBuf.ar(formant, bufnum, 0, 0.5, 0.5, doneAction: 2, loop: 0);
}).play(s, [\out, 0, \bufnum, b]);
)

// play back the overdubbed version
Synth.new(\help_RecordBuf_overdub, [\out, 0, \bufnum, b], s);

// write the contents of the buffer to a file (see Buffer for more options)
(
b.write(sampleFormat: 'int16');
thisProcess.platform.recordingsDir +/+ "SC_" ++ Date.localtime.stamp ++ ".aiff"; // generated path
)

b.close; b.free; // cleanup
::

** class:: Rect
summary:: Rectangle
categories:: Geometry

ClassMethods::

method::new
Return a new Rect with the given upper left corner and dimensions.

method::newSides
Return a new Rect with the given boundaries.

method::fromPoints
Return a new Rect defined by the given Points.

InstanceMethods::

method::left
Get or set the value of the boundary.

method::top
Get or set the value of the boundary.

method::right
Get the value of the boundary.

method::bottom
Get the value of the boundary.

method::set
Set the boundaries to the given values.

method::setExtent
Set the dimensions.

method::width
Set or get the width.

method::height
Set or get the height.

method::origin
Return the upper left corner as a Point.

method::extent
Return a Point whose x value is the height and whose y value is the width.

method::leftTop
Return the upper left corner as a Point.

method::rightTop
Return the upper right corner as a Point.

method::leftBottom
Return the lower left corner as a Point.

method::rightBottom
Return the lower right corner as a Point.

method::moveBy
Returns a new Rect which is offset by x and y.

method::moveTo
Returns a new Rect whose upper left corner is moved to (x, y).

method::moveToPoint
Returns a new Rect whose upper left corner is moved to aPoint.

method::resizeBy
Returns a new Rect whose dimensions have been changed by (x, y).

method::resizeTo
Returns a new Rect whose dimensions are (x, y).

method::insetBy
Returns a new Rect whose boundaries have been inset by (x, y). If only one argument is supplied, it will be used for both x and y.

method::insetAll
Returns a new Rect whose boundaries have been inset by the given amounts.

method::contains
Answers whether aPoint is in the receiver.

method::union, |
Returns a new Rect which contains the receiver and aRect.

method::sect, &
Returns a new Rect which is the intersection of the receiver and aRect.

** class:: Ref
summary:: a reference to a value
categories:: Core

description::

A Ref holds an object which may be retrieved and altered with the messages value and value_(obj).
The backquote code:: ` :: is a unary operator that is equivalent to calling code::Ref.new(obj)::.

Refs are most commonly used to prevent multi-channel expansion in link::Classes/SynthDef::s and link::Classes/Pattern::s (see link::Classes/Klank:: for an example).
Refs can also be used to simplify the coding of co-routines used in EventStreams (see link::Classes/Proutine:: for an example).

code::

x = Ref(nil);
z = obj.method(x);		// method puts something in reference
x.value.doSomething;	// retrieve value and use it

::

Ref is also used as a quoting device to protect against multi channel expansion in certain UGens that require Arrays.

classmethods::

method::new

create a Ref of an object.
discussion::
Another syntax:

code::
`5
::

instancemethods::

method::dereference

Answer the value. This message is also defined in class Object where it just returns the receiver.  Therefore anything.dereference will remove a Ref if there is one. This is slightly different than the value message, because value will also cause functions to evaluate themselves whereas dereference will not.

method::asRef

Answers the receiver. In class Object this message is defined to create a Ref of the object.

method::value

Get or set the value.

method::get

Returns value.

method::set

Sets value.

method::at

Returns code::value.at(index)::

method::put
Executes value.put(index, value)

method::seq

this method is used to return values from within a Routine definition

discussion::
code::
{ this.value = output.embedInStream(this.value); }
::

method::asUGenInput

Returns the Ref - this prevents multi-channel expansion in a SynthDef

method::asControlInput

Returns the value - this is used when sending a Ref as a control value to a server Node.

section::Typical uses of Ref:

subsection::preventing multi-channel expansion

Consult link::Guides/Multichannel-Expansion:: for details on multi-channel expansion in SynthDefs.

Refs prevent multi-channel expansion in a SynthDef, so the array below defines one Klank UGen rather than three.

code::
{ Klank.ar(`[[800, 1071, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play;
::

Refs cannot be used reliably to suppress multi-channel expansion within Events and Patterns.
Instead, it is necessary to enclose the array of values in another array:

code::
(
	SynthDef(\multi, { | out, freq = #[100,200,300], amp = 0.1, pan = 0, sustain = 1|
		var audio, env;
		env = EnvGen.kr(Env.perc(0.01, sustain), doneAction:2);
		audio = Mix(Saw.ar(freq));
		audio = Pan2.ar(audio * env, pan, amp);
		OffsetOut.ar(out, audio)
	}).add;

	( instrument: \multi, freq: [ [500, 501, 700] ], sustain: 2).play

)
::

code::
(
	Pbind(*[
		instrument: \multi,
		freq: 	Prand([
						[[100, 141, 103] ],
						[[100, 310, 190] ],
						[[100, 100.1, 110] ],
				], inf),
		dur: 0.2,
		sustain: 0.3
	]).play;
)
::


method::multichannelExpandRef
This method is called internally on inputs to UGens that take multidimensional arrays, like link::Classes/Klank:: and it allows proper multichannel expansion even in those cases. For SequenceableCollection, this returns the collection itself, assuming that it contains already a number of Refs.

argument::rank
The depth at which the list is expanded. For instance the Klank spec has a rank of 2.
code::
`([[[100, 200], 500], nil, [[[0.01, 0.3], 0.8]]]).multichannelExpandRef(2);
[`[[100, 200], nil, [0.2, 0.8]], `[[130, 202], nil, [0.2, 0.5]]].multichannelExpandRef(2);
::
** class::RefCopy
summary::a reference to the copy of a value
categories::Core

description::
A Ref  instance is an object with a single slot named 'value' that serves as a holder of  an object.
RefCopy, in difference to Ref, returns only copies of the value when next is called.
This can be useful when the original is to be kept unchanged.

see link::Classes/Ref:: for other methods.

examples::

code::
a = [1, 2, 3];
x = RefCopy(a);
b = x.next;
b.put(0, 100); // modify b
a; // a is unchanged.
::class:: ReplaceOut
summary:: Send signal to a bus, overwriting previous contents.
related:: Classes/OffsetOut, Classes/Out, Classes/XOut
categories::  UGens>InOut


Description::
link::Classes/Out::  adds it's output to a given bus, making it
available to all nodes later in the node tree (See Synth and
Order-of-execution for more information). ReplaceOut overwrites those
contents. This can make it useful for processing.


See the link::Reference/Server-Architecture:: and link::Classes/Bus:: helpfiles for more information on
buses and how they are used.


classmethods::

method::ar, kr

argument::bus

The index of the bus to write out to. The lowest numbers are
written to the audio hardware.


argument::channelsArray

An Array of channels or single output to write out. You cannot
change the size of this once a SynthDef has been built.


Examples::

code::

(
SynthDef("ReplaceOutHelp", { arg out=0, freq=440;
	var source;
		source = SinOsc.ar(freq, 0, 0.1);

		// write to the bus, replacing previous contents
		ReplaceOut.ar(out, source);

}).send(s);
)

// each Synth replaces the output of the previous one
x = Synth.tail(s, "ReplaceOutHelp", [\freq, 500]);
y = Synth.tail(s, "ReplaceOutHelp", [\freq, 600]);
z = Synth.tail(s, "ReplaceOutHelp", [\freq, 700]);

// release them in reverse order; the older Synths are still there.
z.free;
y.free;
x.free;

::

** class:: Resonz
summary:: Resonant filter.
related:: Classes/Formlet, Classes/RHPF, Classes/RLPF, Classes/Ringz
categories::  UGens>Filters>Linear


Description::

A two pole resonant filter with zeroes at

code::
z = ±1
::


Based on  emphasis::K. Steiglitz,  "A Note on Constant-Gain Digital Resonators", Computer Music Journal, vol 18, no. 4, pp. 8-10, Winter 1994::.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Resonant frequency in Hertz.


argument::bwr

Bandwidth ratio (reciprocal of Q). rq = bandwidth / centerFreq.


The reciprocal of Q is used rather than Q because it saves a
divide operation inside the unit generator.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::

{ Resonz.ar(WhiteNoise.ar(0.5), 2000, 0.1) }.play

// modulate frequency
{ Resonz.ar(WhiteNoise.ar(0.5), XLine.kr(1000,8000,10), 0.05) }.play

// modulate bandwidth
{ Resonz.ar(WhiteNoise.ar(0.5), 2000, XLine.kr(1, 0.001, 8)) }.play

// modulate bandwidth opposite direction
{ Resonz.ar(WhiteNoise.ar(0.5), 2000, XLine.kr(0.001, 1, 8)) }.play

::

** CLASS:: Rest
summary:: Represents a rest in event patterns
categories:: Streams-Patterns-Events
related:: Classes/Pbind, Classes/Event

DESCRIPTION::
Rest may be used in event patterns to indicate that the resulting event should be a rest (i.e., silent). It should be used in one of the child patterns belonging to a Pbind, for instance.

subsection:: Expressing rests in event patterns

In addition to the Rest class, rests can be specified in two other ways (legacy usages).

list::
## A link::Classes/Symbol:: may be specified in any frequency stream (under the keys degree, note, midinote or freq). The exception to this rule is control bus mapping symbols, beginning with 'c' followed by a number. Typical symbols that have been used include strong::\rest::, strong::\r:: and the empty symbol strong:: \ ::.

code::
p = Pbind(
	\degree, Pseq([
		0, 1, 2, 0, 0, 1, 2, 0,
		2, 3, 4, \rest, 2, 3, 4, \rest
	]),
	\dur, 0.25
).play;
::

## The event's strong::\type:: may be set to strong::\rest::.

code::
p = Pbind(
	\degree, Pseries(0, 1, inf).fold(-7, 7),
	\dur, 0.125,
	\type, Pwrand([\note, \rest], [0.9, 0.1], inf)
).play;

p.stop;
::
::

The Rest class allows rests to be indicated in any stream, not only frequency or event type. Also, using the duration argument (see the *new method below), rests may be embedded into a duration stream. That is, rests may be treated as part of the rhythmic specification, rather than the pitch specification.

subsection:: Usage

list::
## The class Rest may be embedded directly in a child pattern. This sets the isRest flag and puts the number 1 into the event.
## Or, a Rest instance may be embedded. Rest.new's argument specifies the value that will be placed into the event. This allows rests to be given in a duration stream -- the argument is the rest's rhythmic value.
::

section:: How it works

When a Pbind child pattern returns a Rest, the Rest object sets a flag 'isRest' in the resulting event to be true. The child pattern's value in the event is a number. This is to prevent math errors if Rest is used in a pitch or duration stream (degree, note, midiNote, freq, dur, delta, stretch).

When a Rest is returned from a child stream, the rest object itself will not appear in the event. You can tell that the event is a rest by the presence of code::'isRest': true::.

code::
p = Pbind(\degree, Pseq([4, Rest], 1)).asStream;

p.next(());
// prints: ( 'degree': 4 )

p.next(());
// prints: ( 'isRest': true, 'degree': 1 )
::

That is, the importance of the Rest object is not that it appears in the event. The importance is the side effect that this object has on the resulting event.

CLASSMETHODS::
All methods of Rest except *new are private, and should not be used directly.

private:: processRest
private:: embedInStream
private:: asStream

METHOD:: new
Create an instance of Rest, with a value to be used in the resulting rest event.

argument:: dur
Typically, Rest instances will be used in duration streams, so the argument should be the rest's rhythmic value, or duration. Rest instances may also be used in any other stream, but the value will be ignored (since the event will do nothing except take time).


INSTANCEMETHODS::
private:: dur
private:: processRest
private:: embedInStream
private:: asStream

EXAMPLES::

Using the Rest class in a pitch stream

code::
p = Pbind(
	\degree, Pif(
		0.1.loop.coin,
		Rest,
		Pseries(0, 1, inf).fold(-7, 7)
	),
	\dur, 0.125
).play;

p.stop;
::

Using a Rest instance in a duration stream
code::
p = Pbind(
	\degree, Pseries(0, 1, inf).fold(-7, 7),
	\dur, Pseq([Pn(0.125, { rrand(3, 6) }), Rest(0.25)], inf)
).play;

p.stop;
::
** class:: Ringz
summary:: Ringing filter.
related:: Classes/Formlet, Classes/RHPF, Classes/RLPF, Classes/Resonz
categories::  UGens>Filters>Linear


Description::

This is the same as  link::Classes/Resonz:: , except that instead of a
resonance parameter, the bandwidth is specified in a 60dB ring decay
time. One Ringz is equivalent to one component of the
link::Classes/Klank::  UGen.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Resonant frequency in Hertz.


argument::decaytime

The 60 dB decay time of the filter.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang
  { Ringz.ar(Dust.ar(3, 0.3), 2000, 2) }.play

  { Ringz.ar(WhiteNoise.ar(0.005), 2000, 0.5) }.play

  // modulate frequency
  { Ringz.ar(WhiteNoise.ar(0.005), XLine.kr(100,3000,10), 0.5) }.play

  { Ringz.ar(Impulse.ar(6, 0, 0.3), XLine.kr(100,3000,10), 0.5) }.play

  // modulate ring time
  { Ringz.ar(Impulse.ar(6, 0, 0.3), 2000, XLine.kr(4, 0.04, 8)) }.play

  // modulate ring time opposite direction
  { Ringz.ar(Impulse.ar(6, 0, 0.3), 2000, XLine.kr(0.04, 4, 8)) }.play

  (
  {
      var exciter;
      exciter = WhiteNoise.ar(0.001);
      Mix.arFill(10, {
	  Ringz.ar(exciter,
	  XLine.kr(exprand(100.0,5000.0), exprand(100.0,5000.0), 20),
	  0.5)
      })
  }.play
  )
#+END_SRC

#+RESULTS:
#+begin_example
{ Ringz.ar(Dust.ar(3, 0.3), 2000, 2) }.play

{ Ringz.ar(WhiteNoise.ar(0.005), 2000, 0.5) }.play

// modulate frequency
{ Ringz.ar(WhiteNoise.ar(0.005), XLine.kr(100,3000,10), 0.5) }.play

{ Ringz.ar(Impulse.ar(6, 0, 0.3), XLine.kr(100,3000,10), 0.5) }.play

// modulate ring time
{ Ringz.ar(Impulse.ar(6, 0, 0.3), 2000, XLine.kr(4, 0.04, 8)) }.play

// modulate ring time opposite direction
{ Ringz.ar(Impulse.ar(6, 0, 0.3), 2000, XLine.kr(0.04, 4, 8)) }.play

(
{
    var exciter;
    exciter = WhiteNoise.ar(0.001);
    Mix.arFill(10, {
	Ringz.ar(exciter,
	XLine.kr(exprand(100.0,5000.0), exprand(100.0,5000.0), 20),
	0.5)
    })
}.play
)
#+end_example

::

** class:: RootNode
summary:: The persistent root group on the server
categories:: Server>Nodes
related:: Classes/Group, Reference/default_group

description::
A RootNode is the Group with the nodeID of 0 which is always present on each Server and represents the root of that server's node tree.

It is always playing, and always running, cannot be freed, or moved anywhere.

Cacheing is used so that there is always one RootNode per link::Classes/Server::.
code::
#+BEGIN_SRC sclang
s = Server.local;

a = RootNode(s);
b = RootNode(s);

a === b; // identical object
#+END_SRC

::
sending code::"/s_new":: messages to the server, the target 0 is what is represented by this object.
code::
#+BEGIN_SRC sclang
s.sendMsg("/s_new", "default", -1, 0, 0);//the last argument is the target id
#+END_SRC

::
IMPORTANT: In general one should strong::not:: add nodes to the RootNode unless one has a specific reason to do so. Instead one should add nodes to the default_group.
This provides a known basic node order and protects functionality like Server.record, Server.scope, etc. The default group is the default target for all new nodes, so when using object style nodes will normally not be added to the RootNode unless that is explicitly specified. See link::Reference/default_group:: for more information.

classmethods::
private:: initClass
instancemethods::
private:: rninit, free, moveBefore, moveAfter, moveToHead, moveToTail, run

** class:: Rotate2
summary:: Rotate a sound field.
related:: Classes/BiPanB2, Classes/DecodeB2, Classes/PanB, Classes/PanB2
categories::  UGens>Multichannel>Ambisonics, UGens>Multichannel>Panners


Description::

Rotate2 can be used for rotating an ambisonic B-format sound field around
an axis. Rotate2 does an equal power rotation so it also works well on
stereo sounds. It takes two audio inputs (x, y) and an angle control
(pos). It outputs two channels (x, y). It computes this:

code::
#+BEGIN_SRC sclang
xout = cos(angle) * xin + sin(angle) * yin;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
yout = cos(angle) * yin - sin(angle) * xin;
#+END_SRC

::

where angle = pos * pi,  so that -1 becomes -pi and +1 becomes +pi. This
allows you to use an LFSaw to do continuous rotation around a circle.


classmethods::

method::ar, kr

argument::x

Input signal X.


argument::y

Input signal Y.


argument::pos

angle to rotate around the circle from -1 to +1. -1 is 180
degrees, -0.5 is left, 0 is forward, +0.5 is right, +1 is behind.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	var w, x, y, p, q, a, b, c, d;

	p = WhiteNoise.ar(0.05); // source
	q = LFSaw.ar(200,0,0.03)+LFSaw.ar(200.37,0,0.03)+LFSaw.ar(201,0,0.03);

	// B-format encode 2 signals at opposite sides of the circle
	#w, x, y = PanB2.ar(p, -0.5) + PanB2.ar(q, 0.5);

	#x, y = Rotate2.ar(x, y, MouseX.kr(-1,1));

	// B-format decode to quad
	#a, b, c, d = DecodeB2.ar(4, w, x, y);

	[a, b, d, c] // reorder to my speaker arrangement: Lf Rf Lr Rr
}.play;
)



// Rotation of stereo sound:
(
{
	// rotation via lfo
	var x, y;
	x = PinkNoise.ar(0.4);
	y = LFTri.ar(800) * LFPulse.kr(3,0,0.3,0.2);
	#x, y = Rotate2.ar(x, y, LFSaw.kr(0.1));
	[x,y]
}.play;
)

{
	// rotation via mouse
	var x, y;
	x = Mix.fill(4, { LFSaw.ar(200 + 2.0.rand2, 0, 0.1) });
	y = SinOsc.ar(900) * LFPulse.kr(3,0,0.3,0.2);
	#x, y = Rotate2.ar(x, y, MouseX.kr(0,2));
	[x,y]
}.play;


// Rotate B-format about Z axis:

wout = win;
zout = zin;
#xout, yout = Rotate2.ar(xin, yin, pos);

// Rotate B-format about Y axis:

wout = win;
yout = yin;
#xout, zout = Rotate2.ar(xin, zin, pos);

// Rotate B-format about X axis:

wout = win;
xout = xin;
#yout, zout = Rotate2.ar(yin, zin, pos);
#+END_SRC

::

** class::Routine
categories::Core>Kernel
summary:: Functions that can return in the middle and then resume where they left off
related:: Classes/Stream

description::
A Routine runs a link::Classes/Function:: and allows it to be suspended in the middle
and be resumed again where it left off. This functionality is supported by the Routine's
superclass link::Classes/Thread::. Effectively, Routines can be used to implement
co-routines as found in Scheme and some other languages.

A Routine is strong::started:: the first time link::#-next:: is called, which will run
the Function from the beginning. It is strong::suspended:: when it "yields"
(using link::Classes/Object#-yield:: within the Function), and then strong::resumed::
 using link::#-next:: again. When the Function returns, the Routine is considered
strong::stopped::, and calling link::#-next:: will have no effect - unless the Routine is
strong::reset:: using link::#-reset::, which will rewind the Function to the beginning.
You can stop a Routine before its Function returns using link::#-stop::.

When a Routine is strong::scheduled:: on a link::Classes/Clock:: (e.g. using
link::#-play::), it will be started or resumed at the scheduled time. The value yielded
by the Routine will be used as the time difference for rescheduling the Routine. (See
link::#-awake::).

Since Routine inherits from link::Classes/Thread::, it has its own associated
link::Classes/Thread#-beats#logical time::, etc. When a Routine is started or
resumed, it becomes the link::Classes/Thread#.thisThread#current thread::.

Routine also inherits from link::Classes/Stream::, and thus shares its ability to be
combined using math operations and "filtered".


classMethods::

method::new

Creates an instance of Routine, passing it the Function with code to run.

argument::func
A Function with code for the Thread to run.

argument::stackSize
Call stack size (an Integer).

discussion::
code::
#+BEGIN_SRC sclang
a = Routine.new({ 1.yield; 2.yield; });
a.next.postln;
a.next.postln;
a.next.postln;
#+END_SRC

::

instanceMethods::

method::next

This method performs differently according to the Routine's state:
list::
## Starts the Routine, if it has not been started yet or it has been
link::#-reset#reset::; i.e runs its Function from the beginning, passing on the
code::inval:: argument.
## Resumes the Routine, if it has been suspended (it has yielded); i.e. resumes its
Function from the point where link::Classes/Object#-yield#yield:: was called on an Object,
passing the code::inval:: argument as the return value of code::yield::.
## Does nothing if the Routine has stopped (because its Function has returned, or
link::#-stop:: has been called).
::

Since Routine inherits from link::Classes/Thread::, it will become the
emphasis::current thread:: when it is started or resumed; i.e.
link::Classes/Thread#.thisThread#thisThread:: used in the Routine Function will return
the Routine. It will inherit the parent thread's logical time and clock
(see link::Classes/Thread#-parent::).

Synonyms for code::next:: are link::#-value:: and link::#-resume::.

returns::
list::
## Either the value that the Routine yields (the Object on which
link::Classes/Object#-yield#yield:: is called within the Routine Function),
## ...or code::nil::, if the Routine has stopped.
::

discussion::

When a Routine is started by a call to this method (or one of its synonyms), the method's
argument is passed on as the argument to the Routine Function:

code::
#+BEGIN_SRC sclang
Routine { arg inval;
	inval.postln;
}.value("hello routine");
#+END_SRC

::

After the Routine has yielded (it has been suspended at the point in its Function where
code::yield:: is called on an Object), a call to this method (or its synonyms) resumes
executing the Function and the argument to this method becomes the return value of
code::yield::. To access that value within the Function, you have to assign it to a
variable - typically, the argument of the Function is reused:

code::
#+BEGIN_SRC sclang
(
r = Routine { arg inval;
	inval.postln;
	inval = 123.yield;
	inval.postln;
}
)

r.value("hello routine");
r.value("goodbye routine");
#+END_SRC

::

Typically, a Routine yields multiple times, and each time the result of the yield is
reassigning to the argument of its Function.

code::
#+BEGIN_SRC sclang
(
r = Routine { arg inval;
	inval.postln; // Post the value passed in when started.
	5.do { arg i;
		inval = (i + 10).yield;
		inval.postln; // Post the value passed in when resumed.
	}
}
)
(
5.do {
	r.value("hello routine").postln; // Post the value that the Routine yields.
}
)
#+END_SRC

::

method::value

Equivalent to link::#-next::.

method::resume

Equivalent to link::#-next::.

method::stop

Equivalent to the Routine Function reaching its end or returning: after this, the Routine
will never run again (the link::#-next:: method has no effect and returns code::nil::),
unless link::#-reset:: is called.

method::reset

Causes the Routine to start from the beginning next time link::#-next:: is called.

discussion::

If a Routine is stopped (its Function has returned or link::#-stop:: has been called), it
will never run again (the link::#-next:: method has no effect and returns code::nil::),
unless this method is called.

A Routine cannot reset itself, except by calling link::Classes/Object#-yieldAndReset::.

See also: link::Classes/Object#-yield::, link::Classes/Object#-alwaysYield::


method::play

In the SuperCollider application, a Routine can be played using a link::Classes/Clock::, as can any link::Classes/Stream::.
every time the Routine yields, it should do so with a float, the clock will interpret that, usually
pausing for that many seconds, and then resume the routine, passing it the clock's current time.

argument::clock
a Clock, TempoClock by default

argument::quant
see the link::Classes/Quant:: helpfile

discussion::
using link::Classes/Object#idle#Object:idle:: within a routine, return values until this time is over. Time is measured relative to the thread's clock.
code::
#+BEGIN_SRC sclang
// for 6 seconds, return 200, then continue
(
r = Routine {
		199.yield;
		189.yield;
		200.idle(6);
		199.yield;
		189.yield;
};

fork {
	loop {
		r.value.postln;
		1.wait;
	}
}
);

// the value can also be a stream or a function
(
r = Routine {
		199.yield;
		189.yield;
		Routine { 100.do { |i| i.yield } }.idle(6);
		199.yield;
		189.yield;
};

fork {
	loop {
		r.value.postln;
		1.wait;
	}
}
);
#+END_SRC

::

method:: awake

This method is called by a link::Classes/Clock:: on which the Routine was scheduled
when its scheduling time is up. It calls link::#-next::, passing on the scheduling
time in beats as an argument. The value returned by code::next:: (the value yielded
by the Routine) will in turn be returned by this method, thus determining the time
which the Routine will be rescheduled for.

argument:: inBeats
The scheduling time in beats. This is equal to the current logical time
(link::Classes/Thread#-beats::).

argument:: inSeconds
The scheduling time in seconds. This is equal to the current logical time
(link::Classes/Thread#-seconds::).

argument:: inClock
The clock which awoke the Routine.



subsection::Accessible instance variables

Routine inherits from link::Classes/Thread::, which allows access to some of its state:

code::
#+BEGIN_SRC sclang
(
r = Routine { arg inval;
	loop {
		// thisThread refers to the routine.
		postf("beats: % seconds: % time: % \n",
			thisThread.beats, thisThread.seconds, Main.elapsedTime
		);
		1.0.yield;

	}
}.play;
)

r.stop;
r.beats;
r.seconds;
r.clock;
#+END_SRC

::

method::beats

returns:: The elapsed beats (logical time) of the routine. The beats do not proceed when the routine is not playing.

method::seconds

returns:: The elapsed seconds (logical time) of the routine. The seconds do not proceed when the routine is not playing, it is the converted beat value.

method::clock

returns:: The thread's clock. If it has not played, it is the SystemClock.

examples::

code::
#+BEGIN_SRC sclang
(
var r, outval;
r = Routine.new({ arg inval;
	("->inval was " ++ inval).postln;
	inval = 1.yield;
	("->inval was " ++ inval).postln;
	inval = 2.yield;
	("->inval was " ++ inval).postln;
	inval = 99.yield;
});

outval = r.next('a');
("<-outval was " ++ outval).postln;
outval = r.next('b');
("<-outval was " ++ outval).postln;
r.reset; "reset".postln;
outval = r.next('c');
("<-outval was " ++ outval).postln;
outval = r.next('d');
("<-outval was " ++ outval).postln;
outval = r.next('e');
("<-outval was " ++ outval).postln;
outval = r.next('f');
("<-outval was " ++ outval).postln;
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// wait

(
var r;
r = Routine {
	10.do({ arg a;
		a.postln;
		// Often you might see Wait being used to pause a routine
		// This waits for one second between each number
		1.wait;
	});
	// Wait half second before saying we're done
	0.5.wait;
	"done".postln;
}.play;
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// waitUntil

(
var r;
r = Routine {
	var times = { rrand(1.0, 10.0) }.dup(10) + thisThread.beats;
	times = times.sort;
	times.do({ arg a;
		waitUntil(a);
		a.postln;
	});
	// Wait half second before saying we're done
	0.5.wait;
	"done".postln;
}.play;
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// Using Routine to set button states on the fly.
(
var update, w, b;
w = SCWindow.new("State Window", Rect(150,SCWindow.screenBounds.height-140,380,60));

// a convenient way to set the button label
update = {
	|but, string| but.states = [[string.asString, Color.black, Color.red]];
	but.refresh;
};

b = SCButton(w, Rect(10,10,360,40));
b.font_(Font("Impact", 24));

update.value(b, "there is only one state");

// if an action should do something different each time it is called, a routine is the
// right thing to use. This is better than creating variables outside and setting them
// from the action function to keep state from one action to the next

b.action_(Routine { |butt|
	rrand(15, 45).do { |i|
		update.value(butt, "%. there is still only 1 state".format(i + 2));
		0.yield; // stop here
	};
	w.close;
});

w.front;
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// drawing in a window dynamcially with Pen
(
var w, much = 0.02, string, synth;

w = Window.new("swing", Rect(100, 100, 300, 500)).front;
w.view.background_(Color.new255(153, 255, 102).vary);

string = "swing ".dup(24).join;

w.drawFunc = Routine {
	var i = 0;
	var size = 40;
	var func = { |i, j| sin(i * 0.07 + (j * 0.0023) + 1.5pi) * much + 1 };
	var scale;
	Pen.font = Font("Helvetica-Bold", 40);
	loop {
		i = i + 1;
		string.do {	|char, j|

			scale = func.value(i, j).dup(6);

			Pen.fillColor = Color.new255(0, 120, 120).vary;
			Pen.matrix = scale * #[1, 0, 0, 1, 1, 0];
			Pen.stringAtPoint(char.asString,
				((size * (j % 9)) - 10) @ (size * (j div: 9))
			);
		};
		0.yield // stop here, return something unimportant
	}
};

fork { while { w.isClosed.not } { defer { w.refresh }; 0.04.wait; } };

w.front;

)
#+END_SRC

::

** class:: RunningMax
summary:: Track maximum level.
related:: Classes/RunningMin, Classes/RunningSum
categories::  UGens>Maths


Description::

Outputs the maximum value received at the input. When a trigger occurs at
the reset input, the maximum output value is reset to the current value.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::trig

Resets the output value to the current input value. A trigger happens when the signal changes from non-positive to positive.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	SinOsc.ar(
			RunningMax.ar(Dust.ar(20), Impulse.ar(0.4)) * 500 + 200,
			0, 0.2
	)

}.play;
)

// follow a sine lfo, reset rate controlled by mouse x
(
{
	SinOsc.ar(
			RunningMax.kr(SinOsc.kr(0.2), Impulse.kr(MouseX.kr(0.01, 2, 1))) * 500 + 200,
			0, 0.2
	)

}.play;
)
#+END_SRC

::

** class:: RunningMin
summary:: Track minimum level.
related:: Classes/RunningMax, Classes/RunningSum
categories::  UGens>Maths


Description::

Outputs the minimum value received at the input. When a trigger occurs at
the reset input, the minimum output value is reset to the current value.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::trig

Resets the output value to the current input value. A trigger happens when the signal changes from non-positive to positive.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	SinOsc.ar(
			RunningMin.ar(Dust.ar(20), Impulse.ar(0.4)) * 500 + 200,
			0, 0.2
	)

}.play;
)

// follow a sine lfo, reset rate controlled by mouse x
(
{
	SinOsc.ar(
			RunningMin.kr(SinOsc.kr(0.2), Impulse.kr(MouseX.kr(0.01, 2, 1))) * 500 + 200,
			0, 0.2
	)

}.play;
)
#+END_SRC

::

** class:: RunningSum
summary:: Running sum over n frames
categories:: UGens>Analysis, UGens>Maths

description::
A running sum over a user specified number of samples, useful for running RMS power windowing.

classmethods::
method:: ar, kr
argument::in
Input signal
argument::numsamp
How many samples to take the running sum over (initialisation time only, not modulatable. default: 40)

examples::

code::
#+BEGIN_SRC sclang
// distorts of course - would need scaling
{ RunningSum.ar(SoundIn.ar) }.play

// Running Average over x samples
(
{
    var x = 100;
    RunningSum.ar(LFSaw.ar, x) * (x.reciprocal)
 }.play
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// RMS Power
(
{
    var input, numsamp;

    input = LFSaw.ar;
    numsamp = 30;

    (RunningSum.ar(input.squared, numsamp) / numsamp).sqrt
}.play
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// shortcut in class
{ RunningSum.rms(SoundIn.ar) }.play
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// play around
(
{
    var input, numsamp, power;
    numsamp = 500;
    input = SoundIn.ar;
    power = MouseX.kr(0.1, 4);

    (RunningSum.ar(input ** power, numsamp)/numsamp) ** (power.reciprocal)
}.play
)
#+END_SRC

::
** class:: SCContainerView
summary:: An abstract superclass for container views
categories:: GUI>Kits>Cocoa
related:: Classes/CompositeView, Classes/HLayoutView, Classes/VLayoutView, Classes/ScrollView

description::
Users will not normally directly create instances of ContainerView, but only use it through its subclasses. It provides the basic mechanisms for container views of various kinds, which are used for placing and grouping widgets in a window.



subsection:: Some Important Issues Regarding ContainerView

Container views are meant for placing and grouping child views and widgets. While they accept key actions, many do not accept mouse clicks or drags. The exception is SCTopView and its subclasses.

classmethods::


instancemethods::

subsection:: Accessing Instance and Class Variables

method:: decorator
An automatic layout management for a container. Currently the only one existing is link::Classes/FlowLayout::.
note::Crucial Library also has a useful layout tool called GridLayout.::
argument:: arg1

method:: addFlowLayout
A convenience utility which sets decorator to link::Classes/FlowLayout:: and returns the decorator. See link::Classes/FlowLayout:: for examples.
argument:: margin
An instance of link::Classes/Point::.
argument:: gap
An instance of link::Classes/Point::.

method:: children
An array containing all the views (children) contained in the the container.



subsection:: Adding and Removing Subviews

method:: add
Adds a view to children. The placement of the child view will depend on the the decorator, and the child's bounds. Normally you don't need to call this directly, since subviews call it automatically when you create them.
argument:: child

method:: removeAll
Removes all children from the view.



subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method::init
argument:: argParent
argument:: argBounds

method:: prRemoveChild
Private method.
argument:: child

method:: prClose
Private method.
** class:: SCControlView
summary:: An abstract class for backward compatibility
categories:: GUI>Kits>Cocoa

warning::
For backward compatibility only. Inherits everything from link::Classes/SCView::. No new methods.
::
** class:: SCDoc
summary:: Help system main class
categories:: HelpSystem
related:: Reference/SCDocSyntax, Guides/WritingHelp, Classes/SCDocHTMLRenderer, Classes/SCDocNode, Classes/SCDocEntry

DESCRIPTION::
SCDoc manages the SuperCollider documentation system.

It uses parses help files written in link::Reference/SCDocSyntax##SCDoc markup language:: and renders them as human-readable documents.

A guide to writing help can be found here: link::Guides/WritingHelp::.

CLASSMETHODS::

subsection:: Document index

method:: indexAllDocuments
Index all documents and undocumented classes on the system, putting them in the code::SCDoc.documents:: dictionary. If run inside a Routine, this method will yield occasionally.

Run this method if you added a new document and want to see the changes without restarting SuperCollider.

argument:: clearCache
If true, force re-render of files even if the schelp source file is not newer than the destination.

discussion::
This will take a couple of seconds, and will be done automatically once before any help can be viewed. You might consider putting this in your startup.scd file to avoid getting this delay later when you decide to view a helpfile.

method:: documents
The dictionary of indexed documents. They keys are the path relative to the Help folder and without extension, like teletype::Classes/SinOsc:: or teletype::Reference/SCDocSyntax::. The values are instances of link::Classes/SCDocEntry::

method:: didIndexDocuments
A Boolean indicating if code::SCDoc.indexAllDocuments:: was called in this session yet.

method:: helpSourceDir
get/set the system-wide directory of help sourcefiles. Defaults to code::Platform.classLibraryDir.dirname +/+ "HelpSource":: and should typically not be changed by the user.

method:: helpSourceDirs
get the list of HelpSource folders, including extensions and quarks.
discussion::
This searches recursively for all folders named "HelpSource" under code::Platform.userExtensionDir:: and code::Platform.systemExtensionDir:: as well as including the system-wide code::helpSourceDir::

method:: findHelpFile
Find help for a given string. Tries to be smart.
returns:: the URL for help on given string

method:: verbosity
Verbosity level. 0 is silent.

subsection:: Parsing and Rendering

private:: checkVersion, exportDocMapJS, handleCopyMethods, postMsg, prParseFile, renderUndocClass

method:: renderer
The default renderer, defaults to link::Classes/SCDocHTMLRenderer::

method:: helpTargetDir
get/set the user help target directory. Defaults to code::Platform.userAppSupportDir +/+ "Help":: and should typically not be changed by the user.

method:: parseFileFull
Parse file.
argument::
Full path to .schelp file
returns::
An link::Classes/SCDocNode:: tree

method:: parseFileMetaData
Parse only the stuff needed for metadata.
argument::
Base HelpSource directory.
argument::
Path relative above dir.
returns::
An link::Classes/SCDocNode:: tree

method:: parseFilePartial
Parse a file without header, for merging of document additions
argument::
Full path to .ext.schelp file
returns::
An link::Classes/SCDocNode:: tree

method:: parseDoc
Parse the files associated with an link::Classes/SCDocEntry::, including any document additions (teletype::*.ext.schelp::)
argument:: doc
The link::Classes/SCDocEntry:: to parse.
returns::
An link::Classes/SCDocNode:: tree

method:: parseAndRender
Parse and render a specific document.
argument:: doc
The link::Classes/SCDocEntry:: to parse and render.

method:: renderAll
Render all help-files. Useful mainly if you want to render all help to put online or similar.
argument:: includeExtensions
If false, skip quarks, plugins and other extensions.

method:: prepareHelpForURL
Prepare help for the given URL by checking if the file needs rendering from schelp source, or some other action needs to be done.
Used as a wrapper to get on-the-fly rendering and processing of help files.
argument:: url
The url to prepare. If this is not a local file inside link::#*helpTargetDir:: then it will just pass through the url directly.
returns:: the URL or nil if file not found.

subsection:: Utilities

method:: getMethodDoc
Extract the link::Classes/SCDocNode:: tree for the specified method documentation.
argument::
Name of class
argument::
Name of method, prefixed with teletype::*:: for classmethods and teletype::-:: for instancemethods.
returns::
An link::Classes/SCDocNode:: tree

method:: makeClassTemplate
Create a schelp template for specified class.
argument:: doc
The link::Classes/SCDocEntry:: for the undocumented class.
returns::
Returns the template string.

method:: classHasArKrIr
argument:: c
The link::Classes/Class:: to check.
Returns:: code::true:: if the class responds to ar, kr or ir classmethods.

section:: Parser node tree output
The SCDoc parser outputs a tree of link::Classes/SCDocNode::s

The nodes reflects the tags in the input, but it's not a one-to-one correspondation.
A more detailed structure is added in the node tree, for easier rendering.

Example:

DOCUMENT
tree::
    ## HEADER
    tree::
        ## TITLE teletype::"SinOsc"::
        ## SUMMARY teletype::"Interpolating sine wavetable oscillator"::
        ## RELATED
        tree::
            ## STRING teletype::"Classes/FSinOsc"::
            ## STRING teletype::"Classes/SinOscFB"::
        ::
        ## CATEGORIES
        tree::
            ## STRING teletype::"UGens>Generators>Deterministic"::
            ## STRING teletype::"UGens>Oscillators"::
        ::
    ::
    ## BODY
    tree::
        ## DESCRIPTION
        tree::
            ## PROSE
            tree::
                ## TEXT teletype::"A paragraph with "::
                ## LINK teletype::"Classes/Osc##a link"::
                ## TEXT teletype::" to another document."::
            ::
            ## PROSE
            tree::
                ## TEXT teletype::"Another paragraph with "::
                ## STRONG teletype::"strong words"::
                ## TEXT teletype::" in it."::
            ::
        ::
        ## CLASSMETHODS
        tree::
            ## PROSE
            tree::
                ## TEXT teletype::"Some text..."::
            ::
            ## CMETHOD
            tree::
                ## METHODNAMES
                tree::
                    ## STRING teletype::"ar"::
                    ## STRING teletype::"kr"::
                ::
                ## METHODBODY
                tree::
                    ## PROSE
                    tree::
                        ## TEXT teletype::"Some text..."::
                    ::
                    ## ARGUMENTS
                    tree::
                        ## ARGUMENT teletype::"freq"::
                        tree::
                            ## PROSE
                            tree::
                                ## TEXT teletype::"Frequency in hertz"::
                            ::
                        ::
                        ## ARGUMENT teletype::"phase"::
                        tree::
                            ## PROSE
                            tree::
                                ## TEXT teletype::"Phase modulation"::
                            ::
                        ::
                    ::
                ::
            ::
        ::
        ## EXAMPLES
        tree::
            ## PROSE
            tree::
                ## TEXT teletype::"Here are some examples:"::
            ::
            ## CODEBLOCK
            teletype::
"{ SinOsc.ar(200, 0, 0.5) }.play;
// modulate freq
{ SinOsc.ar(XLine.kr(2000, 200), 0, 0.5) }.play;
// modulate freq
{ SinOsc.ar(SinOsc.ar(XLine.kr(1, 1000, 9), 0, 200, 800), 0, 0.25) }.play;
// modulate phase
{ SinOsc.ar(800, SinOsc.ar(XLine.kr(1, 1000, 9), 0, 2pi), 0.25) }.play;"
::
        ::
        ## SECTION teletype::"Another section"::
        tree::
            ## PROSE
            tree::
                ## TEXT teletype::"Some text..."::
            ::
        ::
    ::
::

title:: SCDocEntry
summary:: An SCDoc document index entry
related:: Classes/SCDoc
categories:: HelpSystem

description::
This class is used by link::Classes/SCDoc:: to represent a document in the help file index.

The document represented can be either a real .schelp file, or an auto-generated stub for undocumented classes.

classmethods::

method:: new
Create and initialize a new instance.
argument:: node
An link::Classes/SCDocNode:: instance. Does not have to be a fully parsed document, since only the header tags, methods and keywords are used. (See link::Classes/SCDoc#*parseFileMetaData::).

argument:: path
A link::Classes/String:: for the document key, like "Classes/SinOsc".

method:: newUndocClass
Create and initialize a new instance for an undocumented class.
argument:: name
Name of undocumented class

instancemethods::

private:: prAddCopyMethod, prAddMethodNames, printOn, prJSONList, prJSONString, prScanMethodsKeywords, setAdditions, init, indexUndocumentedMethods

subsection:: Document properties

method:: path
A link::Classes/String:: for the document key, like "Reference/SCDocSyntax".

method:: title
Document title. Should equal the classname for class reference docs.

method:: summary
Document summary.

method:: categories
Document categories. An link::Classes/Array:: of Strings.

method:: related
Related document links. An link::Classes/Array:: of Strings.

method:: keywords
Keywords listed in the document. An link::Classes/Array:: of Strings.

method:: fullPath
The full path to this documents .schelp file, if any.

method:: mtime
The modification time of the .schelp file, if any.

method:: destPath
The render destination path.

method:: docmethods
Documented methods which are not class or instance methods. An link::Classes/Array:: of Strings.

method:: additions
A list of document additions (*.ext.schelp) for this document. An link::Classes/Array:: of Strings.

method:: isExtension
True if this document is an extension (not part of the main library). A link::Classes/Boolean::

method:: isClassDoc
True if this document is a class doc. A link::Classes/Boolean::

subsection:: Class docs
These methods and properties are only used for class docs.

method:: klass
The link::Classes/Class:: documented.

method:: isUndocumentedClass
True if this class is undocumented (which means there are no .schelp file).
A link::Classes/Boolean::

method:: doccmethods
A list of documented class methods.

method:: docimethods
A list of documented instance methods.

method:: privcmethods
A list of private class methods.

method:: privimethods
A list of private instance methods.

method:: undoccmethods
A list of undocumented class methods.

method:: undocimethods
A list of undocumented instance methods.

method:: makeMethodList
Return a list of strings for all non-private methods, prefixed with teletype::xy:: where x is teletype::_:: for documented methods and teletype::?:: for undocumented methods, and y is teletype::*:: for class methods, teletype::-:: for instance methods and teletype::.:: for other/generic methods.

method:: redirect

The name of the class variable holding the implementing class. Used by GUI redirection system, for example.

method:: implKlass

The implementing link::Classes/Class::, if code::redirect:: was set.

method:: implements

The link::Classes/Class:: being implemented. For example, the entry for link::Classes/QButton:: has this set to link::Classes/Button::

method:: toJSON
Write a representation of this document entry as JSON to Stream. Used to export the document entries to the javascript used in the link::Classes/HelpBrowser##HTML help browser::.
argument:: stream
A Stream.

** class:: SCDocHTMLRenderer
summary:: Render SCDoc markup text to HTML
categories:: HelpSystem
related:: Classes/SCDoc, Classes/SCDocParser, Guides/WritingHelp, Reference/SCDocSyntax

description::
This class is part of the SCDoc help system, and handles the rendering of the parsed document tree into HTML output.

In normal cases you won't need to use this class directly, link::Classes/SCDoc:: uses this class by default to render help files.

classmethods::

method:: renderOnStream
Renders a parsed document as HTML onto given stream.
argument:: stream
A stream, for example a link::Classes/File:: instance.
argument:: doc
An instance of link::Classes/SCDocEntry::
argument:: root
An instance of link::Classes/SCDocNode::

method:: renderToFile
Opens a file and passes it to link::#*renderOnStream::

method:: htmlForLink
Create a html string for the given scdoc link.
argument:: link
An scdoc link, such as a document key like "Classes/SinOsc", or an URL, or link to other file installed with the help.
returns::
A String

method:: makeArgString
Used internally.
Returns:: A link::Classes/String:: representing the arguments (with defaults) for a link::Classes/Method::.


section:: CSS styling
The rendered HTML reads the global style from teletype::scdoc.css::, but also reads teletype::frontend.css:: and teletype::custom.css:: (in that order) if available, to enable specific frontends and users to override the CSS.

So to customise the CSS, the user can create a teletype::custom.css:: in their link::Classes/SCDoc#*helpTargetDir:: or at the root of any HelpSource directory (for example in teletype::YourExtension/HelpSource/custom.css:: ).

title:: SCDocNode
summary:: An SCDoc parsed document node
related:: Classes/SCDoc
categories:: HelpSystem

description::
This class is used internally by link::Classes/SCDoc:: to represent a node in the parsed document tree returned by the  parser. It has an id symbol, optional text and optional children.

classmethods::

method:: new
Create a new node

instancemethods::

private:: addDivAfter, makeDiv, notPrivOnly, printOn, sort, sortClassDoc

method:: id
The node ID. A link::Classes/Symbol::

method:: text
Text associated with this node. A link::Classes/String:: or nil.

method:: children
Children of this node. A link::Classes/Array:: or nil.

method:: merge
Merge another document node tree with this one. Used by document additions (*.ext.schelp)
argument:: root2
Another SCDocNode instance.

method:: findChild
Find the first child of this node with specified id.
argument:: id
A link::Classes/Symbol::
** class:: SCDragView
summary:: An abstract superclass for drag views
categories:: GUI>Kits>Cocoa
related:: Classes/DragSource, Classes/DragSink, Classes/DragBoth

description::
Users will not normally directly create instances of SCDragView, but only use it through its subclasses. The three subclasses, link::Classes/DragSource::, link::Classes/DragSink::, link::Classes/DragBoth::, all function basically the same way: they are simple, graphically represented rectangles, which act as a drag-source, a drag target, or both. Their dragging behavior only differs from other GUI views, in that they do not require the cmd key to be held down for dragging. All other dragging functions are those defined by link::Classes/View::. They inherit from SCStaticTextBase, and thus store their content in object and by default display their content using code::asString::. You can keep their string independent of the content, if you set code::setBoth = false::. You can also set a label to be displayed while dragging by using code::dragLabel_()::.



instancemethods::

subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: defaultGetDrag
The method called by default when initiating a drag. Returns object.



examples::
code::
#+BEGIN_SRC sclang
(
s.waitForBoot({	// only needed if you are using sound
	w = Window.new.front;

	// store various kinds of objects in the drag source

	// a string source
	a = DragSource(w, Rect(10, 10, 150, 20)).align_(\center);
	a.object = "I am a string source";

	// a Float source
	b = DragSource(w, Rect(10, 40, 150, 20)).align_(\center);
	b.object = 2.234;

	// a Point source
	c = DragSource(w, Rect(10, 70, 150, 20)).align_(\center);
	c.object = Point(20, 30);

	// A sound function source
	// dragLabel_() is used for the label while dragging
	d = DragSource(w, Rect(10, 100, 150, 20)).align_(\center);
	d.object = { Synth(\default) };
	d.dragLabel = " I am a sound function.\n My dragLabel_() is set \n to inform you about that ";

	// A sound function source
	// here the string label is independent of the content type (Function)
	// dragLabel_() is used for the label while dragging
	f = DragSource(w, Rect(10, 130, 150, 20)).align_(\center).setBoth_(false);
	f.object = { { SinOsc.ar(440,0,0.4) }.play };
	f.string = "My label is independent";
	f.dragLabel = " My dragLabel_() says \n I am dragging a sound function ";

	// receive anthing
	g = DragSink(w, Rect(170, 10, 200, 20)).align_(\center);
	g.string = "recieve anything, do nothing";

	// receive only floats
	g = DragSink(w, Rect(170, 40, 200, 20)).align_(\center);
	g.string = "I only like floats";
	g.canReceiveDragHandler = { View.currentDrag.isFloat };

	// receive only numbers and points, and convert them to rects
	h = DragSink(w, Rect(170, 70, 200, 20)).align_(\center);
	h.string = "I convert to Rect";
	h.canReceiveDragHandler = { View.currentDrag.isKindOf(Number) || View.currentDrag.isKindOf(Point) };
	h.receiveDragHandler = { arg v; h.object = View.currentDrag.asRect };

	// receive only functions, and try to play them
	i = DragSink(w, Rect(170, 100, 200, 20)).align_(\center);
	i.string = "I evaluate a (sound) function";
	i.canReceiveDragHandler = { View.currentDrag.isKindOf(Function) };
	i.receiveDragHandler = { arg v;
		i.object = View.currentDrag.value;
		i.string = "click here for silence";
		i.background_(Color.red)};
	i.mouseDownAction_({
		i.object.free;
		i.string = "I evaluate a (sound) function";
		i.background_(Color.clear) });

	StaticText(w, Rect(10, 200, 380, 50))
		.stringColor_(Color.white)
		.string_("Try dragging any item on the left -----> to any item on the right");
});
)
#+END_SRC

::
** class:: SCEnvelopeEdit
summary:: An envelope editor view
categories:: GUI>Kits>Cocoa
related:: Classes/EnvelopeView

description::
An editable Envelope view.

subsection:: Some Important Issues Regarding SCEnvelopeEdit

The breakpoints are color coded as follows:
table::
## blue || normal
## red || sustain node
## green || loop node
::


classmethods::

method:: new
argument:: parent
The parent view.
argument:: bounds
An instance of link::Classes/Rect::, or a link::Classes/Point:: indicating code::width@height::.
argument:: env
The envelope. An instance of link::Classes/Env::.
argument:: pointsPerSegment
The resolution in points per segment. Default value is 10.

method:: paletteExample
argument:: parent
argument:: bounds

subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: viewClass

instancemethods::

method:: refresh
If the link::Classes/Env:: object is modified directly, this needs to be called to update the GUI.

maxLevel
Changes maximum level shown in editor.
argument:: level
An instance of link::Classes/Float::.

method:: minLevel
Changes minimum level shown in editor.
argument:: level
An instance of link::Classes/Float::.

method:: minTime
Changes minimum time (sec) shown in editor. Negative times are okay because link::Classes/Env:: uses inter-node durations.
argument:: sec
An instance of link::Classes/Float::. Seconds.

method:: maxTime
Changes maximum time (sec) shown in editor.
argument:: sec
An instance of link::Classes/Float::. Seconds.


subsection:: Subclassing and Internal Methods

The following methods are usually not used directly or are called by a primitive. Programmers can still call or override these as needed.

method:: defaultMouseDownAction
argument:: x
argument:: y
argument:: modifiers
argument:: buttonNumber
argument:: clickCount


method:: env
argument:: e

method:: addBreakPoint
argument:: level

method:: insertAtTime
argument:: time
argument:: level

method:: pointsPerSegment

method:: initSCEnvelopeEdit
argument:: argEnv
argument:: argPPS
argument:: setMinMax

method:: redraw

method:: updateAll

method:: updateSegment
argument:: segNum

method:: clear

examples::

Make a basic editor:
code::
#+BEGIN_SRC sclang
(
e = Env([1, 2], [10]);
w = Window("Env Editor", Rect(200, 200, 300, 200));
v = SCEnvelopeEdit(w, w.view.bounds.moveBy(20, 20).resizeBy(-40, -40), e, 20).resize_(5);
w.front;
)

v.addBreakPoint;

(
v.clear;
v.redraw;
v;
)

v.maxLevel_(2); // to give more headroom
v.maxTime_(2); // to increase release point
v.minTime_(-1); // to increase attack time

e.curves_('sin'); // env object is changed
v.refresh; // must refresh editor
#+END_SRC

::

Controlling a Synth
code::
#+BEGIN_SRC sclang
s = Server.internal;
s.boot;

(
e = Env([0, 1, 0.7, 0.9, 0], [0.03, 0.03, 0.03, 0.03], 'sin');
f = Env([0, 1, 0.7, 0.9, 0], [0.03, 0.03, 0.03, 0.03], 'sin');
w = Window("Shards", Rect(100, 100, 500, 400));
v = SCEnvelopeEdit(w, w.view.bounds.resizeBy(-20, -200), e, 10).resize_(2);
StaticText(w, v.bounds).string_(" amplitude").resize_(2);
x = SCEnvelopeEdit(w, v.bounds.moveBy(0, 200), f, 10).resize_(2);
StaticText(w, x.bounds).string_(" frequency").resize_(2);
w.front;
)

(
SynthDef("sineBlip", {
	arg freq = 440, vol = 0.1, la0, la1, la2, la3, la4, ta0, ta1, ta2, ta3, crva,
		lf0, lf1, lf2, lf3, lf4, tf0, tf1, tf2, tf3, crvf;
	var signal, fenv, aenv;
	fenv = EnvGen.ar(Env([lf0, lf1, lf2, lf3, lf4], [tf0, tf1, tf2, tf3], crvf));
	aenv = EnvGen.ar(Env([la0, la1, la2, la3, la4], [ta0, ta1, ta2, ta3], crva), doneAction: 2);
	signal = SinOsc.ar([freq, freq*2] * fenv) * aenv * vol;
	Out.ar(0, signal.dup);
}).send(s);
)

(
Routine({
	var par, indices;
	indices = (2..21);
	loop({
		par = (indices +++ (
			v.env.levels ++
			v.env.times ++
			v.env.curves ++
			x.env.levels ++
			x.env.times ++
			x.env.curves)).flatten;
		s.sendBundle(s.latency, [\s_new, "sineBlip", -1, 1, 1, \freq, exprand(4e3,11e3)] ++ par);
		0.04.wait;
	});
}).play;
)
#+END_SRC

::
** class:: SCImage
summary:: image component
categories:: GUI>Views
related:: Classes/SCImageFilter, Classes/SCImageKernel

DESCRIPTION::

SCImage is an image component for the Mac OS X supercollider client. SCImage is currently a wrapper around different models : you can use it for bitmap operations, image embedding for custom UI and for more advanced image processing as applying filters and kernels, both provided with the CoreImage framework.

SCImage currently supports most formats including tiff, bmp, gif, jpeg, png, tga...ect.. for reading. But for for writing it supports only those in code::SCImage.formats::.

NOTE::
link::Classes/GUI:: Issue : since it is OS X only, be sure to call code::GUI.cocoa:: before any SCImage.call
::

CLASSMETHODS::

PRIVATE::initClass, prFromWindowRect, prFreeAll

METHOD::new
Creates a new SCImage instance. multiple stands here for multiple arguments.

ARGUMENT::multiple
May be a...
list::
## link::Classes/Number:: to create an strong::empty:: image of size multiple as width and height
code::
#+BEGIN_SRC sclang
i = SCImage.new(400);		// Create a 400x400 pixels SCimage.
i.dump;
i.free;

i = SCImage.new(400,200);	// Create a 400x200 pixels SCimage.
i.dump;
i.free;
#+END_SRC

::
## link::Classes/Point:: to create an strong::empty:: image of size multiple.x as width and multiple.y as height
code::
#+BEGIN_SRC sclang
i = SCImage.new(400@200);	// Create a 400x200 pixels SCimage.
i.dump;
i.free;
#+END_SRC

::
## link::Classes/String:: to create an image from a strong::local file:: or from an strong::URL:: (http://, ftp://, file:///)
code::
#+BEGIN_SRC sclang
//	Path string
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
[i.width, i.height].postln;
i.plot;
i.free;
//	URL string - http:// or ftp:// - blocks until image is downloaded
i = SCImage.new("http://www.google.com/intl/en_ALL/images/logo.gif");
i.plot;
i.url;
i.free;
#+END_SRC

::
::

METHOD::color
Creates a new SCImage instance filled with the specified color.
code::
#+BEGIN_SRC sclang
i = SCImage.color(400, 200, Color.blue(0.9,0.1));
i.plot(freeOnClose:true);
#+END_SRC

::

ARGUMENT::args
multiple arguments. the last argument should be a valid link::Classes/Color::

METHOD::open
Creates a new SCImage instance from the local file at strong::path::.
code::
#+BEGIN_SRC sclang
(
i = SCImage.open("/Library/Desktop Pictures/Ripples Blue.jpg");
i.plot(freeOnClose:true);
i.url.postln;
)
#+END_SRC

::

METHOD::openURL
Creates a new SCImage instance from a valid image at the specified URL strong::path::.
code::
#+BEGIN_SRC sclang
i = SCImage.openURL("file:///Library/Desktop%20Pictures/Ripples%20Blue.jpg");
i.url;
w = i.plot(freeOnClose:true);
#+END_SRC

::

METHOD::fromImage
Creates a new SCImage instance from another SCImage.
code::
#+BEGIN_SRC sclang
i = SCImage.new(SCDoc.helpSourceDir +/+ "images/vduck2.jpg");
j = SCImage.fromImage(i);
i.dump;
j.dump;
[i, j].do(_.plot);
[i, j].do(_.free);
#+END_SRC

::

METHOD::fromWindow
Creates a new SCImage from a portion of a SCWindow. this can be used to capture either a window or a specific SCView.

code::
#+BEGIN_SRC sclang
// WINDOW Example:
// First create a window and draw inside of it
(
	w = SCWindow.new;
	w.front; // comment this to copy offscreen window
	w.view.background_(Color.white);
	w.drawFunc = {
		SCPen.translate(100, 100);
		10.do{
			// set the Color
			SCPen.color = Color.blue(rrand(0.0, 1), rrand(0.0, 0.5));
			SCPen.addWedge((100.rand)@(100.rand), rrand(10, 100), 2pi.rand, 2pi.rand);
			SCPen.perform([\stroke, \fill].choose);
		}
	};
	w.refresh;
)

// then grab the window
(
	i = SCImage.fromWindow(w);
	w.close;
	i.plot(freeOnClose:true);
)

// VIEW Capture Example:
// First create a window and add some views inside of it
(
	w = SCWindow.new.front;
	b = [10, 80].asSpec;
	c = SCNumberBox(w, Rect(20, 20, 60, 40));
	a = SCSlider(w, Rect(20, 80, 100, 40))
		.focusColor_(Color.red(alpha:0.2))
		.action_({
			c.value_(b.map(a.value).round(0.01))
	// round the float so it will fit in the SCNumberBox
			});
)

// then grab the window
(
	i = SCImage.fromWindow(w, a.bounds);
	w.close;
	i.plot(freeOnClose:true);
)
#+END_SRC

::

ARGUMENT::window
the SCWindow object.

ARGUMENT::rect
optional. the constrained rect to capture inside the SCWindow. By default, it is the window size.

SUBSECTION::Class variables and attributes

METHOD::formats
returns all the valid image formats as an link::Classes/Array::
code::
#+BEGIN_SRC sclang
SCImage.formats;
#+END_SRC

::

METHOD::compositingOperations
returns all the valid compositing operations you can use when drawing an SCImage as an link::Classes/Array::
code::
#+BEGIN_SRC sclang
SCImage.compositingOperations;
#+END_SRC

::

METHOD::interpolations
returns an link::Classes/Array:: of the different levels of interpolation you can specify when drawing an SCImage.
code::
#+BEGIN_SRC sclang
SCImage.interpolations;
#+END_SRC

::

METHOD::closeAllPlotWindows
close all the SCImage plot windows currently opened.

INSTANCEMETHODS::

PRIVATE::prLockFocus, prDrawAtPoint, prSync, prApplyFilters, prTileInRect, prUpdatePixelsInRect, prGetPixel, prInit, prSetInterpolation, prFree, prSetPixel, prLoadPixels, prSetBackground, prApplyKernel, prUpdatePixels, prWriteToFile, prUnlockFocus, prInitFromURL, prSetColor, prGetColor, prSetName, prGetInterpolation, prDrawInRect

SUBSECTION::commons / general attributes

METHOD::width
returns or set the width of the receiver

METHOD::height
returns or set the height of the receiver

METHOD::setSize
set the size of the receiver

METHOD::bounds
returns the bounds of the receiver.

METHOD::free
deallocate the receiver. this method is useful if you want to manage and reclaim yourself resources. otherwise you do not need to call this method since each object is automatically garbage collected.
code::
#+BEGIN_SRC sclang
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
SCImage.all;
i.free;
SCImage.all;
#+END_SRC

::

METHOD::scalesWhenResized
flag to tell or set if the receiver should update its bitmap representation to scale when a resize operation if performed
code::
#+BEGIN_SRC sclang
(
	i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
	i.bounds.postln; // getting the dimensions
	w =i.plot;
)

// changing the size of an image
(
	i.scalesWhenResized_(true);
	i.setSize(400, 400 / (i.width / i.height));
	a =i.plot;
)
(
a.close; w.close; i.free;
)
#+END_SRC

::

METHOD::url
returns or set the url of the receiver. Returning only if any where supplied at creation, otherwise returns nil. Setting may be used for different purpose but try to supply a valid one since it is used for archiving the image as an object.
code::
#+BEGIN_SRC sclang
i = SCImage.new("http://www.google.com/intl/en_ALL/images/logo.gif");
i.url;
i.plot;
i.free;
#+END_SRC

::

METHOD::accelerated
if true, the receiver currently use the CoreImage model, possibly caching its data on GPU, if not the bitmap model. Set it to switch representation.
WARNING::
this method should never be used directly unless you know perfectly what you are doing. Since the SCImage will switch internally and manage itself the syncronization between representations.
::

METHOD::interpolation
get or set the level of interpolation used when rendering the image - it has not effect when the SCImage is accelerated. see link::#*interpolations:: for a valid range of values.
code::
#+BEGIN_SRC sclang
(
i = SCImage.new(SCDoc.helpSourceDir +/+ "images/vduck2.jpg");
w = i.plot;
i.interpolation;			// get the image currrent interpolation mode
)

(
i.interpolation = 'none';		// experiment with interpolation modes
w.refresh;
)

(
i.interpolation = 'low';
w.refresh;
)

(
i.interpolation = 1;			// same as 'low'
w.refresh;
)

(
i.interpolation = 'high';
w.refresh;
)

(
i.interpolation = 'default';
w.refresh;
)

(
i.accelerated_(true);
i.interpolation = 'none'; // does not work on coreimage accelerated image
w.refresh;
)

i.free;
#+END_SRC

::

SUBSECTION::saving and archiving

METHOD::write
write the SCImage to a file.
code::
#+BEGIN_SRC sclang
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
i.dump
i.write("~/Desktop/my_image.png");
i.free;

//	storeOn / asCompileString
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
i.url;
i.asCompileString;
i.writeArchive("~/Desktop/my_image.scd".standardizePath);

i.free;
i = nil;

Document.open("~/Desktop/my_image.scd".standardizePath);

i = Object.readArchive("~/Desktop/my_image.scd".standardizePath);
i.plot;
i.free;
#+END_SRC

::

ARGUMENT::path
the location where to save it

ARGUMENT::format
(optional) format to use. see SCImage.formats for supported formats. If nil, it will get the format depending on the path extension.

SUBSECTION::rendering

METHOD::plot
plots the image in a SCWindow.
code::
#+BEGIN_SRC sclang
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
w = i.plot;
w.close;

w = i.plot(showInfo:false);
w.close;
i.free;

// other option - image will be automatically freed when closed
SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg").plot("Hello", freeOnClose:true);
#+END_SRC

::

ARGUMENT::name
the title of the SCWindow. may be nil.

ARGUMENT::bounds
the bounds of the SCWindow. may be nil.

ARGUMENT::freeOnClose
flag to tell if the SCWindow should free the SCImage when closed.

ARGUMENT::background
additional background to apply to the SCWindow. may be useful for artifacts due to alpha / compositing...

ARGUMENT::showInfo
shows pixel coordinates while the mouse is over the image's plot window.

METHOD::lockFocus
sets the receiver as the current graphic context. So you can use SCPen to draw inside of it.

METHOD::unlockFocus
restore the graphic context state. the receiver is not anymore the current graphic context.
code::
#+BEGIN_SRC sclang
(
	j = SCImage.new(400,300);

	j.lockFocus;

		SCPen.translate(100, 100);
		1000.do{
			// set the Color
			SCPen.color = Color.green(rrand(0.0, 1), rrand(0.0, 0.5));
			SCPen.addAnnularWedge(
				(100.rand)@(100.rand),
				rrand(10, 50),
				rrand(51, 100),
				2pi.rand,
				2pi.rand
			);
			SCPen.perform([\stroke, \fill].choose);
		};

	j.unlockFocus;
)

j.plot;
j.write("~/Desktop/my_drawing.png"); // write the image
j.free;
#+END_SRC

::

METHOD::draw
shortcut for drawing inside an image. equivalent to :
list::
## receiver.lockFocus
## aFunction
## receiver.unlockFocus
::
code::
#+BEGIN_SRC sclang
(
	j = SCImage.new(400,300);
	j.draw({ arg image;

		SCPen.translate(100, 100);
		1000.do {
			// set the Color
			SCPen.color = Color.green(rrand(0.0, 1), rrand(0.0, 0.5));
			SCPen.addAnnularWedge(
				(100.rand)@(100.rand),
				rrand(10, 50),
				rrand(51, 100),
				2pi.rand,
				2pi.rand
			);
			SCPen.perform([\stroke, \fill].choose);
		};
	}).plot(freeOnClose:true);
)

//	String drawing support on the image
//	drawStringAtPoint(string, point, font, color);
(
	j = SCImage.new(150,50);
	j.draw({ arg bounds;
		j.drawStringAtPoint("Hello, world!", 10@10, Font("Lucida Grande", 24), Color.black);
	});
)

j.plot;
j.write("~/Desktop/hello.png");
j.free;
#+END_SRC

::

METHOD::drawStringAtPoint
renders *correctly* a String inside an SCImage :) code::// to fix to have a compliant interface::
code::
#+BEGIN_SRC sclang
(
	var width, height, tgHeight, ratio, str, font, color, strb, targetWidth=400, shadowColor, run = true;
	shadowColor = Color.black;

	color = Color.gray(0.8);
	str = "I Love Pixels";
	font = Font("Monaco", 10);
	strb = str.bounds(font);
	width = strb.width;
	height = strb.height;
	ratio = height / width;
	i = SCImage(width@(height));
	i.draw({|bb|
		SCPen.smoothing_(false);
		i.drawStringAtPoint(str, 0@0, font, color);
	});
	i.interpolation_(\none);
	tgHeight = targetWidth * ratio;
	w = SCWindow.new("", Rect(400,400, 450, 150)).drawFunc_({
		SCPen.setShadow(2@2, 0.4, color:Color.red);
		i.drawInRect(Rect(5,5,targetWidth, tgHeight));
	});

	w.view.background_(Color.white);
	w.onClose_({run = false; i.free;});
	w.front;
)
#+END_SRC

::

METHOD::drawAtPoint
render the image or a portion of it in the current graphic context.
code::
#+BEGIN_SRC sclang
(
	var operation='sourceOver', fraction=1.0, i, w;

	i = SCImage.new(
	//	"http://supercollider.sourceforge.net/theme/sc01/icon.supercollider.gif"
	//	SCDoc.helpSourceDir +/+ "images/duck_alpha.png"
		SCDoc.helpSourceDir +/+ "images/Swamp.png"
	);

	w = SCWindow.new("SCImage", Rect(120, 400, 360, 180)).front;

	SCSlider.new(w, Rect(10, 150, 150, 16))
		.value_(1.0)
		.action_({ arg sl;
			fraction = sl.value;
			w.refresh;
		});

	SCPopUpMenu.new(w, Rect(170, 150, 100, 16))
		.items_( SCImage.compositingOperations.collect({ arg i; i.asString }) )
		.value_(2)
		.action_({ arg pm;
			operation = SCImage.compositingOperations.at(pm.value);
			w.refresh;
		});

	w.onClose_({ i.free }); // free the image when the window is closed

	w.drawFunc_({

		i.drawAtPoint(10@10, nil, operation, fraction);

	});
)
#+END_SRC

::

ARGUMENT::point
the link::Classes/Point:: where to draw it

ARGUMENT::fromRect
the portion of the SCImage to use

ARGUMENT::operation
the compositing operation to use. code::'sourceOver':: is the default.

ARGUMENT::fraction
the opacity to use, ranging from 0.0 (fully transparent) to 1.0 (fully opaque)

METHOD::drawInRect
render the image or a portion of it in a specified rectangle of the current graphic context. This may stretch the image depending on the destination rect.
code::
#+BEGIN_SRC sclang
(
	i = SCImage.new(
		// "http://supercollider.sourceforge.net/theme/sc01/icon.supercollider.gif"
		SCDoc.helpSourceDir +/+ "images/icon.supercollider.png"
	);

	w = SCWindow.new("SCImage", Rect(120, 400, 360, 180)).front;
	w.onClose_({ i.free }); // free the image when the window is closed
	w.drawFunc_({
		i.drawInRect(Rect(10,10,50,50), Rect(10,10,50,50), 2, 1.0); // only a section
	});
)
#+END_SRC

::

ARGUMENT::rect
the link::Classes/Rect:: where to draw it

ARGUMENT::fromRect
the portion of the SCImage to use

ARGUMENT::operation
the compositing operation to use. code::'sourceOver':: is the default.

ARGUMENT::fraction
the opacity to use, ranging from 0.0 (fully transparent) to 1.0 (fully opaque)

METHOD::tileInRect
tile the image or a portion of it in a specified rectangle of the current graphic context. This may stretch the image depending on the destination rect.
code::
#+BEGIN_SRC sclang
(
	i = SCImage.new(
		// "http://supercollider.sourceforge.net/theme/sc01/icon.supercollider.gif"
		SCDoc.helpSourceDir +/+ "images/icon.supercollider.png"
	);

	w = SCWindow.new("SCImage", Rect(120, 400, 360, 180)).front;
	w.onClose_({ i.free }); // free the image when the window is closed
	w.drawFunc_({
		i.tileInRect(w.view.bounds, nil, 2, 1.0); // all image contents
	});
)
#+END_SRC

::

ARGUMENT::rect
the link::Classes/Rect:: where to draw it

ARGUMENT::fromRect
the portion of the SCImage to use

ARGUMENT::operation
the compositing operation to use. code::'sourceOver':: is the default.
NOTE::
Compositing operations are currently disabled for tileInRect
::

ARGUMENT::fraction
the opacity to use, ranging from 0.0 (fully transparent) to 1.0 (fully opaque)

SUBSECTION::Instance Methods / accessing and setting pixels

METHOD::setPixel
fill a pixel located at x @ y.
code::
#+BEGIN_SRC sclang
i = SCImage.color(60, 60, Color.blue(0.1,0.1));
w = i.plot;
i.setPixel([255,0,0,255].asRGBA, 0, 0); // setting red
w.refresh;
("pixel at 0 @ 0:"+i.getPixel(0,0).rgbaArray).postln;
i.free;
#+END_SRC

::

ARGUMENT::rgbaInteger
an 32 bit link::Classes/Integer:: containing color information packed as 8bit RGBA

METHOD::getPixel
retrieve the pixel value at x @ y as a RGBA integer
code::
#+BEGIN_SRC sclang
// A simple example on how to manipulate pixels with SCImage
b = Int32Array[
	Integer.fromRGBA(255,0,0,255), // red
	Integer.fromRGBA(0,255,0,255), // green
	Integer.fromRGBA(0,0,255,255), // blue
	Integer.fromRGBA(255,0,255,255) // purple
];

b[0].red; // 255 see Integer.red
b[0].green; // 0 see Integer.green
b[0].blue; // 0 see Integer.blue
b[0].alpha; // 255 see Integer.alpha

a = SCImage.new(b.size@1).pixels_(b).interpolation_(\none);
a.plot;


// Set + Get
a.setPixel([255, 0, 255, 128].asRGBA /* create an Integer from 0-255 integer rgba value */, 0, 0).plot;
p = a.getPixel(0,0);

p.red; // 255
p.green; // 0
p.blue; // 255
p.alpha; // 128

// now another important example
a.setPixel([255, 0, 255, 0].asRGBA, 1, 0).plot; // clear color -> alpha is 0
p = a.getPixel(1,0);

p.red; // you expect 255 but you get 0 ??? Why = because SCImage uses premultiplied color component value internally
// meaning all Red, Green, and Blue component are premultiplied by the alpha
// if alpha is 0 you get 0 back for all components.

p.green; // 0
p.blue; // 0
p.alpha; // 0

p = a.getColor(1,0); // more explicit - but same here
#+END_SRC

::

METHOD::setColor
fill the pixel located at x @ y with the specified strong::color::.

METHOD::getColor
retrieve the pixel value at x @ y as a link::Classes/Color::.

METHOD::pixels
retrieve or set all the pixels of the receiver.
NOTE::
Carefull: the returned Array is a link::Classes/Int32Array:: of size receiver.width * receiver.height containing all pixel values as 32bit Integer
::

ARGUMENT::array
an link::Classes/Int32Array:: of size receiver.width * receiver.height containing all pixel values as 32bit Integer

METHOD::loadPixels
load all the pixels of the receiver in an array. it is better and faster to call this function instead of link::#-pixels:: if you plan to retrieve frequently the pixel data (since it won't allocate a new array everytime !)
code::
#+BEGIN_SRC sclang
// exec one line at a time
i = SCImage.new(
	// "http://supercollider.sourceforge.net/theme/sc01/icon.supercollider.gif"
	SCDoc.helpSourceDir +/+ "images/icon.supercollider.png"
);

// first grab the pixels
p = i.pixels;

// do some mods - here invert
i.invert;

// reload directly in my array - do not need to call i.pixels again
i.loadPixels(p);
i.free;
p;
#+END_SRC

::

ARGUMENT::array
the array that will be filled. Should be an link::Classes/Int32Array:: of size receiver.width * receiver.height.

ARGUMENT::region
the targeted rectangular region. (nil by default, meaning full size)

ARGUMENT::start
the start index of the array.

METHOD::setPixels
set the pixels in a specific portion of the receiver.
code::
#+BEGIN_SRC sclang
(
	i = SCImage.new(20@20);
	i.pixels_(
		Int32Array.fill(i.width * i.height, {
			Integer.fromRGBA(255.rand,127.rand,255.rand,255)
		})
	);
	//i.interpolation_(\none); // uncomment to see the difference
	w = i.plot(freeOnClose:true);
	i.pixels.postln;
)

(
	i = SCImage.color(50@50, Color.white);
	i.setPixels(
		Int32Array.fill(20*20,{Integer.fromRGBA(255.rand, 127.rand, 255.rand, 255)}),
		Rect(10,10,20,20)
	);
	i.interpolation_(\none); // uncomment to see the difference
	w = i.plot(freeOnClose:true);
	i.pixels.postln;
)
#+END_SRC

::

ARGUMENT::array
an link::Classes/Int32Array:: of size strong::rect::.width * strong::rect::.height containing all pixel values as 32bit Integer

ARGUMENT::rect
a rectangle defining the portion to update in the receiver. By default strong::rect:: is nil, meaning full image size.

ARGUMENT::start
the array start index.

SUBSECTION::Instance Methods / Attributes for SCImageFilter support

see link::Classes/SCImageFilter:: for more info

METHOD::applyFilters
apply an array of link::Classes/SCImageFilter:: to the image. this should be considered as an in place operation, meaning the SCImage is altered after it.
code::
#+BEGIN_SRC sclang
// ******** Built In CoreImage Generators ********
// Generators are not filters, they actually create an image but do not need an input image
// you just have to create an image of a new size
// ** The Simple Random Filter **
(
f = SCImageFilter.new(\CIRandomGenerator);
a = SCImage.new(500@500);
a.applyFilters(f);
w = a.plot(freeOnClose:true, background:Color.black);
a.bounds.postln;
)

// ** The StarShine example **
(
var width=500, height=500, centerVector;

centerVector = [ width*0.5, height*0.5 ];
a = SCImage.new(500@500);
f = SCImageFilter.new(\CIStarShineGenerator);

f.center_(centerVector);
f.radius_(width*0.05);
f.color_(Color.blue);
f.crossWidth_(2.0);
f.crossAngle_(0.0);
f.crossOpacity_(-4.0);

a.applyFilters(f);
w = a.plot(freeOnClose:true, background:Color.gray); // change background to see
)


// ** Starshine + Pixellate + ZoomBlur **
(
var width=500, height=500, centerVector;

centerVector = [ width*0.5, height*0.5 ];
a = SCImage.new(500@500);

f = SCImageFilter.new(\CIStarShineGenerator);
g = SCImageFilter.new(\CIPixellate);
h = SCImageFilter.new(\CIZoomBlur);

f.center_(centerVector);
f.radius_(width*0.05);
f.color_(Color.blue);
f.crossWidth_(2.0);
f.crossAngle_(0.0);
f.crossOpacity_(-4.0);
g.center_(centerVector);
h.center_(centerVector);
h.amount_(50);

a.applyFilters([f, g, h]);
w = a.plot(freeOnClose:true, background:Color.black);
)
#+END_SRC

::

ARGUMENT::filters
a SCImageFilter or an array of link::Classes/SCImageFilter:: to be applied

ARGUMENT::crop
the crop region to finally use. This may be required for extending bounds since some SCImageFilter / CoreImageFilters require to set a wider region (to be applied correctly) or may create a huge image. Setting crop to nil sets no crop region. In case the current maximum size of a filtered SCImage is 4096 / 4096. Any larger size will be clipped. by default crop is constrained to the receiver bounds.

ARGUMENT::region
NOTE::
supported only in Mac OS 10.5 and later.
::
option to constrain the filter to a specific region IN the SCImage.

METHOD::filteredWith
returns a new SCImage, copy of the receiver filtered with an array of SCImageFilter. arguments are the same as link::#-applyFilters:: (except for strong::region::).
NOTE::
Beware: you are responsible for freeing the newly created SCImage !!!
::

METHOD::filters
filters is the instance variable that holds the array of SCImageFilter attached to the receiver. This is a convenient for applying filters out place and changing the SCImageFilter's attributes. see link::#-addFilter::, link::#-removeFilter::

see link::Classes/SCImageFilter:: for an example on how to use the strong::filters:: array.

METHOD::addFilter
you can also attach filters to the receiver for real-time changing operations. In this case the receiver will create a cache before each rendering to maintain his previous state, and allowing you to use filters without applying them in place. The cache is managed directly by the receiver. you can add several filters to the receiver, the first filter in the array is the first applied in the rendering chain.

see link::Classes/SCImageFilter:: for an example on how to use strong::addFilter::.

ARGUMENT::filter
a SCImageFilter to apply before rendering of the image

METHOD::removeFilter

see link::Classes/SCImageFilter:: for an example on how to use strong::removeFilter::.

ARGUMENT::filter
the SCImageFilter to remove from the rendering chain.

METHOD::flatten
if link::#-filters:: is not zero sized, this method will apply all those filters in place. if the image is accelerated this method force a bitmap representation of the receiver.

METHOD::invert
invert the receiver
code::
#+BEGIN_SRC sclang
(
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
i.invert;
i.plot(freeOnClose:true);
)
#+END_SRC

::

METHOD::crop
crop the receiver
code::
#+BEGIN_SRC sclang
(
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
i.crop( Rect(10,10,120,100) );
i.plot(freeOnClose:true);
)
#+END_SRC

::

ARGUMENT::aRect
the cropping region

SUBSECTION::Instance Methods / Attributes for SCImageKernel support

see link::Classes/SCImageKernel:: for examples and more info.

METHOD::applyKernel
apply a Kernel in place. the receiver is modified after this call.

ARGUMENT::kernel
a link::Classes/SCImageKernel::

EXAMPLES::

SUBSECTION::Views addition

you can now use a SCImage as a valid view background. 16 drawing modes are defined to behave differently.

definitionList::
## tileMode values: ||
table::
## 1 || fixed to left, fixed to top
## 2 || horizontally tile, fixed to top
## 3 || fixed to right, fixed to top
## 4 || fixed to left, vertically tile
## 5 || horizontally tile, vertically tile
## 6 || fixed to right, vertically tile
## 7 || fixed to left, fixed to bottom
## 8 || horizontally tile, fixed to bottom
## 9 || fixed to right, fixed to bottom
## 10 || fit
## 11 || center, center (scale)
## 12 || center , fixed to top
## 13 || center , fixed to bottom
## 14 || fixed to left, center
## 15 || fixed to right, center
## 16 || center, center (no scale)
::

## SCView:backgroundImage_ ||

strong::image:: - the SCImage to use

strong::tileMode:: - the mode to use. by default fixed to left, fixed to top

strong::alpha:: - opacity 0 < x < 1

strong::fromRect:: - the portion of the image to use. by default use the full image.
::
code::
#+BEGIN_SRC sclang
(
	b = 1.0;
	a = SCImage.new(SCDoc.helpSourceDir +/+ "images/vduck2.jpg");
	r = Rect(20,3,40,40);
	w = SCWindow.new("SCImage background" /*, textured:false*/ );
	w.view.background_(Color.gray);
	w.view.backgroundImage_(a, 5, b, r);
	w.front;
)

// monte carlo :) exec every line to test
// r = nil; // uncomment for full image
w.view.backgroundImage_(a, 1, b, r);
w.view.backgroundImage_(a, 2, b, r);
w.view.backgroundImage_(a, 3, b, r);
w.view.backgroundImage_(a, 4, b, r);
w.view.backgroundImage_(a, 5, b, r);
w.view.backgroundImage_(a, 6, b, r);
w.view.backgroundImage_(a, 7, b, r);
w.view.backgroundImage_(a, 8, b, r);
w.view.backgroundImage_(a, 9, b, r);
w.view.backgroundImage_(a, 10, b, r);
w.view.backgroundImage_(a, 11, b, r); // find best ratio - move to see
w.view.backgroundImage_(a, 12, b, r);
w.view.backgroundImage_(a, 13, b, r);
w.view.backgroundImage_(a, 14, b, r);
w.view.backgroundImage_(a, 15, b, r);
w.view.backgroundImage_(a, 16, b, r);

// this is safe even if window is still open because Background object holds the SCImage
a.free;

w.close;

(
	a = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
	w = SCWindow.new("SCImage background");
	l = SC2DSlider.new(w, Rect(10,10,200,200))
		.backgroundImage_( a, 5, 1, Rect(0,0,10,10) );
	w.front;
	a.free; // safe
)

(
	var bounds = Rect(10,10,150,18);
	a = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
	w = SCWindow.new("SCImage background");
	l = SCSlider.new(w, bounds)
		.backgroundImage_(a);
	w.front;
	a.free; // safe
)
#+END_SRC

::
** class:: SCImageFilter
summary:: filter class to use with SCImage
categories:: GUI>Views
related:: Classes/SCImage, Classes/SCImageKernel

DESCRIPTION::

currently this class represents the CoreImage Filters you can apply to a SCImage. All the built-in filters and docs: http://developer.apple.com/documentation/GraphicsImaging/Reference/CoreImageFilterReference/Reference/reference.html

CLASSMETHODS::

PRIVATE::prFilterSet, prGetFilterAttributes, initClass, prGetFilterNames

METHOD::new
code::
#+BEGIN_SRC sclang
f = SCImageFilter.new(\CIStarShineGenerator);
f.attributes;

// or you can do also Synth like style if you already know the attributes of this synth
f = SCImageFilter.new(\CIStarShineGenerator, [\center, [200,200], \radius, 200*0.05]);
f.values; //
#+END_SRC

::

ARGUMENT::filterName
The filter name link::Classes/Symbol:: or link::Classes/String::

ARGUMENT::args
The filter name link::Classes/Symbol:: or link::Classes/String::

METHOD::filterCategories
Returns a Dictionary containing all the filters associated by categories.
code::
#+BEGIN_SRC sclang
// getting filter categories (dictionary)
(
	SCImageFilter.filterCategories.keysDo({|cat|
		cat.postln;
	});
	"ok".postln;
)

// getting Filters for a category - returns a SymbolArray
SCImageFilter.filterCategories.at(\CICategoryGeometryAdjustment);
SCImageFilter.filterCategories.at(\CICategoryGenerator);

// finding Non Built In Plugins usually plugins loaded in (/Library/Graphics/Image Units/)
// all plugins are loaded at startup
// you can find free plugins at http://www.noiseindustries.com/products/
(
var n = 0;
SCImageFilter.filterCategories.do ({
	|symbolArray|
	symbolArray.do ({|pluginName|
		if(pluginName.asString.beginsWith("CI").not, {
			("External Filter Found: " ++ pluginName).postln;
			n = n+1;
		});
	});
});
(n + "plugins found").postln;
n;
)
#+END_SRC

::

INSTANCEMETHODS::

PRIVATE::prAttributeRange, doesNotUnderstand

METHOD::attributes
returns an link::Classes/IdentityDictionary:: containing for each association:
list::
## the attribute/property name as the key.
## the supercollider link::Classes/Class:: you should use as an argument to set the attribute.
::
Once you know the attributes you can set them like using normal instance setters, use the name and append '_'.
code::
#+BEGIN_SRC sclang
(
f = SCImageFilter.new(\CIStarShineGenerator);
f.attributes.keysValuesDo({|k, v|
	("CIStarShineGenerator responds to "++k.asString++"_("++v.asString++")").postln;
});
)

f.center_([200,200]);
f.radius_(200*0.05);
#+END_SRC

::

METHOD::attributeRange
get the numerical range and the default Value for an attribute. returns an Array as code::[ min, max, default ]::. min, max, or default may be a link::Classes/Float::, a link::Classes/Color::, an link::Classes/Array:: or link::Classes/Nil::.
code::
#+BEGIN_SRC sclang
// a SCImageFilter
f = SCImageFilter.new(\CIFlashTransition);

f.dump;

f.attributes;

f.attributeRange(\time);

// getting all attributes MIN - MAX possible values
(
f.attributes.keysDo({|attr|
	(attr ++ " = " + f.attributeRange(attr)).postln; // nil results means there is no min max for those attributes
});
)
#+END_SRC

::

METHOD::values
returns all the values you setted for each attributes. If a value is not explicitely setted for an attribute, it will be set to default when applied to the SCImage.
code::
#+BEGIN_SRC sclang
(
	f = SCImageFilter.new(\CIStarShineGenerator);
	f.center_([200,200]);
	f.radius_(200*0.05);
	f.color_(Color.blue);
	f.crossWidth_(2.0);
	f.crossAngle_(0.0);
	f.crossOpacity_(-4.0);
	f.values.postln;
)
#+END_SRC

::

METHOD::set
set the attributes for this SCImageFilter
code::
#+BEGIN_SRC sclang
(
	f = SCImageFilter.new(\CIStarShineGenerator);
	f.set(\center, [200,200], \radius, 200*0.05, \color, Color.blue, \crossWidth, 2.0);
	f.values.postln;
)
#+END_SRC

::

METHOD::enable
enable or not the Filter when applied to a SCImage.

ARGUMENT::value
If this is false, applying the filter will do nothing.

EXAMPLES::

code::
#+BEGIN_SRC sclang
// thor's fast experimentation request
// example with the filters array wich allows you to use filters without applying them in place
// convenient for RT use / test or whatever...

// here scale down the image otherwise with the zoomblur it will take your computer
// to its knees using addFilter and not applyFilter
// kinda fast swapping test

a = SCImage.new("/Library/Desktop Pictures/Plants/Peony.jpg").scalesWhenResized_(true).setSize(500, 400);
a.plot; // look at me first - i am beautiful

// but i want you to be posterize
(
h = SCImageFilter.new(\CIColorPosterize);
a.addFilter(h); // first call needed
a.plot; // there should have it
)

// then you can freely access and set the slot directly - easier
(
a.filters[0] = SCImageFilter.new(\CIColorInvert);
a.plot;
)

// again
(
a.filters[0] = SCImageFilter.new(\CIZoomBlur);
a.plot;
)

// again
(
a.filters[0] = SCImageFilter.new(\CIRandomGenerator);
a.plot;
)

(
a.removeAllFilters;
a.plot(freeOnClose:true);
)


// ** Masking Example **
(
f = SCImageFilter.new(\CIColorMonochrome); // create a GrayScale image
g = SCImageFilter.new(\CISourceInCompositing); // compositing we will use
f.color_(Color.black);
f.intensity_(1.0);
a = SCImage.new(SCDoc.helpSourceDir +/+ "images/vduck2.jpg");
a.bounds;
b = SCImage.new(SCDoc.helpSourceDir +/+ "images/flowers2.jpg");
a.applyFilters([f, SCImageFilter(\CIColorInvert), SCImageFilter(\CIMaskToAlpha)]); // grayscale + invert + maskToAlpha = create a mask
g.backgroundImage_(a); // set up background image
b.applyFilters(g); // create masked image
a.free;
w = b.plot(freeOnClose:true, background:Color.clear); // set to clear color to see plainly the image
)


// *** Kinda very simple real time FX using the .filters property of SCImage **
// SCImage.filters provides a way to set up filters to apply in the rendering chain
// this can be useful to modify in RT some filter properties
// but they won't be processed inplace, they will be computed at each rendering
// here the filter calc is performed at each rendering call
// so this is convenient but not optimal
// SCPhotoshop :)
(
var width=500, height=500, centerVector;
var controller, specs;

centerVector = [width*0.5, height*0.5];
a = SCImage.new(500@500);
a.accelerated_(true);
f = SCImageFilter.new(\CIStarShineGenerator);
g = SCImageFilter.new(\CIPixellate);
h = SCImageFilter.new(\CIZoomBlur);

f.center_(centerVector);
f.radius_(width*0.05);
f.color_(Color.green);
f.crossWidth_(2.0);
f.crossAngle_(0.0);
f.crossOpacity_(-4.0);
g.center_(centerVector);
h.center_(centerVector);
h.amount_(50);

// simple example control
specs = [
	[f, \crossOpacity_, [-8, 0].asSpec, -4],
	[f, \crossAngle_, [-pi, pi].asSpec, 0.0],
	[h, \amount_, [0, 200].asSpec, 50],

]; // CIStarShine opacity, CIZoomBlur

controller = SCWindow.new("Close Me First !!!", Rect(400,400,300,specs.size * 40));
controller.view.decorator = FlowLayout(controller.view.bounds.insetBy(10), 10@10);
specs.size.do {|i|
	SCSlider.new(controller, Rect(0,0,150,20))
	.action_({|obj|
		specs[i][0].perform(specs[i][1], specs[i][2].map(obj.value));
		w.refresh;
	})
	.value_(specs[i][2].unmap(specs[i][3]));
	controller.view.decorator.nextLine;
};

// adding filters
a.addFilter(f);
a.addFilter(g);
a.addFilter(h);

a.filters.do {|filt, i|
	if(i != 0, {
		SCButton.new(controller, Rect(0,0,20,20))
		.action_({|obj|
			filt.enable_(obj.value != 1);
			w.refresh;
		})
		.states_([["", Color.white], ["", Color.white, Color.black]]);
	});
};

// plotting
w = a.plot(background:Color.black);
controller.front;
controller.onClose_({
	{
	w.close;
	}.defer(0.1);
});
)


/*
// ******** Using EXTERNAL NI Image Units Generator + FX *******
// Download them --- MIGHT BE 10.5 Only so
// http://www.noiseindustries.com/downloads/Units.dmg
// When using for the first time an Image plugin, it might take some extra time due to the plugin loading
// Random
(
f = SCImageFilter.new(\NINoiseGenerator);
f.width_(500); f.height_(500);
f.grayscale_(true);
a = SCImage.new(500@500);
a.applyFilters(f);
w = a.plot(freeOnClose:true, background:Color.black);
)


(
f = SCImageFilter.new(\NIDropShadow);
f.offsetX_(0);
f.offsetY_(0);
f.radius_(30);
f.shadowColor_(Color.red);
a = SCImage.new("vduck2.jpg");
a.applyFilters(f, a.bounds.outsetBy(500));
w = a.plot(freeOnClose:true, background:Color.clear);
a.bounds;
)

(
f = SCImageFilter.new(\NIDotsGenerator);
f.softness_(1);
a = SCImage.new(500@500);
a.applyFilters(f);
w = a.plot(freeOnClose:true, background:Color.black);
)

(
f = SCImageFilter.new(\NICircle);
a = SCImage.new(500@500);
a.applyFilters(f);
w = a.plot(freeOnClose:true);
)
*/
#+END_SRC

::
** class:: SCImageKernel
summary:: kernel class to use with SCImage
categories:: GUI>Views
related:: Classes/SCImage, Classes/SCImageFilter

DESCRIPTION::

code::// very experimental :)::

Currently this class represents the CoreImage strong::CIKernel:: you can apply to a link::Classes/SCImage::. The Kernel language is a subset of the OpenGL Shading Language. more information about the Kernel Language can be found here : http://developer.apple.com/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/chapter_1_section_1.html

and here: http://developer.apple.com/documentation/GraphicsImaging/Reference/CIKernelLangRef/chapter_2_section_1.html#//apple_ref/doc/uid/TP40004397-CH206-TPXREF101

here is the translation table between Kernel language Objects and SuperCollider objects

table::
## strong::Kernel Language Object:: || strong::SuperCollider Object::
## sampler || link::Classes/SCImage::
## __color || link::Classes/Color::
## float || link::Classes/Number::
## vec2, vec3, vec4 || link::Classes/Array::
## __table || link::Classes/SCImage:: (basically the __table modifier just use Images as a data providers - LUT)
::

CLASSMETHODS::

METHOD::new
creates a new SCImageKernel

ARGUMENT::shader
optional. the shader code string. nil by default

ARGUMENT::values
optional. the values that match the kernel proc function defined in the shader string. nil by default

ARGUMENT::bounds
optional. not used for now. nil by default

INSTANCEMETHODS::

METHOD::shader
get or set the shader string.

METHOD::values
get or set the values array. When setting the object indexes in the values Array must match the argument declaration order as defined in the main emphasis::kernel vec4 routine::. See link::#Examples:: for more info.

METHOD::isValid
very basic verification to tell if all arguments of the shader are set.

METHOD::compile
compile the SCImageKernel object (and cache it).
NOTE::
when rendered the first time, the kernel object is always compiled first. If you plan to change the shader string after, you must explicitely compile it to make it effective.
::

EXAMPLES::

code::
#+BEGIN_SRC sclang
/**** Kernels ****/
// very experimental
// COLOR INVERSION SHADER EXAMPLE
(
a = SCImage.new(SCDoc.helpSourceDir +/+ "images/vduck2.jpg"); // get the image
k = SCImageKernel.new;
k.shader_("

vec4	invertPixel(vec4 pix) {
	return vec4(1.0 - pix.r, 1.0 - pix.g, 1.0 - pix.b, pix.a);
}

kernel vec4 _invertColor(sampler source)
{
	vec4 pixel;
	pixel = sample(source, samplerCoord(source));
	unpremultiply(pixel);
	return unpremultiply(invertPixel(pixel));
}
");

// the argument order should be kept in the array
// here we need only the "sampler" argument wich should be as the translation table informs you a SCImage
// the signature of the Kernel function is normaly 'kernel vec4'
// you can of course add other functions in the shader
k.values_([a]);

k.isValid.postln; // is it ok
a.applyKernel(k);

w = a.plot(freeOnClose:true);
)


(
// ANOTHER APPLE KERNEL EXAMPLE - See CoreImage programming guide for original example
a = SCImage.new(SCDoc.helpSourceDir +/+ "images/vduck2.jpg"); // get the image
k = SCImageKernel.new;
k.shader_("
vec2 testVec(float x, float y)
{
	return vec2(x, y);
}

kernel vec4 testKernelFromApple( sampler src, __color color, float distance, float slope )
{
	vec4 	t;
	float	d;
	d = destCoord().y * slope + distance;
	t = unpremultiply(sample(src, samplerCoord(src)));
	t = (t - d*color) / (1.0-d);
	return premultiply(t);
}
");

// as stated in the Apple Example
// distance - min: 0.0 max: 1.0
// slope - min: -0.01 max: 0.01
k.values_(
	[
	a,		// arg 0: the SCImage
	Color.white,	// arg 1: color
	0.5, 		// arg 2: distance
	-0.002		// arg 3: slope
	]
);

a.applyKernel(k);

w = a.plot(freeOnClose:true);
)




(
// OK a Better Colorfull Kernel
a = SCImage.new(600@600); // get the image
k = SCImageKernel.new;

k.shader_(
// shader/kernel from toneburst.com
// Generates spherical and planar displacement maps for VBO-based 3D heightfield.
// http://machinesdontcare.wordpress.com
"
const float PI = 3.14159265359;
const float TWOPI = 6.28318530718;

kernel vec4 _heightMap(sampler image, vec3 scale)
{
	vec2 xyNorm = samplerCoord(image) / samplerSize(image);
	float u = xyNorm.x * PI;
	float v = xyNorm.y * TWOPI;
	vec3 spherical;
	spherical.r = cos(v) * sin(u);
	spherical.g = sin(v) * sin(u);
	spherical.b = cos(u);

	spherical.r = (spherical.r * 0.5 + 0.5) * scale.x;
	spherical.g = (spherical.g * 0.5 + 0.5) * scale.y;
	spherical.b = (spherical.b * 0.5 + 0.5) * scale.z;

	return vec4(spherical,1.0);
}
");

k.values_([a, [1.0, 1.0, 1.0]]);

// k.isValid; // is it ok
a.applyKernel(k);
//.flatten; // ensure a bitmap rep so the kernel is not applied at each rendering call - uncomment that and rescale the plot window to see the difference.

w = a.plot(freeOnClose:true);
)
#+END_SRC

::
** class:: SCNSObject
summary:: Cocoa / Objective-C bridge
categories:: Platform>OSX

description::

note::
This is experimental (03/2006), things might change and be careful wrong or unsupported Cocoa-calls can crash this Application !
::

subsection::Object Creation - LifeCycle

On creation only the init message is passed, alloc is called internally. Instance methods and Class methods are supported by the bridge, but if an object (id or SCNSObject) is returned by the method you owns it (even for autoreleased object - because they are retained internally by SuperCollider), so you must call strong::release:: when you're done with it (SCNSObject(s) are not automatically garbage collected).

subsection::Invocation

Once your Objective-C object is allocated / retained you can call it using strong::invoke::.

Example:
The Objective-C synthax:
code::
#+BEGIN_SRC sclang
NSNumber *n = [[NSNumber alloc] initWithFloat: 1.1];
[n floatValue];
#+END_SRC

::
turns into:
code::
#+BEGIN_SRC sclang
n = SCNSObject("NSNumber", "initWithFloat:", [1.1]);
n.invoke("floatValue");
#+END_SRC

::
Multiple messages are put together in one String and their arguments in one Array.

Example:
Cocoa:
code::
#+BEGIN_SRC sclang
NSWindow *c = [[NSWindow alloc] initWithContentRect: rect styleMask: 10 backing: 2 defer:YES];
#+END_SRC

::
SC:
code::
#+BEGIN_SRC sclang
c = SCNSObject("NSWindow", "initWithContentRect:styleMask:backing:defer:",[Rect(0,0,400,100), 10, 2, 1]);
#+END_SRC

::

subsection::Deferring your calls

Some methods need to be defered. If you want to defer ust call invoke with defer:true. Watch out there is no smart protection for methods that need defer until now! In general you should defer graphic operations.
So calling this might crash sc-lang:
code::
#+BEGIN_SRC sclang
c.invoke("makeKeyAndOrderFront:", [nil]);
#+END_SRC

::
but this line is fine:
code::
#+BEGIN_SRC sclang
c.invoke("makeKeyAndOrderFront:", [nil], true);
#+END_SRC

::

subsection::Common Conversion Table

SuperCollider will try to convert types when possible, here are the most common types and their translation betweem the two languages.

table::
## strong::SuperCollider Types ->:: || strong::Objective-C Types (when using invoke / SCNSObject.new)::
## SCNSObject || id (NSObject)
## Nil || nil, NULL pointer
## Number (Float, Integer) || float, int, long, short, char, NSNumber
## Boolean || YES, NO, bool, NSNumber
## String || NSString, SEL, char*, void*
## Rect || NSRect
## Color || NSColor
## Point || NSPoint, NSRange, NSSize
## Int8Array || void*, char*
## Int16Array || void*, short*
## Int32Array || void*, int*
## DoubleArray || void*, double*
## FloatArray || void*, float*
## Signal || float*
## Array || QTTime, NSRange, NSSize, SCNSObject*
::

table::
## strong::Objective-C Types ->:: || strong::SuperCollider Types (on method return)::
## NSString, char* || String
## NSColor || Color
## NSSize, NSRange, QTTime || Array
## NSRect || Rect
## NSPoint || Point
## BOOL, long, char, int, short || Integer
## float, double || Float
## c99 _bool || Boolean
## *(pointer type) || RawPointer
## id, (any other NSObject) || SCNSObject
::

ClassMethods::

method::new
Creates a new SCNSObject instance. SCNSObject creates a bridge between SuperCollider and Objective-C / Cocoa. It holds an NSObject and sends messages to it. The class and messages are passed as Strings. Arguments must be in an Array.

code::
#+BEGIN_SRC sclang
a = SCNSObject("NSHost", "currentHost");
[\name, a.invoke("name"), \address, a.invoke("address")].postln;
a.release;
#+END_SRC

::

argument::classname
The Objective-C name of the class you want to invoke / instantiate.

argument::initname
can be either a class method or an instance initX method, depending on the possible initialization call. You do not need to specify alloc if you instantiate an object, it is automatically done for you.

argument::args
the Array of arguments for the initname method.

argument::defer
defer the call. Default is false.

method::newFromRawPointer
Creates a new SCNSObject from a link::Classes/RawPointer::. Might be handy for very special occasion.

code::
#+BEGIN_SRC sclang
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");
a = SCNSObject.newFromRawPointer(i.slotAt(0)).invoke("nsimage");
a.className.postln; // verify :)
// now do what you want with the NSImage of the SCImage
i.free; // release it when done
// you do not have here to release the SCNSObject - it is dangerous to do so in this case
#+END_SRC

::

method::dumpPool
Dump the current NSObjects in the pool, so retained by SuperCollider.

method::freePool
Release all the current NSObjects in the pool and clear it. Call this method only if you really know what you are doing : all the SCNSObjects will be unvalidated !

InstanceMethods::

method::invoke
Invoke an SCNSObject.

argument::method
The method to call the receiver with.

argument::args
The arguments link::Classes/Array::.

argument::defer
defer the call. Default is false. (might be needed for GUI otherwise you may experience a crash).

method::release
Release the internal NSObject retained by the application pool. You must call this method when you're done with your object.

note::
It is not fully equivalent to a [myObject release], the NSObject is removed from the pool so if the application is the only one who retained it and owns it, it will properly dealloc it. But if the object is not IN the pool, it won't do anything.
::

code::
#+BEGIN_SRC sclang
SCNSObject.freePool; // free all object first to see
i = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg"); // create a simple SCImage
a = SCNSObject.newFromRawPointer(i.slotAt(0)); // get the SCImage object
a.className; // SCImage
a.invoke("size");
SCNSObject.dumpPool; // look, we do not have any NSObject in our pool
// a.release; // so this won't do anything - just clear our NSObject ref - note that the SCImage is not IN the pool
a.invoke("retain"); // now we can retain the SCImage - but since the method returns the object it is also added - retained also in the pool !
i.free; // release the SCImage
SCNSObject.dumpPool; // look the SCImage is here
a.invoke("release"); // now we have to release it twice
SCNSObject.dumpPool; //
a.release; // should be fine
#+END_SRC

::

method::initAction
Creates a CocoaAction object, a special delegate to handle Target / Action mechanism (See explainations above). strong::initAction:: is a convenience method to add an action to a gui element, mostly for strong::NSControl:: subclasses. Once an action is setted, a special delegate is created on your behalf to wich you can attach a action. You can access this delegate using the strong::nsAction:: accessor method.

code::
#+BEGIN_SRC sclang
(
var win, topview, slider;

win = SCNSObject("NSWindow", "initWithContentRect:styleMask:backing:defer:", [Rect(100,140,400,30), 10, 2, 1]);
win.registerNotification("NSWindowWillCloseNotification", {|name, nsnotification, object|
	[win, topview, slider].do { |obj| obj.release };
	[name, nsnotification, object].postln}
);

slider = SCNSObject("NSSlider", "initWithFrame:", [Rect(0,0,390,20)]);
slider.invoke("setFloatValue:", [0.5]);
slider.initAction.action_({|v,val| val.postln});

topview = win.invoke("contentView");
topview.invoke("addSubview:", [slider]);

win.invoke("makeKeyAndOrderFront:", [win], true);
win.invoke("setTitle:", ["cocoa test"]);
)
#+END_SRC

::

argument::actionName
may be "doFloatAction:" (default), "doIntAction:", "doStateAction:" or "doAction:".

method::setDelegate
Creates a special CocoaAction object delegate object to handle delegate methods and notifications. Should not be confused with the nsAction one. This delegate can be retrieved with the strong::nsDelegate:: accessor.

method::registerNotification
Register a special notification (see NSNotification) with a link::Classes/Function:: that will be triggered each time it is sent. This method will create a defaut strong::nsDelegate:: if it does exist already.

code::
#+BEGIN_SRC sclang
(
var win, delegate;
win = SCNSObject("NSWindow", "initWithContentRect:styleMask:backing:defer:", [Rect(100,400,400,400), 10, 2, 1]);
win.registerNotification("NSWindowWillCloseNotification", {|name, nsnotification, object, delegate|
	[delegate /* the window.nsDelegate */, delegate.object /* the win SCNSObject */, name, nsnotification, object].postln;
	win.release;
});
win.invoke("setMinSize:", [[100,100]]);
win.invoke("makeKeyAndOrderFront:", [win], true);
win.invoke("setTitle:", ["notification test - Close Me"]);
)
#+END_SRC

::

argument::aNotificationName
The name of the notification.

argument::aFunc
The responder function.

argument::obj
The object of the notification, default is this.

method::asArray
SCNSObject holding an NSData object can be converted to array types using the strong::asArray:: method.

code::
#+BEGIN_SRC sclang
d = SCNSObject.new("NSData", "dataWithBytes:length:", ["hellomydear", 11]); // 11 bytes passed
e = d.asArray(\string); // get it back as a String
d.release;

d = SCNSObject.new("NSData", "dataWithBytes:length:", [Int32Array[98,99,100,101], 4*4]); // 4x32bit integers = 16 bytes
e = d.asArray(\int32); // get it back as an Int32Array
d.release;

d = SCNSObject.new("NSData", "dataWithBytes:length:", [Int16Array[98,99,100,101], 4*2]); // 4x16bit integers = 8 bytes
e = d.asArray(\int16); // get it back an Int16Array
d.release;
#+END_SRC

::

argument::arrayType
\string \int8 \int16 \int32 \float \double are the possible argument for an explicit conversion.

Examples::

code::
#+BEGIN_SRC sclang
//create a window and add a Slider that posts its value.
(
var win, slider;

win = SCNSObject("NSWindow", "initWithContentRect:styleMask:backing:defer:",
	[Rect(100,140,400,30), 10, 2, 1]);
win.setDelegate.action_({ // for NSWindow objects using setDelegate.action will trigger the nsAction.action function when it is closed
	"closing window, releasing objects".postln;
	[slider,e].do{|it| it.release};
});
slider = SCNSObject("NSSlider", "initWithFrame:", [Rect(0,0,390,20)]);
e = SCNSObject("SCGraphView", "initWithFrame:", [Rect(0,0,400,30)]);
win.invoke("setContentView:", [e], true);
e.invoke("addSubview:", [slider], true);
slider.invoke("setFloatValue:", [0.5]);
win.invoke("makeKeyAndOrderFront:", [nil], true);
win.invoke("setTitle:", ["cocoa test"]);

{
a = slider.initAction;
a.action_({|v,val| val.postln});}.defer(0.1);
~win = win;
)

~win.className
~win.invoke("close", defer:true);


(
c = SCNSObject("NSWindow", "initWithContentRect:styleMask:backing:defer:",[Rect(0,0,400,100), 10, 2, 1]);
c.setDelegate.action_({ // for NSWindow objects using setDelegate.action will trigger the nsAction.action function when it is closed
	"closing window, releasing objects".postln;
	[c,d,e].do{|it| it.release};
});
d = SCNSObject("NSTextField", "initWithFrame:", [Rect(0,0,100,20)]);
e = SCNSObject("NSView", "initWithFrame:", [Rect(0,0,400,100)]);
c.invoke("setContentView:", [e], true);
e.invoke("addSubview:", [d], true);
c.invoke("makeKeyAndOrderFront:", [nil], true);
)



(
c = SCNSObject("NSWindow", "initWithContentRect:styleMask:backing:defer:",[Rect(100,100,100,20), 10, 2, 1]);
c.setDelegate.action_({ // for NSWindow objects using setDelegate.action will trigger the nsAction.action function when it is closed
	"closing window, releasing objects".postln;
	[c,d,e].do{|it| it.release};
});
d = SCNSObject("NSButton", "initWithFrame:", [Rect(0,0,100,20)]);
e = SCNSObject("NSView", "initWithFrame:", [Rect(0,0,400,100)]);
c.invoke("setContentView:", [e], true);
e.invoke("addSubview:", [d], true);
c.invoke("makeKeyAndOrderFront:", [nil], true);
d.invoke("setButtonType:", [3]);
{
d.initAction("doStateAction:");
d.nsAction.action_({|it,val| val.postln;});
}.defer(0.1);
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
/*
simple QTMovie example
creates a movie in the SuperCollider folder + adds an image to it
*/

(
d = SCNSObject("NSMutableDictionary", "dictionary");
d.invoke("setObject:forKey:", ["jpeg", "QTAddImageCodecType"]);

e = SCNSObject("NSMutableDictionary", "dictionary");
e.invoke("setObject:forKey:", [true, "QTMovieFlatten"]);

m = SCNSObject("QTMovie", "initToWritableFile:error:", [Platform.classLibraryDir ++ "/../test.mov", nil]); // creates an empty movie
i = SCImage("/Library/Desktop Pictures/Ripples Blue.jpg");

// newFromRawPointer does not need any release so fine to get the invocation result directly
a = SCNSObject.newFromRawPointer(i.slotAt(0)).invoke("nsimage"); // this is how you can create a NSImage from
m.invoke("addImage:forDuration:withAttributes:", [a, [3, 1], d]); // 3 seconds
m.invoke("updateMovieFile");

[m, d, e].do ({ |object| object.release; });
i.free;
)

// HUD Panels - 10.5 only
(
w = SCNSObject("NSPanel", "initWithContentRect:styleMask:backing:defer:", [Rect(250, 250, 300, 200), (1<<13) + (1<<4) + 4 + 2 + 8, 2, true]);
w.registerNotification("NSWindowWillCloseNotification", {|notificationName,nsNotification|
	w.release;
});
w.invoke("makeKeyAndOrderFront:", [nil], true);
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
/*----------------------
Notification Examples
using Webview
________________________*/

(
var win, root, cocoaUI, cell, webview, levelIndicator;
win = SCNSObject("NSWindow", "initWithContentRect:styleMask:backing:defer:", [Rect(250, 250, 800, 600), 15, 2, 1]);

root = SCNSObject("NSView", "initWithFrame:", [Rect(0, 0, 800, 600)]);
root.invoke("setAutoresizingMask:", [1 + 2 + 8 + 16]);

webview = SCNSObject("WebView", "initWithFrame:frameName:groupName:", [Rect(10, 30, 800-20, 600-40), "mywebview", "mywebviewgroup"]);
webview.invoke("setAutoresizingMask:", [1 + 2 + 8 + 16]);

~webview = webview; // just to retrieve the source after

cell = SCNSObject("NSLevelIndicatorCell", "initWithLevelIndicatorStyle:", [1]);
levelIndicator = SCNSObject("NSLevelIndicator", "initWithFrame:", [Rect(10, 5, 800-20, 10)]);
levelIndicator.invoke("setCell:", [cell]);
levelIndicator.invoke("setMinValue:", [0]);
levelIndicator.invoke("setMaxValue:", [100]);
levelIndicator.invoke("setFloatValue:", [0]);
levelIndicator.invoke("setContinuous:", [true]);
cell.release;

cocoaUI.add(root);
cocoaUI.add(webview);
cocoaUI.add(levelIndicator);

win.invoke("setContentView:", [root]);
root.invoke("addSubview:", [webview]);
root.invoke("addSubview:", [levelIndicator]);

///// Notifications
// Window
win.registerNotification("NSWindowWillCloseNotification", {
	|notificationName, nsNotificationObjectAsRawPointer|
	"closing window".postln;
	cocoaUI.do {|ui| ui.invoke("removeFromSuperviewWithoutNeedingDisplay")};
	win.release;
	root.release;
	webview.release;
	levelIndicator.release;
	~webview = nil;
});

win.registerNotification("NSWindowDidMoveNotification", {
	|notificationName, nsNotificationObjectAsRawPointer|
	notificationName.postln;
});

win.registerNotification("NSWindowDidMiniaturizeNotification", {
	|notificationName, nsNotificationObjectAsRawPointer|
	notificationName.postln;
});
// Webview Notifications
webview.registerNotification("WebProgressEstimateChangedNotification", {
	|notificationName, nsNotificationObjectAsRawPointer|
	var value;
	value = webview.invoke("estimatedProgress");
	levelIndicator.invoke("setFloatValue:", [value*100]);
	("loading progress: "+ (value*100) + "%").postln;
});

webview.registerNotification("WebProgressFinishedNotification", {
	|notificationName, nsNotificationObjectAsRawPointer|
	var t0, t1;
	levelIndicator.invoke("setFloatValue:", [0]);
	t0 = webview.invoke("mainFrame");
	t1 = t0.invoke("dataSource"); t0.release;
	t0 = t1.invoke("initialRequest"); t1.release;
	t1 = t0.invoke("URL"); t0.release;
	t0 = t1.invoke("absoluteString"); t1.release;
	(t0 ++ " finished Loading").postln;
	win.invoke("setTitle:", [t0]);
});
///// Show Window
win.invoke("makeKeyAndOrderFront:", [win], true);

///// URL Loading
{
	var url;
	url = "http://swiki.hfbk-hamburg.de:8888/MusicTechnology/6";
	webview.invoke("setMainFrameURL:", [url]);
	SCNSObject.dumpPool;
}.defer(0.2);
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
/*----------------------
NSData conversion
using Webview html source
Do not close the window before you exec this code or reload previous example !
________________________*/
(
/// interpret it AFTER previous example for getting source html file
var mainframe, datasource, nsdata;
mainframe = ~webview.invoke("mainFrame");
datasource = mainframe.invoke("dataSource"); mainframe.release;
nsdata = datasource.invoke("data"); datasource.release;
nsdata.isSubclassOf("NSData").postln; //
"---- HTML Source ----".postln;
nsdata.asArray(\string).postln;
"---- End of HTML Source ----".postln;
nsdata.release;
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
/*----------------------
special Delegates actions with return values
using NSURLConnection as an example
________________________*/

/*
(
var url;

// first URL Request
url = SCNSObject("NSURL", "initWithString:", ["http://www.audiosynth.com"]);
~urlRequest = SCNSObject("NSURLRequest", "requestWithURL:cachePolicy:timeoutInterval:", [url, 0, 60]); url.release;

// redirection to set after delegate call
url = SCNSObject("NSURL", "initWithString:", ["http://www.apple.com"]);
~redirection = SCNSObject("NSURLRequest", "requestWithURL:cachePolicy:timeoutInterval:", [url, 0, 60]); url.release;

// we need here to set a void object to set its delegate before it is allocated really
// because urlConnection does not have a setDelegate: method
~urlConnection = SCNSObject.newClear;
~urlConnection.setDelegate; // create and attach a special delegate
~urlConnection.nsDelegate.addMethod("connectionDidFinishLoading:", nil, "@", {
|method, args| [method, args].postln;
});

//// Custom Delegate Method with return values allowed (automatic conversion for most)
//// Here we have to provide the (name, return type of the delegate method, and the type encoding for the arguments)
//// see http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/Articles/chapter_13_section_9.html#//apple_ref/doc/uid/TP30001163-CH9-TPXREF165 for explanations
~urlConnection.nsDelegate.addMethod("connection:didReceiveResponse:", nil, "@@", {
	|method, args| [method, args].postln;
});

~urlConnection.nsDelegate.addMethod("connection:willSendRequest:redirectResponse:", "@", "@@@", {
	|method, arguments|
	[method, arguments].postln;
	url = ~redirection.invoke("URL");
	("redirecting to "++url.invoke("absoluteString")).postln; url.release;
	^~redirection; // redirect !
});

// we can init the object now
~urlConnection.init("NSURLConnection", "initWithRequest:delegate:", [~urlRequest, ~urlConnection.nsDelegate]); // now we can alloc the object and attach its delegate
)

(
~urlConnection.release;
~urlRequest.release;
~redirection.release;
)
*/

SCNSObject.dumpPool;
SCNSObject.freePool;
#+END_SRC

::
** CLASS:: SCViewHolder
summary:: Instead of subclassing a (Q/SC)View, this is a proxy/adapter object that holds the View
categories:: GUI
related:: Classes/View

DESCRIPTION::
When writing gui widgets it is sometimes not desireable to subclass a view class. Its preferable to write a class that acts like a View and is used where Views normally are used but isn't a direct subclass of a View class.

In the SCView hierarchy it is not possible to subclass an SCView class because under the hood there is always a strict relationship between the SCView subclass and its paired C++ class.  The C++ class makes the actual view, the SC class is an interface to that C++ object.

In Qt there is a bit more flexibility.

But there are other reasons to not inherit from a specific view: your widget may not be a single view, in which case you would want to place a CompositeView and then place subviews inside of that.  Altogether these views are what your widget manages.  SCViewHolder can be used in this situation and it would set the top level CompositeView as its primary view.

Although it is still called "SC"ViewHolder it is in fact cross platform since it doesn't draw the view(s), it simply holds them.

Another possible name might be ViewAdapter or PseudoView.  It was originally called SCViewAdapter.

Most of the standard view methods here simply defer to the proxied view.  This makes the ViewHolder act and quack like a View.  

Messages that are not understood by the view holder are forwarded to the proxied view.

Historical note: this class was originally in the cruciallib.  ObjectGui is a subclass of this.

CLASSMETHODS::

METHOD:: consumeKeyDowns
global preference variable: if true then subclasses that do not set a keyDownAction do NOT bubble up keyDown events by default.

returns:: The result of calling the method on the proxied view


INSTANCEMETHODS::


METHOD:: view
get or set the view for which this object is a proxy/adapter.

argument:: v
the view: SCView or QView 

returns:: The result of calling the method on the proxied view


METHOD:: doesNotUnderstand
Messages that are not understood by the view holder are forwarded to the proxied view.  So when the interpreter is told to send a message to a view holder object and that message is not understood, it calls doesNotUnderstand

argument:: selector
The message that was not understood

argument::  ... args
The arguments that were supplied

returns:: the result of calling the method on the proxied view


METHOD:: viewDidClose
Unsets the view variable. After the view is closed (removed from the window) then all calls to the view holder will fail, and should fail as there is no view anymore.  You can check viewHolder.isClosed if you are unsure

returns:: this

METHOD:: remove
Removes the view from the window if it has not already been removed.

returns:: this

METHOD:: action
This method is forwarded to the view

argument:: f


returns:: The result of calling the method on the proxied view

METHOD:: doAction
This method is forwarded to the view

returns:: The result of calling the method on the proxied view

METHOD:: keyDownAction
This method is forwarded to the view

argument:: f


returns:: The result of calling the method on the proxied view

METHOD:: keyDownResponder
This method is forwarded to the view.  Note: this is a cruciallib convention and will be deprecated here.

returns:: The result of calling the method on the proxied view

METHOD:: enableKeyDowns
This method is forwarded to the view. Note: this is a cruciallib convention and will be deprecated here.

returns:: The result of calling the method on the proxied view

METHOD:: asView
returns the view

returns:: the view

METHOD:: bounds
This method is forwarded to the view

argument:: b


returns:: The result of calling the method on the proxied view

METHOD:: resize
This method is forwarded to the view

argument:: r


returns:: The result of calling the method on the proxied view

METHOD:: enabled
This method is forwarded to the view

argument:: b


returns:: The result of calling the method on the proxied view

METHOD:: refresh
This method is forwarded to the view

returns:: The result of calling the method on the proxied view

METHOD:: background
This method is forwarded to the view

argument:: b


returns:: The result of calling the method on the proxied view

METHOD:: focus
This method is forwarded to the view

argument:: flag


returns:: The result of calling the method on the proxied view

METHOD:: visible
This method is forwarded to the view

argument:: boo


returns:: The result of calling the method on the proxied view

METHOD:: isClosed
This method is forwarded to the view

returns:: The result of calling the method on the proxied view

METHOD:: font
This method is forwarded to the view

argument:: f


returns:: The result of calling the method on the proxied view




** class:: SOS
summary:: Second order filter section (biquad).
related:: Classes/FOS
categories::  UGens>Filters>Linear


Description::

A standard second order filter section. Filter coefficients are given
directly rather than calculated for you. Formula is equivalent to:

code::
#+BEGIN_SRC sclang

out(i) = (a0 * in(i)) + (a1 * in(i-1)) + (a2 * in(i-2)) + (b1 * out(i-1)) + (b2 * out(i-2))
#+END_SRC

::


classmethods::

method::ar, kr

argument::in

signal input

argument::a0
See formula above.

argument::a1
See formula above.

argument::a2
See formula above.

argument::b1
See formula above.

argument::b2
See formula above.

argument::mul

argument::add

Examples::

code::
#+BEGIN_SRC sclang

// example: same as TwoPole
(
{
	var rho, theta, b1, b2;
	theta = MouseX.kr(0.2pi, pi);
	rho = MouseY.kr(0.6, 0.99);
	b1 = 2.0 * rho * cos(theta);
	b2 = rho.squared.neg;
	SOS.ar(LFSaw.ar(200, 0, 0.1), 1.0, 0.0, 0.0, b1, b2)
}.play
)


(
{
	var rho, theta, b1, b2;
	theta = MouseX.kr(0.2pi, pi);
	rho = MouseY.kr(0.6, 0.99);
	b1 = 2.0 * rho * cos(theta);
	b2 = rho.squared.neg;
	SOS.ar(WhiteNoise.ar(0.1 ! 2), 1.0, 0.0, 0.0, b1, b2)
}.play
)

// example with SOS.kr kr as modulator
(
{
	var rho, theta, b1, b2, vib;
	theta = MouseX.kr(0.2pi, pi);
	rho = MouseY.kr(0.6, 0.99);
	b1 = 2.0 * rho * cos(theta);
	b2 = rho.squared.neg;

	vib = SOS.kr(LFSaw.kr(3.16), 1.0, 0.0, 0.0, b1, b2);
	SinOsc.ar( vib * 200 + 600) * 0.2
}.play
)
#+END_SRC

::

** class:: SampleDur
summary:: Duration of one sample.
related:: Classes/ControlRate, Classes/RadiansPerSample, Classes/SampleRate, Classes/SubsampleOffset
categories::  UGens>Info


Description::

Returns the current sample duration of the server.
Equivalent to 1/SampleRate.


classmethods::

method::ir

** class:: SampleRate
summary:: Server sample rate.
related:: Classes/ControlRate, Classes/RadiansPerSample, Classes/SampleDur, Classes/SubsampleOffset
categories::  UGens>Info


Description::

Returns the current sample rate of the server.


classmethods::

method::ir

Examples::

code::
#+BEGIN_SRC sclang

// compares a 441 Hz sine tone derived from sample rate (44100 * 0.01, left)
// with a 440 Hz tone (right), resultin in a 1 Hz beating
(
{
	var freq;
	freq = [ SampleRate.ir * 0.01, 440];
	SinOsc.ar(freq, 0, 0.1)
}.play;
)
#+END_SRC

::

** class:: Saw
summary:: Band limited sawtooth.
related:: Classes/SyncSaw, Classes/VarSaw, Classes/LFSaw
categories::  UGens>Generators>Deterministic


Description::

Band limited sawtooth wave generator.


classmethods::

method::ar

argument::freq

Frequency in Hertz.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang

// modulating the frequency

{ Saw.ar(XLine.kr(40,4000,6),0.2) }.play;

// two band limited sawtooth waves through a resonant low pass filter

{ RLPF.ar(Saw.ar([100,250],0.1), XLine.kr(8000,400,5), 0.05) }.play;
#+END_SRC

::

** CLASS::Scale
summary::represents a musical scale
related::Classes/Tuning
categories::Math, Tuning

DESCRIPTION::
Scale supports arbitrary octave divisions and ratios, and (in conjunction with link::Classes/Tuning::) can generate pitch information in various ways, including as input to Patterns.

code::
#+BEGIN_SRC sclang
s.boot;

a = Scale.major;
a.degrees;		// [ 0, 2, 4, 5, 7, 9, 11 ]
a.semitones;		// [ 0, 2, 4, 5, 7, 9, 11 ]
a.cents;		// [ 0, 200, 300, 500, 700, 900, 1100 ]
a.ratios;		// [ 1, 1.1224620483089, 1.2599210498937, 1.3348398541685, etc. ]

Pbind(\scale, a, \degree, Pseq((0..7) ++ (6..0) ++ [\rest], 1), \dur, 0.25).play;

// use non-standard tuning
a.tuning_(\just);
a.degrees;		// no change; degrees are independent of tuning
a.semitones;		// [ 0, 2.0391000173077, 3.1564128700055, 4.9804499913461, etc. ]
a.ratios.collect(_.round(0.001));	// [ 1, 1.125, 1.2, 1.333, 1.5, 1.667, 1.875 ]

Pbind(\scale, a, \degree, Pseq((0..7) ++ (6..0) ++ [\rest], 1), \dur, 0.25).play;
#+END_SRC

::

subsection::Creation

strong::*major, *minor, *dorian, *chromatic, *todi, *hijaz, *partch_o1, etc.::

Creates a scale from the library stored in link::Classes/ScaleInfo::. Each scale comes with an appropriate default link::Classes/Tuning::, but alternate tunings can be specified at creation time:
code::
#+BEGIN_SRC sclang
Scale.phrygian(\pythagorean)
#+END_SRC

::
If the tuning size does not match the scale's link::#-pitchesPerOctave::, a warning will be thrown, and the scale will use its default tuning.

For a complete list of available scales, execute
code::
#+BEGIN_SRC sclang
Scale.directory
#+END_SRC

::

CLASSMETHODS::

method::choose
Creates a random scale from the library, constrained by size and pitchsPerOctave if desired.
code::
#+BEGIN_SRC sclang
Scale.choose;		// could be anything
Scale.choose(7);	// will be a seven-note scale in its default tuning (could be any)
Scale.choose(7, 12);	// will be a seven-note scale in a twelve-tone tuning (usually ET!2)

// Random seven-note scale in random twelve-tone tuning
a = Scale.choose(7, 12).tuning_(Tuning.choose(12));
a.tuning.name;
#+END_SRC

::

method::new
Creates a Scale from scratch. strong::degrees:: should be an array of Integers or scale name. If strong::pitchesPerOctave:: is nil, will guess the most appropriate number based on degrees. strong::tuning:: can be an instance of link::Classes/Tuning:: or a symbol; if nil, will be equal temperament of pitchesPerOctave. Specify strong::descDegrees:: if the Scale should play differently when descending than when ascending; otherwise it should be nil.
code::
#+BEGIN_SRC sclang
Scale.new(#[0, 1, 3, 6, 8, 10, 11], name: "My ET12");		// will be in ET12
Scale.new(#[0, 3, 7, 10, 15, 19, 22], name: "My Quarter-Tone");	// will be in ET24
Scale.new(#[0, 6, 17, 21, 30, 39], 43, \partch, "My Partch");
#+END_SRC

::

INSTANCEMETHODS::

private::storeOn, storedKey, storeArgs, printOn

method::tuning
Sets or gets the tuning of the Scale.
argument::inTuning
can be either an instance of link::Classes/Tuning:: or a symbol matching a library tuning.

method::semitones
Returns a tuned array of semitone values. link::#-as::(Array) is equivalent; link::#-as::(List) returns it as a list, etc.

method::cents
Returns a tuned array of cent values.

method::ratios
Returns a tuned array of ratios.

method::as
Converting. For example code::as(Array)::, code::as(List):: and code::as(LocalBuf):: which is useful for server-side work.
code::
#+BEGIN_SRC sclang
(
r = {
	var scale = Scale.choose.postln;
	SinOsc.ar(
		(
			DegreeToKey.kr(
				scale.as(LocalBuf),
				MouseX.kr(0,15), // mouse indexes into scale
				scale.stepsPerOctave,
				1, // mul = 1
				60 // offset by 72 notes
			)
			+ LFNoise1.kr([3,3], 0.04) // add some low freq stereo detuning
		).midicps, // convert midi notes to hertz
		0,
		0.25
	)
}.play;
)

r.free;
#+END_SRC

::

method::size
Returns the length of the scale.
code::
#+BEGIN_SRC sclang
Scale.ionian.size; // 7
Scale.minorPentatonic.size; // 5
Scale.ajam.size; // 7
Scale.partch_o1.size; // 6
#+END_SRC

::

method::pitchesPerOctave
Returns the size of the pitch class set from which the tuning is drawn.
code::
#+BEGIN_SRC sclang
Scale.ionian.pitchesPerOctave; // 12
Scale.minorPentatonic.pitchesPerOctave; // 12
Scale.ajam.pitchesPerOctave; // 24--this is a quarter-tone scale
Scale.partch_o1.pitchesPerOctave; // 43
#+END_SRC

::

method::stepsPerOctave
Usually 12, but may be different if the current tuning has a stretched or compressed octave. Needed for degreeToKey.
code::
#+BEGIN_SRC sclang
Scale.new((0..14), 15, tuning: \wcAlpha).stepsPerOctave;	// ~ 11.7
Scale.new(#[0, 3, 6, 9, 12], 13, tuning: \bp).stepsPerOctave;	// ~ 19.02
#+END_SRC

::
but note:
code::
#+BEGIN_SRC sclang
Scale.ajam.stepsPerOctave;	// 12 -- quarter-tone scales have normal octaves
#+END_SRC

::

method::at, wrapAt
These access the array generated by semitones.
code::
#+BEGIN_SRC sclang
a = Scale.major;
a.wrapAt(4);	// 7
a.wrapAt(5);	// 9
a.wrapAt(6);	// 11
a.wrapAt(7);	// 0
#+END_SRC

::

method::degreeToFreq
Returns a frequency based on current tuning and rootFreq argument.
code::
#+BEGIN_SRC sclang
Scale.major.degreeToFreq(2, 60.midicps, 1);		// 659.25511...
Scale.major(\just).degreeToFreq(2, 60.midicps, 1);	// 654.06391...
#+END_SRC

::

method::degreeToRatio
Returns a ratio based on current tuning.
code::
#+BEGIN_SRC sclang
Scale.major.degreeToRatio(2, 1).round(0.001);		// 2.52
Scale.major(\just).degreeToRatio(2, 1).round(0.001);	// 2.5
#+END_SRC

::

EXAMPLES::

code::
#+BEGIN_SRC sclang
(
s.waitForBoot({
	a = Scale.ionian;

	p = Pbind(
		\degree, Pseq([0, 1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1, 0, \rest], inf),
		\scale, Pfunc({ a }, inf),
		\dur, 0.25
	);

	q = p.play;
})
)

// change scale
a = Scale.phrygian;

// change tuning
a.tuning_(\just);

// can also set tuning at creation time
a = Scale.ionian(\pythagorean);

// if you use a tuning with the wrong number of pitches per octave,
// you get a warning and the scale reverts to default tuning
a.tuning_(\partch);

// random scale
(
a = Scale.choose(7, 12);
[a.name, a.tuning.name].postln;
)

(
// or make up your own arbitrary scales and tunings
a = Scale.new(
	#[0, 2, 4, 5, 7, 9, 10],
	12,
	Tuning.new([0, 0.8, 2.1, 3, 4.05, 5.2, 6, 6.75, 8.3, 9, 10.08, 11.5]),
	"Custom"
);
)

// tuning has its own class
t = Tuning.werckmeister;

a = Scale.lydian(t);

q.stop;

// getting info
a.name;
a.degrees;
a.semitones;
a.ratios;

a.tuning.name;
a.tuning.semitones;
a.tuning.ratios;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// cmd-J to see scale and tuning dictionaries in full
ScaleInfo
TuningInfo
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// for ascending/descending scales, use Pavaroh
(
Pbind(\note, Pavaroh(
	Pseq([0, 1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1, 0, \rest], 2),
		Scale.melodicMinor,
		Scale.melodicMinorDesc
	),
	\dur, 0.25
).play;
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// note that the root pitch is not stored in the Scale (which should arguably be called a Mode for that reason)
// instead you supply it at play time:

// key of A
Pbind(
	\degree, Pseq((0..7), inf), // your melody goes here
	\scale, Scale.major, // your scale goes here
	\root, -3 // semitones relative to 60.midicps, so this is A
).play;
#+END_SRC

::
** CLASS::Scheduler
categories::Scheduling
summary::schedules functions to be evaluated in the future

DESCRIPTION::
A Scheduler can be used to schedule and reschedule functions to be evaluated at a specific time-point. The Scheduler's time needs to be advanced manually. In most cases you will probably want to use a Clock (e.g. link::Classes/TempoClock::, link::Classes/SystemClock::, link::Classes/AppClock::) instead, in which the march of time is handled for you.

CLASSMETHODS::

method::new
argument::clock
A clock, like SystemClock.
argument::drift
If code::true::, link::#-sched:: will schedule tasks relative to the current absolute time ( link::Classes/Process#*elapsedTime#Main.elapsedTime:: ), otherwise to the current logical time of the scheduler ( link::#-seconds:: ).
argument::recursive
Sets link::#-recursive::.

INSTANCEMETHODS::

method::play
Schedules the task immediately. Equivalent to code::sched(0, task)::.

method::sched
Schedule the task at code::delta:: seconds relative to the current time, as defined by the code::drift:: argument of the link::#*new#constructor::.

Regardless of what time a task is scheduled, it will only be awaken the next time link::#-seconds:: is set.

method::schedAbs
Schedule the task at absolute code::time:: in seconds.

method::advance
Advance the current logical time by code::delta:: seconds. Has same effect as setting link::#-seconds::.

method::seconds
The current logical time of the scheduler.

Setting a new time will wake up (evaluate) any tasks scheduled within that time; a task that returns a new time will be rescheduled accordingly.

method::isEmpty
Returns whether the scheduling queue is empty.

method::clear
Clears the scheduling queue

method::queue
returns:: The instance of link::Classes/PriorityQueue:: used internally as scheduling queue.

method::recursive
If waking up items results in new items being scheduled, but some of them are already expired (scheduled at current time or earlier), this variable determines whether those items will be awaken as well in the same call to -seconds.

EXAMPLES::

code::
#+BEGIN_SRC sclang
a = Scheduler(SystemClock);

a.sched(3, { "now it is 3 seconds.".postln; nil });
a.sched(5, { "now it is 5 seconds.".postln; nil });
a.sched(1, { "now it is 1 second.".postln; nil });

a.advance(0.5);
a.advance(0.5);
a.advance(2);
a.advance(2);

// the beats, seconds and clock are passed into the task function:
a.sched(1, { arg beats, secs, clock; [beats, secs, clock].postln });
a.advance(1);

// the scheduling is relative to "now":
a.sched(3, { "now it was 3 seconds.".postln });
a.sched(5, { "now it was 5 seconds.".postln });
a.sched(1, { "now it was 1 second.".postln });

a.advance(0.5);
a.advance(0.5);
a.advance(2);
a.advance(2);

// play a Routine or a task:
a.play(Routine { 5.do { arg i; i.postln; 1.yield } });
a.advance(0.9);
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// scheduling tasks
(
x = Scheduler(TempoClock.default);

Task {
	inf.do { |i|
		("next " ++ i ++ " in task." + Main.elapsedTime).postln;
		0.5.wait;
	}
}.play(x);
)

x.advance(0.1);
x.seconds;
x.advance(5);
x.seconds;

(
Routine {
	loop { x.advance(0.1); 0.1.wait };
}.play;
)

(
Task { 5.do {
	x.advance(1);
	2.0.rand.wait;
	}
}.play;
)

x.advance(8.1);

Pbind(\degree, Pseries(0, 2, 8), \dur, 0.25).play(x);

(
Task { 5.do {
	x.advance(0.20);
	1.0.wait;
	}
}.play;
)
#+END_SRC

::
** class:: Schmidt
summary:: Schmidt trigger.
related:: Classes/InRange, Classes/InRect
categories::  UGens>Maths


Description::

When  code::in::  crosses to greater than
code::hi:: , output 1, then when signal crosses lower
than  code::lo::  output 0. Uses the formula:

code::
#+BEGIN_SRC sclang

if (out == 1, { if (in < lo, { out = 0.0 }) }, { if (in > hi, { out = 1.0 }) }).
#+END_SRC

::

Output is initially zero.


classmethods::

method::ar, kr

argument::in

Signal to be tested.


argument::lo

Low threshold.


argument::hi

High threshold.


Examples::

code::
#+BEGIN_SRC sclang

s.boot;

{ Schmidt.kr(SinOsc.kr(1, 0, 0.2), -0.15, 0.15)}.scope; // see the trigger

{ Schmidt.kr(MouseX.kr(0, 1), 0.2, 0.8)}.scope; // try it with the cursor

// threshold octave jumps
(
{
	var in = LFNoise1.kr(3);
	var octave = Schmidt.kr(in, -0.15, 0.15) + 1;
	SinOsc.ar(in * 200 + 500 * octave, 0, 0.1)
}.scope;
)
#+END_SRC

::

** class:: ScopeOut
summary:: FIXME: ScopeOut purpose.
categories::  UGens>Buffer, UGens>Undocumented


Description::

FIXME: ScopeOut description.


classmethods::

method::ar, kr

argument::inputArray

FIXME: explain parameter inputArray.


argument::bufnum

FIXME: explain parameter bufnum.

** CLASS:: ScopeView
redirect:: implClass
summary:: A buffer plotting view.
categories:: GUI>Views
related:: Classes/Stethoscope, Classes/FreqScopeView, Classes/FreqScope

DESCRIPTION::

ScopeView is mainly intended to support the implementation of link::Classes/Stethoscope:: (an oscilloscope), link::Classes/FreqScopeView:: (a basic frequency spectrum plotting view) and link::Classes/FreqScope:: (a frequency spectrum analyzer tool).

It is optimized to efficiently perform frequent plotting of the contents of a link::Classes/Buffer:: into which a link::Classes/ScopeOut:: UGen is writing. It will periodically poll the buffer for data and update the plot, as long as the ScopeOut UGen is writing into it; the buffer will not be plotted otherwise.


CLASSMETHODS::

PRIVATE:: key


INSTANCEMETHODS::

METHOD:: bufnum
    The number of the Buffer to plot.

    As soon as a valid buffer number is set and a link::Classes/ScopeOut:: UGen is writing into it, the view starts periodically plotting the buffer. If the ScopeOut UGen stops writing, or an invalid buffer number is set, the plotting will pause.

    argument::
        An integer.

METHOD:: style
    The plotting style:
    list::
    ## 0 = the channels are vertically spaced
    ## 1 = the channels are overlayed
    ## 2 = lissajou; the first two channels are used for 2D plotting (as streams of x and y coordinates).
    ::

    argument::
        One of the above Integers.

METHOD:: xZoom
    The scaling factor on the horizontal axis.

    argument::
        A Float.

METHOD:: yZoom
    The scaling factor on the vertical axis.

    argument::
        A Float.

METHOD:: x
    The horizontal offset.
    argument::
        A Float.

METHOD:: y
    The vertical offset.
    argument::
        A Float.

METHOD:: waveColors
    The colors used to plot each of the channels.

    argument::
        An Array of Colors, one per channel.

EXAMPLES::

SUBSECTION:: A step-by-step example

code::
#+BEGIN_SRC sclang
// execute these in succession
(
s.boot;
)
(
f = Buffer.alloc(s,1024,2);
b = Bus.audio(s,1);

w=Window.new.front;
c = ScopeView(w.view,w.view.bounds.insetAll(10,10,10,10));
c.bufnum = f.bufnum;
)
(
// listening to the bus, using ScopeOut to write it to the buffer
a=SynthDef("monoscope", { arg bus, bufnum;
                var z;
                z = In.ar(bus,2);
                // ScopeOut writes the audio to the buffer
                ScopeOut.ar(z, bufnum);
            }).play(
                RootNode(s),
                [\bus,b.index, \bufnum, f.bufnum] ,
                \addToTail // make sure it goes after what you are scoping
            );

// making noise onto the buffer
d=SynthDef("noise", { arg bus;
                var z;
                z = LFSaw.ar(SinOsc.kr(0.1).range(300,1000),[0,1]*pi) * 0.1;
                Out.ar(bus, z);
            }).play(
                s,
                [\bus,b.index]
            );
)

c.style = 0 // vertically spaced
c.style = 1 // overlapped
c.style = 2 // x/y

(
//remember to free your stuff when finished
a.free;
d.free;
f.free;
b.free;
w.close;
)
#+END_SRC

::

SUBSECTION:: An interactive example with sound

This explains all the options:

code::
#+BEGIN_SRC sclang
(


s.waitForBoot({ 

    var func, sdef1, sdef2, syn1, syn2,startButton ;
    f = Buffer.alloc(s,1024,2);
    b = Bus.audio(s,1);

    w=Window("Scope", Rect(150, SCWindow.screenBounds.height-500,790,400)).front;
    c = ScopeView(w,Rect(10,10,380,380)); // this is SCScope
    c.bufnum = f.bufnum;

    v=CompositeView(w,Rect(400,10,380,380)).background_(Color.rand(0.7));
    v.decorator = n = FlowLayout(v.bounds, margin: 0@0, gap: 5@5);

    a = StaticText(v, Rect(20, 70, 90, 20)).string_(" xZoom = 1").background_(Color.rand);
    m = Slider(v, Rect(20, 60, 285, 20)).background_(a.background).action_({func.value}).value_(0.5);
    d = StaticText(v, Rect(20, 70, 90, 20)).string_(" yZoom = 1").background_(Color.rand);
    g = Slider(v, Rect(20, 60, 285, 20)).background_(d.background).action_({func.value}).value_(0.5);

    h = StaticText(v, Rect(20, 70, 90, 20)).string_(" x = 0").background_(Color.rand);
    i = Slider(v, Rect(20, 60, 285, 20)).background_(h.background).action_({func.value}).value_(0.5);

    Button(v, Rect(0,0,380, 20))
        .states_([["waveColors = [ Color.rand, ... ]",Color.black,Color.rand]])
        .action_({c.waveColors = [Color.rand,Color.rand]});

    Button(v, Rect(0,0,380, 20))
        .states_([[" background = Color.rand(0.1,0.3) ",Color.black,Color.rand]])
        .action_({c.background = Color.rand(0.1,0.3) });

    t= Button(v, Rect(0,0,380, 20))
        .states_([["Current style is 0",Color.black,Color.rand],
            ["Current style is 1",Color.black,Color.rand],
            ["Current style is 2",Color.black,Color.rand]])
        .action_({func.value});

    func={
        c.xZoom = ([0.25, 10, \exp, 1/8, 1].asSpec.map(m.value)); a.string = " xZoom = %".format(c.xZoom);
        c.yZoom = ([0.25, 10, \exp, 1/8, 1].asSpec.map(g.value)); d.string = " yZoom = %".format(c.yZoom);
        c.x = ([ -1024,1024, \linear, 1/8, 1].asSpec.map(i.value)); h.string = " x = %".format(c.x);
//      c.y = ([-1,1, \linear, 1/16, 1].asSpec.map(k.value)); j.string = " y = %".format(c.y);
        c.style=t.value
        };

    startButton = Button.new(v, Rect(0,0,380, 50))
        .states_([["Start Sound",Color.black,Color.green],["Stop Sound",Color.black,Color.red]]).action_({});


    startButton.action_{
        (startButton.value==1).if{
    syn1=SynthDef("test1", { arg bus, bufnum;
                    var z;
                    z = In.ar(bus,2);
                    // ScopeOut writes the audio to the buffer
                    ScopeOut.ar(z, bufnum);
                    Out.ar(0,z);
                }).play(
                    RootNode(s),
                    [\bus,b.index, \bufnum, f.bufnum] ,
                    \addToTail // make sure it goes after what you are scoping
                );

    // making noise onto the buffer
    syn2=SynthDef("test2", { arg bus;
                    var z;
                    z = PMOsc.ar([300,250],*SinOsc.ar([0.027,0.017])*pi) * 0.1;
                    Out.ar(bus, z);
                }).play(s,[\bus,b.index]);



        }{syn1.free; syn2.free};

    };
    w.onClose={syn1.free; syn2.free; b.free; f.free};
    CmdPeriod.doOnce({w.close});
})
)
#+END_SRC

::
** class:: Score
summary:: score of timed OSC commands
related:: Guides/Non-Realtime-Synthesis
categories:: Control, Server>NRT, External Control>OSC

description::
Score encapsulates a list of timed OSC commands and provides some methods for using it, as well as support for the creation of binary OSC files for non-realtime synthesis. See link::Guides/Non-Realtime-Synthesis:: for more details.

The list should be in the following format, with times in ascending order. Bundles are okay.

code::
#+BEGIN_SRC sclang
[
[beat1, [OSCcmd1]],
[beat2, [OSCcmd2], [OSCcmd3]],
...
[beat_n, [OSCcmdn]],
[beatToEndNRT, [\c_set, 0, 0]] // finish
]
#+END_SRC

::

For NRT synthesis the final event should a dummy event, after which synthesis will cease. It is thus important that this event be timed to allow previous events to complete.

Score scheduling defaults to link::Classes/TempoClock::. A setting of code::TempoClock.default.tempo = 1 :: (60 beats per minute), may be used to express score events in seconds if desired.

ClassMethods::

private::initClass

method::new
returns a new Score object with the supplied list.

argument::list
can be an link::Classes/Array::, a link::Classes/List::, or similar object.

method::newFromFile
as link::#*new::, but reads the list in from a text file.

argument::path
a link::Classes/String:: indicating the path of the file. The file must contain a valid SC expression.

method::play
as link::#*new:: but immediately plays it. (See also the instance method below.)

argument::list
the list.

argument::server
If no value is supplied it will play on the default link::Classes/Server::.

method::playFromFile
as link::#*play::, but reads the list from a file.

method::write
a convenience method to create a binary OSC file for NRT synthesis. Does not create an instance.

argument::list
the list.

argument::oscFilePath
a link::Classes/String:: containing the desired path of the OSC file.

argument::clock
Use clock as a tempo base. code::TempoClock.default:: is used if clock is nil.

method::writeFromFile
as link::#*write:: but reads the list from a file.

argument::path
a path to a file with a list.

argument::oscFilePath
a link::Classes/String:: containing the desired path of the OSC file.

argument::clock
Use clock as a tempo base. code::TempoClock.default:: is used if clock is nil.

method::recordNRT
a convenience method to synthesize strong::list:: in non-realtime. This method writes an OSC file to strong::oscFilePath:: (you have to do your own cleanup if desired) and then starts a server app to synthesize it. For details on valid headerFormats and sampleFormats see link::Classes/SoundFile::. Use code::TempoClock.default:: as a tempo base. Does not return an instance.

argument::list
the list.

argument::oscFilePath
the path to which the binary OSC file will be written.

argument::outputFilePath
the path of the resultant soundfile.

argument::inputFilePath
an optional path for an input soundfile.

argument::sampleRate
the sample rate at which synthesis will occur.

argument::headerFormat
the header format of the output file. The default is 'AIFF'.

argument::sampleFormat
the sample format of the output file. The default is 'int16'.

argument::options
an instance of link::Classes/ServerOptions::. If not supplied the options of the default link::Classes/Server:: will be used.

argument::completionString

argument::duration

argument::action
A function to be evaluated once the NRT server has finished rendering its score.

InstanceMethods::

method::play
play the list on strong::server::, use strong::clock:: as a tempo base and quantize start time to strong::quant::. If strong::server:: is nil, then on the default server. code::TempoClock.default:: if strong::clock:: is nil. now if strong::quant:: is 0.

method::stop
stop playing.

method::write
create a binary OSC file for NRT synthesis from the list. Use strong::clock:: as a tempo base. code::TempoClock.default:: if strong::clock:: is nil.

method::score
get or set the list.

method::add
adds bundle to the list.

method::sort
sort the score time order. This is recommended to do strong::before recordNRT or write:: when you are not sure about the packet order.

method::recordNRT
synthesize the score in non-realtime. For details of the arguments see link::#*recordNRT:: above.

method::saveToFile
save the score list as a text file to strong::path::.

Examples::

subsection::NRT Examples

code::
#+BEGIN_SRC sclang
// A sample synthDef
(
SynthDef("helpscore",{ arg freq = 440;
	Out.ar(0,
		SinOsc.ar(freq, 0, 0.2) * Line.kr(1, 0, 0.5, doneAction: 2)
	)
}).add;
)

// write a sample file for testing
(
var f, g;
TempoClock.default.tempo = 1;
g = [
	[0.1, [\s_new, \helpscore, 1000, 0, 0, \freq, 440]],
	[0.2, [\s_new, \helpscore, 1001, 0, 0, \freq, 660]],
	[0.3, [\s_new, \helpscore, 1002, 0, 0, \freq, 220]],
	[1, [\c_set, 0, 0]] // finish
	];
f = File("score-test","w");
f.write(g.asCompileString);
f.close;
)

//convert it to a binary OSC file for use with NRT
Score.writeFromFile("score-test", "test.osc");
#+END_SRC

::

From the command line, the file can then be rendered from within the build directory:

code::
#+BEGIN_SRC sclang
./scsynth -N test.osc _ test.aif 44100 AIFF int16 -o 1
#+END_SRC

::

Score also provides methods to do all this more directly:

code::
#+BEGIN_SRC sclang
(
var f, o;
g = [
	[0.1, [\s_new, \helpscore, 1000, 0, 0, \freq, 440]],
	[0.2, [\s_new, \helpscore, 1001, 0, 0, \freq, 660],
		[\s_new, \helpscore, 1002, 0, 0, \freq, 880]],
	[0.3, [\s_new, \helpscore, 1003, 0, 0, \freq, 220]],
	[1, [\c_set, 0, 0]] // finish
	];
o = ServerOptions.new.numOutputBusChannels = 1; // mono output
Score.recordNRT(g, "help-oscFile", "helpNRT.aiff", options: o); // synthesize
)
#+END_SRC

::

subsection::Real-time Examples

code::
#+BEGIN_SRC sclang
s.boot; // boot the default server

// A sample synthDef
(
SynthDef("helpscore",{ arg freq = 440;
	Out.ar(0,
		SinOsc.ar(freq, 0, 0.2) * Line.kr(1, 0, 0.5, doneAction: 2)
	)
}).add;
)

// write a sample file for testing
(
var f, g;
TempoClock.default.tempo = 1;
g = [
	[0.1, [\s_new, \helpscore, 1000, 0, 0, \freq, 440]],
	[0.2, [\s_new, \helpscore, 1001, 0, 0, \freq, 660],
		[\s_new, \helpscore, 1002, 0, 0, \freq, 880]],
	[0.3, [\s_new, \helpscore, 1003, 0, 0, \freq, 220]],
	[1, [\c_set, 0, 0]] // finish
	];
f = File("score-test","w");
f.write(g.asCompileString);
f.close;
)

z = Score.newFromFile("score-test");

// play it on the default server
z.play;

// change the list
(
x = [
[0.0, [ \s_new, \helpscore, 1000, 0, 0, \freq, 1413 ]],
[0.1, [ \s_new, \helpscore, 1001, 0, 0, \freq, 712 ]],
[0.2, [ \s_new, \helpscore, 1002, 0, 0, \freq, 417 ]],
[0.3, [ \s_new, \helpscore, 1003, 0, 0, \freq, 1238 ]],
[0.4, [ \s_new, \helpscore, 1004, 0, 0, \freq, 996 ]],
[0.5, [ \s_new, \helpscore, 1005, 0, 0, \freq, 1320 ]],
[0.6, [ \s_new, \helpscore, 1006, 0, 0, \freq, 864 ]],
[0.7, [ \s_new, \helpscore, 1007, 0, 0, \freq, 1033 ]],
[0.8, [ \s_new, \helpscore, 1008, 0, 0, \freq, 1693 ]],
[0.9, [ \s_new, \helpscore, 1009, 0, 0, \freq, 410 ]],
[1.0, [ \s_new, \helpscore, 1010, 0, 0, \freq, 1349 ]],
[1.1, [ \s_new, \helpscore, 1011, 0, 0, \freq, 1449 ]],
[1.2, [ \s_new, \helpscore, 1012, 0, 0, \freq, 1603 ]],
[1.3, [ \s_new, \helpscore, 1013, 0, 0, \freq, 333 ]],
[1.4, [ \s_new, \helpscore, 1014, 0, 0, \freq, 678 ]],
[1.5, [ \s_new, \helpscore, 1015, 0, 0, \freq, 503 ]],
[1.6, [ \s_new, \helpscore, 1016, 0, 0, \freq, 820 ]],
[1.7, [ \s_new, \helpscore, 1017, 0, 0, \freq, 1599 ]],
[1.8, [ \s_new, \helpscore, 1018, 0, 0, \freq, 968 ]],
[1.9, [ \s_new, \helpscore, 1019, 0, 0, \freq, 1347 ]],
[2.0, [\c_set, 0, 0]] // finish
];

z.score_(x);
)

// play it
z.play;

// play and stop after one second
(
z.play;
SystemClock.sched(1.0, {z.stop;});
)
#+END_SRC

::

subsection::creating Score from a pattern

code::
#+BEGIN_SRC sclang
SynthDescLib.read;

// new pattern
(
p = Pbind(
	\dur, Prand([0.3, 0.5], inf),
	\freq, Prand([200, 300, 500],inf)
);
)

// make a score from the pattern, 4 beats long
z = p.asScore(4.0);

z.score.postcs;
z.play;

// rendering a pattern to sound file directly:

// render the pattern to aiff (4 beats)

p.render("asScore-Help.aif", 4.0);
#+END_SRC

::
** class:: ScrollView
redirect:: implClass
summary:: A container view that can scroll its contents
categories:: GUI>Views
related:: Classes/CompositeView

DESCRIPTION::

A container view which allows the user to scroll across contents when they exceed the view's bounds.

subsection:: The canvas

The view places the children onto a emphasis::canvas::, which may then be scrolled. The child views' position is always relative to the canvas, and thus not affected by scrolling.

The size of the canvas is always equal to the collective bounds of the children, and automatically adjusts when they are added, moved, resized and removed. If you wish to set it to a particular size, you could do so by first placing e.g. a link::Classes/CompositeView:: (or another container) of desired size, and then placing all the other views into that container.

Exceptionally though, in strong::Qt GUI:: you can strong::replace the canvas:: with any other view (e.g. simply with link::Classes/View::), which allows you to install a link::Classes/QLayout##layout:: on it. In that case, the canvas will fill the whole visible area of the ScrollView, if the layout contents allow so, or a larger area, if the layout contents demand so. Effectively, the strong::contents will resize:: together with the ScrollView, unless their size constraints prevent that, and if link::#-autohidesScrollers:: is code::true::, a scrollbar will only be shown if the contents can not be resized small enough in the scrollbar's direction. See link::#-canvas:: for further explanation.

subsection:: Restrictions

note::
list::
## The link::Classes/View#-resize:: mode of the children is ignored.
## One should not use a decorator such as FlowLayout directly on a ScrollView, only on a container view placed within it.
::
::


CLASSMETHODS::
PRIVATE::key


INSTANCEMETHODS::


SUBSECTION:: Geometry

METHOD:: canvas
    note:: Only in Qt GUI ::

    Returns the current canvas that carries the child views, or replaces it with another.

    By default, the canvas is a subclass of QObject, and hence does not allow the type of manipulations that views do. However, it can only be replaced with a subclass of QView, which greatly extends the possibilities, including the use of layouts on the canvas.

    The new canvas will always resize with the ScrollView, as far its size constraints allow. A plain link::Classes/View:: which completely disregards its children will be freely resizable, and hence the scrolling will never be possible, since the scrollbars are activated according to the size of the canvas. To prevent this, you can either place explicit size constraints on it using link::Classes/View#-minSize:: and similar, or you can install a layout on it, which will forward to it the size constraints of the children.

    See the link::#examples#example:: below.

    Once the canvas is replaced, new views constructed with the ScrollView as the parent will end up as children of the canvas view, equivalent to constructing them with the canvas as the parent, or inserting them into the layout installed on the canvas.

    warning:: Replacing the canvas will remove and destroy all the views placed on the previous one! ::

METHOD:: innerBounds

    Returns either the rectangle corresponding to the size of the canvas, or the visible area of the ScrollView's background, whichever is larger. The position of the rectangle is always 0@0.

    See the link::#description#discussion:: above regarding the size of the canvas.

    Returns:: A Rect.

METHOD:: visibleOrigin

    Gets the position on the canvas corresponding to its upper-left-most visible point, or moves the canvas so as to leave the given point on it at the top-left corner of the visible bounds, if possible.

    Argument::
        A Point.


SUBSECTION:: Behavior

METHOD:: autohidesScrollers

    Sets or gets whether the view hides one or another scrollbar if the contents do not exceed the view's bounds in the scrollbar's direction.

    If link::#-hasHorizontalScroller:: or link::#-hasVerticalScroller:: is set to code::false::, the respective scrollbar will always be hidden, regardless of this policy.

    Defaults to strong::true::.

METHOD:: hasHorizontalScroller

    Sets or gets whether the view has the horizontal scrollbar. If this is code::true::, the scrollbar may still be hidden if link::#-autohidesScrollers:: allows so; however, if this is code::false:: the scrollbar will never be shown.

    Defaults to strong::true::.

METHOD:: hasVerticalScroller

    Sets or gets whether the view has the vertical scrollbar. If this is code::true::, the scrollbar may still be hidden if link::#-autohidesScrollers:: allows so; however, if this it code::false:: the scrollbar will never be shown.

    Defaults to strong::true::.

METHOD:: autoScrolls

    note:: Not implemented yet in Qt GUI ::

    Sets or gets whether the view scrolls automatically when you drag on a child view past the edge of visible bounds.

    Defaults to strong::true::.


SUBSECTION:: Appearance

METHOD:: hasBorder

    Sets or gets whether the view draws its border.

    Defaults to strong::true::.

SUBSECTION:: Actions

METHOD:: action

    Sets or gets the object to be evaluated when the user moves the scrollbars, or when link::#-visibleOrigin:: is set.

EXAMPLES::

SUBSECTION:: Layout management on the canvas

note:: Only works with Qt GUI ::

By replacing the canvas of the ScrollView with a View, and installing a layout on it, the contents will expand to the edge of the ScrollView, and only exceed the edge if necessary.

code::
#+BEGIN_SRC sclang
(
var scroll = ScrollView(bounds:Rect(0,0,300,300).center_(Window.availableBounds.center));
var canvas = View();
var layout;
var i = 0;

var makeEntry = {
    var view = View().background_(Color.rand).layout_(
        HLayout(
            TextField().string_( ("This is entry number " + i.asString) ),
            Button().states_([["Delete"]]).action_({view.remove; i = i - 1;})
        )
    );
    i = i + 1;
    view;
};

layout = VLayout();
layout.add ( View().background_(Color.black).layout_(
    HLayout(
        Button().states_([["Add"]]).action_({ layout.insert(makeEntry.(), i) }),
        nil // stretch remaining empty space
    )
));

canvas.layout = layout;
10.do { canvas.layout.add( makeEntry.() ) };
canvas.layout.add(nil); // stretch remaining empty space

scroll.canvas = canvas;
scroll.front;
)
#+END_SRC

::

SUBSECTION:: Force a canvas size

code::
#+BEGIN_SRC sclang
(
w = Window.new;

b = ScrollView(w, Rect(0, 0, 300, 300)).hasBorder_(true);
c = CompositeView(b, Rect(0, 0, 500, 500)); // 'canvas' is this big
c.decorator = FlowLayout(c.bounds); // now we can use a decorator

Slider2D(c, Rect(0, 0, 240, 240));
Slider2D(c, Rect(0, 0, 240, 240));
Slider2D(c, Rect(0, 0, 240, 240));

c.decorator.nextLine;
w.front;
)
#+END_SRC

::

SUBSECTION:: "Rulers", using an action function

code::
#+BEGIN_SRC sclang
(
var drawFunc;
w = Window.new;

a = ScrollView(w, Rect(40, 40, 300, 300));
b = ScrollView(w, Rect(0, 40, 40, 300)).hasHorizontalScroller_(false).hasVerticalScroller_(false);
c = ScrollView(w, Rect(40, 0, 300, 40)).hasHorizontalScroller_(false).hasVerticalScroller_(false);
b.background = Color.grey;
c.background = Color.grey;

d = UserView(a, Rect(0, 0, 620, 620));
e = UserView(b, Rect(0, 0, 40, 630));
f = UserView(c, Rect(0, 0, 630, 40));

a.action = { var origin;
    origin = a.visibleOrigin;
    b.visibleOrigin = 0@(origin.y);
    c.visibleOrigin = (origin.x)@0;
};

drawFunc = {
    30.do({arg i;
        (i+1).asString.drawAtPoint((i+1 * 20)@0, Font("Courier", 9), Color.black);
    });
};

d.drawFunc = {
    Pen.use({
        Pen.translate(0, 5);
        drawFunc.value;
    });
    Pen.translate(15, 0).rotate(0.5pi);
    drawFunc.value;
};

e.drawFunc = {
    Pen.translate(40, 0).rotate(0.5pi);
    drawFunc.value;
};

f.drawFunc = {
    Pen.translate(0, 25);
    drawFunc.value;
};

w.front;
)
#+END_SRC

::
** class:: Select
summary:: Select output from an array of inputs.
categories:: UGens>Multichannel>Select
related:: Classes/SelectX, Classes/SelectXFocus, Classes/LinSelectX

Description::
The output is selected from an array of inputs.

note:: All the UGens are continously running. This may not be the most efficient
way if each input is CPU-expensive. ::

Note that the array is fixed at the time of writing the SynthDef, and the
whole array is embedded in the SynthDef file itself.  For small arrays
this is more efficient than reading from a buffer.


classmethods::

method::ar, kr

argument::which

Integer index


argument::array

Input array of signals


Examples::

code::
#+BEGIN_SRC sclang
(
SynthDef("help-Select",{ arg out=0;

	var a,cycle;
	a = [
			SinOsc.ar,
			Saw.ar,
			Pulse.ar
		];
	cycle = a.size  * 0.5;
	Out.ar(out,
		Select.ar(LFSaw.kr(1.0,0.0,cycle,cycle),a) * 0.2
	)
}).play;

)

//Here used as a sequencer:
(
SynthDef("help-Select-2",{ arg out=0;

	var a,s,cycle;
	a = Array.fill(32,{ rrand(30,80) }).midicps;
	a.postln;
	cycle = a.size  * 0.5;

	s = Saw.ar(
			Select.kr(
				LFSaw.kr(1.0,0.0,cycle,cycle),
				a
			),
			0.2
	);
	Out.ar(out,s )
}).play;
)
#+END_SRC

::

** class:: SelectX
summary:: Mix one output from many sources
categories:: UGens>Multichannel>Select
related:: Classes/Select, Classes/SelectXFocus, Classes/LinSelectX

description::
The output is mixed from an array of inputs, performing an equal power crossfade between two adjacent channels.

classmethods::
method:: ar, kr

argument:: which
argument:: array
argument:: wrap
wrap does not work yet.

examples::
code::
#+BEGIN_SRC sclang
(
{
	var a;
	a = [
			SinOsc.ar,
			Saw.ar(300),
			Pulse.ar(230)
		];

	SelectX.ar(MouseX.kr(0, 1) * a.size, a) * 0.2
}.play;
)

(
{
	var a;
	a = [
			SinOsc.kr(0.25),
			LFSaw.kr(10),
			LFPulse.kr(0.3)
		];

	SinOsc.ar(SelectX.kr(MouseX.kr(0, 1) * a.size, a) * 300 + 400) * 0.2
}.play;
)
#+END_SRC

::

note::
all the ugens are continously running. This may not be the most efficient way if each input is  cpu-expensive. The array is fixed at the time of writing the SynthDef, and the whole array is embedded in the SynthDef file itself.  For small arrays this is more efficient than reading from a buffer.
::

wrap does not work yet.

(by adc)
** class:: SelectXFocus
summary:: Mix one output from many sources
categories:: UGens>Multichannel>Select
related:: Classes/Select, Classes/SelectX, Classes/LinSelectX

description::
The output is mixed from an array of inputs, linearly interpolating from a number of adjacent channels.

A focus argument allows to control how many adjacent sources are mixed. (by adc)

classmethods::
method:: ar, kr

argument:: which
argument:: array
argument:: focus

examples::
code::
#+BEGIN_SRC sclang
(
{
	var a;
	a = [
			Saw.ar(LFSaw.kr(3 * [1, 1.01], 0, 100, 230)),
			SinOsc.ar,
			Pulse.ar(LFPulse.kr(3 * [1, 1.02], 0, 0.4, 100, 230)),
			SinOsc.ar(SinOsc.kr(4 * [1, 1.03], 0, 200, 300))
		];

	SelectXFocus.ar(MouseX.kr(0, 1) * a.size, a, MouseY.kr(0, a.size)) * 0.2
}.play;
)
#+END_SRC

::

note::
all the ugens are continously running. This may not be the most efficient way if each input is  cpu-expensive. The array is fixed at the time of writing the SynthDef, and the whole array is embedded in the SynthDef file itself.  For small arrays this is more efficient than reading from a buffer.
::

code::
#+BEGIN_SRC sclang
// radio tuner
// (jrh) (cc 2006)
(
{
	var a, n, mx, my, mwrap;
	n = 8;
	mx = MouseX.kr(0, 1, 0, 0.1);
	my = MouseY.kr;
	mwrap = { |pmin, pmax, min, max| sin(mx * ExpRand(pmin, pmax)) + 1 * 0.5 * ExpRand(min, max) };
	a = {
		var freq, fmul, phase;
		freq = mwrap.(10, 40, 200, 5000) + ExpRand(200, 3000);
		fmul = LFNoise0.kr(ExpRand(0.1, 8)).round(1/6).exprange(1, Rand(1, 1.2));
		phase = LFNoise2.ar(mwrap.(1, 20, 10, 1000), Rand(2, 5));
		SinOsc.ar(freq * fmul, phase)
	} ! n;
	a = a.add(
		SinOsc.ar(LFDNoise0.kr(11, SetResetFF.kr(*Dust.kr([1, 2] * 0.3))).range(0, 700) + 220)
	);
	SelectXFocus.ar(mx * n, a, my * n) * 0.2 + OnePole.ar(PinkNoise.ar(0.5 ! 2), 0.4)
	* Line.kr(0, 1, 3);
}.play;
)


// jimmy played harmonica in the pub where I was born
// (hh) (jrh) (cc 2006)
(
{
	var blas, zieh, mx, my, trig, which, amp, u, schnauf;
	var del = 9, det = 0.1;
	schnauf = 0.3;
	mx = MouseX.kr;
	my = MouseY.kr(0.1, 2, 1);

	blas = [0, 12, 24] +.x [60, 64, 67] ++ [60+36];
	zieh = [62, 67, 71,   74, 77, 81, 83,   86, 89, 93];

	trig = Dust.kr(1);
	which = ToggleFF.kr(TDelay.kr(trig, schnauf));
	amp = EnvGen.kr(Env([1, 0, 1], [schnauf, schnauf]), trig);
	blas = Select.kr(which, [blas, zieh]);
	u = SelectXFocus.ar(
		mx * blas.size,
		blas.collect {|f|
			Pulse.ar((Rand(-0.04, 0.09) + f).midicps * 0.5, 0.48 + LFNoise1.kr(0.06, 0.1), 0.2)
		},
		my
	) * Slope.kr(mx + my).abs.lag2(2) * amp;
	u = Pan2.ar(OnePole.ar(u, -0.3), mx * 2 - 1);
	DelayL.ar(BPF.ar(u * 2, 1500, 0.3), del + det, LFNoise2.kr(0.2, det, del)) + u
}.play;
);
#+END_SRC

::
** CLASS::Semaphore
categories::Scheduling
summary::control parallel execution of threads

CLASSMETHODS::

method::new
Create a new instance, set the maximum number of running threads (default: 1).

INSTANCEMETHODS::

method::count
Determines the number of running threads.

method::clear
Remove any reference to threads, but do not reschedule any pending ones.

method::wait
Stop current thread if already too many are running, otherwise continue.

method::signal
Unblock the semaphore, reschedule next pending thread.

EXAMPLES::

code::
#+BEGIN_SRC sclang
// allow only one thread
(
c = Semaphore(1);
fork {
	c.wait;
	"thread 1> now I am doing something for 10 seconds. Block the semaphore meanwhile.".postln;
	10.wait;
	c.signal;
	"thread 1> ok, done. Release the semaphore.".postln;
};
fork {
	3.0.rand.wait;
	"thread 2> I would like to go on, if I may.".postln;
	c.wait; // may I?
	"thread 2> this took until the other thread has released the semaphore. "
		"Blocking for 4 seconds.".postln;
	4.wait;
	"thread 2> ok, done. Releasing the semaphore".postln;
	c.signal;
};
fork {
	4.wait;
	"thread 3> I, too, would like to go on, if I may.".postln;
	c.wait; // may I?
	"thread 3> this took until both other threads had released the semaphore.".postln;
	c.signal;
};
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// allow two threads at a time.
(
c = Semaphore(2);
fork {
	c.wait;
	"thread 1> now I am doing something for 20 seconds. Block the semaphore.".postln;
	10.wait;
	"thread 1> ok, done. Releasing the semaphore".postln;
	c.signal;
};
fork {
	rrand(3.0, 5.0).wait;
	"thread 2> I would like to go on, if I may.".postln;
	if(c.count <= 0) { "thread 3> ok, then I wait ...".postln };
	c.wait; // may I?
	"thread 1> ok, going ahead.".postln;
	17.wait;
	"thread 2> ok, done. Releasing the semaphore".postln;
	c.signal;
};
fork {
	6.wait;
	"thread 3> I, too, would like to go on, if I may.".postln;
	if(c.count <= 0) { "thread 3> ok, then I wait ...".postln };
	c.wait; // may I?
	"thread 3> ok, this took until the first thread had released the semaphore. "
		"Ok, doing something for 4 seconds. Block the semaphore".postln;
		4.wait;
	"Releasing the semaphore.".postln;
	c.signal;
};
fork {
	7.wait;
	"thread 4> Me, the fourth one, would like to go on, if I may.".postln;
	if(c.count <= 0) { "thread 4> ok, then I wait ...".postln };
	c.wait; // may I?
	"thread 4> ok, this took until the third thread had released the semaphore. "
		"Ok, doing something for 3 seconds. Block the semaphore".postln;
		3.wait;
	"Releasing the semaphore.".postln;
	c.signal;
};
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// grant exclusive access to data to only one thread
// there should never be mixed values in the data array
(
var data, useAndModify;

data = [1, 2, 3];
c = Semaphore(1);
// c = Semaphore(2); use this to test how it would behave without exclusive access.
useAndModify = { |newData, who|
	postln(who + "trying to get blocking access.");
	if(c.count <= 0) { who + "ok, then I wait ...".postln };
	c.wait; // may I access? if not, I wait. if yes, disallow others.
	"\n".post;
	(who + "continuing...").postln;
	data.do({ |x|
			0.1.wait;
			postln(who + x);
		});
	"\n".post;
	newData.do { |x, i| data[i] = x };
	postln(who + "rewriting data to:" + newData);
	postln(who + "releasing");
	c.signal; // allow others access again
};

// e.g. set the values to integers
u = Routine {
	inf.do { |i|
		useAndModify.value([100, 200, 300], "thread 1>");
		rrand(1, 3).wait;
	}
};

// e.g. set the values to floats
k =  Routine {
	0.5.wait;
	inf.do { |i|
		useAndModify.value([pi, 0.5pi, 2pi], "thread 2>");
		rrand(1, 5).wait;
	}
};
u.play;
k.play;
);
#+END_SRC

::
** class:: SemiColonFileReader
summary:: file reader for semi-colon separated data
related:: Classes/File
categories:: Files

description::
SemiColonFileReader reads semi-colon delimited files into 2D arrays.

For tab delimited files use link::Classes/TabFileReader::. For comma-separated files use link::Classes/CSVFileReader::. For space-delimited files, or custom delimiters, use link::Classes/FileReader::.

Examples::

code::
#+BEGIN_SRC sclang
(
// write a test file:
f = File("SemiColonTest.sc", "w");
f.write(
"Some semi-colon delimited data;

123;;4;
0.5;0.6;0.7
"
);
f.close;
)


	// open file, read and put strings into array, close file.
x = SemiColonFileReader.read("SemiColonTest.sc").postcs;

	// can skip empty lines:
x = SemiColonFileReader.read("SemiColonTest.sc", true).postcs;

	// can skip blank entries caused by multiple commas:
x = SemiColonFileReader.read("SemiColonTest.sc", true, true).postcs;

	// do file open/close by hand if you prefer:
f = File("SemiColonTest.sc", "r"); f.isOpen;
t = SemiColonFileReader(f);
t.read;
f.close;

(
// write a test file with numbers:
f = File("SemiColonTestNum.sc", "w");

(1..10).do { |n| f.write(n.asString ++ ";"); };
f.close;
)

x = SemiColonFileReader.read("SemiColonTestNum.sc").postcs;
x.collect(_.collect(_.interpret));	// convert to numbers.

	// or you can do it immediately:
x = SemiColonFileReader.readInterpret("SemiColonTestNum.sc").postcs;

(
// write a test file with numbers:
f = File("SemiColonTestNum.sc", "w");

(1..100).do { |n|
	f.write(n.asString ++ if (n % 10 != 0, $;, Char.nl)); };
f.close;
)


x = SemiColonFileReader.readInterpret("SemiColonTestNum.sc").postln;
#+END_SRC

::
** CLASS:: SendPeakRMS
summary:: Track peak and power of a signal for GUI applications.
related:: Classes/Peak, Classes/PeakFollower, Classes/OSCFunc
categories::  UGens>Analysis>Amplitude


DESCRIPTION::

The SendPeakRMS unit generator computes peak and power of a signal and sends the
computed values back to the clients. It does not produce any output.


CLASSMETHODS::

private:: new1


method::ar, kr

Unlike with other unit generators, the code::ar:: and code::kr:: methods do not
specify the rate of the computation, but the granularity. When the SendPeakRMS ugen
is instantiated with code::kr::, the reply rate id quantized to control-rate
blocks.

argument::sig

The input signal.

argument::replyRate

Float or Integer. Specifies the number of replies that are sent to the clients
per second.

argument::peakLag

Float or Integer. Lag time, which is applied to the peak values. This option is
commonly used for GUI VU meters.

argument::cmdName

Symbol or String. Address pattern for reply message.

argument::replyID

Integer ID (similar to link::Classes/SendTrig::).

INSTANCEMETHODS::
private:: numOutputs, writeOutputSpecs


EXAMPLES::

code::
#+BEGIN_SRC sclang
(
{
	SendPeakRMS.kr(Dust.ar(20), 20, 3, "/replyAddress")
}.play;
)

(
o = OSCFunc({ |msg|
	"peak: %, rms: %".format(msg[3], msg[4]).postln
}, '/replyAddress');
)
o.free;
#+END_SRC

::

** class:: SendReply
summary:: Send an array of values from the server to all notified clients
categories:: UGens>Triggers
related:: Classes/SendTrig, Classes/OSCFunc, Classes/SendReply, Classes/SendTrig

description::
A message is sent to all notified clients. See link::Classes/Server::.

list::
## strong::cmdName::
	list::
	## int - node ID
	## int - reply ID
	## ... floats - values.
	::
::

classmethods::
method:: ar, kr

argument:: trig
a non-positive to positive transition triggers a message.
argument:: cmdName
a string or symbol, as a message name.
argument:: values
array of ugens, or valid ugen inputs.
argument:: replyID
integer id (similar to link::Classes/SendTrig::).

examples::
code::
#+BEGIN_SRC sclang
(
{
	SendReply.kr(Impulse.kr(3), '/the_answer', [40, 41, 42, 43] + MouseX.kr, 1905);
}.play(s);
)

o = OSCFunc({ |msg| msg.postln }, '/the_answer');


// multichannel expansion
(
{
	SendReply.kr(Impulse.kr(3),
		'/the_answer',
		values: [[40, 80], [41, 56], 42, [43, 100, 200]],
		replyID: [1905, 1906, 1907, 1908]
	);
}.play(s);
)

o.free;
#+END_SRC

::
** class:: SendTrig
summary:: Send a trigger message from the server back to the client.
categories::  UGens>Triggers
related:: Classes/OSCFunc


Description::

On receiving a trigger (a non-positive to positive transition), send a
trigger message from the server back to the client.


The trigger message sent back to the client is this:

table::

## /tr || A trigger message.

## int: || Node ID.

## int: || Trigger ID.

## float: || Trigger value.

::


This command is the mechanism that synths can use to trigger events in
clients. The node ID is the node that is sending the trigger. The trigger
ID and value are determined by inputs to the SendTrig unit generator
which is the originator of this message.


classmethods::

method::ar, kr

argument::in

The trigger.


argument::id

An integer that will be passed with the trigger message. This is
useful if you have more than one SendTrig in a SynthDef.


argument::value

A UGen or float that will be polled at the time of trigger, and
its value passed with the trigger message.


Examples::

code::
#+BEGIN_SRC sclang

s = Server.local;
s.boot;

(
SynthDef("help-SendTrig",{
	SendTrig.kr(Dust.kr(1.0),0,0.9);
}).send(s);

// register to receive this message
o = OSCFunc({ arg msg, time;
	[time, msg].postln;
},'/tr', s.addr);
)

Synth("help-SendTrig");

o.free;
#+END_SRC

::
** CLASS::SequenceableCollection
summary::Abstract superclass of integer indexable collections
categories::Collections>Ordered

DESCRIPTION::
SequenceableCollection is a subclass of Collection whose elements can be indexed by an Integer. It has many useful subclasses; link::Classes/Array:: and link::Classes/List:: are amongst the most commonly used.

CLASSMETHODS::

copymethod:: Collection *fill

method::series
Fill a SequenceableCollection with an arithmetic series.
code::
#+BEGIN_SRC sclang
Array.series(5, 10, 2);
#+END_SRC

::

method::geom
Fill a SequenceableCollection with a geometric series.
code::
#+BEGIN_SRC sclang
Array.geom(5, 1, 3);
#+END_SRC

::

method::fib
Fill a SequenceableCollection with a fibonacci series.
code::
#+BEGIN_SRC sclang
Array.fib(5);
Array.fib(5, 2, 32); // start from 32 with step 2.
#+END_SRC

::
argument::size
the number of values in the collection
argument::a
the starting step value
argument::b
the starting value

method::rand
Fill a SequenceableCollection with random values in the range strong::minVal:: to strong::maxVal::.
code::
#+BEGIN_SRC sclang
Array.rand(8, 1, 100);
#+END_SRC

::

method::rand2
Fill a SequenceableCollection with random values in the range -strong::val:: to +strong::val::.
code::
#+BEGIN_SRC sclang
Array.rand2(8, 100);
#+END_SRC

::

method::linrand
Fill a SequenceableCollection with random values in the range strong::minVal:: to strong::maxVal:: with a linear distribution.
code::
#+BEGIN_SRC sclang
Array.linrand(8, 1, 100);
#+END_SRC

::

method::exprand
Fill a SequenceableCollection with random values in the range strong::minVal:: to strong::maxVal:: with exponential distribution.
code::
#+BEGIN_SRC sclang
Array.exprand(8, 1, 100);
#+END_SRC

::

method::interpolation
Fill a SequenceableCollection with the interpolated values between the strong::start:: and strong::end:: values.
code::
#+BEGIN_SRC sclang
Array.interpolation(5, 3.2, 20.5);
#+END_SRC

::



INSTANCEMETHODS::


method::|@|
synonym for link::Classes/ArrayedCollection#-clipAt::.
code::
#+BEGIN_SRC sclang
[3, 4, 5]|@|6;
#+END_SRC

::

method::@@
synonym for link::Classes/ArrayedCollection#-wrapAt::.
code::
#+BEGIN_SRC sclang
[3, 4, 5]@@6;
[3, 4, 5]@@ -1;
[3, 4, 5]@@[6, 8]
#+END_SRC

::

method::@|@
synonym for link::Classes/ArrayedCollection#-foldAt::.
code::
#+BEGIN_SRC sclang
[3, 4, 5]@|@[6, 8];
#+END_SRC

::

method::first
Return the first element of the collection.
code::
#+BEGIN_SRC sclang
[3, 4, 5].first;
#+END_SRC

::

method::last
Return the last element of the collection.
code::
#+BEGIN_SRC sclang
[3, 4, 5].last;
#+END_SRC

::

method::putFirst, putLast
Place strong::item:: at the first / last index in the collection. Note that if the collection is empty (and therefore has no indexed slots) the item will not be added.
code::
#+BEGIN_SRC sclang
[3, 4, 5].putFirst(100);
[3, 4, 5].putLast(100);
#+END_SRC

::

method::indexOf
Return the index of an strong::item:: in the collection, or nil if not found.
code::
#+BEGIN_SRC sclang
[3, 4, 100, 5].indexOf(100);
[3, 4, \foo, \bar].indexOf(\foo);
#+END_SRC

::

method::indexOfEqual
Return the index of something in the collection that equals the strong::item::, or nil if not found.
code::
#+BEGIN_SRC sclang
[3, 4, "foo", "bar"].indexOfEqual("foo");
#+END_SRC

::

method::indicesOfEqual
Return an array of indices of things in the collection that equal the strong::item::, or nil if not found.
code::
#+BEGIN_SRC sclang
y = [7, 8, 7, 6, 5, 6, 7, 6, 7, 8, 9];
y.indicesOfEqual(7);
y.indicesOfEqual(5);
#+END_SRC

::

method::indexOfGreaterThan
Return the first index containing an strong::item:: which is greater than strong::item::.
code::
#+BEGIN_SRC sclang
y = List[ 10, 5, 77, 55, 12, 123];
y.indexOfGreaterThan(70);
#+END_SRC

::

copymethod:: Collection -maxIndex

copymethod:: Collection -minIndex


method::find
If the strong::sublist:: exists in the receiver (in the specified order), at an offset greater than or equal to the initial strong::offset::, then return the starting index.
code::
#+BEGIN_SRC sclang
y = [7, 8, 7, 6, 5, 6, 7, 6, 7, 8, 9];
y.find([7, 6, 5]);
#+END_SRC

::

method::findAll
Similar to link::#-find:: but returns an array of all the indices at which the sequence is found.
code::
#+BEGIN_SRC sclang
y = [7, 8, 7, 6, 5, 6, 7, 6, 7, 8, 9];
y.findAll([7, 6]);
#+END_SRC

::

method::indexIn
Returns the closest index of the value in the collection (collection must be sorted).
code::
#+BEGIN_SRC sclang
[2, 3, 5, 6].indexIn(5.2);
#+END_SRC

::

method::indexInBetween
Returns a linearly interpolated float index for the value (collection must be sorted). Inverse operation is link::#-blendAt::.
code::
#+BEGIN_SRC sclang
x = [2, 3, 5, 6].indexInBetween(5.2);
[2, 3, 5, 6].blendAt(x);
#+END_SRC

::

method::blendAt
Returns a linearly interpolated value between the two closest indices. Inverse operation is link::#-indexInBetween::.
code::
#+BEGIN_SRC sclang
x = [2, 5, 6].blendAt(0.4);
#+END_SRC

::

method::copyRange
Return a new SequenceableCollection which is a copy of the indexed slots of the receiver from strong::start:: to strong::end::.
code::x.copyRange(a, b):: can also be written as code::x[a..b]::
code::
#+BEGIN_SRC sclang
(
var y, z;
z = [1, 2, 3, 4, 5];
y = z.copyRange(1, 3);
z.postln;
y.postln;
)
#+END_SRC

::

method::copyToEnd
Return a new SequenceableCollection which is a copy of the indexed slots of the receiver from strong::start:: to the end of the collection.
code::x.copyToEnd(a):: can also be written as code::x[a..]::

method::copyFromStart
Return a new SequenceableCollection which is a copy of the indexed slots of the receiver from the start of the collection to strong::end::.
code::x.copyFromStart(a):: can also be written as code::x[..a]::

method::remove
Remove strong::item:: from collection.

method::take
Remove and return strong::item:: from collection. The last item in the collection will move to occupy the vacated slot (and the collection size decreases by one). See also takeAt, defined for link::Classes/ArrayedCollection#-takeAt::.
code::
#+BEGIN_SRC sclang
a = [11, 12, 13, 14, 15];
a.take(12);
a;
#+END_SRC

::

method::keep
Keep the first strong::n:: items of the array. If strong::n:: is negative, keep the last -strong::n:: items.
code::
#+BEGIN_SRC sclang
a = [1, 2, 3, 4, 5];
a.keep(3);
a.keep(-3);
#+END_SRC

::

method::drop
Drop the first strong::n:: items of the array. If strong::n:: is negative, drop the last -strong::n:: items.
code::
#+BEGIN_SRC sclang
a = [1, 2, 3, 4, 5];
a.drop(3);
a.drop(-3);
#+END_SRC

::

method::join
Returns a link::Classes/String:: formed by connecting all the elements of the receiver, with strong::joiner:: inbetween. See also link::Classes/String#-split:: as the complementary operation.
code::
#+BEGIN_SRC sclang
["m", "ss", "ss", "pp", ""].join("i").postcs;
"mississippi".split("i").postcs;
#+END_SRC

::

method::flat
Returns a collection from which all nesting has been flattened.
code::
#+BEGIN_SRC sclang
[[1, 2, 3], [[4, 5], [[6]]]].flat;
#+END_SRC

::

method::flatten
Returns a collection from which strong::numLevels:: of nesting has been flattened.
code::
#+BEGIN_SRC sclang
[[1, 2, 3], [[4, 5], [[6]]]].flatten(1).postcs;
[[1, 2, 3], [[4, 5], [[6]]]].flatten(2).postcs;
#+END_SRC

::

method::flop
Invert rows and colums in a two dimensional Collection (turn inside out). See also: link::Classes/Function::.
code::
#+BEGIN_SRC sclang
[[1, 2, 3], [4, 5, 6]].flop;
[[1, 2, 3], [4, 5, 6], [7, 8]].flop; // shorter array wraps
[].flop; // result is always 2-d.
#+END_SRC

::
Note that the innermost arrays are not copied:
code::
#+BEGIN_SRC sclang
a = [1, 2];
x = [[[a, 5], [a, 10]], [[a, 50, 60]]].flop;
a[0] = pi;
x // pi is everywhere
#+END_SRC

::


method::flopWith
Flop with a user defined function. Can be used to collect over several collections in parallel.
code::
#+BEGIN_SRC sclang
[[1, 2, 3], [4, 5, 6]].flopWith(_+_);
[[1, 2, 3], 1, [7, 8]].flopWith{ |a,b,c| a+b+c }; // shorter array wraps

// typical use case (pseudocode)
[synths, buffers].flopWith{ |a,b| a.set(\buf, b) }
#+END_SRC

::
argument::func
A function taking as many arguments as elements in the array.

method::flopTogether
Invert rows and colums in a an array of dimensional Collections (turn inside out), so that they all match up in size, but remain separated.
code::
#+BEGIN_SRC sclang
(
a = flopTogether(
	[[1, 2, 3], [4, 5, 6, 7, 8]] * 100,
	[[1, 2, 3], [4, 5, 6], [7, 8]],
	[1000]
)
);

a.collect(_.size); // sizes are the same
a.collect(_.shape) // shapes can be different
#+END_SRC

::


method::flopDeep
Fold dimensions in a multi-dimensional Collection (turn inside out).

argument::rank
The depth (dimension) from which the array is inverted inside-out.

code::
#+BEGIN_SRC sclang
[[1, 2, 3], [[41, 52], 5, 6]].flopDeep(2);
[[1, 2, 3], [[41, 52], 5, 6]].flopDeep(1);
[[1, 2, 3], [[41, 52], 5, 6]].flopDeep(0);
[[1, 2, 3], [[41, 52], 5, 6]].flopDeep; // without argument, flop from the deepest level

[[[10, 100, 1000], 2, 3], [[41, 52], 5, 6]].flopDeep(2); // shorter array wraps
[].flopDeep(1); // result is always one dimension higher.
[[]].flopDeep(4);
#+END_SRC

::

note::Note that, just like in flop, the innermost arrays (deeper than rank) are not copied.::

code::
#+BEGIN_SRC sclang
a = [1, 2];
x = [[[a, 5], [a, 10]], [[a, 50, 60]]].flopDeep(1);
a[0] = pi;
x // pi is everywhere
#+END_SRC

::

method::maxSizeAtDepth
Returns the maximum size of all subarrays at a certain depth (dimension)

argument::rank
The depth at which the size of the arrays is measured

code::
#+BEGIN_SRC sclang
[[1, 2, 3], [[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(2);
[[1, 2, 3], [[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(1);
[[1, 2, 3], [[41, 52], 5, 6], 1, 2, 3].maxSizeAtDepth(0);
[].maxSizeAtDepth(0);
[[]].maxSizeAtDepth(0);
[[]].maxSizeAtDepth(1);
#+END_SRC

::

method::maxDepth
Returns the maximum depth of all subarrays.

argument::max
Internally used only.

code::
#+BEGIN_SRC sclang
[[1, 2, 3], [[41, 52], 5, 6], 1, 2, 3].maxDepth
#+END_SRC

::

method::resamp0
Returns a new Collection of the desired length, with values resampled evenly-spaced from the receiver without interpolation.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4].resamp0(12);
[1, 2, 3, 4].resamp0(2);
#+END_SRC

::

method::resamp1
Returns a new Collection of the desired length, with values resampled evenly-spaced from the receiver with linear interpolation.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4].resamp1(12);
[1, 2, 3, 4].resamp1(3);
#+END_SRC

::

method::choose
Choose an element from the collection at random.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4].choose;
#+END_SRC

::

method::wchoose
Choose an element from the collection at random using a list of probabilities or weights. The weights must sum to 1.0.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4].wchoose([0.1, 0.2, 0.3, 0.4]);
#+END_SRC

::

method::sort
Sort the contents of the collection using the comparison function argument. The function should take two elements as arguments and return true if the first argument should be sorted before the second argument. If the function is nil, the following default function is used. { arg a, b; a < b }
code::
#+BEGIN_SRC sclang
[6, 2, 1, 7, 5].sort;
[6, 2, 1, 7, 5].sort({ arg a, b; a > b }); // reverse sort
#+END_SRC

::

method::sortBy
Sort the contents of the collection using the key strong::key::, which is assumed to be found inside each element of the receiver.
code::
#+BEGIN_SRC sclang
(
a = [
	Dictionary[\a->5, \b->1, \c->62],
	Dictionary[\a->2, \b->9, \c->65],
	Dictionary[\a->8, \b->5, \c->68],
	Dictionary[\a->1, \b->3, \c->61],
	Dictionary[\a->6, \b->7, \c->63]
]
)
a.sortBy(\b);
a.sortBy(\c);
#+END_SRC

::

method::order
Return an array of indices that would sort the collection into order. strong::function:: is treated the same way as for the link::#-sort:: method.
code::
#+BEGIN_SRC sclang
[6, 2, 1, 7, 5].order;
#+END_SRC

::

method::swap
Swap two elements in the collection at indices strong::i:: and strong::j::.

method::pairsDo
Calls function for each subsequent pair of elements in the SequentialCollection. The function is passed the two elements and an index.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4, 5].pairsDo({ arg a, b; [a, b].postln; });
#+END_SRC

::

method::doAdjacentPairs
Calls function for every adjacent pair of elements in the SequentialCollection. The function is passed the two adjacent elements and an index.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4, 5].doAdjacentPairs({ arg a, b; [a, b].postln; });
#+END_SRC

::

method::separate
Separates the collection into sub-collections by calling the function for each adjacent pair of elements. If the function returns true, then a separation is made between the elements.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 5, 6, 8, 10].separate({ arg a, b; (b - a) > 1 }).postcs;
#+END_SRC

::

method::split
Separates the collection into sub-collections at the separator element or subarray. The separator is a link::Classes/Collection::, or anything that can be converted into the class this method is called on. It is strong::not:: included in the output array. The default separator is $/, for the common use in link::Classes/String::.
code::
#+BEGIN_SRC sclang
[1, 2, 1, 2, 3, 1, 2, 1, 3].split([2, 1])
#+END_SRC

::

method::clump
Separates the collection into sub-collections by separating every groupSize elements.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4, 5, 6, 7, 8].clump(3).postcs;
#+END_SRC

::

method::clumps
Separates the collection into sub-collections by separating elements into groupings whose size is given by integers in the groupSizeList.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4, 5, 6, 7, 8].clumps([1, 2]).postcs;
#+END_SRC

::

method::curdle
Separates the collection into sub-collections by randomly separating elements according to the given probability.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4, 5, 6, 7, 8].curdle(0.3).postcs;
#+END_SRC

::

method::integrate
Returns a collection with the incremental sums of all elements.
code::
#+BEGIN_SRC sclang
[3, 4, 1, 1].integrate;
#+END_SRC

::

method::differentiate
Returns a collection with the pairwise difference between all elements.
code::
#+BEGIN_SRC sclang
[3, 4, 1, 1].differentiate;
#+END_SRC

::

method::reduce
Applies the method named by operator to the first and second elements of the collection - then applies the method to the result and to the third element of the collection - then applies the method to the result and to the fourth element of the collection - and so on, until the end of the array.
code::
#+BEGIN_SRC sclang
[3, 4, 5, 6].reduce('*'); // this is the same as [3, 4, 5, 6].product
[3, 4, 5, 6].reduce(\lcm); // Lowest common multiple of the whole set of numbers
["d", "e", (0..9), "h"].reduce('++'); // concatenation
[3, 4, 5, 6].reduce({ |a, b| sin(a) * sin(b) }); // product of sines
#+END_SRC

::
argument::operator
may be a link::Classes/Function:: or a link::Classes/Symbol::.

method::convertDigits
Returns an integer resulting from interpreting the elements as digits to a given base (default 10). See also asDigits in link::Classes/Integer#asDigits:: for the complementary method.
code::
#+BEGIN_SRC sclang
[1, 0, 0, 0].convertDigits;
[1, 0, 0, 0].convertDigits(2);
[1, 0, 0, 0].convertDigits(3);
#+END_SRC

::

method::hammingDistance
Returns the count of array elements that are not equal in identical positions. http://en.wikipedia.org/wiki/Hamming_distance

The collections are not wrapped - if one array is shorter than the other, the difference in size should be included in the count.
code::
#+BEGIN_SRC sclang
[0, 0, 0, 1, 1, 1, 0, 1, 0, 0].hammingDistance([0, 0, 1, 1, 0, 0, 0, 0, 1, 1]);
"SuperMan".hammingDistance("SuperCollider");
#+END_SRC

::

subsection::Math Support - Unary Messages

All of the following messages send the message link::#-performUnaryOp:: to the receiver with the unary message selector as an argument.

method::neg, reciprocal, bitNot, abs, asFloat, asInt, ceil, floor, frac, sign, squared, cubed, sqrt, exp, midicps, cpsmidi, midiratio, ratiomidi, ampdb, dbamp, octcps, cpsoct, log, log2, log10, sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, rand, rand2, linrand, bilinrand, sum3rand, distort, softclip, coin, even, odd, isPositive, isNegative, isStrictlyPositive, real, imag, magnitude, magnitudeApx, phase, angle, rho, theta, asFloat, asInteger

method::performUnaryOp
Creates a new collection of the results of applying the selector to all elements in the receiver.
code::
#+BEGIN_SRC sclang
[1, 2, 3, 4].neg;
[1, 2, 3, 4].reciprocal;
#+END_SRC

::

subsection::Math Support - Binary Messages

All of the following messages send the message link::#-performBinaryOp:: to the receiver with the binary message selector and the second operand as arguments.

method::+, -, *, /, div, %, **, min, max, <, <=, >, >=, &, |, bitXor, lcm, gcd, round, trunc, atan2, hypot, >>, +>>, ring1, ring2, ring3, ring4, difsqr, sumsqr, sqrdif, absdif, amclip, scaleneg, clip2, excess, <!, rrand, exprand

method::performBinaryOp
Creates a new collection of the results of applying the selector with the operand to all elements in the receiver. If the operand is a collection then elements of that collection are paired with elements of the receiver.
code::
#+BEGIN_SRC sclang
([1, 2, 3, 4] * 10);
([1, 2, 3, 4] * [4, 5, 6, 7]);
#+END_SRC

::

subsection::Multichannel wrappers
All of the following messages are performed on the elements of this collection, using link::Classes/Object#-multiChannelPerform::.

The result depends on the objects in the collection, but the main use case is for link::Classes/UGen::s.

See also link::Guides/Multichannel-Expansion::

method::clip, wrap, fold, prune, linlin, linexp, explin, expexp, lincurve, curvelin, bilin, biexp, range, exprange, unipolar, bipolar, lag, lag2, lag3, lagud, lag2ud, lag3ud, varlag, slew, blend, checkBadValues
Calls code:: this.multiChannelPerform(selector, *args) :: where selector is the name of the message.

method::multichannelExpandRef
This method is called internally on inputs to UGens that take multidimensional arrays, like link::Classes/Klank:: and it allows proper multichannel expansion even in those cases. For SequenceableCollection, this returns the collection itself, assuming that it contains already a number of Refs. See link::Classes/Ref:: for the corresponding method implementation.
argument::rank
The depth at which the list is expanded. For instance the Klank spec has a rank of 2. For more examples, see link::Classes/SequenceableCollection#-flopDeep::
code::
#+BEGIN_SRC sclang
`([[[100, 200], 500], nil, [[[0.01, 0.3], 0.8]]]).multichannelExpandRef(2);
[`[[100, 200], nil, [0.2, 0.8]], `[[130, 202], nil, [0.2, 0.5]]].multichannelExpandRef(2);
#+END_SRC

::

subsection:: Rhythm-lists
method:: convertRhythm
Convert a rhythm-list to durations.
discussion::
supports a variation of Mikael Laurson's rhythm list RTM-notation. footnote::
see Laurson and Kuuskankare's 2003, "From RTM-notation to ENP-score-notation"
http://jim2003.agglo-montbeliard.fr/articles/laurson.pdf
::

The method converts a collection of the form code:: [beat-count, [rtm-list], repeats] :: to a link::Classes/List:: of link::Classes/Float::s. A negative integer within the rtm-list equates to a value tied over to the duration following. The method is recursive in that any subdivision within the rtm-list can itself be a nested convertRhythm collection (see example below). The repeats integer has a default value of 1.

If the divisions in the rtm-list are events, the event durations are interpreted as relative durations, and a list of events is returned.
code::
#+BEGIN_SRC sclang
// using numbers as score
[3, [1, 2, 1], 1].convertRhythm; // List[ 0.75, 1.5, 0.75 ]
[2, [1, 3, [1, [2, 1, 1, 1]], 1, 3], 1].convertRhythm;
[2, [1, [1, [2, 1, 1, 1]]], 1].convertRhythm;
[2, [1, [1, [2, 1, 1, 1]]], 2].convertRhythm; // repeat
[2, [1, [1, [2, 1, 1, -1]]], 2].convertRhythm; // negative value is tied over.

// sound example
Pbind(\degree, Pseries(0, 1, inf), \dur, Pseq([2, [1, [1, [2, 1, 1, -1]]], 2].convertRhythm)).play;
#+END_SRC

::

** class:: SerialPort
summary:: serial port interface
categories:: External Control

ClassMethods::

private::initClass

method::new
opening the port.

argument::port
device path or index.

argument::baudrate
baudrate [4800..230400]

argument::databits
5 | 6 | 7 | 8

argument::stopbit
true | false

argument::parity
nil | 'even' | 'odd'

argument::crtscts
hardware flow control (true | false)

argument::xonxoff
software flow control (true | false)

argument::exclusive
open the device exclusively (true | false)

method::devices
returns an array of available device.
code::
#+BEGIN_SRC sclang
SerialPort.devices;
#+END_SRC

::

method::listDevices
prints to postbuffer
code::
#+BEGIN_SRC sclang
SerialPort.listDevices;
#+END_SRC

::

method::devicePattern
change device selection
code::
#+BEGIN_SRC sclang
SerialPort.devicePattern = "/dev/ttyUSB*"; // linux usb serial
SerialPort.devices;

SerialPort.devicePattern = nil;
SerialPort.devices;
#+END_SRC

::

method::closeAll
close all ports.

InstanceMethods::

private::initSerialPort, prOpen, prClose, primCleanup, prCleanup, prPut, prDataAvailable, prDoneAction

method::next
Read a byte from the device. Non-blocking read.

method::read
Read a byte from the device. Blocking read.

method::rxErrors
Rx errors since last query.

method::put
Write a byte to the device. Always blocks.

method::putAll
Write multiple bytes to the device. Collection may be link::Classes/Int8Array:: or link::Classes/String::.

method::doneAction
A link::Classes/Function:: which will be evaluated if the port gets closed (maybe unexpectedly so, due to hardware failure or accidental disconnection). This allows you to for example to make a backup solution and activate it (like using fake input data for your algorithm, or trying to reopen the device). By default it will post a message to the post window.

method::close
close the port.

Examples::

code::
#+BEGIN_SRC sclang
(
p = SerialPort(
	"/dev/tty.usbserial-181",
	baudrate: 9600,
	crtscts: true);
)

// read a byte from the device

p.next;			// doesn't block
fork{p.read.postln};	// may suspend thisThread - should be called within a routine

// write a byte to the device

fork{p.put(42)};	// may suspend thisThread - should be called within a routine

// write multiple bytes to the device

p.putAll("whaddayawant");
p.putAll(Int8Array[13, 10]);

p.doneAction = { "my serial port got closed".postln; }

p.close;	// close the port

SerialPort.closeAll;	// close all ports
#+END_SRC

::

subsection::Arduino write example

First load the sketch Examples/Communication/Dimmer. See http://www.arduino.cc/en/Tutorial/Dimmer

note::
Always make sure the serial monitor is closed in the Arduino application before opening the port in SuperCollider.
::

code::
#+BEGIN_SRC sclang
(
p = SerialPort(
	"/dev/tty.usbserial-A800crTT",	//edit to match your port. SerialPort.listDevices
	baudrate: 9600,	//check that baudrate is the same as in arduino sketch
	crtscts: true);
)

//send serial data - slow pulsating
(
r= Routine({
	inf.do{|i|
		p.put(i.fold(0, 100).linexp(0, 100, 1, 255).asInteger.postln);
		0.02.wait;
	};
}).play;
)

r.stop;
p.close;
#+END_SRC

::

subsection::Arduino read example

First load the sketch Examples/Communication/Graph. See http://www.arduino.cc/en/Tutorial/Graph

note::
Always make sure the serial monitor is closed in the Arduino application before opening the port in SuperCollider.
::

code::
#+BEGIN_SRC sclang
(
p = SerialPort(
	"/dev/tty.usbserial-A800crTT",	//edit to match your port. SerialPort.listDevices
	baudrate: 9600,	//check that baudrate is the same as in arduino sketch
	crtscts: true);
)

//read 10bit serial data sent from Arduino's Serial.println
(
r= Routine({
	var byte, str, res;
	99999.do{|i|
		if(p.read==10, {
			str = "";
			while({byte = p.read; byte !=13 }, {
				str= str++byte.asAscii;
			});
			res= str.asInteger;
			("read value:"+res).postln;
		});
	};
}).play;
)

r.stop;
p.close;
#+END_SRC

::
** class:: Server
summary:: Object representing an sc-server application
categories:: Server>Abstractions
related:: Classes/ServerOptions, Reference/Server-Architecture, Reference/Server-Command-Reference

description::

A Server object is the client-side representation of a server app and is used to control the app from the SuperCollider language application. (See link::Guides/ClientVsServer:: for more details on the distinction.)
It forwards osc-messages and has a number of allocators that keep track of IDs for nodes, buses and buffers.

The server application is a commandline program, so all commands apart from osc-messages are unix commands.

The server application represented by a Server object might be running on the same machine as the client (in the same address space as the language application or separately; see below), or it may be running on a remote machine.

Most of a Server's options are contolled through its instance of ServerOptions. See the link::Classes/ServerOptions:: helpfile for more detail.

subsection:: Paths

Server apps running on the local machine have two unix environment variables: code::SC_SYNTHDEF_PATH:: and code::SC_PLUGIN_PATH::. These indicate directories of synthdefs and ugen plugins that will be loaded at startup. These are in addition to the default synthdef/ and plugin/ directories which are hard-coded.

These can be set within SC using the getenv and setenv methods of class link::Classes/String::.
code::
#+BEGIN_SRC sclang
// all defs in this directory will be loaded when a local server boots
"SC_SYNTHDEF_PATH".setenv("~/scwork/".standardizePath);
"echo $SC_SYNTHDEF_PATH".unixCmd;
#+END_SRC

::

subsection:: The default group

When a Server is booted there is a top level group with an ID of 0 that defines the root of the node tree. (This is represented by a subclass of link::Classes/Group:: : link::Classes/RootNode::.)
If the server app was booted from within SCLang (as opposed to from the command line) the method code::initTree:: will be called automatically after booting.
This will also create a link::Reference/default_group:: with an ID of 1, which is the default group for all link::Classes/Node::s when using object style.
This provides a predictable basic node tree so that methods such as Server-scope, Server-record, etc. can function without running into order of execution problems.

The default group is persistent, i.e. it is recreated after a reboot, pressing cmd-., etc. See link::Classes/RootNode:: and link::Reference/default_group:: for more information.
Note::
If a Server has been booted from the command line you must call code::initTree:: manually in order to initialize the default group, if you want it. See code::initTree:: below.
::

subsection:: Local vs. Internal

In general, when working with a single machine one will probably be using one of two Server objects which are created at startup and stored in the class variables link::#*local:: and link::#*internal::. In SuperCollider.app (OSX), two GUI windows are created to control these. Use link::#-makeGui:: to create a GUI window manually.

The difference between the two is that the local server runs as a separate application with its own address space, and the internal server runs within the same space as the language/client app.

Both local and internal server supports link::#-scope#scoping:: and link::Classes/Bus#Synchronous control bus methods#synchronous bus access::.

The local server, and any other server apps running on your local machine, have the advantage that if the language app crashes, it (and thus possibly your piece) will continue to run. It is thus an inherently more robust arrangement. But note that even if the synths on the server continue to run, any language-side sequencing and control will terminate if the language app crashes.

There is generally no benefit in using the internal server.

subsection:: The default Server

There is always a default Server, which is stored in the class variable code::default::. Any link::Classes/Synth::s or link::Classes/Group::s created without a target will be created on the default server. At startup this is set to be the local server (see above), but can be set to be any Server.

ClassMethods::
private:: initClass

method:: new

argument:: name
a symbol;  each Server object is stored in one global classvariable under its name.

argument:: addr
an optional instance of link::Classes/NetAddr::, providing host and port.
The default is the localhost address using port 57110; the same as the local server.

argument:: options
an optional instance of link::Classes/ServerOptions::. If code::nil::, an instance of ServerOptions will be created, using the default values.

argument:: clientID
an integer. In multi client situations, every client can be given a separate nodeID range. The default is 0.


method:: local
get/set the local server, stored in classvar code::local:: (created already on initClass)

method:: internal
get/set the internal server, stored in classvar code::internal:: (created already on initClass)

method:: default
Get or set the default server. By default this is the local server (see above).
discussion::
Setting this will also assign it to the link::Classes/Interpreter:: variable 's'.
code::
#+BEGIN_SRC sclang
Server.default = Server.internal; // set the internal Server to be the default Server
s.postln; // internal
#+END_SRC

::

method:: all
get/set the set of all servers.

method:: allRunningServers
returns:: the set of all running servers.

method:: quitAll
quit all registered servers

method:: killAll
query the system for any sc-server apps and hard quit them

method:: freeAll
free all nodes in all registered servers

method:: supernova

Switches server program to use supernova. Check link::Classes/ParGroup:: how to make use of multicore hardware with the supernova server.

method:: scsynth

Switches server program to use supernova.


InstanceMethods::

private:: doSend

method:: sendMsg
send an osc message to the server.
discussion::
code::
#+BEGIN_SRC sclang
s.sendMsg("/s_new", "default", s.nextNodeID, 0, 1);
#+END_SRC

::

method:: sendBundle
send an osc bundle to the server.
discussion::
Since the network may have irregular performance, time allows for the bundle to be evaluated at a specified point in the future.
Thus all messages are synchronous relative to each other, but delayed by a constant offset.
If such a bundle arrives late, the server replies with a late message but still evaluates it.
code::
#+BEGIN_SRC sclang
s.sendBundle(0.2, ["/s_new", "default", x = s.nextNodeID, 0, 1], ["/n_set", x, "freq", 500]);
#+END_SRC

::

method:: sendRaw

method:: listSendMsg
as sendMsg, but takes an array as argument.

method:: listSendBundle
as sendBundle, but takes an array as argument.
discussion::
This allows you to collect messages in an array and then send them.
code::
#+BEGIN_SRC sclang
s.listSendBundle(0.2, [["/s_new", "default", x = s.nextNodeID, 0, 1],
    ["/n_set", x, "freq", 600]]);
#+END_SRC

::

method:: sendSynthDef
send a synthDef to the server that was written in a local directory

method:: loadSynthDef
load a synthDef that resides in the remote directory

method:: loadDirectory
load all the SynthDefs in the directory dir.
argument:: dir
a link::Classes/String:: which is a valid path.
argument:: completionMsg

method:: nextNodeID
get a unique nodeID.

method:: nextPermNodeID
get a permanent node ID. This node ID is in a reserved range and will be held until you explicitly free it.

method:: freePermNodeID
free a permanent node ID for later reuse.

method:: wait
this can be used within a link::Classes/Routine:: to wait for a server reply

method:: waitForBoot
Evaluate "onComplete" as soon as the server has booted. This method will boot the server for you if it is not already running or booting. If the server is already running, "onComplete" is executed immediately.
argument:: onComplete
A function to evaluate after the server has booted successfully.
argument:: limit
The number of times to check for a successful boot. (5 times/sec)
argument:: onFailure
A function to evaluate after the server fails to boot. If onFailure is not given, an error message is posted. Providing a function suppresses the error message. If you want to supply a function and print the normal error message, make sure that your function returns "false," e.g. code::s.waitForBoot(onFailure: { ... custom action...; false })::.

method:: doWhenBooted
Evaluate "onComplete" as soon as the server has booted. This method assumes the server is being booted explicitly through a separate code::boot:: call. If the server is already running, "onComplete" is executed immediately.
argument:: onComplete
A function to evaluate after the server has booted successfully.
argument:: limit
The number of times to check for a successful boot.
argument:: onFailure
A function to evaluate after the server fails to boot. If onFailure is not given, an error message is posted. Providing a function suppresses the error message. If you want to supply a function and print the normal error message, make sure that your function returns "false," e.g. code::s.doWhenBooted(onFailure: { ... custom action...; false })::.

method:: boot
boot the remote server, create new allocators.
argument:: startAliveThread
If true, start a Routine to send a /status message to the server every so often. The interval between the messages is set by code::theServer.aliveThreadPeriod = (seconds)::. The default period is 0.7. If false, /status will not be sent and the server's window will not update.
argument:: recover
If true, create a new node ID allocator for the server, but use the old buffer and bus allocators. This is useful if the server process did not actually stop. In normal use, the default value "false" should be used.
argument:: onFailure
In this method, the onFailure argument is for internal use only. If you wish to take specific actions when the server boots or fails to boot, it is recommended to use link::#-waitForBoot:: or link::#-doWhenBooted::.
discussion::
N.B. You cannot boot a server app on a remote machine.

method:: quit
quit the server application

method:: reboot
quit and restart the server application

method:: freeAll
free all nodes in this server

method:: status
query the server status

method:: notify
server sends notifications, for example if a node was created, a 'tr' message from a link::Classes/SendTrig::, or a strong::/done:: action. if code::flag:: is set to false, these messages are not sent. The default is true.

method:: ping
measure the time between server and client, which may vary. the code::func:: is
evaluated after code::n:: number of times and is passed the resulting maximum.

method:: options
Get or set this Server's link::Classes/ServerOptions:: object. Changes take effect when the server is rebooted.

method:: defaultGroup
returns:: this Server's default group.

method:: volume
Get an instance of Volume that runs after the defualt group, or sets the Volume of the Server's output to level. Level is in db.

method:: mute
mute the server's output. This can also be toggled from the Server window with the 'm' key.

method:: unmute
unmute the server. This can also be toggled from the Server window with the 'm' key.

method:: reorder
Move the nodes in code::nodeList:: to the location specified by code::target:: and code::addAction::, placing them there in the order indicated by nodeList.
discussion::
Any nodes which have already been freed will be skipped. Passing nil for target and addAction will result in the location being the head of the default group.
code::
#+BEGIN_SRC sclang
g = Group.new;
x = Array.fill(5, {Synth(\default)});
s.queryAllNodes;
s.reorder(x, g, \addToTail);
s.queryAllNodes;
#+END_SRC

::

method:: inputBus
Return a link::Classes/Bus:: object that represents the input audio bus.

method:: outputBus
Return a link::Classes/Bus:: object that represents the output audio bus.


subsection:: Information and debugging

method:: dumpOSC
argument:: code
table::
## 0 || turn dumping OFF.
## 1 || print the parsed contents of the message.
## 2 || print the contents in hexadecimal.
## 3 || print both the parsed and hexadecimal representations of the contents.
::

note:: teletype::/status:: messages won't be posted, when dumping is enabled::

method:: queryAllNodes
Post a representation of this Server's current node tree to the post window. See link::#-plotTree:: for a graphical variant.
discussion::
Very helpful for debugging. For local servers this uses g_dumpTree and for remote g_queryTree. See link::Classes/Group:: and link::Reference/Server-Command-Reference:: for more info.
code::
#+BEGIN_SRC sclang
s.boot;
s.queryAllNodes; // note the root node (ID 0) and the default group (ID 1)
s.quit;
#+END_SRC

::

method:: peakCPU, avgCPU
Get peak and average CPU usage.

method:: numSynths
Get number of running link::Classes/Synth::s.

method:: numGroups
Get number of link::Classes/Group::s.

method:: numUGens
Get number of running link::Classes/UGen::s.

method:: numSynthDefs
Get number of loaded link::Classes/SynthDef::initions.

method:: pid
Get process ID of running server (if not internal).

method:: hasShmInterface
Returns true if a link::Classes/ServerShmInterface:: is available. See also link::Classes/Bus#Synchronous control bus methods::.
discussion::
The shared memory interface is initialized after first server boot.

subsection:: Automatic Message Bundling

Server provides support for automatically bundling messages. This is quite convenient in object style, and ensures synchronous execution. See also link::Guides/Bundled-Messages::

method:: makeBundle
The Function code::func:: is evaluated, and all OSC messages generated by it are deferred and added to a bundle.
argument:: time
If set to nil or a number the bundle will be automatically sent and executed after the corresponding delay in seconds. If code::time:: is set to false the bundle will not be sent.
argument:: func
The function to evaluate.
argument:: bundle
allows you to pass in a preexisting bundle and continue adding to it.
returns:: The bundle so that it can be further used if needed.
discussion::
Calling code::sync:: inside func will split the bundle and wait for asynchronous actions to complete before continuing.

If an error is encountered while evaluating code::func:: this method will throw an link::Classes/Error:: and stop message deferral.
code::
#+BEGIN_SRC sclang
s.boot;
(
// send a synth def to server
SynthDef("tpulse", { arg out=0,freq=700,sawFreq=440.0;
	Out.ar(out, SyncSaw.ar(freq,  sawFreq,0.1) )
}).add;
)

// all OSC commands generated in the function contained below will be added to a bundle
// and executed simultaneously after 2 seconds.
(
s.makeBundle(2.0, {
	x = Synth.new("tpulse");
	a = Bus.control.set(440);
	x.map(\freq, a);
});
)
x.free;

// don't send
(
b = s.makeBundle(false, {
	x = { PinkNoise.ar(0.1) * In.kr(0, 1); }.play;
});
)
// now pass b as a pre-existing bundle, and start both synths synchronously
(
s.makeBundle(nil, { // nil executes ASAP
	y = { SinOsc.kr(0.2).abs }.play(x, 0, 0, \addBefore); // sine envelope
}, b);
)
x.free; y.free;

// Throw an Error
(
try {
	s.makeBundle(nil, {
		s.farkermartin;
	});
} { |error|
	("Look Ma, normal operations resume even though:\n" + error.errorString).postln;
	x = { FSinOsc.ar(440, 0, 0.2) }.play; // This works fine
}
)
x.free;

// use sync
(
s.makeBundle(nil, {
	b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
	s.sync; // wait until load is done and then send the rest of the bundle
	x = { PlayBuf.ar(1, b) * 0.5 }.play;
});
)
x.free; b.free;
#+END_SRC

::

method:: bind
Just as in code::makeBundle::, the Function code::func:: is evaluated, and all OSC messages generated by it are deferred and added to a bundle, which is sent to the server, using the server default latency.
discussion::
code::
#+BEGIN_SRC sclang
(
s.bind {
	a = { |freq=100| SinOsc.ar(freq, LFTri.ar(freq)) * 0.2 }.play;
	a.set(\freq, 400);
}
)
#+END_SRC

::

subsection:: Shared Controls

The internal server has a number of shared control buses. Their values can be set or polled using the methods below.

method:: getSharedControl
get the current value of a shared control bus. num is the index of the bus to poll. This command is synchronous and only works with the internal server.

method:: setSharedControl
set the current value of a shared control bus to value. num is the index of the bus to set. This command is synchronous and only works with the internal server.

method:: allocSharedControls
set the number of shared control buses. Must be done before the internal server is booted. The default is 1024.

subsection:: Persistent Node Trees

The class link::Classes/ServerTree:: can be used to store functions which will be evaluated after the server is booted, after all nodes are freed, and after cmd-. is pressed.
This allows, for example, for one to create a persistent basic node structure. ServerTree is evaluated in the method initTree after the default group is created, so its existence can be relied upon.

method:: initTree
This method initializes the link::Reference/default_group:: and runs link::Classes/ServerTree::.
discussion::
This method is called automatically when you boot a Server from the language. N.B. If you started a server app from the command line you will have to call initTree manually if you need this functionality.
code::
#+BEGIN_SRC sclang
s.quit;
f = {Group.new(s.defaultGroup); "Other code can be evaluated too".postln;};
ServerTree.add(f);
s.boot;
s.queryAllNodes; // note the group within the default group
ServerTree.remove(f);
#+END_SRC

::
link::Classes/ServerBoot:: and link::Classes/ServerQuit:: provide similar functionality at boot and quit times.

subsection:: GUI methods

method:: makeGui
Create and show the server window. The window responds to a number of keyboard shortcuts:
table::
## strong::key:: || strong::action::
## teletype::n:: || Post a representation of this Server's current node tree to the post window. (See link::#-queryAllNodes::)
## teletype::N:: || As 'n' above but include controls.
## teletype::l:: || Show input/output level meters. (See link::#-meter::)
## teletype::p:: || Show graphical view of the node tree. (See link::#-plotTree::)
## (space) || Boot server if not already booted. (See link::#-boot::)
## teletype::s:: || Show scope window. (See link::#-scope::)
## teletype::f:: || Show frequency analyzer window. (See link::#-freqscope::)
## teletype::d:: || Toggle dumping of OSC messages.
## teletype::m:: || Toggle mute.
## teletype::0:: || Reset volume to 0 db.
::


method:: scope
Open a scope window showing the output of the Server.
see link::Classes/Stethoscope:: for further details.

argument:: numChannels
the number of channels to be scoped out. The default is this server's options' numOutputBusChannels.
argument:: index
the first channel to be output. The default is 0.
argument:: bufsize
the size of the buffer for the ScopeView. The default is 4096.
argument:: zoom
a zoom value for the scope's X axis. Larger values show more. The default is 1.
argument:: rate
whether to display audio or control rate buses (either \audio or \control)

method:: freqscope
Show frequency analyzer window.

method:: meter
Show input/output level meters.

method:: plotTree
Plot the node/group tree. As link::#-queryAllNodes:: but graphical.

subsection:: Recording Support

The following methods are for convenience use. For recording with sample accurate start and stop times you should make your own nodes. See the link::Classes/DiskOut:: helpfile for more info. For non-realtime recording, see the link::Guides/Non-Realtime-Synthesis:: helpfile.

This functionality is also available through the recording button on the server windows.
Pressing it once calls record, and pressing it again calls stopRecording (see below). When doing so the file created will be in your recordings folder and be named for the current date and time.
The default location of the recordings folder varies from platform to platform but is always stored in code::thisProcess.platform.recordingsDir::. Setting this variable allows you to change the default.

NOTE::
record creates the recording synth after the Server's default group and uses In.ar. Thus if you add nodes after the recording synth their output will not be captured.
To avoid this, either use Node objects (which use the default node as their target) or (when using messaging style) use a target nodeID of 1.
code::
#+BEGIN_SRC sclang
s.sendMsg("/s_new", "default", s.nextNodeID, 1,1);
#+END_SRC

::
::

For more detail on this subject see link::Guides/Order-of-execution::, link::Reference/default_group::, and link::Guides/NodeMessaging::.

See link::Classes/SoundFile:: for information on the various sample and header formats.
Not all sample and header formats are compatible. Note that the sampling rate of the output file will be the same as that of the server app. This can be set using the Server's link::Classes/ServerOptions::.

Example:
code::
#+BEGIN_SRC sclang
s.boot; // start the server

// something to record
(
SynthDef("bubbles", {
	var f, zout;
	f = LFSaw.kr(0.4, 0, 24, LFSaw.kr([8,7.23], 0, 3, 80)).midicps; // glissando function
	zout = CombN.ar(SinOsc.ar(f, 0, 0.04), 0.2, 0.2, 4); // echoing sine wave
	Out.ar(0, zout);
}).add;
SynthDef("tpulse", { arg out=0,freq=700,sawFreq=440.0;
	Out.ar(out, SyncSaw.ar(freq,  sawFreq,0.1) )
}).add;

)

x = Synth.new("bubbles");

s.prepareForRecord; // you have to call this first

s.record;

s.pauseRecording; // pausable

s.record // start again

s.stopRecording; // this closes the file and deallocates the buffer recording node, etc.

x.free; // stop the synths

// look in your recordings folder and you'll find a file named for this date and time
#+END_SRC

::

method:: prepareForRecord
Allocates the necessary buffer, etc. for recording the server's output. (See code::record:: below.)
argument:: path
a link::Classes/String:: representing the path and name of the output file.
discussion::
If you do not specify a path than a file will be created in your recordings folder (see the note above on this) called SC_thisDateAndTime. Changes to the header or sample format, or to the number of channels must be made strong::before:: calling this.

method:: record
Starts or resumes recording the output.
argument:: path
this is optional, and is passed to code::prepareForRecord:: (above).
discussion::
If you have not called prepareForRecord first (see above) then it will be invoked for you (but that adds a slight delay before recording starts for real).

method:: pauseRecording
Pauses recording. Can be resumed by executing record again.

method:: stopRecording
Stops recording, closes the file, and frees the associated resources.
discussion::
You must call this when finished recording or the output file will be unusable. Cmd-. while recording has the same effect.

method:: recordNode
Returns:: the current recording synth so that it can be used as a target. This should only be necessary for nodes which are not created in the default group.

method:: recChannels
Get/set the number of channels (int) to record. The default is two. Must be called strong::before:: prepareForRecord.

method:: recHeaderFormat
Get/set the header format (string) of the output file. The default is "aiff". Must be called strong::before:: prepareForRecord.

method:: recSampleFormat
Get/set the sample format (string) of the output file. The default is "float". Must be called strong::before:: prepareForRecord.

subsection:: Asynchronous Commands

Server provides support for waiting on the completion of asynchronous OSC commands such as reading or writing soundfiles. N.B. The following methods must be called from within a running link::Classes/Routine::. Explicitly passing in a link::Classes/Condition:: allows multiple elements to depend on different conditions. The examples below should make clear how all this works.

method:: bootSync
Boot the Server and wait until it has completed before resuming the thread.
argument:: condition
an optional instance of link::Classes/Condition:: used for evaluating this.

method:: sendMsgSync
Send the following message to the wait until it has completed before resuming the thread.
argument:: condition
an optional instance of link::Classes/Condition:: used for evaluating this.
argument:: ... args
one or more valid OSC messages.

method:: sync
Send a code::/sync:: message to the server, which will replie with the message code::/synced:: when all pending asynchronous commands have been completed.
argument:: condition
an optional instance of link::Classes/Condition:: used for evaluating this.
argument:: bundles
one or more OSC messages which will be bundled before the sync message (thus ensuring that they will arrive before the /sync message). argument:: latency
allows for the message to be evaluated at a specific point in the future.

discussion::
This may be slightly less safe then sendMsgSync under UDP on a wide area network, as packets may arrive out of order, but on a local network should be okay. Under TCP this should always be safe.
code::
#+BEGIN_SRC sclang
(
Routine.run {
	var c;

	// create a condition variable to control execution of the Routine
	c = Condition.new;

	s.bootSync(c);
	\BOOTED.postln;

	s.sendMsgSync(c, "/b_alloc", 0, 44100, 2);
	s.sendMsgSync(c, "/b_alloc", 1, 44100, 2);
	s.sendMsgSync(c, "/b_alloc", 2, 44100, 2);
	\b_alloc_DONE.postln;
};
)

(
Routine.run {
	var c;

	// create a condition variable to control execution of the Routine
	c = Condition.new;

	s.bootSync(c);
	\BOOTED.postln;

	s.sendMsg("/b_alloc", 0, 44100, 2);
	s.sendMsg("/b_alloc", 1, 44100, 2);
	s.sendMsg("/b_alloc", 2, 44100, 2);
	s.sync(c);
	\b_alloc_DONE.postln;
};
)
#+END_SRC

::

section:: Keyboard Shortcuts

when a server window is in focus, these shortcuts can be used:
table::
## space || start the server
## d || toggle dumpOSC
## n || post a representation of the node tree
## N || post a representation of the node tree and the current control values of any synths
## s || scope
::

** class:: ServerBoot
summary:: register actions to be taken when a server has booted
related:: Classes/Server, Classes/ServerQuit, Classes/ServerTree, Classes/StartUp
categories:: Control

description::
The singleton ServerBoot provides a place for registering functions and objects for events that should happen when a given server has booted.

See link::Classes/AbstractServerAction:: for usage.

ClassMethods::

private::initClass
** class:: ServerOptions
summary:: Encapsulates commandline and other options for a Server
categories:: Server
related:: Classes/Server, Reference/Server-Architecture, Reference/Server-Command-Reference

description::

ServerOptions encapsulates various options for a server app within an object. This makes it convenient to launch multiple servers with the same options, or to archive different sets of options, etc.
Every link::Classes/Server:: has an instance of ServerOptions created for it if one is not passed as the options argument when the Server object is created. (This is the case for example with the local and internal Servers which are created at startup.)

A Server's instance of ServerOptions is stored in its options instance variable, which can be accessed through corresponding getter and setter methods.

N.B. A ServerOptions' instance variables are translated into commandline arguments when a server app is booted. Thus a running Server must be rebooted before changes will take effect. There are also a few commandline options which are not currently encapsulated in ServerOptions. See link::Reference/Server-Architecture:: for more details.

ClassMethods::
private:: prListDevices

method:: new
Create and return a new instance of ServerOptions.

method:: devices
Return an Array of Strings listing the audio devices currently available on the system.

method:: inDevices
Return an Array of Strings listing the audio devices currently available on the system which have input channels.

method:: outDevices
Return an Array of Strings listing the audio devices currently available on the system which have output channels.

instancemethods::
subsection:: The Options

method:: blockSize
The number of samples in one control period. The default is 64.

method:: device
A String that allows you to choose a sound device to use as input and output. The default, nil will use the system's default input and output device(s) (more below in the examples).

note::When the server is compiled for jack natively, the teletype::device:: can be used to connect to a named server and
use a specific client name. The argument specifies either a server name or a server name and the requested client
name. Passing code::nil:: is equivalent to to teletype::default:SuperCollider::.

The jack connections can be configured via the environment variables teletype::SC_JACK_DEFAULT_INPUTS:: and
teletype::SC_JACK_DEFAULT_OUTPUTS::. The format is either a string that specifies the another jack client or a
comma-separate list of jack ports.

code::
#+BEGIN_SRC sclang
// connect first to input channels with system
"SC_JACK_DEFAULT_INPUTS".setenv("system:capture_1,system:capture_2");

// connect all output channels with system
"SC_JACK_DEFAULT_OUTPUTS".setenv("system");
#+END_SRC

::

::

method:: inDevice
A String that allows you to choose an input sound device. The default, nil will use the system's default input device (more below in the examples).

method:: outDevice
A String that allows you to choose an output sound device. The default, nil will use the system's default output device (more below in the examples).

method:: hardwareBufferSize
The preferred hardware buffer size. If non-nil the server app will attempt to set the hardware buffer frame size. Not all sizes are valid. See the documentation of your audio hardware for details. Default value is nil.

method:: initialNodeID
By default, the Server object in the client begins allocating node IDs at 1000, reserving 0-999 for "permanent" nodes. You may change this default here.

method:: inputStreamsEnabled
A String which allows turning off input streams that you are not interested in on the audio device. If the string is "01100", for example, then only the second and third input streams on the device will be enabled. Turning off streams can reduce CPU load. The default value is nil.

method:: loadDefs
A Boolean indicating whether or not to load the synth definitions in synthdefs/ (or anywhere set in the environment variable SC_SYNTHDEF_PATH) at startup. The default is true.

method:: maxNodes
The maximum number of nodes. The default is 1024.

method:: maxSynthDefs
The maximum number of synthdefs. The default is 1024.

method:: memSize
The number of kilobytes of real time memory allocated to the server. This memory is used to allocate synths and any memory that unit generators themselves allocate (for instance in the case of delay ugens which do not use buffers, such as CombN), and is separate from the memory used for buffers. Setting this too low is a common cause of 'exception in real time: alloc failed' errors. The default is 8192.

method:: numAudioBusChannels
The number of audio rate busses, which includes input and output busses. The default is 128.

method:: numBuffers
The number of global sample buffers available. (See Buffer.) The default is 1024.

method:: numControlBusChannels
The number of internal control rate busses. The default is 4096.

method:: numInputBusChannels
The number of audio input bus channels. This need not correspond to the number of hardware inputs. The default is 8.

method:: numOutputBusChannels
The number of audio output bus channels. This need not correspond to the number of hardware outputs (this can be useful for instance in the case of recording). The default is 8.

method:: numRGens
The number of seedable random number generators. The default is 64.

method:: numWireBufs
The maximum number of buffers that are allocated to interconnect unit generators. (Not to be confused with the global sample buffers represented by Buffer.) This sets the limit of complexity of SynthDefs that can be loaded at runtime. This value will be automatically increased if a more complex def is loaded at startup, but it cannot be increased thereafter without rebooting. The default is 64.

method:: outputStreamsEnabled
A String which allows turning off output streams that you are not interested in on the  audio device. If the string is "11000", for example, then only the first two output streams on the device will be enabled. Turning off streams can reduce CPU load.

method:: protocol
A Symbol representing the communications protocol. Either code::\udp:: or code::\tcp::. The default is code::\udp::.

method:: remoteControlVolume
A Boolean indicating whether this server should allow its volume to be set remotely. The default value is code::false::.

method:: sampleRate
The preferred sample rate. If non-nil the server app will attempt to set the sample rate of the hardware. The hardware has to support the sample rate that you choose.

method:: verbosity
Controls the verbosity of server messages. A value of 0 is normal behaviour, -1 suppresses informational messages, and -2 suppresses informational and many error messages. The default is 0.

method:: zeroConf
A Boolean indication whether or not the server should publish its port using zero configuration networking, to facilitate network interaction. This is true by default; if you find unacceptable delays (beachballing) upon server boot, you can try setting this to false.

method:: restrictedPath
Allows you to restrict the system paths in which scsynth is allowed to read/write files during running. A nil value (the default) means no restriction. Otherwise, set it as a string representing a single path.

method:: threads
Number of audio threads that are spawned by supernova. For scsynth this value is ignored. If it is code::nil::or 0, it
uses the one thread per CPU. Default is code::nil::.

method:: memoryLocking
A Boolean indicating whether the server should try to lock its memory into physical RAM. Default is code::false::.


subsection:: Other Instance Methods
method:: asOptionsString
argument:: port
The port number for the resulting server app. Default value is 57110.
Returns:: a String specifying the options in the format required by the command-line scsynth app.

method:: firstPrivateBus
Returns:: the index of the first audio bus on this server which is not used by the input and output hardware.


Examples::
code::
#+BEGIN_SRC sclang
// Get the local server's options

o = Server.local.options;

// Post the number of output channels

o.numOutputBusChannels.postln;

// Set them to a new number

o.numOutputBusChannels = 6; // The next time it boots, this will take effect

// specify a device

o.device ="MOTU Traveler"; 	// use a specific soundcard
o.device = nil;			// use the system default soundcard

// Create a new instance of ServerOptions

o = ServerOptions.new;

// Set the memory size to twice the default

o.memSize = 4096;

// Create a new Server on the local machine using o for its options

t = Server(\Local2, NetAddr("127.0.0.1", 57111), o);
t.makeWindow;
t.boot;
t.quit;
#+END_SRC

::

** class:: ServerQuit
summary:: register actions to be taken when a server quits
related:: Classes/Server, Classes/ServerBoot, Classes/ServerTree, Classes/ShutDown
categories:: Control

description::
The singleton ServerQuit provides a place for registering functions and objects for events that should happen when a given server quits.

See link::Classes/AbstractServerAction:: for usage.

ClassMethods::

private::initClass
** class:: ServerTree
summary:: register actions to be taken to initialise a basic tree of groups on the server
related:: Classes/Server, Classes/ServerQuit, Classes/ServerBoot, Classes/CmdPeriod
categories:: Control

description::
The singleton ServerTree provides a place for registering functions and objects for events that should happen when a given server has booted and when all synths are freed. This is to initialise a basic tree of groups on the server.

See link::Classes/AbstractServerAction:: for usage.

ClassMethods::

private::initClass
** CLASS::Set
summary::a set according to equality
related::Classes/IdentitySet, Classes/List, Classes/Dictionary
categories::Collections>Unordered

DESCRIPTION::
A Set is s collection of objects, no two of which are equal. Most of its methods are inherited from Collection. The contents of a Set are unordered. You must not depend on the order of items in a set. For an ordered set, see link::Classes/OrderedIdentitySet::.

INSTANCEMETHODS::

private::initSet, putCheck, fullCheck, grow, noCheckAdd

subsection::Adding and Removing

method::add
Add anObject to the Set. An object which is equal to an object already in the Set will not be added.
code::
#+BEGIN_SRC sclang
Set[1, 2, 3].add(4).postln;
Set[1, 2, 3].add(3).postln;
Set["abc", "def", "ghi"].add("jkl").postln;
Set["abc", "def", "ghi"].add("def").postln;
#+END_SRC

::

method::remove
Remove anObject from the Set.
code::
#+BEGIN_SRC sclang
Set[1, 2, 3].remove(3).postln;
#+END_SRC

::

subsection::Iteration

method::do
Evaluates function for each item in the Set. The function is passed two arguments, the item and an integer index.
code::
#+BEGIN_SRC sclang
Set[1, 2, 3, 300].do({ arg item, i; item.postln });
#+END_SRC

::

method::keyAt
Returns the object at the internal strong::index::. This index is not deterministic.

subsection::Set specific operations

method::sect, &
Return the set theoretical intersection of this and strong::that::.
code::
#+BEGIN_SRC sclang
a = Set[1, 2, 3]; b = Set[2, 3, 4, 5];
sect(a, b);
a & b // shorter syntax
#+END_SRC

::

method::union, |
Return the set theoretical union of this and strong::that::.
code::
#+BEGIN_SRC sclang
a = Set[1, 2, 3]; b = Set[2, 3, 4, 5];
union(a, b);
a | b // shorter syntax
#+END_SRC

::

method::difference, -
Return the set of all items which are elements of this, but not of strong::that::.
code::
#+BEGIN_SRC sclang
a = Set[1, 2, 3]; b = Set[2, 3, 4, 5];
difference(a, b);
a - b // shorter syntax
#+END_SRC

::

method::symmetricDifference, --
Return the set of all items which are not elements of both this and strong::that::.
code::
#+BEGIN_SRC sclang
a = Set[1, 2, 3]; b = Set[2, 3, 4, 5];
symmetricDifference(a, b);
a -- b // shorter syntax
#+END_SRC

::

method::isSubsetOf
Returns true if all elements of this are also elements of strong::that::.
code::
#+BEGIN_SRC sclang
a = Set[1, 2, 3, 4];
Set[1, 2].isSubsetOf(a); // true
Set[1, 5].isSubsetOf(a); // false
#+END_SRC

::

EXAMPLES::

code::
#+BEGIN_SRC sclang
a = Set[1, 2, 3, 4];
b = a.powerset; // set of all parts
a.isSubsetOf(b); // false: no set is ever part of itself.
b.asArray.reduce(\union) == a; // true parts may not contain other elements that original
b.asArray.reduce(\difference).isEmpty; // true.
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// you can use Set to efficiently remove duplicates from an array:

a = [1, 2, 3, 4, 3, 5, 5, 2, 2, 1];
a.as(Set);		// convert to set
a.as(Set).as(Array);	// and convert back
#+END_SRC

::
** class:: SetResetFF
summary:: Set-reset flip flop.
related:: Classes/ToggleFF
categories::  UGens>Triggers


Description::

Output is set to 1.0 upon receiving a trigger in the trig input, and to
0.0 upon receiving a trigger in the reset input. Once the flip flop is
set to zero or one further triggers in the same input are have no effect.
One use of this is to have some precipitating event cause something to
happen until you reset it.

If both inputs receive a trigger at the same time, the teletype::reset:: input takes precedence. The output will be 0. See the examples below.

classmethods::

method::ar, kr

argument::trig

The trigger that sets output to 1. Trigger can be any signal.
A trigger happens when the signal changes from non-positive to
positive.


argument::reset

The trigger that sets output to 0. Trigger can be any signal.
A trigger happens when the signal changes from non-positive to
positive.


Examples::

code::
#+BEGIN_SRC sclang

(
play({
	a = Dust.ar(5); // the set trigger
	b = Dust.ar(5); // the reset trigger
	SetResetFF.ar(a,b) * BrownNoise.ar(0.2);

}))
#+END_SRC

::

subsection::Simultaneous triggers

Here, 'reset' is triggered twice as often as 'trig'. Since 'trig' is always matched by a 'reset', the output is 0. (If 'trig' took precedence, you would have a 50%-duty-cycle pulse wave.)

code::
#+BEGIN_SRC sclang
a = { SetResetFF.kr(Impulse.kr(50), Impulse.kr(100)) }.plot(duration: 0.1);
#+END_SRC

::

You can reverse this behavior, by reversing the inputs so that SetResetFF is triggered twice as often as resetting. This results in a signal that is 0 initially and switches to 1 halfway through the cycle: emphasis::reset, then trigger::. To make it emphasis::trigger, then reset::, invert the phase: code::1 - SetResetFF::.

code::
#+BEGIN_SRC sclang
a = { 1 - SetResetFF.kr(Impulse.kr(100), Impulse.kr(50)) }.plot(duration: 0.1);
#+END_SRC

::

** class:: Shaper
summary:: Wave shaper.
related:: Classes/Index, Classes/WrapIndex
categories::  UGens>Buffer

Description::
Performs waveshaping on the input signal by indexing into the table.

classmethods::
method::ar, kr

argument::bufnum
The number of a buffer filled in wavetable format containing the
transfer function.

argument::in
The input signal.


Examples::
code::
#+BEGIN_SRC sclang
s.boot;

b = Buffer.alloc(s, 512, 1, { |buf| buf.chebyMsg([1,0,1,1,0,1])});

(
{
	Shaper.ar(
		b,
		SinOsc.ar(300, 0, Line.kr(0,1,6)),
		0.5
	)
}.scope;
)

b.free;
#+END_SRC

::

image::chebyshevpolynomials.png::

Wave shaping transfer functions are typically designed by using Chebyshev polynomials to control which harmonics are generated when a cosine wave is passed in. The implementation in SuperCollider compensates for the DC offset due to even polynomial terms, making sure that when 0 is put into the transfer function, you get 0 out. By default, normalization is set to true, which avoids output overload. If you want to construct a transfer function without this, you need to be careful with the final output scaling, since it could easily overload the -1 to 1 range for audio.
code::
#+BEGIN_SRC sclang
// I want the first harmonic at 0.25 amplitude, second at 0.5, third at 0.25
b = Buffer.alloc(s, 512, 1, {arg buf; buf.chebyMsg([0.25,0.5,0.25], false)});

(
{
	Shaper.ar(
		b,
		SinOsc.ar(440, 0.5pi, Line.kr(0,1,6)), //input cosine wave
		0.5 //scale output down because otherwise it goes between -1.05 and 0.5, distorting...
	)
}.scope;
)

b.free;
#+END_SRC

::

For those who like to make their own wavetables for arbitrary shapers, your buffer must be in wavetable format to have a valid transfer function. Wavetable format is a special representation to make linear interpolation faster (see at the bottom of this file). You don't have to worry about this directly, because there are two straight forward ways to get wavetables into a server buffer. First, the server can generate them (see the Buffer help file for the methods sine1, sine2, sine3 and cheby):
code::
#+BEGIN_SRC sclang
b = Buffer.alloc(s, 1024, 1);
b.cheby([1, 0.5, 1, 0.125]);

(
{ 	var	sig = Shaper.ar(b, SinOsc.ar(440, 0, 0.4));
	sig ! 2
}.scope;
)

b.free;
#+END_SRC

::
Or, you can calculate the transfer function in a client-side array (Signal class) then convert it to a wavetable and send the data over.
code::
#+BEGIN_SRC sclang
b = Buffer.alloc(s, 1024, 1);

//size must be power of two plus 1
t = Signal.chebyFill(513,[1, 0.5, 1, 0.125]);

// linear function
t.plot

// t.asWavetableNoWrap will convert it to the official Wavetable format at next power of two size
b.sendCollection(t.asWavetableNoWrap);  // may also use loadCollection here

b.plot

(
{ 	var	sig = Shaper.ar(b, SinOsc.ar(440, 0, 0.4));
	sig ! 2
}.scope;
)

b.free;
#+END_SRC

::

This way of working then allows you to get creative with your transfer functions!
code::
#+BEGIN_SRC sclang
b = Buffer.alloc(s, 1024, 1);

// or, for an arbitrary transfer function, create the data at 1/2 buffer size + 1
t = Signal.fill(513, { |i| i.linlin(0.0, 512.0, -1.0, 1.0) });

// linear function
t.plot

// t.asWavetable will convert it to the official Wavetable format at twice the size
b.sendCollection(t.asWavetableNoWrap);  // may also use loadCollection here

// shaper has no effect because of the linear transfer function
(
{ 	var	sig = Shaper.ar(b, SinOsc.ar(440, 0, 0.4));
	sig ! 2
}.scope;
)


// now for a twist
(
a = Signal.fill(256, { |i|
	var t = i/255.0;
	t + (0.1 * (max(t, 0.1) - 0.1) * sin(2pi * t * 80 + sin(2pi * 25.6 * t)))
})
);

a.plot

d = (a.copy.reverse.neg) ++(Signal[0])++ a;

d.plot

d.size	//must be buffer size/2 + 1, so 513 is fine

b.sendCollection(d.asWavetableNoWrap);  // may also use loadCollection here

b.plot // wavetable format!

// test shaper
(
{
	Shaper.ar(
		b,
		SinOsc.ar(440, 0.5, Line.kr(0,0.9,6))
	)
}.scope
)
#+END_SRC

::

subsection:: Advanced notes: wavetable format
code::
#+BEGIN_SRC sclang
Signal: [a0, a1, a2...]
Wavetable: [2*a0-a1, a1-a0, 2*a1-a2, a2-a1, 2*a2-a3, a3-a2...]
#+END_SRC

::
This strange format is not a standard linear interpolation (integer + frac), but for (integer part -1) and (1+frac))  due to some efficient maths for integer to float conversion in the underlying C code.

** class:: SharedIn
summary:: Read from a shared control bus.
related:: Classes/SharedOut
categories::  UGens>InOut


Description::

warning::
SharedIn has been deprecated. Synchronous access to busses on local servers is possible via
link::Classes/Bus#-getSynchronous:: and link::Classes/Bus#-setSynchronous::
::

Reads from a control bus shared between the internal server and the SC
client. Control rate only. Writing to a shared control bus from the
client is synchronous. When not using the internal server use node
arguments or the set method of Bus (or /c_set in messaging style).


classmethods::

method::kr

argument::bus

The index of the shared control bus to read from.


argument::numChannels

the number of channels (i.e. adjacent buses) to read in. The
default is 1. You cannot modulate this number by assigning it to
an argument in a SynthDef.


Examples::

code::
#+BEGIN_SRC sclang

(
// only works with the internal server
s = Server.internal;
s.boot;
)

(
SynthDef("help-SharedIn1", {
	Out.ar(0, SinOsc.ar(Lag.kr(SharedIn.kr(0, 1), 0.01), 0, 0.2));
}).send(s);
SynthDef("help-SharedIn2", {
	Out.ar(1, SinOsc.ar(Lag.kr(SharedIn.kr(0, 1), 0.01, 1.5), 0, 0.2));
}).send(s);
)

(
s.setSharedControl(0, 300); // an initial value
s.sendMsg(\s_new, "help-SharedIn1", x = s.nextNodeID, 0, 1);
s.sendMsg(\s_new, "help-SharedIn2", y = s.nextNodeID, 0, 1);

Routine({
	30.do({
		s.setSharedControl(0, 300 * (10.rand + 1));
		0.2.wait;
	});
	s.sendMsg(\n_free, x);
	s.sendMsg(\n_free, y);
}).play;
)


s.quit;
#+END_SRC

::

** class:: SharedOut
summary:: Write to a shared control bus.
related:: Classes/SharedIn
categories::  UGens>InOut


Description::

warning::
SharedIn has been deprecated. Synchronous access to busses on local servers is possible via
link::Classes/Bus#-getSynchronous:: and link::Classes/Bus#-setSynchronous::
::


Reads from a control bus shared between the internal server and the SC
client. Control rate only. Reading from a shared control bus on the
client is synchronous. When not using the internal server use the get
method of Bus (or /c_get in messaging style) or
link::Classes/SendTrig:: with an link::Classes/OSCFunc::.


classmethods::

method::kr

argument::bus

The index of the shared control bus to write to.


argument::channelsArray

An Array of channels or single output to write out. You cannot
change the size of this once a SynthDef has been built.


Examples::

code::
#+BEGIN_SRC sclang

(
// only works with the internal server
s = Server.internal;
s.boot;
)

(
SynthDef("help-SharedOut", {
	SharedOut.kr(0, SinOsc.kr(0.2));
}).send(s);
)

(
s.sendMsg(\s_new, "help-SharedOut", x = s.nextNodeID, 0, 1);
s.sendMsg(\n_trace, x);

// poll the shared control bus
Routine({
	30.do({
		s.getSharedControl(0).postln;
		0.2.wait;
	});
}).play;
)


s.quit;
#+END_SRC

::

** class:: ShutDown
summary:: register functions to be evaluated before system shuts down
related:: Classes/StartUp, Classes/ServerQuit, Classes/ServerTree, Classes/CmdPeriod
categories:: Control

description::
ShutDown registers functions to perform an action before system shut down.

ClassMethods::

method::run
Call the object in order.
** CLASS::Signal
summary::Sampled audio buffer
related::Classes/Wavetable
categories:: Signals

DESCRIPTION::
A Signal is a FloatArray that represents a sampled function of time buffer.  Signals support math operations.

CLASSMETHODS::

method::sineFill
Fill a Signal of the given size with a sum of sines at the given amplitudes and phases. The Signal will be normalized.
code::
#+BEGIN_SRC sclang
Signal.sineFill(1000, 1.0/[1, 2, 3, 4, 5, 6]).plot;
#+END_SRC

::
argument::size
the number of samples in the Signal.
argument::amplitudes
an Array of amplitudes for each harmonic beginning with the fundamental.
argument::phases
an Array of phases in radians for each harmonic beginning with the fundamental.

method::chebyFill
Fill a Signal of the given size with a sum of Chebyshev polynomials at the given amplitudes. For eventual use in waveshaping by the Shaper ugen; see link::Classes/Shaper:: helpfile and link::Classes/Buffer#-cheby#Buffer:cheby:: too.
code::
#+BEGIN_SRC sclang
Signal.chebyFill(1000, [1]).plot;
Signal.chebyFill(1000, [0, 1]).plot;
Signal.chebyFill(1000, [0, 0, 1]).plot;
Signal.chebyFill(1000, [0.3, -0.8, 1.1]).plot;
#+END_SRC

::
argument::size
the number of samples in the Signal.
argument::amplitudes
an link::Classes/Array:: of amplitudes for each Chebyshev polynomial beginning with order 1.
argument::normalize
a link::Classes/Boolean::

method::hanningWindow
Fill a Signal of the given size with a Hanning window.
code::
#+BEGIN_SRC sclang
Signal.hanningWindow(1024).plot;
Signal.hanningWindow(1024, 512).plot;
#+END_SRC

::
argument::size
the number of samples in the Signal.
argument::pad
the number of samples of the size that is zero padding.

method::hammingWindow
Fill a Signal of the given size with a Hamming window.
code::
#+BEGIN_SRC sclang
Signal.hammingWindow(1024).plot;
Signal.hammingWindow(1024, 512).plot;
#+END_SRC

::
argument::size
the number of samples in the Signal.
argument::pad
the number of samples of the size that is zero padding.

method::welchWindow
Fill a Signal of the given size with a Welch window.
code::
#+BEGIN_SRC sclang
Signal.welchWindow(1024).plot;
Signal.welchWindow(1024, 512).plot;
#+END_SRC

::
argument::size
the number of samples in the Signal.
argument::pad
the number of samples of the size that is zero padding.

method::rectWindow
Fill a Signal of the given size with a rectangular window.
code::
#+BEGIN_SRC sclang
Signal.rectWindow(1024).plot;
Signal.rectWindow(1024, 512).plot;
#+END_SRC

::
argument::size
the number of samples in the Signal.
argument::pad
the number of samples of the size that is zero padding.

method::fftCosTable
Fourier Transform: Fill a Signal with the cosine table needed by the FFT methods. See also the instance methods link::#-fft:: and link::#-ifft::.
code::
#+BEGIN_SRC sclang
Signal.fftCosTable(512).plot;
#+END_SRC

::

INSTANCEMETHODS::

private::performBinaryOpOnSignal, performBinaryOpOnComplex, performBinaryOpOnSimpleNumber

method::plot
Plot the Signal in a window. The arguments are not required and if not given defaults will be used.
code::
#+BEGIN_SRC sclang
Signal.sineFill(512, [1]).plot;
Signal.sineFill(512, [1]).plot("Signal 1", Rect(50, 50, 150, 450));
#+END_SRC

::
argument::name
a String, the name of the window.
argument::bounds
a Rect giving the bounds of the window.

method::play
Loads the signal into a buffer on the server and plays it. Returns the buffer so you can free it again.
code::
#+BEGIN_SRC sclang
b = Signal.sineFill(512, [1]).play(true, 0.2);
b.free;	// free the buffer again.
#+END_SRC

::
argument::loop
A link::Classes/Boolean:: whether to loop the entire signal or play it once. Default is to loop.
argument::mul
volume at which to play it, 0.2 by default.
argument::numChannels
if the signal is an interleaved multichannel file, number of channels, default is 1.
argument::server
the server on which to load the signal into a buffer.

method::waveFill
Fill the Signal with a function evaluated over an interval.
code::
#+BEGIN_SRC sclang
(
a = Signal.newClear(512);
a.waveFill({ arg x, i; sin(x).max(0) }, 0, 3pi);
a.plot;
)
#+END_SRC

::
argument::function
a function that should calculate the value of a sample.

The function is called with two arguments:
definitionList::
## x || the value along the interval.
## i || the sample index.
::

argument::start
the starting value of the interval.
argument::end
the ending value of the interval.

method::asWavetable
Convert the Signal into a Wavetable.
code::
#+BEGIN_SRC sclang
Signal.sineFill(512, [1]).asWavetable.plot;
#+END_SRC

::

method::fill
Fill the Signal with a value.
code::
#+BEGIN_SRC sclang
Signal.newClear(512).fill(0.2).plot;
#+END_SRC

::

method::scale
Scale the Signal by a factor strong::in place::.
code::
#+BEGIN_SRC sclang
a = Signal[1, 2, 3, 4];
a.scale(0.5); a;
#+END_SRC

::

method::offset
Offset the Signal by a value strong::in place::.
code::
#+BEGIN_SRC sclang
a = Signal[1, 2, 3, 4];
a.offset(0.5); a;
#+END_SRC

::

method::peak
Return the peak absolute value of a Signal.
code::
#+BEGIN_SRC sclang
Signal[1, 2, -3, 2.5].peak;
#+END_SRC

::

method::normalize
Normalize the Signal strong::in place:: such that the maximum absolute peak value is 1.
code::
#+BEGIN_SRC sclang
Signal[1, 2, -4, 2.5].normalize;
Signal[1, 2, -4, 2.5].normalize(0, 1);	// normalize only a range
#+END_SRC

::

method::normalizeTransfer
Normalizes a transfer function so that the center value of the table is offset to zero and the absolute peak value is 1. Transfer functions are meant to be used in the link::Classes/Shaper:: ugen.
code::
#+BEGIN_SRC sclang
Signal[1, 2, 3, 2.5, 1].normalizeTransfer;
#+END_SRC

::

method::invert
Invert the Signal strong::in place::.
code::
#+BEGIN_SRC sclang
a = Signal[1, 2, 3, 4];
a.invert(0.5); a;
#+END_SRC

::

method::reverse
Reverse a subrange of the Signal strong::in place::.
code::
#+BEGIN_SRC sclang
a = Signal[1, 2, 3, 4];
a.reverse(1, 2); a;
#+END_SRC

::

method::fade
Fade a subrange of the Signal strong::in place::.
code::
#+BEGIN_SRC sclang
a = Signal.fill(10, 1);
a.fade(0, 3);		// fade in
a.fade(6, 9, 1, 0);	// fade out
#+END_SRC

::

method::integral
Return the integral of a signal.
code::
#+BEGIN_SRC sclang
Signal[1, 2, 3, 4].integral;
#+END_SRC

::

method::overDub
Add a signal to myself starting at the index. If the other signal is too long only the first part is overdubbed.
code::
#+BEGIN_SRC sclang
a = Signal.fill(10, 100);
a.overDub(Signal[1, 2, 3, 4], 3);

		// run out of range
a = Signal.fill(10, 100);
a.overDub(Signal[1, 2, 3, 4], 8);

a = Signal.fill(10, 100);
a.overDub(Signal[1, 2, 3, 4], -4);

a = Signal.fill(10, 100);
a.overDub(Signal[1, 2, 3, 4], -1);

a = Signal.fill(10, 100);
a.overDub(Signal[1, 2, 3, 4], -2);

a = Signal.fill(4, 100);
a.overDub(Signal[1, 2, 3, 4, 5, 6, 7, 8], -2);
#+END_SRC

::

method::overWrite
Write a signal to myself starting at the index. If the other signal is too long only the first part is overdubbed.
code::
#+BEGIN_SRC sclang
a = Signal.fill(10, 100);
a.overWrite(Signal[1, 2, 3, 4], 3);

		// run out of range
a = Signal.fill(10, 100);
a.overWrite(Signal[1, 2, 3, 4], 8);

a = Signal.fill(10, 100);
a.overWrite(Signal[1, 2, 3, 4], -4);

a = Signal.fill(10, 100);
a.overWrite(Signal[1, 2, 3, 4], -1);

a = Signal.fill(10, 100);
a.overWrite(Signal[1, 2, 3, 4], -2);

a = Signal.fill(4, 100);
a.overWrite(Signal[1, 2, 3, 4, 5, 6, 7, 8], -2);
#+END_SRC

::

method::blend
Blend two signals by some proportion.
code::
#+BEGIN_SRC sclang
Signal[1, 2, 3, 4].blend(Signal[5, 5, 5, 0], 0);
Signal[1, 2, 3, 4].blend(Signal[5, 5, 5, 0], 0.2);
Signal[1, 2, 3, 4].blend(Signal[5, 5, 5, 0], 0.4);
Signal[1, 2, 3, 4].blend(Signal[5, 5, 5, 0], 1);
Signal[1, 2, 3, 4].blend(Signal[5, 5, 5, 0], 2);
#+END_SRC

::

subsection::Fourier Transform

method::fft
Perform an FFT on a real and imaginary signal in place. See also the class method link::#*fftCosTable::.
code::
#+BEGIN_SRC sclang
(
var size = 512, real, imag, cosTable, complex;

real = Signal.newClear(size);
		// some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
		// add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

imag = Signal.newClear(size);
cosTable = Signal.fftCosTable(size);

complex = fft(real, imag, cosTable);
[real, imag, (complex.magnitude) / 100 ].flop.flat
	.plot("fft", Rect(0, 0, 512 + 8, 500), numChannels: 3);
)
#+END_SRC

::

method::ifft
Perform an inverse FFT on a real and imaginary signal in place. See also the class method link::#*fftCosTable::.
code::
#+BEGIN_SRC sclang
(
var size = 512, real, imag, cosTable, complex, ifft;

real = Signal.newClear(size);
		// some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
		// add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

imag = Signal.newClear(size);
cosTable = Signal.fftCosTable(size);

complex = fft(real, imag, cosTable).postln;
ifft = complex.real.ifft(complex.imag, cosTable);

[real, ifft.real].flop.flat
	.plot("fft and back", Rect(0, 0, 512 + 8, 500), numChannels: 2);
)
#+END_SRC

::

subsection::Unary Messages

Signal will respond to unary operators by returning a new Signal.
code::
#+BEGIN_SRC sclang
x = Signal.sineFill(512, [0, 0, 0, 1]);
[x, x.neg, x.abs, x.sign, x.squared, x.cubed, x.asin.normalize, x.exp.normalize, x.distort].flop.flat
	.plot(numChannels: 9);
#+END_SRC

::

method::neg, abs, sign, squared, cubed, sqrt, exp, log, log2, log10, sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, distort, softclip, isPositive, isNegative, isStrictlyPositive

subsection::Binary Messages

Signal will respond to binary operators by returning a new Signal.
code::
#+BEGIN_SRC sclang
(
x = Signal.fill(512, { rrand(0.0, 1.0) });
y = Signal.fill(512, { |i| (i * pi / 64).sin });
[x, y, (x + y) * 0.5, x * y, min(x, y), max(x, y) ].flop.flat
	.plot(numChannels: 6);
)
#+END_SRC

::
method::+, -, *, /, div, %, **, min, max, ring1, ring2, ring3, ring4, difsqr, sumsqr, sqrdif, absdif, amclip, scaleneg, clip2, excess, <!

** class:: Silent
summary:: Output silence.
categories::  UGens>Generators>Single-value


Description::

Output silence.


classmethods::

method::ar

argument::numChannels

Number of channels to output.

** CLASS:: SimpleController
summary:: Controller according to the model-view-controller (M-V-C) paradigm
categories:: Core
related:: Classes/Object

DESCRIPTION::

SimpleController can be used as a controller according to the model-view-controller (M-V-C) paradigm. It provides an
link::Classes/IdentityDictionary:: of actions, which are called whenever the attached model sends a notification by
calling changed.


CLASSMETHODS::

METHOD:: new
Creates a SimpleController instance with the model to be observed.

argument:: model
An object of any class


INSTANCEMETHODS::

private:: init, update

METHOD:: put

argument:: what
Register an action, which is called when the model invokes changed(what, moreArgs).

argument:: action

Action to register.


METHOD:: remove

Remove a registered action.

argument:: action

Action to remove

EXAMPLES::

code::
#+BEGIN_SRC sclang
(
var controller, model, view;

model = Ref(0.5);
controller = SimpleController(model);
controller.put(\value,
	{|theChanger, what, moreArgs|
		view.value_(theChanger.value);
	});

view = Slider(Window("slider", Rect(100, 100, 330, 38)).front, Rect(5, 5, 320, 20));
view.onClose_{controller.remove};

// run a routine to change the model's value:
r{
	100.do{
		model.value_(1.0.rand.postln).changed(\value);
		0.5.wait;
	}
}.play(AppClock)
)
#+END_SRC

::
** CLASS:: SimpleNumber
summary:: one-dimensional value
categories:: Math
related::Classes/Polar, Classes/Complex, Classes/Float, Classes/Integer, Classes/UnaryOpUGen, Classes/BinaryOpUGen

DESCRIPTION::
Base class for numbers which can be represented by a single one dimensional value.

Most of the Unary and Binary operations are also implemented by link::Classes/UnaryOpUGen:: and link::Classes/BinaryOpUGen::, so you can get more examples by looking at the help for those.

CLASSMETHODS::

method:: new
allocates a new SimpleNumber.

INSTANCEMETHODS::

private:: prSimpleNumberSeries

subsection:: math support

method:: +
Addition


method:: -
Subtraction

method:: *
Multiplication

method:: /
Division

method:: %
Modulo

method:: mod
Modulo

method:: div
Integer Division

method:: **
Exponentiation

method:: !=
Is not

method:: >
greater than

method:: <
greater than

method:: >=
greater or equal than

method:: <=
smaller or equal than

method:: lcm
Least common multiple

method:: gcd
Greatest common divisor

method:: round
Round to multiple of aNumber
method:: roundUp
round up to a multiply of aNumber

method:: thresh

method:: min
Minimum

method:: max
Maximum

method:: wrap2

method:: trunc
Truncate to multiple of aNumber

method:: atan2
Arctangent of (this/aNumber)

method:: hypot
Square root of the sum of the squares.


method:: log
returns:: Base e logarithm.

method:: log2
returns:: Base 2 logarithm.

method:: log10
returns:: Base 10 logarithm.

method:: neg
returns:: negation

method:: abs
returns:: absolute value.

method:: sign
returns:: Answer -1 if negative, +1 if positive or 0 if zero.

method:: ceil
returns:: next larger integer.

method:: floor
returns:: next smaller integer

method:: sin
Sine

method:: cos
Cosine

method:: tan
Tangent

method:: asin
Arcsine

method:: acos
Arccosine

method:: atan
Arctangent

method:: sinh
Hyperbolic sine

method:: cosh
Hyperbolic cosine

method:: tanh
Hyperbolic tangent

method:: frac
fractional part

method:: squared
the square of the number

method:: cubed
the cube of the number

method:: sqrt
the square root of the number.

method:: exp
e to the power of the receiver.

method:: reciprocal
1 / this

method:: pow
this to the power of aNumber

method:: fold2
the folded value, a bitwise or with aNumber

method:: previousPowerOf
the number relative to this that is the previous power of aNumber

method:: nextPowerOf
the next power of aNumber

method:: nextPowerOfTwo
returns:: the number relative to this that is the next power of 2

method:: nextPowerOfThree
the next power of three

method:: hash
returns:: a hash value

method:: <!
returns:: the receiver. aNumber is ignored.

method:: &
Bitwise And

method::|
Bitwise Or

method:: bitXor
Bitwise Exclusive Or

method:: bitHammingDistance
Binary Hamming distance: the count of bits that are not the same in the two numbers

method:: bitTest
returns:: true if bit at index aNumber is set.

method:: bitNot
returns:: ones complement

method:: <<
Binary shift left.

method:: >>
Binary shift right.

method:: +>>
Unsigned binary shift right.

method:: rightShift
returns:: performs a binary right shift

method:: unsignedRightShift
returns:: performs an unsigned right shift

method:: leftShift
returns:: performs a binary left shift

method:: bitOr
returns:: performs a bitwise or with aNumber

method:: bitAnd
returns:: performs a bitwise and with aNumber

method:: ring1
(a * b) + a

method:: ring2
((a*b) + a + b)

method:: ring3
(a * a *b)

method:: ring4
((a*a *b) - (a*b*b))

method:: difsqr
(a*a) - (b*b)

method:: sumsqr
(a*a) + (b*b)

method:: sqrdif
(a - b) ** 2

method:: sqrsum
(a + b) ** 2

method:: absdif
(a - b).abs

method:: amclip
0  when  b <= 0,  a*b  when  b > 0

method:: scaleneg
a * b when a < 0, otherwise a.

method:: clip2
clips receiver to +/- aNumber

method:: excess
Returns the difference of the receiver and its clipped form.
discussion::
code::
#+BEGIN_SRC sclang
(a - clip2(a,b))
#+END_SRC

::

method:: madd
code::
#+BEGIN_SRC sclang
this * a + b
#+END_SRC

::

subsection:: testing
method:: isPositive
Answer if the number is >= 0.

method:: isNegative
Answer if the number is < 0.

method:: isStrictlyPositive
Answer if the number is > 0.

method:: booleanValue
returns:: true, if strictly positive ( > 0), otherwise false (see link::Classes/Boolean::)

method:: isNaN
method:: ==

subsection:: conversion

method:: asFraction
argument::denominator
argument::fasterBetter
if true, asFraction may find a much closer approximation and do it faster.
returns:: an array of denominator and divisor of the nearest and smallest fraction

method:: asAudioRateInput
Converts this into an audiorate input.

method:: asTimeString
Compile a time string.
argument:: precision
how accurate
argument::maxDays
the maximum number of days
argument::dropDaysIfPossible
a link::Classes/Boolean::
returns:: a string corresponding to the hours:minutes:seconds based on the receiver as number of seconds
discussion::
code::
#+BEGIN_SRC sclang
(
var start;
start = Main.elapsedTime;
{ loop({(Main.elapsedTime - start).asTimeString.postln; 0.05.wait}) }.fork;
)
#+END_SRC

::

method:: asPoint
returns:: this as link::Classes/Point::. x = y = this.

method:: asComplex
returns:: this as link::Classes/Point::. x = y = this.

method:: asWarp
argument::spec
a link::Classes/ControlSpec::
returns:: this as link::Classes/CurveWarp:: according to spec.

method:: asFloat
returns:: this as link::Classes/Float::

method:: asRect
returns:: a link::Classes/Rect:: with x = y = w = h = this.

method:: asBoolean
returns:: this as a link::Classes/Boolean::.  this > 0

method:: asQuant
returns:: the values as link::Classes/Quant::

method:: asInteger
returns:: this as link::Classes/Integer::

subsection:: timing

method::wait
within a routine, yield the number so that the clock can wait for this many beats. Outside a Routine, this trows an error (see also Routine for details).

discussion::
Create a routine by a function fork
code::
#+BEGIN_SRC sclang
(
fork {
	1.wait;
	"I did wait".postln;
	1.0.rand.wait;
	"No you didn't".postln;
	2.wait;
	(1..).do { |i|
		"yes I did".postln;
		i.asFloat.rand.wait;
		"no you didn't".postln;
		i.wait
	}
}
)
#+END_SRC

::

method:: waitUntil
like wait, only specify a time (measured in beats of the current thread's clock). Outside a Routine, this trows an error (see also Routine for details).

method:: sleep
make the current thread sleep, until woken up by re-scheduling. Outside a Routine, this trows an error (see also Routine for details).

method:: nextTimeOnGrid
argument::clock
returns:: the next possible multiple of the clock's beats.

method:: schedBundleArrayOnClock



subsection:: series and arrays

method:: nearestInList
returns:: the value in the list closest to this

discussion::
code::
#+BEGIN_SRC sclang
(
l = [0, 0.5, 0.9, 1];
(0, 0.05..1).collect { |i| i.nearestInList(l) }
)
#+END_SRC

::

method:: nearestInScale
argument:: scale
an array of SimpleNumbers each treated as a step in the octave.
argument:: stepsPerOctave
12 by default
returns:: the value in the collection closest to this, assuming an octave repeating table of note values.

discussion::
code::
#+BEGIN_SRC sclang
(
l = [0, 1, 5, 9, 11]; // pentatonic scale
(60, 61..76).collect { |i| i.nearestInScale(l, 12) }
)
#+END_SRC

::

method:: series
return an artithmetic series from this over second to last.
discussion::
This is used in the shortcuts:
code::
#+BEGIN_SRC sclang
(0..100);
(1, 3 .. 17)
#+END_SRC

::
If second is nil, it is one magnitude step towards last (1 or -1).
Examples:
code::
#+BEGIN_SRC sclang
series(5, 7, 10);
series(5, nil, 10);
(5, 7 .. 10)
#+END_SRC

::

method:: seriesIter
returns:: a Routine that iterates over the numbers from this to last.

discussion::
Since this is a lazy operation, last may be inf, generating an endless series
(see also link::Guides/ListComprehensions::)
code::
#+BEGIN_SRC sclang
r = seriesIter(0, 5);
r.nextN(8);
r.nextN(8);
#+END_SRC

::


subsection:: windowing

method:: rectWindow
returns:: a value for a rectangular window function between 0 and 1.

method:: hanWindow
returns:: a value for a hanning window function between 0 and 1.

method:: welWindow
returns:: a value for a welsh window function between 0 and 1.

method:: triWindow
returns:: a value for a triangle window function between 0 and 1.

subsection:: mapping

method:: distort
a nonlinear distortion function.

method:: softclip
Distortion with a perfectly linear region from -0.5 to +0.5

method:: scurve
Map receiver in the onto an S-curve.
discussion::
code::
#+BEGIN_SRC sclang
((0..100) / 100 ).collect(_.scurve).plot
#+END_SRC

::

method:: ramp
Map receiver onto a ramp starting at 0.
discussion::
code::
#+BEGIN_SRC sclang
((-100..100) / 100 ).collect(_.ramp).plot
#+END_SRC

::

method::magnitude
returns:: abolute value (see link::Classes/Polar::, link::Classes/Complex::)

method::angle
returns:: angle of receiver conceived as link::Classes/Polar:: or link::Classes/Complex:: number.


method:: degreeToKey
argument:: scale
an array of SimpleNumbers each treated as a step in the octave.
argument:: stepsPerOctave
12 is the standard chromatic scale.
discussion::
the value is truncated to an integer and used as an index into an octave repeating table of note values. Indices wrap around the table and shift octaves as they do.

code::
#+BEGIN_SRC sclang
(
l = [0, 1, 5, 9, 11]; // pentatonic scale
(1, 2..15).collect{|i|
	i.degreeToKey(l, 12)
};
)
#+END_SRC

::

method:: keyToDegree
inverse of degreeToKey.
argument:: scale
an array of SimpleNumbers each treated as a step in the octave.
argument:: stepsPerOctave
12 is the standard chromatic scale.
discussion::
code::
#+BEGIN_SRC sclang
(
l = [0, 1, 5, 9, 11]; // pentatonic scale
(60, 61..75).collect { |i| i.keyToDegree(l, 12) }
)
#+END_SRC

::
code::
#+BEGIN_SRC sclang
(
l = [0, 1, 5, 9, 11]; // pentatonic scale
(60, 61..75).postln.collect { |i| i.keyToDegree(l, 12).degreeToKey(l) }
)
#+END_SRC

::



method::gaussCurve
map the receiver onto a gauss function.

discussion::
Uses the formula:
code::
#+BEGIN_SRC sclang
a * (exp(squared(this - b) / (-2.0 * squared(c)))) Defalt values: a = 1; b = 0; c = 1
#+END_SRC

::
Example code
code::
#+BEGIN_SRC sclang
(0..1000).normalize(-10, 10).collect { |num| num.gaussCurve }.plot;
#+END_SRC

::


method:: equalWithPrecision
returns:: true if receiver is closer to that than precision.

discussion::
code::
#+BEGIN_SRC sclang
3.1.equalWithPrecision(3.0, 0.05); // false
3.1.equalWithPrecision(3.0, 0.1); // false
3.1.equalWithPrecision(3.0, 0.11); // true
#+END_SRC

::

method:: quantize
round the receiver to the quantum.
argument::quantum
amount.
argument::tolerance
allowed tolerance.
argument::strength
Determines how much the value is allowed to differ in the tolerance range.
discussion::
code::
#+BEGIN_SRC sclang
((0..10) / 10).collect { |num| num.quantize(1, 0.3, 0.5) }.postcs.plot;
((0..10) / 10).collect { |num| num.quantize(1, 0.6, 0.5) }.postcs.plot;
((0..10) / 10).collect { |num| num.quantize(1, 1.0, 0.5) }.postcs.plot;
#+END_SRC

::

method:: linlin
map the receiver from an assumed linear input range to a linear output range. If the input exceeds the assumed input range, the behaviour is specified by the clip argument.
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).

discussion::
code::
#+BEGIN_SRC sclang
(0..10).collect { |num| num.linlin(0, 10, -4.3, 100) };
(0..10).linlin(0, 10, -4.3, 100); // equivalent.
#+END_SRC

::

method::linexp
map the receiver from an assumed linear input range (inMin..inMax) to an exponential output range (outMin..outMax). The output range must not include zero. If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).
discussion::
code::
#+BEGIN_SRC sclang
(0..10).collect { |num| num.linexp(0, 10, 4.3, 100) };
(0..10).linexp(0, 10, 4.3, 100); // equivalent.
#+END_SRC

::

method::explin
map the receiver from an assumed exponential input range (inMin..inMax) to a linear output range (outMin..outMax). If the input exceeds the assumed input range. The input range must not include zero.
If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).
discussion::
code::
#+BEGIN_SRC sclang
(1..10).collect { |num| num.explin(0.1, 10, -4.3, 100) };
(1..10).explin(0.1, 10, -4.3, 100); // equivalent.
#+END_SRC

::

method::expexp
map the receiver from an assumed exponential input range (inMin..inMax) to an exponential output range (outMin..outMax). If the input exceeds the assumed input range. Both input range and output range must not include zero.
If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).
discussion::
code::
#+BEGIN_SRC sclang
(1..10).collect { |num| num.expexp(0.1, 10, 4.3, 100) };
(1..10).expexp(0.1, 10, 4.3, 100); // equivalent.
#+END_SRC

::

method::lincurve
map the receiver from an assumed linear input range (inMin..inMax) to an exponential curve output range (outMin..outMax). A curve is like the curve parameter in Env. Unlike with linexp, the output range may include zero.
If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outMin
output minimum
argument::outMax
output maximum
argument::curve
0 (linear) <0 (concave, negatively curved) >0 (convex, positively curved)
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).
discussion::
code::
#+BEGIN_SRC sclang
(0..10).collect { |num| num.lincurve(0, 10, -4.3, 100, -3) };
(0..10).lincurve(0, 10, -4.3, 100, -3); // equivalent.
#+END_SRC

::
code::
#+BEGIN_SRC sclang
// different curves:
(-4..4).do { |val|
	(0..100).collect(_.lincurve(0, 100, 0, 1, val)).plot
}
#+END_SRC

::

method::curvelin
map the receiver from an assumed curve-exponential input range (inMin..inMax) to a linear output range (outMin..outMax). If the input exceeds the assumed input range. A curve is like the curve parameter in Env. Unlike with explin, the input range may include zero. If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outMin
output minimum
argument::outMax
output maximum
argument::curve
0 (linear) <0 (concave, negatively curved) >0 (convex, positively curved)
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).

discussion::
code::
#+BEGIN_SRC sclang
(1..10).collect { |num| num.curvelin(0, 10, -4.3, 100, -3) };
(1..10).curvelin(0, 10, -4.3, 100, -3); // equivalent.
#+END_SRC

::
code::
#+BEGIN_SRC sclang
// different curves:
(-4..4).do { |val|
	(0..100).collect(_.curvelin(0, 100, 0, 1, val)).plot
}
#+END_SRC

::

method::bilin
map the receiver from two assumed linear input ranges (inMin..inCenter) and (inCenter..inMax) to two linear output ranges (outMin..outCenter) and (outCenter..outMax). If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inCenter
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outCenter
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).
discussion::
code::
#+BEGIN_SRC sclang
var center = 0.5, ctlCenter;
w = Window("bilin", Rect(100, 100, 200, 100)).front;
a = Slider(w, Rect(20, 20, 150, 20)).value_(0.5);
b = Slider(w, Rect(20, 45, 150, 20)).value_(0.5);
b.action = { center = b.value };
a.mouseDownAction = { ctlCenter = a.value };
a.action = {
	b.value = a.value.bilin(ctlCenter, 0, 1, center, 0, 1);
};
#+END_SRC

::


method::biexp
map the receiver from two assumed exponential input ranges (inMin..inCenter) and (inCenter..inMax) to two linear output ranges (outMin..outCenter) and (outCenter..outMax). The input range must not include zero. If the input exceeds the input range, the following behaviours are specified by the clip argument.
argument::inCenter
argument::inMin
assumed input minimum
argument::inMax
assumed input maximum
argument::outCenter
argument::outMin
output minimum
argument::outMax
output maximum
argument::clip
nil (don't clip)
\max (clip ceiling)
\min (clip floor)
\minmax (clip both - this is default).

discussion::
code::
#+BEGIN_SRC sclang
// doesn't properly work yet.
(
var center = 0.5, ctlCenter;
w = Window("biexp", Rect(100, 100, 200, 100)).front;
a = Slider(w, Rect(20, 20, 150, 20)).value_(0.5);
b = Slider(w, Rect(20, 45, 150, 20)).value_(0.5);
b.action = { center = b.value };
a.mouseDownAction = { ctlCenter = a.value + 0.05 };
a.action = {
	b.value = (a.value + 0.1).biexp(ctlCenter, 0.1, 1.1, center, 0, 1);
};
)
#+END_SRC

::

method::lcurve
map the receiver onto an L-curve.

discussion::
Uses the formula
code::
#+BEGIN_SRC sclang
a * (m * exp(x) * rTau + 1) / (n * exp(x) * rTau + 1)
#+END_SRC

::
This is used for smoothing values and limiting them to a range.
code::
#+BEGIN_SRC sclang
(0..1000).normalize(-10, 10).collect { |num| num.lcurve }.plot;
#+END_SRC

::


method:: degrad
returns:: converts degree to radian

method:: raddeg
returns:: converts radian to degree

method:: midicps
Convert MIDI note to cycles per second
returns:: cycles per second

method:: cpsmidi
Convert cycles per second to MIDI note.
returns:: midi note


method:: midiratio
Convert an interval in semitones to a ratio.
returns:: a ratio

method:: ratiomidi
Convert a ratio to an interval in semitones.
returns:: an interval in semitones

method:: ampdb
Convert a linear amplitude to decibels.


method:: dbamp
Convert a decibels to a linear amplitude.

method:: octcps
Convert decimal octaves to cycles per second.

method:: cpsoct
Convert cycles per second to decimal octaves.


subsection:: streams

method:: storeOn
stores this on the given stream
method:: printOn
printrs this on the given stream

subsection:: random

method:: coin
Answers a Boolean which is the result of a random test whose probability of success in a range from zero to one is this.

method:: rand
returns:: Random number from zero up to the receiver, exclusive.

method:: rand2
returns:: a random number from -this to +this.

method:: rrand
argument::aNumber
the upper limit
argument::adverb
returns:: a random number in the interval ]a, b[.
discussion::
If both a and b are link::Classes/Integer:: then the result will be an link::Classes/Integer::.

method:: linrand
returns:: a linearly distributed random number from zero to this.

method:: bilinrand
returns:: Bilateral linearly distributed random number from -this to +this.

method:: sum3rand
This was suggested by Larry Polansky as a poor man's gaussian.
returns:: A random number from -this to +this that is the result of summing three uniform random generators to yield a bell-like distribution.

method:: exprand
an exponentially distributed random number in the interval ]a, b[. This is always a link::Classes/Float::.
(Note that the distribution of numbers is not exactly an EMPHASIS::exponential distribution::, since that would be unbounded: we might call it a EMPHASIS::logarithmic uniform distribution::.)
argument::aNumber
the upper limit
argument::adverb

method:: gauss
a gaussian distributed random number.
argument::standardDeviation
the upper limit
discussion::
Always returns a link::Classes/Float::.
code::
#+BEGIN_SRC sclang
(0..1000).collect { |num| gauss(0.0, num) }.plot;
#+END_SRC

::

method:: partition
randomly partition a number into parts of at least min size.
argument:: parts
number of parts
argument:: min
the minimum size

discussion::
code::
#+BEGIN_SRC sclang
75.partition(8, 3);
75.partition(75, 1);
#+END_SRC

::


subsection:: UGen Compatibility Methods

Some methods to ease the development of generic ugen code.

method:: lag, lag2, lag3, lagud, lag2ud, lag3ud, slew, varlag

returns:: code::this::


subsection:: misc

method:: isValidUGenInput
returns:: false if receiver cannot be used in UGen.

** class:: SinOsc
summary:: Interpolating sine wavetable oscillator.
related:: Classes/FSinOsc, Classes/SinOscFB
categories::  UGens>Generators>Deterministic


Description::

This is the same as  link::Classes/Osc::  except that the table is
a sine table of 8192 entries.


classmethods::

method::ar, kr

argument::freq
Frequency in Hertz.

argument::phase
Phase offset or modulator in radians.
(Note: phase values should be within the range +-8pi. If your phase values are larger then simply use code::.mod(2pi):: to wrap them.)

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang

{ SinOsc.ar(200, 0, 0.5) }.play;

// modulate freq
{ SinOsc.ar(XLine.kr(2000, 200), 0, 0.5) }.play;

// modulate freq
{ SinOsc.ar(SinOsc.ar(XLine.kr(1, 1000, 9), 0, 200, 800), 0, 0.25) }.play;

// modulate phase
{ SinOsc.ar(800, SinOsc.ar(XLine.kr(1, 1000, 9), 0, 2pi), 0.25) }.play;
#+END_SRC

::

** class:: SinOscFB
summary:: Feedback FM oscillator
related:: Classes/SinOsc, Classes/FSinOsc, Classes/PMOsc
categories::  UGens>Generators>Deterministic, UGens>Generators>Chaotic


Description::

SinOscFB is a sine oscillator that has phase modulation feedback; its output plugs back into the phase input.
Basically this allows a modulation between a sine wave and a sawtooth like wave. Overmodulation causes chaotic oscillation. It may be useful if you want to simulate feedback FM synths.




classmethods::

method::ar, kr

argument::freq

The base frequency of the sine oscillator in Hertz.

argument::feedback

The second argument is the amplitude of phase feedback in radians.

argument::mul

Output will be multiplied by this value.

argument::add

This value will be added to the output after any multiplication.


Examples::

code::
#+BEGIN_SRC sclang


{SinOscFB.ar(440,MouseX.kr(0,4))*0.1}.play


{SinOscFB.ar(MouseY.kr(10,1000,'exponential'),MouseX.kr(0.5pi,pi))*0.1}.play


{SinOscFB.ar(100*SinOscFB.ar(MouseY.kr(1,1000,'exponential'))+200,MouseX.kr(0.5pi,pi))*0.1}.play


// Scope the wave form
{ SinOscFB.ar([400,301], MouseX.kr(0,4),0.3); }.scope;
#+END_SRC

::
** class:: SkipJack
summary:: A utility for background tasks that survive cmd-period
categories:: Scheduling, Libraries>JITLib>GUI
related:: Classes/CmdPeriod

Description::
SkipJack is a utility to run a function in the background repeatedly, that survive cmd-period.

A typical use is with a window displaying the state of some objects every now and then. (This is better in some cases than
updating the GUI at every change. If the changes happen fast, you don't choke your CPU on gui updating.)

But SkipJack is useful whenever you need a periodic function to run in the background and not go away if the user hits cmd-period.

ClassMethods::

private::initClass

method::new

argument::updateFunc
A link::Classes/Function:: to repeat in the background.

argument::dt
The time interval at which to repeat. It can also be a stream or a function that returns a number.

argument::stopTest
A test whether to stop the task now. Usually a Function.

argument::name
A name for this skipjack. Used for posting information and in the link::#*stop:: classmethod.

argument::clock
The clock that plays the task. Default is link::Classes/AppClock::, so SkipJack can call GUI primitives. If you need more precise timing, you can supply your own clock, and use defer only where necessary.

argument::autostart
When true (default) SkipJack starts automatically as it is created.

method:: stop
Stop a skipjack by name.

method:: stopAll
Stop all skipjacks.

method:: defaultClock
The default clock (AppClock)

method:: verbose
When true, SkipJack posts messages when it starts, stops or restarts.

method:: all
The global set of all skipjacks.

Instancemethods::
private:: cmdPeriod

method:: dt
Get or set the time interval.

method:: task
The internal Routine that wraps updateFunc.

method:: name
The name of this skipjack.

method:: stopTest
The current stopTest. (see argument in link::#*new:: )

method:: start
Start this skipjack.

method:: play
Same as code::start::

method:: stop
Stop this skipjack.

method:: clock
Get or set the clock used. This will only be updated when the skipjack restarts.

method:: updateFunc
The updateFunc set by the argument to link::#*new::

Examples::
Simple example:
code::
#+BEGIN_SRC sclang
w = SkipJack({ "watch...".postln; }, 0.5, name: "test");
SkipJack.verbose = true;    // post stop/wakeup logs

w.stop;
w.start;

// 	now try to stop with cmd-. : SkipJack always restarts itself.
thisProcess.stop;

w.stop;
#+END_SRC

::

Using stopTest:
code::
#+BEGIN_SRC sclang
a = 5;
w = SkipJack({ "watch...".postln; }, 0.5, { a == 10 }, "test");
a = 10;	// fulfil stopTest
#+END_SRC

::

Typical use: SkipJack updates a window displaying the state of some objects every now and then.
code::
#+BEGIN_SRC sclang
(
d = (a: 12, b: 24);
d.win = Window("dict", Rect(0,0,200,60)).front;
d.views = [\a, \b].collect { |name, i|
    StaticText(d.win, Rect(i * 100,0,96,20))
        .background_(Color.yellow).align_(0).string_(name);
};
w = SkipJack({
        "...".postln;
        [\a, \b].do { |name, i|
            d.views[i].string_(name ++ ":" + d[name])
        }
    },
    0.5,
    { d.win.isClosed },
    "showdict"
);
)

d.a = 123;      // updates should be displayed
d.b = \otto;
d.win.close;    // when window closes, SkipJack stops.
#+END_SRC

::

If you need to get rid of an unreachable skipjack:
code::
#+BEGIN_SRC sclang
SkipJack({ "unreachable, unkillable...".postln }, name: "jack");

SkipJack.stopAll        // do this to stop all;

SkipJack.stop("jack");  // reach it by name and stop
#+END_SRC

::

** class:: Slew
summary:: Slew rate limiter.
related:: Classes/Slope, Classes/Ramp, Classes/Lag, Classes/VarLag
categories::  UGens>Filters>Nonlinear


Description::

Limits the slope of an input signal. The slope is expressed in units per
second.

For smoothing out control signals, take a look at link::Classes/Lag:: and link::Classes/VarLag::

classmethods::

method::ar, kr

argument::in

The input signal.


argument::up

Maximum upward slope in units per second.


argument::dn

Maximum downward slope in units per second.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	z = LFPulse.ar(800);
	[z, Slew.ar(z, 4000, 4000)]
}.plot)



Has the effect of removing transients and higher frequencies.
(
{

	z = Saw.ar(800,mul:0.2);
	Slew.ar(z,400,400)

}.play
)
#+END_SRC

::

** CLASS:: Slider
redirect:: implClass
summary:: A view consisting of a sliding handle.
categories:: GUI>Views

DESCRIPTION::

A view that allows setting a numerical value by means of moving a sliding handle. It can have horizontal or vertical orientation, meaning the direction in which the handle moves.




CLASSMETHODS::

PRIVATE:: key

METHOD:: new

	When a new Slider is created, its link::#-orientation:: is determined by the initial size: if it is wider than high, the orientation will be horizontal, otherwise it will be vertical.





INSTANCEMETHODS::



SUBSECTION:: Data

METHOD:: value
	Numerical value between 0 and 1, represented by the handle position within the groove.

	argument::
		A Float.

METHOD:: valueAction
	Sets link::#-value:: and triggeres link::#-action::.

METHOD:: increment
	Increments the value by link::#-step:: multiplied by 'factor'.

	argument:: factor
		Any number.

METHOD:: decrement
	Decrements the value by link::#-step:: multiplied by 'factor'.

	argument:: factor
		Any number.




SUBSECTION:: Appearance

METHOD:: orientation
	The orientation of the Slider - the direction in which the handle moves. The default value depends on the size of the view when created.

	argument::
		One of the two Symbols: \horizontal or \vertical.

METHOD:: thumbSize
	The size of the handle - its width or height, depending on link::#-orientation::.

	argument::
		An Integer amount of pixels.

METHOD:: knobColor
	The color of the handle.

	argument::
		A Color.



SUBSECTION:: Interaction

METHOD:: step
	The amount by which the value will changed when link::#-increment:: or link::#-decrement:: is called, or when related keys are pressed.

	argument::
		A Float.

METHOD:: pixelStep
	The absolute amount by which the value would change if the handle moved by one pixel.

	returns::
		A Float.

METHOD:: shift_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the value by keyboard while the Shift key is pressed.

	argument::
		A Float.

METHOD:: ctrl_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the value by keyboard while the Ctrl key is pressed.

	argument::
		A Float.

METHOD:: alt_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the value by keyboard while the Alt key is pressed.

	argument::
		A Float.


SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user moves the handle.

METHOD:: defaultKeyDownAction

	Implements the default effects of key presses as follows:

	table::
	## strong::Key::   || strong::Effect::
	## r               || valueAction_(1.0.rand)
	## n               || valueAction_(0)
	## x               || valueAction_(1)
	## c               || valueAction_(0.5)
	## ]               || increment
	## [               || decrement
	## up arrow        || increment
	## down arrow      || decrement
	## right arrow     || increment
	## left arrow      || decrement
	::



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The link::#-value::.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a number.

METHOD:: defaultReceiveDrag
	Sets link::#-valueAction:: to the current drag data.



EXAMPLES::
subsection:: Show the slider value in a NumberBox
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
c = NumberBox(w, Rect(20, 20, 150, 20));
a = Slider(w, Rect(20, 60, 150, 20))
	.action_({
		c.value_(a.value)
		});
a.action.value;
)

( // change the bounds to become vertical
w = Window.new.front;
c = NumberBox(w, Rect(20, 20, 150, 20));
a = Slider(w, Rect(200, 60, 20, 150))
	.action_({
		c.value_(a.value)
		});
a.action.value;
)
#+END_SRC

::

subsection:: Use a Spec to round and map the output range
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
b = ControlSpec(-50, 50, \linear, 0.01); // min, max, mapping, step
c = StaticText(w, Rect(20, 20, 150, 20)).align_(\center).background_(Color.rand);
a = Slider(w, Rect(20, 50, 150, 20))
	.focusColor_(Color.red(alpha:0.2))
	.background_(Color.rand)
	.value_(0.5)
	.action_({
		c.string_(b.map(a.value).asString)
		// round the float so it will fit in the NumberBox
		});
a.action.value;

)
#+END_SRC

::

subsection:: Change the stepsize of the slider, selected via a PopUpMenu
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
a = ["0", "0.0625", "0.125", "0.25", "0.5", "1"];
b = Slider(w, Rect(20, 100, 100, 20))
	.action_({
		c.value_(b.value)
		}).background_(Color.rand);
d = PopUpMenu(w, Rect(20, 60, 100, 20))
	.items_(a)
	.action_({
		b.step_((a.at(d.value)).asFloat);
		});
StaticText(w, Rect(130, 60, 100, 20)).string_("change step");	
c = NumberBox(w, Rect(20, 20, 100, 20));
)
#+END_SRC

::

subsection:: Use the slider view to accept key actions
code::
#+BEGIN_SRC sclang
( // select the slider, type something and watch the post window
w = Window.new;
c = Slider(w,Rect(0,0,100,30));
c.keyDownAction = { arg view,char,modifiers,unicode,keycode;
[char,modifiers,unicode,keycode].postln;
};
w.front;
)
#+END_SRC

::

subsection:: Adding functionality to a view by the method addAction
This is useful for adding things to existing frameworks that have action functions already.
code::
#+BEGIN_SRC sclang
(
w = Window.new("A Slider");
a = Slider.new(w, Rect(40, 10, 300, 30));
w.front
);

// now incrementally add some action to the slider
a.addAction({ |sl| sl.value.postln });
a.addAction({ |sl| w.view.background = Color.green(sl.value) });
a.addAction({ |sl| sl.background = Color.red(1 - sl.value) });

// adding and removing an action:
f = { |sl| "--------*******-------".postln; };
a.addAction(f);
a.removeAction(f);

// or remove all, of course
a.action = nil;
#+END_SRC

::

subsection:: Use Slider for triggering sounds
code::
#+BEGIN_SRC sclang
(
s.waitForBoot({
	SynthDef(\pluck,{arg freq=55;
		Out.ar(0,
		Pluck.ar(WhiteNoise.ar(0.06),
			EnvGen.kr(Env.perc(0,4), 1.0, doneAction: 2),
			freq.reciprocal,
			freq.reciprocal,
			10,
		coef:0.1)
		);
	}).send(s);
	

	w = Window.new("Hold arrow keys to trigger sound",Rect(300,Window.screenBounds.height-300,400,100)).front;
	a = Slider(w, Rect(50, 20, 300, 40))
		.value_(0.5)
		.step_(0.05)
		.focus
		.action_({
			// trigger a synth with varying frequencies
			Synth(\pluck, [\freq,55+(1100*a.value)]);
			w.view.background_(Gradient(Color.rand,Color.rand));
		})
});

)
#+END_SRC

::

subsection:: Change background color of Window
code::
#+BEGIN_SRC sclang
(
w = Window("RGB fader", Rect(100, 500, 400, 400))
	.front;
f = { w.view.background_(Color.new(r.value, g.value, b.value, 1)) };
r = Slider(w, Rect(100, 140, 200, 20))
	.value_(0.5)
	.action_({ f.value });
g = Slider(w, Rect(100, 170, 200, 20))
	.value_(0.5)
	.action_({ f.value });
b = Slider(w, Rect(100, 200, 200, 20))
	.value_(0.5)
	.action_({ f.value });
f.value;
);
#+END_SRC

::
** class:: Slider2D
redirect:: implClass
summary:: A view with a handle movable in two dimensions.
categories:: GUI>Views
related:: Classes/TabletSlider2D, Classes/TabletView

DESCRIPTION::

A view that allows setting two numerical values represented by the horizontal and vertical position of a handle movable in two dimensions.

The values are always within the range between 0 and 1. Scaling the output and input values to your needs can easily be achieved by using a link::Classes/ControlSpec:: with its link::Classes/ControlSpec#-map#-map:: and link::Classes/ControlSpec#-unmap#-unmap:: methods.

The link::#-step:: variable determines the amount by which the values will change when the handle is controlled using the keyboard. By default, holding down the Shift, Ctrl, or Alt key will multiply this amount by 100, 10, or 0.1 respectively, though you can customize this by setting link::#-shift_scale::, link::#-ctrl_scale::, or link::#-alt_scale::.

Drag and drop gives and accepts a link::Classes/Point:: of which the two coordinates represent the two values of the Slider2D.




CLASSMETHODS::

PRIVATE:: key




INSTANCEMETHODS::

SUBSECTION:: Data

METHOD:: x
	The value represented by the horizontal position of the handle. It will always be clipped to the range between 0 and 1.

	argument::
		A Float.

METHOD:: y
	The value represented by the vertical position of the handle. It will always be clipped to the range between 0 and 1.

	argument::
		A Float.

METHOD:: activex
	Sets link::#-x:: and triggers the link::#-action::.


METHOD:: activey
	Sets link::#-y:: and triggers the link::#-action::.

METHOD:: setXY
	Sets link::#-x:: and link::#-y:: to the two arguments.

METHOD:: setXYActive
	Sets link::#-x:: and link::#-y:: to the two arguments, and triggers the link::#-action::.

METHOD:: incrementX
	Increments link::#-x:: by link::#-step:: multiplied by code::factor::.

METHOD:: decrementX
	Decrements link::#-x:: by link::#-step:: multiplied by code::factor::.

METHOD:: incrementY
	Increments link::#-y:: by link::#-step:: multiplied by code::factor::.

METHOD:: decrementY
	Decrements link::#-y:: by link::#-step:: multiplied by code::factor::.




SUBSECTION:: Appearance

METHOD:: knobColor
	The color of the handle.

	argument::
		A Color.



SUBSECTION:: Interaction

METHOD:: step
	The amount by which link::#-x:: or link::#-y:: will change when incremented or decremented, either by calling relevant methods, or when related keys are pressed.

	argument::
		A Float.

METHOD:: pixelStepX
	The absolute amount by which link::#-x:: would change if the handle moved horizontally by one pixel.

	returns::
		A Float.

METHOD:: pixelStepY
	The absolute amount by which link::#-y:: would change if the handle moved vertically by one pixel.

	returns::
		A Float.

METHOD:: shift_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the values by keyboard while the Shift key is pressed.

	argument::
		A Float.

METHOD:: ctrl_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the values by keyboard while the Ctrl key is pressed.

	argument::
		A Float.

METHOD:: alt_scale
	The factor by which link::#-step:: is multiplied when incrementing or decrementing the values by keyboard while the Alt key is pressed.

	argument::
		A Float.



SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user changes the position or size of the handle.

METHOD:: defaultKeyDownAction

	Implements the default effects of key presses as follows:

	table::
	## strong::Key::   || strong::Effect::
	## r               || x_(1.rand), y_(1.rand), and triggers action
	## n               || x_(0), y_(0), and triggers action
	## x               || x_(1), y_(1), and triggers action
	## c               || x_(0.5), y_(0.5), and triggers action
	## up arrow        || incrementY
	## down arrow      || decrementY
	## right arrow     || incrementX
	## left arrow      || decrementX
	::



SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		A Point of which the x and y coordinates are set to link::#-x:: and link::#-y::, respectively.

METHOD:: defaultCanReceiveDrag
	returns::
		True if the current drag data is a Point.

METHOD:: defaultReceiveDrag
	Sets link::#-x:: and link::#-y:: to the two coordinates of the Point stored as the current drag data, respectively, and triggers the link::#-action::.




EXAMPLES::

code::
#+BEGIN_SRC sclang
(
w = Window("Slider2D", Rect(100, 100, 140, 140));
t = Slider2D(w, Rect(20, 20, 80, 80))
		.x_(0.5) // initial location of x
		.y_(1)   // initial location of y
		.action_({|sl|
			[\sliderX, sl.x, \sliderY, sl.y].postln;
		});
w.front;
)

t.x        // get the x loc
t.x_(0.25) // set the x loc
#+END_SRC

::

Drag an drop Points
code::
#+BEGIN_SRC sclang
(
w = Window("Slider2D", Rect(100, 100, 500, 300));
w.view.decorator = FlowLayout(w.view.bounds);
t = Slider2D(w, Rect(20, 20, 280, 280))
		.x_(0.5) // initial location of x
		.y_(1)   // initial location of y
		.background_(Color.rand)
		.action_({|sl|
			[\sliderX, sl.x, \sliderY, sl.y].postln;
		});
t.step_(0.01);

n = CompositeView.new(w, 200@300);
n.decorator = FlowLayout(n.bounds);

v = { |i| DragBoth.new(n, Rect(0, i * 20, 200, 20)).background_(Color.rand).align_(\center) }.dup(5);

StaticText.new(n, 200@150).string_("hold down cmd and drag points from the slider to the drag slots, or reverse").stringColor_(Color.white);

w.front;
)
#+END_SRC

::

Shape a Sound
code::
#+BEGIN_SRC sclang
(
s.waitForBoot({
	a = {arg mod = 0.05, index = 0.05;
			var r,out, out2;
			r = Saw.ar(8, 0.03);
			out = PMOsc.ar(
				440,
				660 * mod, 3 * index, 0,
				Lag.ar(r,0.01,1));
			[out,Delay1.ar(out)];
	}.play;

	w = Window("Slider2D", Rect(100,Window.screenBounds.height - 400, 300, 300));
	w.view.decorator = FlowLayout(w.view.bounds);
	t = Slider2D(w, Rect(0, 0,292, 292))
			.y_(0.05)
			.x_(0.05)
			.background_(Color.rand)
			.knobColor_(Color.rand)
			.action_({|sl|
				a.set(\mod,sl.x,\index,sl.y);
			});
	w.front;
	CmdPeriod.doOnce({w.close});
})
)
#+END_SRC

::
** class:: Slope
summary:: Slope of signal
categories:: UGens>Analysis, UGens>Filters>Linear, UGens>Maths

description::
Measures the rate of change per second of a signal.
Formula implemented is:

code::
#+BEGIN_SRC sclang
out[i] = (in[i] - in[i-1]) * sampling_rate
#+END_SRC

::

classmethods::
method:: ar, kr
argument::in
Input signal to measure.
argument::mul
argument::add

examples::
code::
#+BEGIN_SRC sclang
(
{
    var a, b, c, scale;
    a = LFNoise2.ar(2000);  // quadratic noise
    b = Slope.ar(a);        // first derivative produces line segments
    c = Slope.ar(b);        // second derivative produces constant segments
    scale = 0.0002; // needed to scale back to +/- 1.0
    [a, b * scale, c * scale.squared]
}.plot
)
#+END_SRC

::

For another example of Slope see link::Classes/AbstractFunction#hypot#AbstractFunction:hypot::.

** CLASS::SortedList
summary::a Collection whose items are kept in a sorted order.
categories::Collections>Ordered

CLASSMETHODS::

method::new
Creates a SortedList with the initial capacity given by strong::size:: and a comparison strong::function::.

INSTANCEMETHODS::

private::indexForInserting

method::add
Adds an item in the SortedList at the correct position.
code::
#+BEGIN_SRC sclang
SortedList[1, 2, 5, 6].add(4).postln;
#+END_SRC

::

method::addAll
Adds all the items in the collection into the SortedList.
code::
#+BEGIN_SRC sclang
SortedList[1, 2, 5, 6].addAll([0, 3, 4, 7]).postln;
#+END_SRC

::
** class:: SoundFile
summary:: sclang soundfile data
related:: Classes/File, Classes/Buffer
categories:: Files

description::
The SoundFile class is used to check the size, format, channels etc. when the sclang client needs this information about a SoundFile. Soundfile data can be read and modified. Soundfile data can also be read and written incrementally, so with properly designed code, there is no restriction on the file size.

In most cases you will wish to send commands to the server to get it to load SoundFiles directly into Buffers. You will not need to use this class for this. See the link::Classes/Buffer:: helpfile.

code::
#+BEGIN_SRC sclang
(
f = SoundFile.new;
f.openRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
f.inspect;
f.close;
)
#+END_SRC

::

ClassMethods::

method::new
Creates a new SoundFile instance.

method::collect
Returns an link::Classes/Array:: of SoundFile objects whose paths match the pattern. (The associated files are closed. These objects can be used to cue playback buffers)
code::
#+BEGIN_SRC sclang
SoundFile.collect("sounds/*").do { |f| f.path.postln };
#+END_SRC

::

method::use
Reads the data of a SoundFile, evaluates the function (passing the file as argument) and closes it again.
code::
#+BEGIN_SRC sclang
SoundFile.use(Platform.resourceDir +/+ "sounds/a11wlk01.wav", { |f| f.inspect });
#+END_SRC

::

method::normalize
Normalizes a soundfile to a level set by the user. The normalized audio will be written into a second file.

Using this class method (SoundFile.normalize) will automatically open the source file for you. You may also link::#-openRead:: the SoundFile yourself and call link::#-normalize:: on it. In that case, the source path is omitted because the file is already open.

See instance method link::#-normalize:: for more information.

InstanceMethods::

private::prOpenRead, prOpenWrite

subsection::Playback

method::cue
Allocates a buffer and cues the SoundFile for playback. Returns an event parameterized to play that buffer. (See link::Reference/NodeEvent:: for a description of how events can be used to control running synths.) The event responds to strong::play::, strong::stop::, strong::pause::, strong::resume::, keeping both the file and buffer open. The file is closed and the buffer is freed when the event is sent a strong::close:: message.

argument::ev
An link::Classes/Event:: can passed as an argument allowing playback to be customized using the following keys:
table::
## strong::key:: || strong::default value:: || strong::what it does::
## bufferSize || 65536 ||
## firstFrame || 0 || first frame to play
## lastFrame || nil || last frame to play (nil plays to end of file)
## out: || 0 || sets output bus
## server: || Server.default || which server
## group: || 1 || what target
## addAction: || 0 || head/tail/before/after
## amp: || 1 || amplitude
## instrument: || nil || if nil SoundFile:cue determines the SynthDef (one of diskIn1, diskIn2, ...diskIn16)
::
Where strong::bufferSize::, strong::firstFrame::, strong::lastFrame:: are for buffer and playback position, and strong::out::, strong::server::, strong::group::, strong::addAction::, strong::amp:: are synth parameters. Here is the default SynthDef used for stereo files:
code::
#+BEGIN_SRC sclang
SynthDef(\diskIn2, { | bufnum, out, gate = 1, sustain, amp = 1, ar = 0, dr = 0.01 |
	Out.ar(out, DiskIn.ar(2, bufnum)
	* Linen.kr(gate, ar, 1, dr, 2)
	* EnvGen.kr(Env.linen(0, sustain - ar - dr max: 0 ,dr),1, doneAction: 2) * amp)
});
#+END_SRC

::
The control strong::sustain:: determines playback duration based on the firstFrame and lastFrame. The control strong::gate:: allows early termination of the playback

argument::playNow
This is a link::Classes/Boolean:: that determines whether the file is to be played immediately after cueing.
code::
#+BEGIN_SRC sclang
f = SoundFile.collect("sounds/*");
e = f[1].cue;

e = f[1].cue( (addAction: 2, group: 1) );	// synth will play ahead of the default group
#+END_SRC

::

subsection::Read/Write

method::openRead
Read the header of a file. Answers a link::Classes/Boolean:: whether the read was successful. Sets the link::#-numFrames::, link::#-numChannels:: and link::#-sampleRate::. Does strong::not:: set the link::#-headerFormat:: and link::#-sampleFormat::.

argument::pathName
a link::Classes/String:: specifying the path name of the file to read.

method::readData
Reads the sample data of the file into the raw array you supply. You must have already called link::#-openRead::.

When you reach EOF, the array's size will be 0. Checking the array size is an effective termination condition when looping through a sound file. See the method link::#-channelPeaks:: for example.

argument::rawArray
The raw array must be a link::Classes/FloatArray::. Regardless of the sample format of the file, the array will be populated with floating point values. For integer formats, the floats will all be in the range -1..1.

The size of the FloatArray determines the maximum number of single samples (not sample frames) that will be read. If there are not enough samples left in the file, the size of the array after the readData call will be less than the original size.

method::openWrite
Write the header of a file. Answers a link::Classes/Boolean:: whether the write was successful.

argument::pathName
a link::Classes/String:: specifying the path name of the file to write.

method::writeData
Writes the rawArray to the sample data of the file. You must have already called link::#-openWrite::.

argument::rawArray
The raw array must be a link::Classes/FloatArray:: or link::Classes/Signal::, with all values between -1 and 1 to avoid clipping during playback.
code::
#+BEGIN_SRC sclang
(
f = SoundFile.new.headerFormat_("AIFF").sampleFormat_("int16").numChannels_(1);
f.openWrite("sounds/sfwrite.aiff");
	// sawtooth
b = Signal.sineFill(100, (1..20).reciprocal);
	// write multiple cycles (441 * 100 = 1 sec worth)
441.do({ f.writeData(b) });
f.close;
)
#+END_SRC

::

method::isOpen
answers if the file is open.

method::close
closes the file.

method::duration
the duration in seconds of the file.

subsection::Normalizing

method::normalize
Normalizes a soundfile to a level set by the user. The normalized audio will be written into a second file.

The normalizer may be used to convert a soundfile from one sample format to another (e.g., to take a floating point soundfile produced by SuperCollider and produce an int16 or int24 soundfile suitable for use in other applications).

note::
While the normalizer is working, there is no feedback to the user. It will look like SuperCollider is hung, but it will eventually complete the operation. You can set code::threaded:true:: to get feedback but it will take slightly longer to complete.
::

argument::outPath
a path to the destination file.

argument::newHeaderFormat
the desired header format of the new file; if not specified, the header format of the source file will be used.

argument::newSampleFormat
the desired sample format of the new file; if not specified, the sample format of the source file will be used.

argument::startFrame
an index to the sample frame to start normalizing.

argument::numFrames
the number of sample frames to copy into the destination file (default nil, or entire soundfile).

argument::maxAmp
the desired maximum amplitude. Provide a floating point number or, if desired, an array to specify a different level for each channel.

argument::linkChannels
a link::Classes/Boolean:: specifying whether all channels should be scaled by the same amount. The default is strong::true::, meaning that the peak calculation will be based on the largest sample in any channel. If false, each channel's peak will be calculated independently and all channels will be scaled to maxAmp (this would alter the relative loudness of each channel).

argument::chunkSize
how many samples to read at once (default is 4194304, or 16 MB).

argument::threaded
if true, the normalization runs in a routine so that SC can respond (intermittently) while processing. Prevents OSX beachballing.

subsection::Instance Variables

method::path
Get the pathname of the file. This variable is set via the link::#-openRead:: or link::#-openWrite:: calls.

method::headerFormat
This is a link::Classes/String:: indicating the header format which was read by openRead and will be written by openWrite. In order to write a file with a certain header format you set this variable.

definitionList::
## read/write header formats: ||
table::
## "AIFF" || Apple/SGI AIFF format
## "WAV","WAVE", "RIFF" || Microsoft WAV format
## "Sun", "NeXT" || Sun/NeXT AU format
## "SD2" || Sound Designer 2
## "IRCAM" || Berkeley/IRCAM/CARL
## "raw" || no header = raw data
## "MAT4" || Matlab (tm) V4.2 / GNU Octave 2.0
## "MAT5" || Matlab (tm) V5.0 / GNU Octave 2.1
## "PAF" || Ensoniq PARIS file format
## "SVX" || Amiga IFF / SVX8 / SV16 format
## "NIST" || Sphere NIST format
## "VOC" || VOC files
## "W64" || Sonic Foundry's 64 bit RIFF/WAV
## "PVF" || Portable Voice Format
## "XI" || Fasttracker 2 Extended Instrument
## "HTK" || HMM Tool Kit format
## "SDS" || Midi Sample Dump Standard
## "AVR" || Audio Visual Research
## "FLAC" || FLAC lossless file format
## "CAF" || Core Audio File format
::
::
Additionally, a huge number of other formats are supported read only.

method::sampleFormat
A link::Classes/String:: indicating the format of the sample data which was read by link::#-openRead:: and will be written by link::#-openWrite::. libsndfile determines which header formats support which sample formats. This information is detailed at http://www.mega-nerd.com/libsndfile . The possible header formats are:
definitionList::
## sample formats: ||
table::
## "int8", "int16", "int24", "int32"
## "mulaw", "alaw",
## "float"
::
::
Not all header formats support all sample formats.

method::numFrames
The number of sample frames in the file.

method::numChannels
The number of channels in the file.

method::sampleRate
The sample rate of the file.
** class:: SoundFileView
redirect:: implClass
summary:: Sound file display
categories:: GUI>Views
related:: Classes/SoundFile


DESCRIPTION::

A sound file viewer with numerous options.

In strong::Qt GUI:: you can strong::zoom:: in and out using Shift + right-click + mouse-up/down; likewise, you can strong::scroll:: using right-click + mouse-left/right.

CLASSMETHODS::

PRIVATE:: key


INSTANCEMETHODS::

SUBSECTION:: Data

METHOD:: soundfile

    argument::
        An Instance of SoundFile to display.


METHOD:: read

    Reads a section of the link::#-soundfile:: and displays it in the view. For large files, you may want to use readWithTask instead.

    note:: In Qt GUI, the 'block' argument has no effect; the display resolution is infinite. ::

    argument:: startFrame
        The beginning of the section, in frames.

    argument:: frames
        The size of the section, in frames.

    argument:: block
        The block size - visual resolution of the display. An Integer of the form 2**n.

    argument:: closeFile
        If true, closes the SoundFile after reading.


METHOD:: readFile

    Reads a section of an open instance of SoundFile, and displays it in the view. For large files, you may want to use the method readWithTask instead.

    note:: In Qt GUI, the 'block' argument has no effect; the display resolution is infinite. ::

    argument:: soundfile
        An open instance of SoundFile.

    argument:: startFrame
        The beginning of the section, in frames.

    argument:: frames
        The size of the section, in frames.

    argument:: block
        The block size - visual resolution of the display. An Integer of the form 2**n.

    argument:: closeFile
        If true, closes the SoundFile after reading.

METHOD:: readWithTask

    Reads a section of the link::#-soundfile:: asynchronously (in the background), updating the link::#-readProgress:: along the way. If the code::showProgress:: argument is code::true::, a SoundFileViewProgressWindow opens to show the progress.

    note:: In Qt GUI:
        The 'block' argument has no effect; the display resolution is infinite.
        The 'showProgress' argument has no effect; the view always displays reading progress within itself.
    ::

    argument:: startFrame
        The beginning of the section, in frames.

    argument:: frames
        The size of the section, in frames.

    argument:: block
        The block size - visual resolution of the display. An Integer of the form 2**n.

    argument:: doneAction
        An optional function to be evaluated on completion.

    argument:: showProgress
        Whether to open a progress window. Defaults to code::true::.


METHOD:: readFileWithTask

    Reads a section of an open instance of SoundFile asynchronously (in the background), updating the link::#-readProgress:: along the way. If the code::showProgress:: argument is code::true::, a SoundFileViewProgressWindow opens to show the progress.

    note:: In Qt GUI:
        The 'block' argument has no effect; the display resolution is infinite.
        The 'showProgress' argument has no effect; the view always displays reading progress within itself.
    ::

    argument:: soundfile
        An open instance of SoundFile.

    argument:: startFrame
        The beginning of the section, in frames.

    argument:: frames
        The size of the section, in frames.

    argument:: block
        The block size - visual resolution of the display. An Integer of the form 2**n.

    argument:: doneAction
        An optional function to be evaluated on completion.

    argument:: showProgress
        Whether to open a progress window. Defaults to code::true::.

METHOD:: data

    Gets the display data, or sets custom data instead of a sound file.

    note:: In Qt and SwingOSC it is not possible to get the data. ::

    In Cocoa and SwingOSC, setting this property is equivalent to link::#-setData:: with number of channels and sample rate of the current link::#-soundfile:: (if any), while in Qt it always assumes 1 channel and sample rate of 44100 Hz. Use link::#-setData:: instead if you want more control.

    argument::
        An Array of Floats; multiple channel data should be interleaved.

METHOD:: setData

    Sets custom display data instead of a sound file, interpreting it using specified number of channels and sample rate.

    note:: In Qt GUI, the 'block' argument has no effect; the display resolution is infinite. ::

    argument:: arr
        An Array of Floats; multiple channel data should be interleaved.

    argument:: block
        The block size - visual resolution of the display. An Integer of the form 2**n.

    argument:: startframe
        An integer.

    argument:: channels
        An integer.

    argument:: samplerate
        An integer.

METHOD:: alloc
    NOTE:: Only in Qt GUI ::
    Allocates a desired amount of display channels and frames; all frames have initial value of 0.
    argument:: frames
        An Integer.
    argument:: channels
        An Integer.
    argument:: samplerate
        An Integer.

METHOD:: set
    NOTE:: Only in Qt GUI ::
    Overwrites a range of display data with another data. This method can be used after link::#-alloc:: or link::#-setData:: has been called, but not while the view is displaying a sound file.

    argument:: offset
        The frame at which to start overwriting; an Integer.
    argument:: data
        The new data; an Array of Floats; multiple channel data should be interleaved.

METHOD:: startFrame

    The beginning of the read section of the soundfile, or 0 if link::#-alloc:: or link::#-setData:: has been used.

METHOD:: numFrames

    The total amount of frames in the view; this is unrelated to link::#-zoom#zooming:: and link::#-scroll#scrolling::.

METHOD:: readProgress

     The reading progress, updated periodically when reading a soundfile using link::#-readWithTask:: or link::#-readFileWithTask::.

SUBSECTION:: Navigation

METHOD:: viewFrames

    The amount of currently visible frames in the view.

METHOD:: zoom

    Zooms by a factor relative to current zoom.

    argument::
        A Float.

METHOD:: zoomToFrac

    Zooms to a specific scale.

    argument::
        A Float.

METHOD:: zoomAllOut

    Zooms to the link::#-currentSelection#current selection::.

METHOD:: zoomSelection

    Zooms to a specific selection.

    argument::
        The index of the selection; an Integer between 0 an 63.

METHOD:: scrollPos

    The scrolling position of the view, as a fraction of the total scrolling range.

    returns::
        A Float in the range of 0.0 to 1.0.

METHOD:: scrollTo

    Scrolls to a fraction of the total scrolling range.

    argument::
        A Float in the range of 0.0 to 1.0.

METHOD:: scroll

    Scrolls by a fraction of the visible range.

    argument::
        A Float.

METHOD:: scrollToStart

    Scrolls to the beginning.

METHOD:: scrollToEnd

    Scrolls to the end.


SUBSECTION:: Selection

METHOD:: selections

    All the selections.

    returns:: An array of 64 arrays of start frames and sizes: [ [ start0, size0 ] , [ start1, size1 ], ... ].

METHOD:: selection

    The selection at index.

    returns::
        An Array of the form code::[start, size]::, where start and size denote frames.

METHOD:: setSelection

    Sets the selection at index.

    argument:: index
        An Integer between 0 an 63.

    argument:: selection
        An Array of the form code::[start, size]::, where start and size are Integers and denote frames.

METHOD:: currentSelection

    The index of the current selection

    argument::
        An integer between 0 an 63.

METHOD:: selectionStart

    The start frame of a selection.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    returns::
        An Integer.

METHOD:: setSelectionStart

    Sets the start frame of a selection.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    argument:: frame
        The starting frame of the selection, an Integer.

METHOD:: selectionSize

    The size of a selection.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    returns::
        An Integer.

METHOD:: setSelectionSize

    Sets the size of a selection.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    argument:: frames
        The size in frames of the selection, an Integer.

METHOD:: selectionStartTime

    The start of a selection in seconds.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    returns::
        A Float.

METHOD:: selectionDuration

    The size of a selection in seconds.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    returns::
        A Float.

METHOD:: selectAll

    Sets a selection to span the whole data range.

    argument:: index
        The index of the selection; an Integer between 0 an 63.


METHOD:: selectNone

    Sets the size of a selection to 0.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

METHOD:: setSelectionColor

    Sets the color of a selection.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    argument:: color
        A Color.

METHOD:: setEditableSelectionStart

    Sets whether the start point of a selection can be edited.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    argument:: editable
        A Boolean.

METHOD:: setEditableSelectionSize

    Whether the end point of a selection can be edited.

    argument:: index
        The index of the selection; an Integer between 0 an 63.

    argument:: editable
        A Boolean.

METHOD:: readSelection

    note:: Not in Qt GUI ::

    Read the data within a selection.

    argument:: block
        The block size - visual resolution of the display. An Integer of the form 2**n.

    argument:: closeFile
        If true, closes the SoundFile after reading.

METHOD:: readSelectionWithTask

    note:: Not in Qt GUI ::

    Read the data within the current selection asynchronously (in the background), showing the progress in a separate window.


SUBSECTION:: Display

METHOD:: gridOn

    Whether the grid is displayed. Defaults to code::true::.

    argument::
        A Boolean.

METHOD:: gridResolution

    The resolution of the grid.

    argument::
        An instance of Float.

METHOD:: gridOffset

    Sets the grid offset.

    argument::
        An integer.

METHOD:: gridColor

    The color of the grid.

    argument::
        A Color.

METHOD:: drawsWaveForm

    Whether the data is displayed. Defaults to code::true::.

    argument::
        A Boolean.

METHOD:: timeCursorOn

    Whether the time cursor is displayed. Defaults to code::false::.

    argument::
        A Boolean.

METHOD:: timeCursorPosition

    The position of the time cursor in frames.

    argument::
        An Integer.

METHOD:: timeCursorColor

    The color of the time cursor.

    argument::
        A Color.

METHOD:: elasticMode

    ???

SUBSECTION:: Actions

METHOD:: action

    The object to be evaluated whenever the user interacts with the view.

METHOD:: metaAction

    The object to be evaluated on Ctrl + click.


EXAMPLES::

SUBSECTION:: Basic example

code::
#+BEGIN_SRC sclang
// In Qt GUI:
// To zoom in/out: Shift + right-click + mouse-up/down
// To scroll: right-click + mouse-left/right
(
w = Window.new("soundfile test", Rect(200, 300, 740, 100));
a = SoundFileView.new(w, Rect(20,20, 700, 60));

f = SoundFile.new;
f.openRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
f.inspect;

a.soundfile = f;
a.read(0, f.numFrames);
a.elasticMode = true;

a.timeCursorOn = true;
a.timeCursorColor = Color.red;
a.timeCursorPosition = 2050;
a.drawsWaveForm = true;
a.gridOn = true;
a.gridResolution = 0.2;

w.front;
)
#+END_SRC

::

SUBSECTION:: Step by step examples

code::
#+BEGIN_SRC sclang
( // make a simple SoundFileView
y = Window.screenBounds.height - 120;
w = Window.new("soundfile test", Rect(200, y, 740, 100)).alwaysOnTop_(true);
w.front;
a = SoundFileView.new(w, Rect(20,20, 700, 60));

f = SoundFile.new;
f.openRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
// f.inspect;

a.soundfile = f;            // set soundfile
a.read(0, f.numFrames);     // read in the entire file.
a.refresh;                  // refresh to display the file.
)

// In Qt GUI:
// To zoom in/out: Shift + right-click + mouse-up/down
// To scroll: right-click + mouse-left/right

// reading file
a.read(0, f.numFrames / 2).refresh; // read first half
a.read.refresh;                     // read entire file by default
a.read(f.numFrames / 2).refresh;    // read second half
a.read(0, -1).refresh;              // -1 also reads entire file, like buffer.

// In Qt GUI, the resolution of the view is always infinite;
// you can always zoom in until you see a single sample.

// In other GUI kits, 'block' sets the resolution of the view (default is 64).
// i.e. the view keeps peak values for each block of e.g. 64 samples
// rather than the entire waveform.
a.read(0, -1, block: 32).refresh;
a.read(0, -1, block: 24).refresh;
a.read(0, -1, block: 16).refresh;

// for longer files, you can use:
a.readWithTask;

// zoom is relative
a.zoom(0.2).refresh;
a.zoom(2).refresh;
a.zoom(2).refresh;
a.zoomToFrac(0.5); // zoom to half file size
a.zoomAllOut;

a.gridOn = true;            // time grid, 1 second by default,
a.gridResolution = 0.2;     // or set resolution in seconds
a.gridColor = Color.cyan;   // color is changeable.
a.gridOffset_(0.1);         // not sure if this is working?

a.timeCursorOn = true;          // a settable cursor
a.timeCursorPosition = 2050;    // position is in frames.
a.timeCursorColor = Color.white;

// toggle drawing on/off
a.drawsWaveForm = false;
a.drawsWaveForm = true;

// these methods should return view properties:
a.gridOn
a.gridResolution
a.gridColor
a.timeCursorOn
a.timeCursorPosition
a.timeCursorColor

// Selections: multiple selections are supported.
// e.g. use selection 0:
a.setSelectionColor(0, Color.red);  // set...( index, value )
a.selectionStart(0);                // at index
a.setSelectionStart(0, 12345);
a.setSelectionSize(0, 12345);

a.setSelectionStart(0, 1234);
a.selectionStart(0);

// now selection 1
a.setSelectionColor(1, Color.white);
a.setSelectionStart(1, 1234).setSelectionSize(1, 1234 * 2);
a.selectionStart(1);
a.setSelectionStart(0, 12345);

// the current selection gets changed when click/dragging in view.
a.currentSelection;     // index of current selection;
a.currentSelection_(1); // switch current selection - try click/drag white now.
a.currentSelection;

a.selections.size;      // 64 selections
a.selections[0];
a.selections[1];
a.selections;

// setSelection (index, selection);
a.setSelection(0, [234, 2345]);
a.selection(1); // returns [start, size].


a.elasticMode = true;   // not sure if this is working yet?

(       // mouseUpAction
a.mouseUpAction = {
    ("mouseUp, current selection is now:"
        + a.selections[a.currentSelection]).postln;
};
)
// lock selection 0:
a.currentSelection_(0);
a.setEditableSelectionStart(0, false);
a.setEditableSelectionSize(0, false);


// unlock selection 0:
a.setEditableSelectionStart(0, true);
a.setEditableSelectionSize(0, true);

a.selectionStartTime(0);
a.selectionDuration(0);


a.setSelectionStart(0, 12345);
a.setSelectionSize(0, 12345);
a.readSelection.refresh;
a.readSelection(16).refresh;    // in higher resolution
a.read.refresh;                 // go back to entire file.


a.dataNumSamples;   // visual data have this many points
a.data.plot;
a.setData(a.data.reverse);


a.zoom(0.25);       // scrolling is normalized
a.scrollTo(0.5);    //
a.scrollTo(0.6);    //
a.scroll(12);       // scroll is in viewFrames.

a.zoom(4);

w.close;
#+END_SRC

::
** class:: SoundIn
summary:: Read audio from hardware inputs
categories:: UGens>InOut
related:: Classes/In, Classes/ServerOptions

description::
SoundIn is a convenience UGen to read audio from the input of your computer or soundcard. It is a wrapper link::Classes/UGen:: based on link::Classes/In::, which offsets the index such that 0 will always correspond to the first input regardless of the number of inputs present.

note::
On Intel based Macs, reading the built-in microphone or input may require creating an aggregate device in AudioMIDI Setup.

code::"open -a 'Audio MIDI Setup'".unixCmd; // execute this to launch it::
::

classmethods::
method:: ar

argument:: bus
the channel (or array of channels) to read in. These start at 0, which will correspond to the first audio input.

argument:: mul

argument:: add

examples::
code::
#+BEGIN_SRC sclang
// world's most expensive patchcord (use headphones to avoid feedback)
{ SoundIn.ar(0) }.play;

// stereo version
{ SoundIn.ar([0, 1]) }.play;

// scope input; silent output
{ Amplitude.kr(SoundIn.ar(0)); }.scope;
#+END_SRC

::
** CLASS::SparseArray
categories::Collections>Ordered
summary:: Array that stores duplicated values more efficiently

DESCRIPTION::
A sparse array is a data structure that acts in exactly the same manner as an Array. However, data is represented differently in memory, in a way that makes it much more efficient to store very large arrays in which many values are the same.

Take for example an array consisting of a million zeroes, with a 1 appended to the end; SparseArray would compress this array by storing zero as a default value, and only explicitly storing the single value that differs, therefore offering a much more economical use of memory.

The benefits of using SparseArray typically arise when creating collections containing many millions of slots.

CLASSMETHODS::

method::newClear
Create a new SparseArray of the specified strong::size::, with each slot's value being strong::default::.
code::
#+BEGIN_SRC sclang
g = SparseArray.newClear(20, 3);
g.postcs;
#+END_SRC

::
argument::size
Number of slots in the desired array. Note that slots are not explicitly created, so the speed of creation is not related to the array size.
argument::default
The default value, i.e. the value that all slots should take at first.

method::reduceArray
Create a new SparseArray holding the same data as strong::array::.
code::
#+BEGIN_SRC sclang
a = [4, 7, 4, 4, 4, 4, 4, 4, 9, 9, 8];
g = SparseArray.reduceArray(a, 4);
g.postcs;
#+END_SRC

::
argument::array
Any link::Classes/ArrayedCollection::.
argument::default
The default value, i.e. the value that all slots should take at first. For best memory efficiency, you should supply the most common value found in the collection.

INSTANCEMETHODS::

private::prPutSlot

method::put
Put a value at the desired index. This works just like all ArrayedCollection types. Behind the scenes the class will ensure the compact representation (deciding whether to store the value explicitly or implicitly).
code::
#+BEGIN_SRC sclang
g = SparseArray.newClear(10, 3);
g.put(4, \horse);
g.put(6, [4,5,6]);
g[1] = \hello; // Common compact notation
#+END_SRC

::

method::at
Retrieve the value at index.
code::
#+BEGIN_SRC sclang
g = SparseArray.newClear(20, 3);
g.put(4, \horse);
g.at(4);
g[4];
#+END_SRC

::

method::asArray
Convert to an ordinary link::Classes/Array::.
code::
#+BEGIN_SRC sclang
g = SparseArray.newClear(20, 3);
g.postcs;
g.asArray;
#+END_SRC

::

EXAMPLES::

Here we compare speed of Array vs SparseArray.

code::
#+BEGIN_SRC sclang
// Let's create a standard array, big but with only a couple of unusual values hidden in there
(
{
	a = {10}.dup(1000000);
	a[551] = 77;
	a[8722] = \foo;
}.bench
)
// Now a SparseArray made out of exactly the same data
(
{
	b = SparseArray.newClear(a.size, 10);
	b[551] = 77;
	b[8722] = \foo;
}.bench
)

// Alternatively you could make the SparseArray out of the existing array,
// although this is typically not as efficient as starting from scratch
// since the Array needs to be scanned directly.
(
{
	b = SparseArray.reduceArray(a, 10);
}.bench
)

// accessing:
{1000.do{ a[a.size.rand] == 60.rand }}.bench
{1000.do{ b[b.size.rand] == 60.rand }}.bench
// setting:
{1000.do{ a[a.size.rand] = 60.rand }}.bench
{1000.do{ b[b.size.rand] = 60.rand }}.bench
#+END_SRC

::
** class:: Spec
summary:: input datatype specification
related:: Classes/ControlSpec, Classes/Warp
categories:: Control, Spec

description::
Specs specify what kind of input is required or permissible, and what the range of those parameters are. This is an abstract class - the most common subclass is: link::Classes/ControlSpec::.

ControlSpec is used by GUI sliders and knobs to specify the range and curve of the controls. Input datatypes are of interest to functions, to gui interface objects (sliders etc.) and can also be used for introspection.

The class Spec itself holds a master link::Classes/IdentityDictionary:: of common specifications. The name that the spec was stored as can then be used as a shorthand to refer to specs:
code::
#+BEGIN_SRC sclang
\freq.asSpec
#+END_SRC

::

Some common mappings are initialized in code::ControlSpec.initClass::. You may add or overwrite mappings as you wish. The crucial library (available as a quark, see link::Classes/Quarks::) defines a number of additional subclasses. See the file quarks/cruciallib/Instr/MoreSpecs.sc

ClassMethods::

private::initClass

method::add
Add a spec to the global spec dictionary. The item will be converted to a spec using .asSpec.

Examples::

code::
#+BEGIN_SRC sclang
Spec.add(\helpExp, ControlSpec( 0.01, 1.0, \exp) );

// the array will be converted to a control spec
Spec.add(\helpLin, [0, 1, \lin, 0.011, 0.01]);

// a symbol will be looked up converteuse the existing \freq spec for \helpLin2
Spec.add(\helpLin2, \freq);

// existing spec:
Spec.add(\helpLin, ControlSpec(0.ampdb, 1.ampdb, \db, units: " dB"));


// List of default specs:

\unipolar -> ControlSpec(0, 1),
\bipolar -> ControlSpec(-1, 1, default: 0),

\freq -> ControlSpec(20, 20000, \exp, 0, 440, units: " Hz"),
\lofreq -> ControlSpec(0.1, 100, \exp, 0, 6, units: " Hz"),
\midfreq -> ControlSpec(25, 4200, \exp, 0, 440, units: " Hz"),
\widefreq -> ControlSpec(0.1, 20000, \exp, 0, 440, units: " Hz"),
\phase -> ControlSpec(0, 2pi),
\rq -> ControlSpec(0.001, 2, \exp, 0, 0.707),

\audiobus -> ControlSpec(0, Server.default.options.numAudioBusChannels-1, step: 1),
\controlbus -> ControlSpec(0, Server.default.options.numControlBusChannels-1, step: 1),

\midi -> ControlSpec(0, 127, default: 64),
\midinote -> ControlSpec(0, 127, default: 60),
\midivelocity -> ControlSpec(1, 127, default: 64),

\db -> ControlSpec(0.ampdb, 1.ampdb, \db, units: " dB"),
\amp -> ControlSpec(0, 1, \amp, 0, 0),
\boostcut -> ControlSpec(-20, 20, units: " dB",default: 0),

\pan -> ControlSpec(-1, 1, default: 0),
\detune -> ControlSpec(-20, 20, default: 0, units: " Hz"),
\rate -> ControlSpec(0.125, 8, \exp, 0, 1),
\beats -> ControlSpec(0, 20, units: " Hz"),

\delay -> ControlSpec(0.0001, 1, \exp, 0, 0.3, units: " secs")
#+END_SRC

::
** class:: SpecCentroid
summary:: Spectral centroid
categories:: UGens>FFT
related:: Classes/SpecFlatness, Classes/SpecPcile

description::
Given an link::Classes/FFT:: strong::chain::, this measures the emphasis::spectral:: centroid, which is the weighted mean frequency, or the "centre of mass" of the spectrum. (DC is ignored.)

This can be a useful indicator of the perceptual emphasis::brightness:: of a signal.

classmethods::
method:: kr

argument:: buffer
an link::Classes/FFT:: chain.

examples::

A link::Classes/Blip:: oscillator is ideal for demonstrating this because the number of harmonics is directly manipulated: as the number of harmonics increases, the centroid is pushed higher. In the example, left-to-right changes the number of harmonics, but up-to-down changes the fundamental pitch; note the different effects of these two on the centroid.

code::
#+BEGIN_SRC sclang
s.boot;
b = Buffer.alloc(s,2048,1);
(
x = {
var in, chain, freq, rq, centroid;

//freq = LFPar.kr(0.3).exprange(100, 1000);
freq = MouseY.kr(1000, 100, 1);

in = Blip.ar(freq, MouseX.kr(1, 100, 1));

chain = FFT(b, in);

centroid = SpecCentroid.kr(chain);

Out.ar(0, in.dup * 0.1);
centroid.poll(10);
}.play(s);
)

x.free;
#+END_SRC

::
** class:: SpecFlatness
summary:: Spectral Flatness measure
categories:: UGens>FFT
related:: Classes/SpecCentroid, Classes/SpecPcile

description::
Given an link::Classes/FFT:: strong::chain:: this calculates the emphasis::Spectral Flatness:: measure, defined as a power spectrum's geometric mean divided by its arithmetic mean. This gives a measure which ranges from approx 0 for a pure sinusoid, to approx 1 for white noise.

The measure is calculated linearly. For some applications you may wish to convert the value to a decibel scale - an example of such conversion is shown below.

classmethods::
method:: kr

argument:: buffer
an link::Classes/FFT:: chain.

examples::

code::
#+BEGIN_SRC sclang
s = Server.internal.boot;
b = Buffer.alloc(s,2048,1);

(
{ // Example - vary mixture of white noise and pure tone with the mouse
var in, chain, flat, flatdb, flatdbsquish;
in = XFade2.ar(WhiteNoise.ar, SinOsc.ar, MouseX.kr(-1,1));
chain = FFT(b, in);
Out.ar(0, in * 0.1);

flat = SpecFlatness.kr(chain);

flatdb = 10 * flat.log; // Convert to decibels
flatdbsquish = LinLin.kr(flatdb, -45, -1.6, 0, 1).max(-10); // Rescale db roughly to 0...1.

flat.poll(10, "flatness: ");
flatdb.poll(10, "flatness (db): ");

Out.kr(0, [flat, flatdbsquish]);
}.scope;
)

(
{ // Now try with your own voice
var in, chain;
in = SoundIn.ar([0,1]).mean;
chain = FFT(b, in);
Out.kr(0, [in, SpecFlatness.kr(chain).poll(1, "flatness: ")]);
}.scope;
)
#+END_SRC

::
** class:: SpecPcile
summary:: Find a percentile of FFT magnitude spectrum
categories:: UGens>FFT
related:: Classes/SpecCentroid, Classes/SpecFlatness

description::
Given an link::Classes/FFT:: chain this calculates the cumulative distribution of the frequency spectrum, and outputs the frequency value which corresponds to the desired percentile.

For example, to find the frequency at which 90% of the spectral energy lies below that frequency, you want the 90-percentile, which means the value of emphasis::fraction:: should be 0.9. The 90-percentile or 95-percentile is often used as a measure of strong::spectral roll-off::.

The optional third argument strong::interpolate:: specifies whether interpolation should be used to try and make the percentile frequency estimate more accurate, at the cost of a little higher CPU usage. Set it to 1 to enable this.

classmethods::
method:: kr

argument:: buffer
an link::Classes/FFT:: chain.
argument:: fraction
argument:: interpolate

examples::

code::
#+BEGIN_SRC sclang
s = Server.internal.boot;
b = Buffer.alloc(s,2048,1);

// Simple demo with filtering white noise, and trying to infer the cutoff freq.
// Move the mouse.
(
{
var in, chain, realcutoff, estcutoff;
realcutoff = MouseX.kr(0.00001,22050);
in = LPF.ar(WhiteNoise.ar, realcutoff);
chain = FFT(b, in);
estcutoff = Lag.kr(SpecPcile.kr(chain, 0.9), 1);
realcutoff.poll(Impulse.kr(1), "real cutoff");
estcutoff.poll(Impulse.kr(1), "estimated cutoff");
Out.ar(0, in);
Out.kr(0, estcutoff * 22050.0.reciprocal);
}.scope;
)

// Audio input - try different vowel/long-consonant sounds and see what comes out.
// Specifically, change from "ssss" through to "aaaa" through to "wwww".
(
{
var in, chain, perc;
in = SoundIn.ar([0,1]).mean;
chain = FFT(b, in);
//Out.ar(0, in * 0.1);
perc = SpecPcile.kr(chain, 0.5);
Out.ar(1, LPF.ar(WhiteNoise.ar, perc)); //NB Outputting to right channel - handy on PowerBooks
Out.kr(0, perc * 22050.0.reciprocal);
}.scope;
)
#+END_SRC

::
** class:: Speech
summary:: lets you use the Apple speech synthesizer
categories:: Platform>OSX

description::

code::
#+BEGIN_SRC sclang
"hi i'm talking with the default voice now, i guess".speak;
#+END_SRC

::

Speech consists of an link::Classes/Array:: of SpeechChannels. By default Speech is initialized with only one channel, but can be set up to use up to 16 by providing an argument to init. Channels may be used through a SpeechChannel object or by setting the channel in Speech's methods (see examples below).

Speech is a function of the operating system and not the server. By consequence, strong::it is not possible to use UGens to filter or record the output directly::. You may be able to patch system output to system input (either by hardware of by software) to rout it to the server.

note::
Currently only supported on OS X. In SwingOSC there is the equivalent JSpeech.
::

ClassMethods::

private::prInitSpeech

Examples::

code::
#+BEGIN_SRC sclang
Speech.init(2);
Speech.channels[0].speak("hallo");
Speech.channels[0].isActive;
Speech.channels[0].voice_(3);
Speech.channels[0].speak("hallo");
Speech.channels[0].pitch_(60);
Speech.channels[0].speak("hallo");
Speech.channels[0].volume_(-20.dbamp);
Speech.channels[0].pitchMod_(50);
Speech.channels[0].speak("hallo");
Speech.channels[0].stop(\immediate);
Speech.channels[0].stop(\endOfWord);
Speech.channels[0].stop(\endOfSentence);
#+END_SRC

::

Force the voice to speaking something different by setting the second argument of speak to true.
code::
#+BEGIN_SRC sclang
Speech.channels[0].speak("Force the voice to speaking something different.");
Speech.channels[0].speak("Force the voice to speaking something different.".reverse, true);
#+END_SRC

::

First argument is always the voice channel number, second the value.
code::
#+BEGIN_SRC sclang
Speech.setSpeechVoice(0,14);
Speech.setSpeechPitch(0, 40); //pitch in MIDI Num
Speech.setSpeechRate(0, 10);
Speech.setSpeechVolume(0,0.1);
Speech.setSpeechPitchMod(0, 200);
Speech.stop(0, 1);
#+END_SRC

::

Two actions can be applied:
code::
#+BEGIN_SRC sclang
Speech.wordAction = {arg voiceNum;
	//i.postln;
	// the currently speaking text may not be changed
	//Speech.setSpeechPitch(voiceNum,[41,60].choose);
	//Speech.setSpeechRate(voiceNum,[60,80, 10].choose);
};
Speech.doneAction_({arg voiceNum;
	Speech.setSpeechPitch(voiceNum,[41,48,40,43,30,60].choose);
});
#+END_SRC

::

Pause the speech while speaking: 1=pause, 0= start
code::
#+BEGIN_SRC sclang
Speech.pause(0,1);
#+END_SRC

::

Initialization happens automatically, by default with one voice channel.
You may explicitly initalize with more channels, up to 16:
code::
#+BEGIN_SRC sclang
(
Speech.init(16);

Task({
	16.do ({arg i;
		[0.1, 0.18, 0.2].choose.wait;
		Speech.setSpeechRate(i,[90, 30, 60].choose);
		Speech.setSpeechVolume(i,0.07);
		"no this is private. float . boolean me. char[8] ".speak(i);
	});
}).play;
)

//jan@sampleAndHold.org 04/2003
//update 10/2007
#+END_SRC

::
** class:: Splay
summary:: Splay spreads an array of channels across the stereo field
categories:: UGens>Multichannel>Panners
related:: Classes/SplayAz, Classes/SplayZ

description::
Splay spreads an array of channels across the stereo field.
Optional arguments are spread and center, and equal power levelCompensation.
The formula for the stereo position is ((0 .. (n - 1)) * (2 / (n - 1) - 1) * spread + center

classmethods::
method:: ar, kr
argument:: inArray
The array of channels to be distributed over the two stereo pairs
argument:: spread
For spread = 0, all channels end up in the centre, for 1, they have maximum distribution
argument:: level
An amplitude multiplier for all channels
argument:: center
Shift the centre of the distribution.
argument:: levelComp


method:: arFill
In analogy to Mix:arFill, this method takes a function that produces the channels. The countinmg index is passed to it.
argument:: n
Number of channels
argument:: function
Function to return each channel
argument:: spread
For spread = 0, all channels end up in the centre, for 1, they have maximum distribution
argument:: level
An amplitude multiplier for all channels
argument:: center
Shift the centre of the distribution.
argument:: levelComp

examples::

code::
#+BEGIN_SRC sclang
(
x = { arg spread=1, level=0.2, center=0.0;
 Splay.ar(
  SinOsc.ar( { |i| LFNoise2.kr(1).exprange(200, 4000) } ! 10),
  spread,
  level,
  center
 );
}.play;
)

x.set(\spread, 1,   \center, 0);  // full stereo
x.set(\spread, 0.5, \center, 0);  // less wide
x.set(\spread, 0,   \center, 0);  // mono center
x.set(\spread, 0.5, \center, 0.5);
// spread from center to right
x.set(\spread, 0,   \center, -1); // all left
x.set(\spread, 1,   \center, 0);  // full stereo


 // the a similar example written with arFill:
(
x = { arg spread=1, level=0.2, center=0.0;
 Splay.arFill(10,
  { |i| SinOsc.ar( LFNoise2.kr( rrand(10, 20), 200, i + 3 * 100))  },
  spread,
  level,
  center
 );
}.play;
)


 // with mouse control
(
x = { var src;
 src = SinOsc.ar( { |i| LFNoise2.kr( rrand(10, 20), 200, i + 3 * 100) } ! 10);
 Splay.ar(src, MouseY.kr(1, 0), 0.2, MouseX.kr(-1, 1));
}.play;
)
#+END_SRC

::
** class:: SplayAz
summary:: Spreads an array of channels across a ring of channels
categories:: UGens>Multichannel>Panners
related:: Classes/Splay, Classes/SplayZ

description::
SplayAz spreads an array of channels across a ring of channels.
Optional spread and center controls, and levelComp(ensation) (equal power).
numChans and orientation are as in link::Classes/PanAz::.

classmethods::

method:: ar
argument:: numChans
argument:: inArray
argument:: spread
argument:: level
argument:: width
argument:: center
argument:: orientation
argument:: levelComp

method:: arFill
argument:: numChans
argument:: n
argument:: function
argument:: spread
argument:: level
argument:: width
argument:: center
argument:: orientation
argument:: levelComp

examples::
code::
#+BEGIN_SRC sclang
(
x = { arg spread=1, level=0.2, width=2, center=0.0;
 SplayAz.ar(
  4,
  SinOsc.ar( { |i| LFNoise2.kr( rrand(10, 20), 200, i + 3 * 100) } ! 10),
  spread,
  level,
  width,
  center
 );
}.scope;
)

x.set(\spread, 1,   \center, 0);  // full n chans
x.set(\spread, 0.5, \center, -0.25); // less wide
x.set(\spread, 0, \center, 0);  // mono center (depends on orientation, see PanAz)
x.set(\spread, 0, \center, -0.25); //
x.set(\spread, 0.0, \center, 0.5); // mono, but rotate 1 toward the higher channels
x.set(\spread, 0.5, \center, 0.5); // spread over the higher channels
x.set(\spread, 0,   \center, -0.25); // all on first channel
x.set(\spread, 1,   \center, 0);  // full n chans

x.free;

 // the same example written with arFill:
(
x = { arg spread=1, level=0.5, width=2, center=0.0;
 SplayAz.arFill(
  4,
  10,
  { |i| SinOsc.ar( LFNoise2.kr( rrand(10, 20), 200, i + 3 * 100) ) },
  spread,
  level,
  width,
  center
 );
}.scope;
)

 // or with mouse control
(
x = { var src;
 src = SinOsc.ar( { |i| LFNoise2.kr( rrand(10, 20), 200, i * 100 + 400) } ! 10);
 SplayAz.ar(4, src, MouseY.kr(1, 0), 0.2, center: MouseX.kr(-1, 1));
}.scope;
)

// test for correct behavior:
	// only on chan 0
{ SplayAz.ar(4, SinOsc.ar * 0.2, orientation: 0) }.scope;

	//  on chan 0, 3, i.e. equally around the ring
{ SplayAz.ar(6, SinOsc.ar([2, 3] * 200) * 0.2, orientation: 0) }.scope;

	// equal spread on 0, 2, 4
{ SplayAz.ar(6, SinOsc.ar([2, 3, 5] * 200) * 0.2, orientation: 0) }.scope;


	// wrong behavior of SplayZ:
		// plays on chan 2, but should play on 0
{ SplayZ.ar(4, SinOsc.ar * 0.2, orientation: 0) }.scope;

	//  wrong: mixes both to chan 2,
	// because pan values [-1, 1] are the same pos on the ring
{ SplayZ.ar(6, SinOsc.ar([2, 3] * 200) * 0.2, orientation: 0) }.scope;

	// wrong equal spread to pan values [-1, 0, 1], which outputs to chans 2, 0, 2
{ SplayZ.ar(6, SinOsc.ar([2, 3, 5] * 200) * 0.2, orientation: 0) }.scope;
#+END_SRC

::
** class:: SplayZ
summary:: Spreads an array of channels across a ring of channels
categories:: UGens>Multichannel>Panners
related:: Classes/PanAz, Classes/SplayAz

description::
SplayZ spreads an array of channels across a ring of channels.
Optional spread and center controls, and levelComp(ensation) (equal power).
numChans and orientation are as in PanAz.

warning::
ATTENTION - SplayZ is deprecated because its geometry is wrong. It is only kept for backwards compatibility - please adapt your patches to link::Classes/SplayAz::! See link::Classes/SplayAz:: help file for the comparison in behavior.
::

classmethods::

method:: ar
argument:: numChans
argument:: inArray
argument:: spread
argument:: level
argument:: width
argument:: center
argument:: orientation
argument:: levelComp

method:: arFill
argument:: numChans
argument:: n
argument:: function
argument:: spread
argument:: level
argument:: width
argument:: center
argument:: orientation
argument:: levelComp

examples::
code::
#+BEGIN_SRC sclang
(
x = { arg spread=1, level=0.2, width=2, center=0.0;
 SplayZ.ar(
  4,
  SinOsc.ar( { |i| LFNoise2.kr( rrand(10, 20), 200, i + 3 * 100) } ! 10),
  spread,
  level,
  width,
  center
 );
}.scope;
)

x.set(\spread, 1,   \center, 0);  // full n chans
x.set(\spread, 0.5, \center, -0.25); // less wide
x.set(\spread, 0, \center, 0);  // mono center (depends on orientation, see PanAz)
x.set(\spread, 0, \center, -0.25); //
x.set(\spread, 0.0, \center, 0.5); // mono, but rotate 1 toward the higher channels
x.set(\spread, 0.5, \center, 0.5); // spread over the higher channels
x.set(\spread, 0,   \center, -0.25); // all first
x.set(\spread, 1,   \center, 0);  // full n chans

x.free;

 // the same example written with arFill:
(
x = { arg spread=1, level=0.5, width=2, center=0.0;
 SplayZ.arFill(
  4,
  10,
  { |i| SinOsc.ar( LFNoise2.kr( rrand(10, 20), 200, i + 3 * 100) ) },
  spread,
  level,
  width,
  center
 );
}.scope;
)

 // or with mouse control
(
x = { var src;
 src = SinOsc.ar( { |i| LFNoise2.kr( rrand(10, 20), 200, i * 100 + 400) } ! 10);
 SplayZ.ar(4, src, MouseY.kr(1, 0), 0.2, center: MouseX.kr(-1, 1));
}.scope;
)
#+END_SRC

::
** class:: Spring
summary:: physical model of resonating spring
categories:: UGens>Filters>Nonlinear, UGens>Generators>PhysicalModels
related:: Classes/Ball, Classes/TBall

description::
models the force of a resonating spring

classmethods::

method:: ar, kr

argument::in
modulated input force

argument::spring
spring constant (incl. mass)

argument::damp
damping


examples::
code::
#+BEGIN_SRC sclang
// trigger gate is mouse button
// spring constant is mouse x
// mouse y controls damping
(
{
	var inforce, outforce, freq, k, d;
	inforce = K2A.ar(MouseButton.kr(0,1,0)) > 0;
	k = MouseY.kr(0.1, 20, 1);
	d = MouseX.kr(0.00001, 0.1, 1);
	outforce = Spring.ar(inforce, k, d);
	freq = outforce * 400 + 500; // modulate frequency with the force
	SinOsc.ar(freq, 0, 0.2)
}.play;
)


// several springs in series.
// trigger gate is mouse button
// spring constant is mouse x
// mouse y controls damping
(
{ 	var m0, m1, m2, m3, d, k, inforce;
	d = MouseY.kr(0.00001, 0.01, 1);
	k = MouseX.kr(0.1, 20, 1);
	inforce = K2A.ar(MouseButton.kr(0,1,0)) > 0;
	m0 = Spring.ar(inforce, k, 0.01);
	m1 = Spring.ar(m0, 0.5 * k, d);
	m2 = Spring.ar(m0, 0.6 * k + 0.2, d);
	m3 = Spring.ar(m1 - m2, 0.4, d);
	SinOsc.ar(m3 * 200 + 500, 0, 0.2) // modulate frequency with the force

}.play;
)

// modulating a resonating string with the force
// spring constant is mouse x
// mouse y controls damping
(
{ 	var m0, m1, m2, m3, m4, d, k, t;
	k = MouseX.kr(0.5, 100, 1);
	d = MouseY.kr(0.0001, 0.01, 1);
	t = Dust.ar(2);
	m0 = Spring.ar(ToggleFF.ar(t), 1 * k, 0.01);
	m1 = Spring.ar(m0, 0.5 * k, d);
	m2 = Spring.ar(m0, 0.6 * k, d);
	m3 = Spring.ar([m1,m2], 0.4 * k, d);
	m4 = Spring.ar(m3 - m1 + m2, 0.1 * k, d);
	CombL.ar(t, 0.1, LinLin.ar(m4, -10, 10, 1/8000, 1/100), 12)

}.play;
)
#+END_SRC

::
** CLASS:: StackLayout
summary:: A layout that stacks views on top of each other
categories:: GUI>Layout
related:: Classes/HLayout, Classes/VLayout, Classes/GridLayout, Guides/GUI-Layout-Management
redirect:: implClass

DESCRIPTION::

note:: StackLayout is only implemented in strong::Qt GUI:: ::

StackLayout manages several views stacked into the same space. It has two modes: it can either switch the view that is visible, hiding the others, or it can keep all of them visible, switching the one that is on top.

The second mode is useful for example for overlaying a view with a link::Classes/UserView::, on which you can then draw additional information. If you still want to be able to interact with the view below using the mouse, you can make the one above ignore the mouse using link::Classes/View#-acceptsMouse::. See the link::#examples#example:: below.

Views can be added to the layout immediately at link::#*new#construction::, or you can link::#-add#add:: or link::#-insert#insert:: them after. To remove a view, you simply call link::Classes/View#-remove::.

You can change the current view (the one visible / on top) using link::#-index::, while link::#-count:: tells you how many views are managed by the layout.

To switch between the two modes use link::#-mode::.

note::
Unlike other layouts, StackLayout can not contain another layout, but only subclasses of View.
::


CLASSMETHODS::

PRIVATE:: key
PRIVATE:: qtClass

METHOD:: new

    Creates a StackLayout and fills it with the items given as arguments. The first view becomes the current one, i.e. visible and on top of others.

    argument:: ... views
    A sequence of strong::views::. Unlike other layouts, StackLayout can not contain another layout.

    discussion::

    In the example below, the button will switch between the three text editing areas:
code::
#+BEGIN_SRC sclang
(
var stack;
w = Window().layout_( VLayout(
    Button().states_([["One"],["Two"],["Three"]]).action_({ |b| stack.index = b.value }),
    stack = StackLayout(
        TextView().string_("This is a chunk of text..."),
        TextView().string_("...and this is another..."),
        TextView().string_("...and another.")
    );
)).front;
)
#+END_SRC

::

INSTANCEMETHODS::

METHOD:: add
    Adds a view at the last index. This does not affect the current link::#-index::.

    argument:: view
    A View.

METHOD:: insert
    Inserts a view at the specific index. This does not affect the current link::#-index::.

    argument:: view
    A View.

    argument:: index
    An integer. If it is less than 0 or more than link::#-count::, the view will always be inserted as last.

METHOD:: count
    The number of views managed by the layout.

METHOD:: index
    Sets or gets the index of the current view. The current view is placed on top of others, and if link::#-mode:: is 0, all the others are hidden.

METHOD:: mode
    Sets or gets the current mode: in mode 0, the layout only displays the current view; in mode 1, the layout displays all the views. In both modes, the current view will be placed on top of others.

    See also: link::#-index::.

    argument:: value
        0 or 1. Instead of an integer you can also use symbols \stackOne or \stackAll.
    returns::
        0 or 1.

EXAMPLES::

Overlaying a TextView with a UserView to do additional drawing on top, while still allowing the interaction with the text:

code::
#+BEGIN_SRC sclang
(
var text, canvas;
text = TextView().string_("Hello world!").keyDownAction_({canvas.refresh});
canvas = UserView().acceptsMouse_(false).drawFunc_({
    var b = canvas.bounds();
    var str = text.string;
    Pen.translate( b.center.x, b.center.y );
    Pen.fillColor = text.palette.baseText.alpha_(0.1);
    str.do { |c|
        var x = 40.0.rand + 10.0;
        var r = c.asString.bounds.center_(0@0);
        Pen.push;
        Pen.rotate( 1.0.rand );
        Pen.translate( rand2(-0.3,0.3) * b.width, rand2(-0.3,0.3) * b.width );
        Pen.scale( x, x );
        Pen.stringCenteredIn(c.asString, r);
        Pen.pop;
    }
}).refresh;
w=Window().layout_( StackLayout( canvas, text ).mode_(\stackAll) ).front;
)
#+END_SRC

::
** class:: StandardL
summary:: Standard map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/StandardN

description::
A linear-interpolating sound generator based on the difference equations:

code::
#+BEGIN_SRC sclang
	x[n+1] = (x[n] + y[n+1]) % 2pi
	y[n+1] = (y[n] + k * sin(x[n])) % 2pi
#+END_SRC

::
warning:: revise formulae conversion to c like code ::

The standard map is an area preserving map of a cylinder discovered by the plasma physicist Boris Chirikov.

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: k
Perturbation amount
argument:: xi
Initial value of x
argument:: yi
Initial value of y

examples::
code::
#+BEGIN_SRC sclang
// vary frequency
{ StandardL.ar(MouseX.kr(20, SampleRate.ir)) * 0.3 }.play(s);
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// mouse-controlled param
{ StandardL.ar(SampleRate.ir/2, MouseX.kr(0.9,4)) * 0.3 }.play(s);
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// as a frequency control
{ SinOsc.ar(StandardL.ar(40, MouseX.kr(0.9,4))*800+900)*0.4 }.play(s);
#+END_SRC

::
** class:: StandardN
summary:: Standard map chaotic generator
categories:: UGens>Generators>Chaotic
related:: Classes/StandardL

description::
A non-interpolating sound generator based on the difference equations:

code::
#+BEGIN_SRC sclang
	x[n+1] = (x[n] + y[n+1]) % 2pi
	y[n+1] = (y[n] + k * sin(x[n])) % 2pi
#+END_SRC

::
warning:: revise formulae conversion to c like code ::

The standard map is an area preserving map of a cylinder discovered by the plasma physicist Boris Chirikov.

classmethods::
method:: ar
argument:: freq
Iteration frequency in Hertz
argument:: k
Perturbation amount
argument:: xi
Initial value of x
argument:: yi
Initial value of y
argument:: mul
argument:: add

examples::
code::
#+BEGIN_SRC sclang
// vary frequency
{ StandardN.ar(MouseX.kr(20, SampleRate.ir)) * 0.3 }.play(s);
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// mouse-controlled param
{ StandardN.ar(SampleRate.ir/2, MouseX.kr(0.9,4)) * 0.3 }.play(s);
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// as a frequency control
{ SinOsc.ar(StandardN.ar(40, MouseX.kr(0.9,4))*800+900)*0.4 }.play(s);
#+END_SRC

::
** class:: StartUp
summary:: register functions to be evaluated after the startup is finished
related:: Classes/ShutDown, Classes/ServerBoot, Classes/ServerTree, Classes/CmdPeriod
categories:: Control

description::
StartUp registers functions to perform an action after the library has been compiled, and after the startup file has run. For instance this is used for creating link::Classes/SynthDef:: in the strong::initClass:: function of class files in order to be able to make the synthdef directory customizable by the startup script.

If an object is registered, strong::doOnStartUp:: must be implemented. Otherwise a function can be used.

ClassMethods::

method::add
Registers an object or function to be evaluated after startup is finished.

method::defer
Registers an object or function to be evaluated after startup is finished, or immediately, if this has happened already.

method::remove
Removes an object that was previously registered.

method::run
Call the object in order.

Examples::

code::
#+BEGIN_SRC sclang
*initClass {
	StartUp.add {
		// something to do...
	}
}
#+END_SRC

::
** CLASS:: StaticText
redirect:: implClass
summary:: A view displaying non-editable text
categories:: GUI>Views

DESCRIPTION::
A view displaying non-editable text


CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::

SUBSECTION:: Data

METHOD:: string
	The text displayed by the view.

	argument::
		A String.

METHOD:: object
	If link::#-setBoth:: is true, setting this variable also sets link::#-string:: to the value interpreted link::Classes/Object#-asString#as String::.

	argument::
		Any object, typically one which makes sense to display as a string, such as a Float.

METHOD:: setBoth
	A variable stating whether setting link::#-object:: will also set link::#-string::.

	argument::
		A Boolean.

SUBSECTION:: Appearance

METHOD:: align
	The alignment of the displayed text. See link::Reference/gui_alignments:: for possible values.

METHOD:: font
	The font used to display the text.

	argument::
		A Font.

METHOD:: stringColor
	The color used to display the text.

	argument::
		A Color.

METHOD:: background
	Setting this variable colors the whole area occupied by the view under the text with the given color.

	argument::
		A Color.


EXAMPLES::

subsection:: Basic Example

code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
a = StaticText(w, Rect(10, 10, 200, 20));
a.string = "Rolof's Rolex";
)

// adjust look , alignment and content
a.background=Color.grey;
a.align = \center;
a.font = Font("Monaco", 11);
a.string = "Your Rolex";
#+END_SRC

::


subsection:: Monitoring Values in a Synth

code::
#+BEGIN_SRC sclang
(

w = Window("Frequency Monitor", Rect(200, Window.screenBounds.height-200,300,150)).front;

a = StaticText(w, Rect(45, 10, 200, 20)).background_(Color.rand);

a.string = " Current Frequency ";

Button.new(w, Rect(45, 70, 200, 20)).states_([["close",Color.black,Color.rand]]).action_({w.close});

s.waitForBoot({

    b=Bus.new(\control,0,1);

    q=SynthDef(\Docs_FreqMonitor, {var freq,snd;
        freq=LFNoise0.ar(2, 400, 650);
        snd=SinOsc.ar(freq,0,0.2);
        Out.ar(0,snd);
        Out.kr(b.index,freq); // output the frequency to a control bus
    }).play;

    r= Routine{
        {           // Set the value of the StaticText to the value in the control bus.
                    // Setting GUI values is asynchronous, so you must use .defer in the system clock.
                    // Also you must check if the window is still open, since Routine will continue for at least
                    // one step after you close the window.
        b.get( {arg v; {w.isClosed.not.if{ a.string= " Current Frequency: "++v.round(0.01)}; }.defer} );

        0.01.wait;
        }.loop

    }.play
});

CmdPeriod.doOnce({w.close});
w.onClose={r.stop; q.free; b.free }; //clean up if the window closes

)
#+END_SRC

::


subsection:: Dynamic Text

code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
w.view.background=Color.white;
a = Array.fill(20, {StaticText(w, Rect(w.bounds.extent.x.rand, w.bounds.extent.y.rand, 160, 16))
    .string_("Rolof's Rolex".scramble)
    .align_(\center)
    .stringColor_(Color.rand)
    .font_(Font([
        "Helvetica-Bold",
        "Helvetica",
        "Monaco",
        "Arial",
        "Gadget",
        "MarkerFelt-Thin"
    ].choose, 11))
});

r = {inf.do{|i|
    thisThread.randSeed_(1284);
    a.do{|item|
        // setting GUI values is asynchronous, so you must use .defer
        {item.bounds = Rect(5+w.bounds.extent.x.rand * (cos(i*0.01)).abs,
                    w.bounds.extent.y.rand * sin(i*0.01),
                    160, 20)}.defer;
    };
    0.15.wait;
}}.fork;
CmdPeriod.doOnce({w.close});
w.onClose_({r.stop});
)
#+END_SRC

::
** class:: Stepper
summary:: Pulse counter.
related:: Classes/PulseCount
categories::  UGens>Triggers


Description::

Each trigger increments a counter which is output as a signal. The
counter wraps between  code::min::  and
code::max:: .


classmethods::

method::ar, kr

argument::trig

The trigger. Trigger can be any signal. A trigger happens when
the signal changes from non-positive to positive.


argument::reset

Resets the counter to
code::resetval::  when
triggered.


argument::min

Minimum value of the counter.


argument::max

Maximum value of the counter.


argument::step

Step value each trigger. May be negative.


argument::resetval

Value to which the counter is reset when it receives a reset
trigger. If nil, then this is patched to

code::min:: .


Examples::

code::
#+BEGIN_SRC sclang

SynthDef("help-Stepper",{ arg out=0;
	Out.ar(out,
		SinOsc.ar(
			Stepper.kr(Impulse.kr(10), 0, 4, 16, 1) * 100,
			0, 0.05
		)
	)
}).play;

SynthDef("help-Stepper",{ arg out=0;
	Out.ar(out,
		SinOsc.ar(
			Stepper.kr(Impulse.kr(10), 0, 4, 16, -3) * 100,
			0, 0.05
		)
	)
}).play;

SynthDef("help-Stepper",{ arg out=0;
	Out.ar(out,
		SinOsc.ar(
			Stepper.kr(Impulse.kr(10), 0, 4, 16, 4) * 100,
			0, 0.05
		)
	)
}).play;


///////////////////////////////////////////////////////////////////////////////////
//
// Using Stepper and BufRd for sequencing
//

s.boot;

s.sendMsg(\b_alloc, 10, 128);

m = #[0,3,5,7,10];

a = ({rrand(0,15)}.dup(16).degreeToKey(m) + 36).midicps;
s.performList(\sendMsg, \b_setn, 10, 0, a.size, a);

(
SynthDef(\stepper, {
	var rate, clock, index, freq, ffreq, env, out, rev, lfo;

	rate = MouseX.kr(1,5,1);
	clock = Impulse.kr(rate);
	env = Decay2.kr(clock, 0.002, 2.5);
	index = Stepper.kr(clock, 0, 0, 15, 1, 0);
	freq = BufRd.kr(1, 10, index, 1, 1);
	freq = Lag2.kr(freq) + [0,0.3];
	ffreq = MouseY.kr(80,1600,1) * (env * 4 + 2);
	out = Mix.ar(LFPulse.ar(freq * [1, 3/2, 2], 0, 0.3));
	out = RLPF.ar(out, ffreq, 0.3, env);
	out = RLPF.ar(out, ffreq, 0.3, env);
	out = out * 0.02;

	// echo
	out = CombL.ar(out, 1, 0.66/rate, 2, 0.8, out);

	// reverb
	rev = out;
	5.do { rev = AllpassN.ar(rev, 0.05, {0.05.rand}.dup, rrand(1.5,2.0)) };
	out = out + (0.3 * rev);

	out = LeakDC.ar(out);

	// flanger
	lfo = SinOsc.kr(0.2, [0,0.5pi], 0.0024, 0.0025);
	1.do { out = DelayL.ar(out, 0.1, lfo, 1, out) };

	// slight bass emphasis
	out = OnePole.ar(out, 0.9);

	Out.ar(0, out);

}).send(s);
)

s.sendMsg(\s_new, \stepper, 1000, 0, 0);

a = ({rrand(0,15)}.dup(16).degreeToKey(m) + 38).midicps;
s.performList(\sendMsg, \b_setn, 10, 0, a.size, a);

a = a * 2.midiratio; // transpose up 2 semitones
s.performList(\sendMsg, \b_setn, 10, 0, a.size, a);


(
a = [ 97.999, 195.998, 523.251, 466.164, 195.998, 233.082, 87.307, 391.995, 87.307, 261.626, 195.998, 77.782, 233.082, 195.998, 97.999, 155.563 ];
s.performList(\sendMsg, \b_setn, 10, 0, a.size, a);
)

s.sendMsg(\n_free, 1000);
#+END_SRC

::

** class:: StereoConvolution2L
summary:: Stereo real-time convolver with linear interpolation
categories:: UGens>FFT, UGens>Convolution
related:: Classes/Convolution, Classes/Convolution2L

description::
Strict convolution with fixed kernel which can be updated using a trigger signal. There is a linear crossfade between the buffers upon change.

Like link::Classes/Convolution2L::, but convolves with two buffers and outputs a stereo signal. This saves one FFT transformation per period, as compared to using two copies of link::Classes/Convolution2L::.

Useful applications could include stereo reverberation or HRTF convolution.

See Steven W Smith, The Scientist and Engineer's Guide to Digital Signal Processing: chapter 18: http:// www.dspguide.com/ch18.htm

classmethods::
method:: ar

argument:: in
processing target.
argument:: kernelL
buffer index for the fixed kernel of the left channel, may be modulated in combination with the trigger.
argument:: kernelR
buffer index for the fixed kernel of the right channel, may be modulated in combination with the trigger.
argument:: trigger
update the kernel on a change from <= 0 to > 0.
argument:: framesize
size of FFT frame, must be a power of two. Convolution uses twice this number internally, maximum value you can give this argument is 2^16=65536. Note that it gets progressively more expensive to run for higher powers! 512, 1024, 2048, 4096 standard.
argument:: crossfade
The number of periods over which a crossfade is made. The default is 1. This must be an integer.
argument:: mul
argument:: add

examples::
code::
#+BEGIN_SRC sclang
(//allocate three buffers
b = Buffer.alloc(s, 2048);
c = Buffer.alloc(s, 2048);
d = Buffer.alloc(s, 2048);

b.zero;
c.zero;
d.zero;
)

(
50.do({ |it| c.set(20 * it + 10, 1.0.rand); });
3.do({ |it| b.set(400 * it + 100, 1); });
20.do({ |it| d.set(40 * it + 20, 1); });
)


(
SynthDef(\conv_test, { arg kernel1, kernel2, t_trig = 0;
	var input;

	input = Impulse.ar(1);

	// must have power of two framesize
	Out.ar(0, StereoConvolution2L.ar(input, kernel1, kernel2, t_trig, 2048, 1, 0.5));
}).add

)


x = Synth(\conv_test, [\kernel1, b, \kernel2, c]);

// changing the buffer number:
x.set(\kernel1,d);
x.set(\t_trig,1); // after this trigger, the change will take effect.
x.set(\kernel2,d);
x.set(\t_trig,1); // after this trigger, the change will take effect.

d.zero;
40.do({ |it| d.set(20 * it + 10, 1); });// changing the buffers' contents
x.set(\t_trig, 1); // after this trigger, the change will take effect.

x.set(\kernel1, b);
x.set(\t_trig, 1); // after this trigger, the change will take effect.

x.free;
#+END_SRC

::
** CLASS:: Stethoscope
redirect:: implClass
summary:: An oscilloscope
categories:: GUI>Interfaces
related:: Classes/ScopeView, Classes/FreqScope

DESCRIPTION::

Stethoscope provides a complete oscilloscope GUI. It displays a window containing a bus-plotting link::Classes/ScopeView:: and an interface to configure the plotting and choose among the buses.

SUBSECTION:: Creation by message .scope

Several classes provide a convenient 'scope' method that creates a Stethoscope to display their data. See for example: link::Classes/Server#-scope::, link::Classes/Bus#-scope::, link::Classes/Function#-scope::.

SUBSECTION:: Keyboard shortcuts

The following keyboard shortcuts may be used when focused on the Stethoscope display:

table::
## strong::Shortcut:: || strong::Action::
## J || one channel back
## K || switch rate (audio vs. control)
## L || one channel forward
## O || jump to first hardware output channel and adjust numChannels to hardware
## I || jump to first hardware input channel and adjust numChannels to hardware
## space || run, if not running already
## . (period) || stop
## M || toggle screen size
## + / - || zoom horizontally
## * / _ || zoom vertically
## S || change style between parallel and overlay
## Shift+S || change style to lissajou
## Shift+A || allocate buffer size so it fills the screen (to next power of two) (this can be dangerous, might crash)
::

CLASSMETHODS::

PRIVATE:: key

METHOD:: new

    Create a Stethoscope, either as a window, or placed on a given parent view.

    argument:: server
        A valid Server (see link::#*isValidServer::), or code::nil::, in which case the link::#*defaultServer:: is used.
    argument:: numChannels
        An integer. Default value is 2.
    argument:: index
        The offset index. An Integer. Default is nil.
    argument:: bufsize
        The size of the analysis buffer. Default is 4096. See also link::#-bufsize::.
    argument:: zoom
        Horizontal maginification of the displayed wave. Default is 1. See also link::#-xZoom::.
    argument:: rate
        \audio or \control. Default is \audio.
    argument:: view
        The optional parent view. Default is nil. If nil, then it will open in its own Window.
    argument:: bufnum
        The id number of the Buffer to analyze. Default value is nil. If nil, then a Buffer of size bufSize is allocated.

    discussion:
    Example:
code::
#+BEGIN_SRC sclang
Server.default = s = Server.internal
s.boot
{SinOsc.ar([330,440], 0, 0.4)}.play;
SCStethoscope(s,2);
#+END_SRC

::

METHOD:: defaultServer

    The default server used if no server is passed to the link::#*new#constructor::.


METHOD:: isValidServer

    Tests whether Stethoscope can operate on the given server.

    This is the current state of server support:
    list::
    ## strong::Qt::: any local server (see link::Classes/Server#-isLocal::).
    ## strong::Cocoa::: only the in-process (internal) server (see link::Classes/Server#*internal:: and link::Classes/Server#-inProcess::).
    ## strong::SwingOSC::: any out-of-process server, even remote (see link::Classes/Server#-inProcess::).
    ::

    argument::
        A link::Classes/Server::.
    returns::
        A Boolean.

METHOD:: ugenScopes

    Returns an array of the running ugen scopes.

code::
#+BEGIN_SRC sclang
Server.default = s = Server.internal
s.boot
{[SinOsc.ar.scope,WhiteNoise.ar(0.5).scope]*0.1}.scope(2);
Stethoscope.ugenScopes; // returns the ugen scopes
#+END_SRC

::

METHOD:: tileBounds

    A utility method used by link::Classes/UGen#-scope:: to tile scope windows.

    returns::
        A Rect.



INSTANCEMETHODS::


SUBSECTION:: Data

METHOD:: server
    The server on which the scope operates.

METHOD:: rate
    Whether to operate on audio or control busses.
    argument::
        One of the two symbols: code::\audio:: or code::\control::.

METHOD:: index
    The starting index of the busses to scope.
    argument::
        An Integer.

METHOD:: numChannels
    The amount of adjacent busses to scope (from link::#-index:: on).
    argument::
        An Integer.

METHOD:: bufsize
    The size of the scoping buffer.

    In strong::Swing:: and strong::Cococa:: GUI kits, this is the amount of signal frames that will be accumulated before they are displayed. However, it is strong::NOT ensured:: that the onsets of displayed portions of signals fall within any constant period. In other words, it is undefined how many frames will pass between one displayed portion, and another.

    In strong::Qt:: GUI, this is not the issue; code::bufsize:: only defines the maximum allowed link::#-cycle::.

METHOD:: cycle
    note:: Only available in Qt GUI ::

    The exact scoping period, in signal frames. Reciprocal to what is also known as emphasis::sweep speed:: in analog oscilloscopes. It is dynamically adjustable while the scope is running.

    Data from scoped signals will be accumulated into a buffer until it reaches code::cycle:: amount frames, at which point the buffering will immediatly restart. The view will repeatedly display the entire buffer; it may skip a cycle if the drawing is too slow to keep up with the speed of incoming data, but the cycle boundaries will never shift with respect to signals.

    If you are scoping a periodic signal, setting code::cycle:: to match the signal's period will keep the waveform locked in place.

SUBSECTION:: Display

METHOD:: window
    The (parent) Window of the scope.

METHOD:: size
    Sets the width and the height of the scope window.
    argument::
        An Integer (the window is square).

METHOD:: toggleSize

    Toggle between small and large size.

METHOD:: zoom
    A synonym for link::#-xZoom::.

METHOD:: xZoom
    Magnifies the displayed wave horizontally to the given factor.

    In strong::Qt GUI::, this sets link::#-cycle:: to code::1024 * xZoom.reciprocal::.

    argument::
        A Float.

METHOD:: yZoom
    Magnifies the displayed wave vertically to the given factor.

    argument::
        A Float.

METHOD:: style
    The plotting style:
    list::
    ## 0 = the channels are vertically spaced
    ## 1 = the channels are overlayed
    ## 2 = lissajou; the first two channels are used for 2D plotting (as streams of x and y coordinates).
    ::

    argument::
        One of the above Integers.


SUBSECTION:: Operation

METHOD:: run

    Starts the scope, if not already running.

METHOD:: quit

    Closes the window, and cleans up any used synths and buffers.

SUBSECTION:: Convenience

METHOD:: setProperties

    Sets several properties at once: link::#-numChannels::, link::#-index::, link::#-bufsize::, link::#-zoom::, and link::#-rate::.



EXAMPLES::

SUBSECTION:: A step-by-step example
code::
#+BEGIN_SRC sclang
(
Server.default = Server.internal;
s = Server.default;
s.boot;
)
(
{
    SinOsc.ar([225, 450, 900], 0, 0.2)
    + LPF.ar(
        LFPulse.ar(226 * [1, 2, 5],[0,0.1,0.1],0.2, 0.2),
        MouseX.kr(20, 10000, 1)
        )
}.scope;
)

// server.scope only changes the properies explicitly given:

s.scope(numChannels:5);
s.scope(index:12);
s.scope(zoom:4);
s.scope(index:0);

s.scopeWindow.size = 600;
s.scopeWindow.size = 222;

// scoping buses:

a = Bus.audio(s, 4);
{ WhiteNoise.ar(0.2.dup(4)) }.play(s, a);

a.scope;

c = Bus.control(s, 3);
{ WhiteNoise.kr(1.dup(4) * MouseX.kr) }.play(s, c);

c.scope;

// note that scoping control rate buses shows block size interpolation (this is due to the
// fact that ScopeOut.kr doesn't work yet.)
#+END_SRC

::

SUBSECTION:: Embedded use
You can pass your own view in to add a stethoscope to it:

code::
#+BEGIN_SRC sclang
w = Window.new("my own scope", Rect(20, 20, 400, 500));
w.view.decorator = FlowLayout(w.view.bounds);
c = Stethoscope.new(s, view:w.view);
w.onClose = { c.free }; // don't forget this
w.front;
#+END_SRC

::
** class:: Stream
summary:: Stream is the base class for classes that define streams
related:: Classes/Routine, Classes/FuncStream, Classes/EventStreamPlayer
categories:: Streams-Patterns-Events

description::

Stream is an abstract class that is not used directly. The following attempts to document some aspects of the use of Streams for music generation.

subsection::Overview

A Stream represents a sequence of values that are obtained incrementally by repeated strong::next:: messages. A Stream can be restarted with a strong::reset:: message. (Not all streams actually implement reset semantics.)

The class link::Classes/Object:: defines strong::next:: to return the object itself. Thus every object can be viewed as a stream and most simply stream themselves.

In SuperCollider, Streams are primarily used for handling text and for generating music.

subsection::FuncStream(nextFunction, resetFunction)

A link::Classes/Function:: defines a stream consisting of the Function itself, a link::Classes/FuncStream:: defines a stream that consists of emphasis::evaluations:: of its nextFunction.

code::
#+BEGIN_SRC sclang
// Example 1: a Function vs. a FuncStream
(
	f = { 33.rand };
	x = FuncStream(f);
	10.do({ [f.next, x.next].postln });
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// Example 2: the reset function
(
	f = { 33.rand };
	x = FuncStream(f, {thisThread.randSeed_(345)});
	x.reset;
	10.do({ [f.next, x.next].postln });
	x.reset;
	10.do({ [f.next, x.next].postln });
)
#+END_SRC

::

subsection::Routine(nextFunction, stacksize)

In a link::Classes/FuncStream::, the nextFunction runs through to completion for each element of the stream. In a link::Classes/Routine::, the nextFunction returns values with strong::yield:: and resumes execution (when it receives a strong::next:: message) at the expression following the yield. This allows a sequence of expressions in the function definition to represent a sequence of distinct events, like a musical score.

code::
#+BEGIN_SRC sclang
// example
(
	x = Routine({
		1.yield;
		2.yield;
		3.yield;
	});
	4.do({ x.next.postln });
)
#+END_SRC

::

Once the nextFunction completes execution, the Routine simply yields nil repeatedly. Control structures (such as strong::do:: or strong::while::) can be used within the nextFunction in a manner analogous to repeat marks in a score.

code::
#+BEGIN_SRC sclang
// example
(
	x = Routine({
		4.do({
			[1,2,3,4].do({ arg i; i.yield; });
		});
	});
	17.do({ x.next.postln });
)
#+END_SRC

::

subsection::Playing streams

Because streams respond like functions to the value message, they can be used as a scheduling task.

code::
#+BEGIN_SRC sclang
// compare:
// a function, returning 0.5
(
SystemClock.sched(0.0,
	{ "***".postln; 0.5 }
);
)

// a stream, returning 0.5 and 0.1
(
SystemClock.sched(0.0,
	Routine({ loop {
		"***".postln; 0.5.yield;
		"_*_".postln; 0.1.yield;
	} });
);
)

// this is the reason why 'wait' works the same (for numbers) like 'yield'
(
SystemClock.sched(0.0,
	Routine({ loop {
		"***".postln; 0.5.wait;
		"_*_".postln; 0.1.wait;
	} });
);
)
#+END_SRC

::

Streams that return strong::numbers:: can be played directly with the strong::play:: message.

code::
#+BEGIN_SRC sclang
// play at the next beat, with offset 0.4
(
Routine({ loop {
	"***".postln; 0.5.wait;
	"_*_".postln; 0.1.wait;
} }).play(quant:[1, 0.4]);
)
#+END_SRC

::

Streams that return strong::Events:: need to be wrapped in an link::Classes/EventStreamPlayer::. The Event's strong::delta:: (can also be set by strong::dur::) is used as a scheduling beats value:

code::
#+BEGIN_SRC sclang
// play at the next beat, with offset 0.4
(
Routine({ loop {
	"///".postln; (delta:0.5).yield;
	"_/_".postln; (delta: 0.1).wait;
} }).asEventStreamPlayer.play;
)
#+END_SRC

::

subsection::Iteration

The method link::#-do:: effectively 'plays' a stream by iterating all of its contects.

And the following messages create a stream by filtering another stream in some way: link::#-collect::, link::#-reject::, link::#-select::, link::#-dot::, link::#-interlace::, link::#-appendStream::, link::#-embedInStream::, link::#-trace::.

subsection::Composite Streams

Routines can be strong::embedded:: in each other, using link::#-embedInStream:: :

code::
#+BEGIN_SRC sclang
// example
(
x = Routine({
	2.do({
		[1,2,3,4].do({ arg i; i.yield; });
	});
});
y = Routine({
	100.yield;
	30.yield;
	x.embedInStream;
	440.yield;
	1910.yield;
});
17.do({ y.next.postln });
)
#+END_SRC

::

Routines can be strong::concatenated:: just like Streams:

code::
#+BEGIN_SRC sclang
(
x = Routine({
	2.do({
		[1,2,3,4].do({ arg i; i.yield; });
	});
});
y = Routine({
	100.yield;
	30.yield;
});
z = x ++ y;
17.do({ z.next.postln });
)
#+END_SRC

::

Routines can be strong::combined:: with the composition operator <>

code::
#+BEGIN_SRC sclang
(
x = Routine({ arg inval;
	2.do({
		[1,2,3,4].do({ arg i;
			if(inval.isNil) { nil.alwaysYield };
			inval = (i * inval).yield;
		});
	});
});
y = Routine({
	100.yield;
	30.yield;
	4.do { 1.0.rand.yield };
});
z = x <> y;
17.do({ z.value.postln }); // call .value here, as this is a function.
)
#+END_SRC

::

Composite Streams can be defined as combinations of Streams using the unary and binary messages.

subsection::Unary messages

Streams support most of the unary messages defined in link::Classes/AbstractFunction:: :

code::
#+BEGIN_SRC sclang
(
a = Routine({ 20.do({ 33.rand.yield }) });
b = Routine({ [-100,00,300,400].do({ arg v; v.yield}) });

c = b.neg; // define a composite stream

// enumerate and perform all of the unary messages:
[
	\neg, \reciprocal, \bitNot, \abs, \asFloat, \asInteger, \ceil,
	\floor, \frac, \sign, \squared, \cubed, \sqrt, \exp, \midicps,
	\cpsmidi, \midiratio, \ratiomidi, \ampdb, \dbamp, \octcps,
	\cpsoct, \log, \log2, \log10, \sin, \cos, \tan, \asin, \acos, \atan,
	\sinh, \cosh, \tanh, \rand, \rand2, \linrand, \bilinrand, \sum3rand,
	\distort, \softclip, \coin, \even, \odd, \isPositive, \isNegative,
	\isStrictlyPositive
]
.do({ arg msg;
	postf("\n msg: % \n", msg);
	b.reset.perform(msg).do({arg v; v.post; " ".post;});
});
nil;
)
#+END_SRC

::

subsection::Binary messages

Streams support the following binary messages defined in link::Classes/AbstractFunction:: :

code::
#+BEGIN_SRC sclang
(
a = Routine({ 20.do({ 33.rand.yield }) });
b = Routine({ [-100,00,300,400].do({ arg v; v.yield}) });
[
	'+' , '-' , '*', '/', \div, '%', '**', \min, \max, '<', '<=', '>', '>=', '&', '|',
	\bitXor, \lcm, \gcd, \round, \trunc, \atan2,
	\hypot, '>>', '+>>', \ring1, \ring2, \ring3, \ring4,
	\difsqr, \sumsqr, \sqrdif, \absdif, \amclip,
	\scaleneg, \clip2, \excess, '<!', \rrand, \exprand
]
.do({ arg msg;
	postf("\n msg: % \n", msg);
	b.reset.perform(msg).do({ arg v; v.post; " ".post; });
});
nil;
)
#+END_SRC

::

InstanceMethods::

method::play
Streams that return strong::numbers:: can be played directly with the strong::play:: message. Streams that return strong::events:: need to be wrapped in an link::Classes/EventStreamPlayer::. See link::#-asEventStreamPlayer::.

argument::clock
a clock. link::Classes/TempoClock:: by default.

argument::quant
either a number strong::n:: (quantize to strong::n:: beats), or an array strong::[n, m]:: (quantize to n beats, with offset m).

method::do
iterate until a nil is encountered.
warning::
Applying do to an endless stream will lock up the interpreter!
::

method::collect
iterate indefinitely.

method::reject
return only those elements for which function.value(element) is false.

method::select
return only those elements for which function.value(element) is true.

method::dot
return function.value(this.next, stream.next) for each element.

method::interlace
iterate all of stream for each element of this. Combine the values using function.

method::appendStream
append stream after this returns nil. The same like ++

method::embedInStream
iterate all of this from within whatever Stream definition it is called.

method::trace
print out the results of a stream while returning the original values.

argument::key
when streaming events, post only this key.

argument::printStream
printOn this stream (default: link::Classes/Post::).

argument::prefix
string added to the printout to separate different streams.
** class:: StreamClutch
summary:: buffers a streamed value
related:: Classes/Routine, Classes/FuncStream, Classes/EventStreamPlayer
categories:: Streams-Patterns-Events


ClassMethods::

method::new

argument::pattern
a pattern or stream to be buffered.

argument::connected
if true it will call the next stream value for each time next is called. if false it returns the last value.

Examples::

code::
#+BEGIN_SRC sclang
a = Pseq([1, 2, 3], inf);
b = StreamClutch(a);

6.do({ b.next.postln });
b.connected = false;
6.do({ b.next.postln });


//statistical clutch
a = Pseq([1, 2, 3], inf);
b = StreamClutch(a, { 0.5.coin });
12.do({ b.next.postln });
#+END_SRC

::

code::
#+BEGIN_SRC sclang
s.boot;
//sound example:
(
var clutch, pat, decicion;
decicion = Pseq([Pn(true,10), Prand([true, false], 10)], inf).asStream;
pat = Pbind(\freq, Pseq([200, [300, 302], 400, 450], inf), \dur, 0.3);
clutch = StreamClutch(pat, decicion);
clutch.asEventStreamPlayer.play;
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// independant stepping
(
var clutch, pat, decicion;
pat = Pbind(\freq, Pseq([200, [300, 302], 400, 450], inf), \dur, 0.3);
b = StreamClutch(pat);
b.connected = false;
b.asEventStreamPlayer.play;
)

b.step;
#+END_SRC

::
instancemethods::

subsection:: Extensions by SCDoc

method:: stripWhiteSpace
Strips whitespace at the beginning and end of the string.
returns:: The stripped string

method:: unixCmdGetStdOutLines
Like link::#-unixCmdGetStdOut:: but returns the lines in an Array instead.
returns:: an link::Classes/Array:: of each line of output

** CLASS::String
summary::array of characters
categories:: Collections>Ordered

DESCRIPTION::
String represents an array of characters.

Strings can be written literally using double quotes:
code::
#+BEGIN_SRC sclang
"my string".class
#+END_SRC

::
A sequence of string literals will be concatenated together:
code::
#+BEGIN_SRC sclang
x = "hel" "lo";
y = "this is a\n"
    "multiline\n"
    "string";
#+END_SRC

::

CLASSMETHODS::

private::initClass
private::doUnixCmdAction
private::unixCmdActions

method::readNew
Read the entire contents of a link::Classes/File:: and return them as a new String.

method::scDir
Provided for backwards compatibility.
returns::
the value of code::Platform.resourceDir::, which is the base resource directory of SuperCollider.
discussion::
Please use link::Classes/Platform#*resourceDir:: instead.

INSTANCEMETHODS::

private::prUnixCmd, prFormat, prCat, prBounds, hash, species, getSCDir, prDrawInRect, prDrawAtPoint, openTextFile

subsection:: Accessing characters

method::@, at
Strings respond to .at in a manner similar to other indexed collections. Each element is a link::Classes/Char::.
code::
#+BEGIN_SRC sclang
"ABCDEFG".at(2)
#+END_SRC

::

method::ascii
Returns an Array of asci numbers of the Strings's characters.
code::
#+BEGIN_SRC sclang
"wertvoll".ascii
#+END_SRC

::

subsection:: Comparing strings

method::compare
Returns a -1, 0, or 1 depending on whether the receiver should be sorted before the argument, is equal to the argument or should be sorted after the argument. This is a case sensitive compare.

method::<
Returns a link::Classes/Boolean:: whether the receiver should be sorted before the argument.
code::
#+BEGIN_SRC sclang
"same" < "samf"
#+END_SRC

::

method::>
Returns a link::Classes/Boolean:: whether the receiver should be sorted after the argument.
code::
#+BEGIN_SRC sclang
"same" > "samf"
#+END_SRC

::
method::<=
Returns a link::Classes/Boolean:: whether the receiver should be sorted before the argument, including the same string.
code::
#+BEGIN_SRC sclang
"same" <= "same"
"same" <= "samf"
#+END_SRC

::

method::>=
Returns a link::Classes/Boolean:: whether the receiver should be sorted after the argument, including the same string.
code::
#+BEGIN_SRC sclang
"same" >= "same"
"same" >= "samf"
#+END_SRC

::

method::==
Returns a link::Classes/Boolean:: whether the two Strings are equal.
note::
This method is (now) case sensitive!
::
code::
#+BEGIN_SRC sclang
"same" == "same"
"same" == "Same"; // false
#+END_SRC

::

method::!=
Returns a link::Classes/Boolean:: whether the two Strings are not equal.
code::
#+BEGIN_SRC sclang
"same" != "same"; // false
"same" != "Same"; 
#+END_SRC

::

subsection:: Posting strings

method::post
Prints the string to the current post window.
code::
#+BEGIN_SRC sclang
"One".post; "Two".post;"";
#+END_SRC

::

method::postln
Prints the string and a carriage return to the current post window.
code::
#+BEGIN_SRC sclang
"One".postln; "Two".postln;"";
#+END_SRC

::

method::postc, postcln
As link::#-post:: and link::#-postln::, but formatted as a comment.
code::
#+BEGIN_SRC sclang
"This is a comment.".postcln;
#+END_SRC

::

method::postf
Prints a formatted string with arguments to the current post window. The % character in the format string is replaced by a string representation of an argument. To print a % character use \\% .
code::
#+BEGIN_SRC sclang
postf("this % a %. pi = %, list = %\n", "is", "test", pi.round(1e-4), (1..4))

this is a test. pi = 3.1416, list = [ 1, 2, 3, 4 ]
#+END_SRC

::

method::postcs
As link::#-postln::, but posts the link::#-asCompileString#compileString:: of the reciever.
code::
#+BEGIN_SRC sclang
List[1, 2, ["comment", [3, 2]], { 1.0.rand }].postcs;
#+END_SRC

::

method::error
Prepends an error banner and posts the string.
code::
#+BEGIN_SRC sclang
"Do not press this button again".error;
#+END_SRC

::

method::warn
Prepends a warning banner and posts the string.
code::
#+BEGIN_SRC sclang
"Do not press this button again".warn;
#+END_SRC

::

method::inform
Posts the string.
code::
#+BEGIN_SRC sclang
"Do not press this button again".inform;
#+END_SRC

::

subsection:: Interpreting strings as code

method::compile
Compiles a String containing legal SuperCollider code and returns a Function.
code::
#+BEGIN_SRC sclang
(
var f;
f = "2 + 1".compile.postln;
f.value.postln;
)
#+END_SRC

::

method::interpret
Compile and execute a String containing legal SuperCollider code, returning the result.
code::
#+BEGIN_SRC sclang
"2 + 1".interpret.postln;
#+END_SRC

::

method::interpretPrint
Compile, execute and print the result of a String containing legal SuperCollider code.
code::
#+BEGIN_SRC sclang
"2 + 1".interpretPrint;
#+END_SRC

::

subsection:: Converting strings

method::asCompileString
Returns a String formatted for compiling.
code::
#+BEGIN_SRC sclang
(
var f;
f = "myString";
f.postln;
f.asCompileString.postln;
)
#+END_SRC

::

method::asSymbol
Return a link::Classes/Symbol:: derived from the String.
code::
#+BEGIN_SRC sclang
(
var z;
z = "myString".asSymbol.postln;
z.class.postln;
)
#+END_SRC

::

method::asInteger
Return an link::Classes/Integer:: derived from the String. Strings beginning with non-numeric characters return 0.
code::
#+BEGIN_SRC sclang
"4".asInteger.postln;
#+END_SRC

::

method::asFloat
Return a link::Classes/Float:: derived from the String. Strings beginning with non-numeric characters return 0.
code::
#+BEGIN_SRC sclang
"4.3".asFloat.postln;
#+END_SRC

::

method::asSecs
Return a link::Classes/Float:: based on converting a time string in format (dd):hh:mm:ss.s. This is the inverse method to link::Classes/SimpleNumber#-asTimeString::.
code::
#+BEGIN_SRC sclang
(45296.asTimeString).asSecs;
"32.1".asSecs;
"62.1".asSecs;		// warns
"0:0:59.9".asSecs;
"1:1:1.1".asSecs;
"-1".asSecs;		// neg sign supported
"-12:34:56".asSecs;
"12:-34:56".asSecs;	// warns
"-23:12.3456".asSecs;	//
"-1:00:00:00".asSecs;	// days too.
#+END_SRC

::

subsection:: Concatenate strings

method::++
Return a concatenation of the two strings.
code::
#+BEGIN_SRC sclang
"hello" ++ "word"
#+END_SRC

::

method::+
Return a concatenation of the two strings with a space between them.
code::
#+BEGIN_SRC sclang
"hello" + "word"
#+END_SRC

::

method::+/+
Path concatenation operator - useful for avoiding doubling-up slashes unnecessarily.
code::"foo"+/+"bar":: returns code::"foo/bar"::

method::catArgs
Concatenate this string with the following args.
code::
#+BEGIN_SRC sclang
"These are some args: ".catArgs(\fish, SinOsc.ar, {4 + 3}).postln;
#+END_SRC

::

method::scatArgs
Same as link::#-catArgs::, but with spaces in between.
code::
#+BEGIN_SRC sclang
"These are some args: ".scatArgs(\fish, SinOsc.ar, {4 + 3}).postln;
#+END_SRC

::

method::ccatArgs
Same as link::#-catArgs::, but with commas in between.
code::
#+BEGIN_SRC sclang
"a String".ccatArgs(\fish, SinOsc.ar, {4 + 3}).postln;
#+END_SRC

::

method::catList, scatList, ccatList
As link::#-catArgs::, link::#-scatArgs:: and link::#-ccatArgs:: above, but takes a Collection (usually a link::Classes/List:: or an link::Classes/Array::) as an argument.
code::
#+BEGIN_SRC sclang
"a String".ccatList([\fish, SinOsc.ar, {4 + 3}]).postln;
#+END_SRC

::



subsection:: Regular expressions

method::matchRegexp
POSIX regular expression matching. Returns true if the receiver (a regular expression pattern) matches the string passed to it. The strong::start:: is an offset where to start searching in the string (default: 0), strong::end:: where to stop.
code::
#+BEGIN_SRC sclang
"c".matchRegexp("abcdefg", 2, 5); // true
"c".matchRegexp("abcdefg", 4, 5); // false

"behaviou?r".matchRegexp("behavior"); // true
"behaviou?r".matchRegexp("behaviour"); // true
"behaviou?r".matchRegexp("behavir"); // false
"b.h.v.r".matchRegexp("behavor"); // true
"b.h.vi*r".matchRegexp("behaviiiiir"); // true
"(a|u)nd".matchRegexp("und"); // true
"(a|u)nd".matchRegexp("and"); // true
"[a-c]nd".matchRegexp("ind"); // false
"[a-c]nd".matchRegexp("bnd"); // true
#+END_SRC

::

method::findRegexp
POSIX regular expression search.
code::
#+BEGIN_SRC sclang
"foobar".findRegexp("o*bar");
"32424 334 /**aaaaaa*/".findRegexp("/\\*\\*a*\\*/");
"foobar".findRegexp("(o*)(bar)");
"aaaabaaa".findAllRegexp("a+");
#+END_SRC

::

method::findAllRegexp
Like link::#-findAll::, but use regular expressions.

subsection:: Searching strings

method::find
Returns the index of the string in the receiver, or nil if not found. If strong::ignoreCase:: is true, find makes no difference between uppercase and lowercase letters. The strong::offset:: is the point in the string where the search begins.
code::
#+BEGIN_SRC sclang
"These are several words".find("are").postln;
"These are several words".find("fish").postln;
#+END_SRC

::

method::findBackwards
Same like link::#-find::, but starts at the end of the string.
code::
#+BEGIN_SRC sclang
// compare:
"These words are several words".find("words"); // 6
"These words are several words".findBackwards("words"); // 24
#+END_SRC

::

method::findAll
Returns the indices of the string in the receiver, or nil if not found.
code::
#+BEGIN_SRC sclang
"These are several words which are fish".findAll("are").postln;
"These are several words which are fish".findAll("fish").postln;
#+END_SRC

::

method::contains
Returns a link::Classes/Boolean:: indicating if the String contains string.
code::
#+BEGIN_SRC sclang
"These are several words".contains("are").postln;
"These are several words".contains("fish").postln;
#+END_SRC

::

method::containsi
Same as link::#-contains::, but case insensitive.
code::
#+BEGIN_SRC sclang
"These are several words".containsi("ArE").postln;
#+END_SRC

::

method::containsStringAt
Returns a link::Classes/Boolean:: indicating if the String contains string beginning at the specified index.
code::
#+BEGIN_SRC sclang
"These are several words".containsStringAt(6, "are").postln;
#+END_SRC

::

method::icontainsStringAt
Same as link::#-containsStringAt::, but case insensitive.

method::beginsWith
method::endsWith
Returns true if this string begins/ends with the specified other string.
argument:: string
The other string
returns::
A link::Classes/Boolean::

subsection:: Manipulating strings

method::rotate
Rotate the string by n steps.
code::
#+BEGIN_SRC sclang
"hello word".rotate(1)
#+END_SRC

::

method::scramble
Randomize the order of characters in the string.
code::
#+BEGIN_SRC sclang
"hello word".scramble
#+END_SRC

::


method::replace
Like link::#-tr::, but with strings as arguments.
code::
#+BEGIN_SRC sclang
"Here are several words which are fish".replace("are", "were");
#+END_SRC

::

method::format
Returns a formatted string with arguments. The % character in the format string is replaced by a string representation of an argument. To print a % character use \\% .
code::
#+BEGIN_SRC sclang
format("this % a %. pi = %, list = %\n", "is", "test", pi.round(1e-4), (1..4))

this is a test. pi = 3.1416, list = [ 1, 2, 3, 4 ]
#+END_SRC

::

method::escapeChar
Add the escape character (\) before any character of your choice.
code::
#+BEGIN_SRC sclang
// escape spaces:
"This will become a Unix friendly string".escapeChar($ ).postln;
#+END_SRC

::

method::quote
Return this string enclosed in double-quote ( teletype::":: ) characters.
code::
#+BEGIN_SRC sclang
"tell your" + "friends".quote + "not to tread onto the lawn"
#+END_SRC

::

method::zeroPad
Return this string enclosed in space characters.
code::
#+BEGIN_SRC sclang
"spaces".zeroPad.postcs;
#+END_SRC

::

method::underlined
Return this string followed by dashes in the next line ( teletype::-:: ).
code::
#+BEGIN_SRC sclang
"underlined".underlined;
"underlined".underlined($~);
#+END_SRC

::

method::tr
Transliteration. Replace all instances of strong::from:: with strong::to::.
code::
#+BEGIN_SRC sclang
":-(:-(:-(".tr($(, $)); //turn the frowns upside down
#+END_SRC

::


method::padLeft
method::padRight
Pad this string with strong::string:: so it fills strong::size:: character.
argument:: size
Number of characters to fill
argument:: string
Padding string
code::
#+BEGIN_SRC sclang
"this sentence has thirty-nine letters".padRight(39, "-+");
"this sentence has thirty-nine letters".padLeft(39, "-+");
"this sentence more than thirteen letters".padRight(13, "-+"); // nothing to pad.
#+END_SRC

::

method::toUpper
Return this string with uppercase letters.
code::
#+BEGIN_SRC sclang
"Please, don't be impolite".toUpper;
#+END_SRC

::

method::toLower
Return this string with lowercase letters.
code::
#+BEGIN_SRC sclang
"SINOSC".toLower;
#+END_SRC

::

method::stripRTF
Returns a new String with all RTF formatting removed.
code::
#+BEGIN_SRC sclang
(
// same as File-readAllStringRTF
g = File("/code/SuperCollider3/build/Help/UGens/Chaos/HenonC.help.rtf","r");
g.readAllString.stripRTF.postln;
g.close;
)
#+END_SRC

::

method::split
Returns an Array of Strings split at the separator. The separator is a link::Classes/Char::, and is strong::not:: included in the output array.
code::
#+BEGIN_SRC sclang
"These are several words".split($ );

// The default separator $/ is handy for Unix paths.
"This/could/be/a/Unix/path".split;
#+END_SRC

::

subsection:: Stream support

method::printOn
Print the String on stream.
code::
#+BEGIN_SRC sclang
"Print this on Post".printOn(Post);

// equivalent to:
Post << "Print this on Post";
#+END_SRC

::

method::storeOn
Same as link::#-printOn::, but formatted link::#-asCompileString::.
code::
#+BEGIN_SRC sclang
"Store this on Post".storeOn(Post);

// equivalent to:
Post <<< "Store this on Post";
#+END_SRC

::



subsection::Unix Support

Where relevant, the current working directory is the same as the location of the SuperCollider app and the shell is the Bourne shell (sh). Note that the cwd, and indeed the shell itself, does not persist:
code::
#+BEGIN_SRC sclang
"echo $0".unixCmd; // print the shell (sh)
"pwd".unixCmd;
"cd Help/".unixCmd;
"pwd".unixCmd;

"export FISH=mackerel".unixCmd;
"echo $FISH".unixCmd;
#+END_SRC

::
It is however possible to execute complex commands:
code::
#+BEGIN_SRC sclang
"pwd; cd Help/; pwd".unixCmd;
"export FISH=mackerel; echo $FISH".unixCmd;
#+END_SRC

::
Also on os x applescript can be called via osascript:
code::
#+BEGIN_SRC sclang
"osascript -e 'tell application \"Safari\" to activate'".unixCmd;
#+END_SRC

::
Should you need an environment variable to persist you can use link::#-setenv::.

note::
Despite the fact that the method is called 'unixCmd', strong::it does work in Windows::. The string must be a DOS command, however: "dir" rather than "ls" for instance.
::

method::unixCmd
Execute a unix command asynchronously using the standard shell (sh).
argument:: action
A link::Classes/Function:: that is called when the process has exited. It is passed two arguments: the exit code and pid of the exited process.
argument:: postOutput
A link::Classes/Boolean:: that controls whether or not the output of the process is displayed in the post window.
returns::
An link::Classes/Integer:: - the pid of the newly created process. Use link::Classes/Integer#-pidRunning:: to test if a process is alive.
discussion::
Example:
code::
#+BEGIN_SRC sclang
"ls Help".unixCmd;
"echo one; sleep 1; echo two; sleep 1".unixCmd { |res, pid| [\done, res, pid].postln };
#+END_SRC

::

method::unixCmdGetStdOut
Similar to link::#-unixCmd:: except that the stdout of the process is returned (synchronously) rather than sent to the post window.
code::
#+BEGIN_SRC sclang
~listing = "ls Help".unixCmdGetStdOut; // Grab
~listing.reverse.as(Array).stutter.join.postln; // Mangle
#+END_SRC

::

method::systemCmd
Executes a unix command synchronously using the standard shell (sh).

returns:: Error code of the unix command

method::runInTerminal
Execute the String in a new terminal window (asynchronously).
argument::shell
The shell used to execute the string.
discussion::
note:: On OSX, the string is incorporated into a temporary script file and executed using the shell. ::
Example:
code::
#+BEGIN_SRC sclang
"echo ---------Hello delightful SuperCollider user----------".runInTerminal;
#+END_SRC

::

method::setenv
Set the environment variable indicated in the string to equal the String strong::value::. This value will persist until it is changed or SC is quit. Note that if strong::value:: is a path you may need to call link::#-standardizePath:: on it.
code::
#+BEGIN_SRC sclang
// all defs in this directory will be loaded when a local server boots
"SC_SYNTHDEF_PATH".setenv("~/scwork/".standardizePath);
"echo $SC_SYNTHDEF_PATH".unixCmd;
#+END_SRC

::

method::getenv
Returns the value contained in the environment variable indicated by the String.
code::
#+BEGIN_SRC sclang
"USER".getenv;
#+END_SRC

::

method::unsetenv
Set the environment variable to nil.

method::mkdir
Make a directory from the given path location.

method::pathMatch
Returns an link::Classes/Array:: containing all paths matching this String. Wildcards apply, non-recursive.
code::
#+BEGIN_SRC sclang
Post << "Help/*".pathMatch;
#+END_SRC

::

method::loadPaths
Perform link::#-pathMatch:: on this String, then load and execute all paths in the resultant link::Classes/Array::.
code::
#+BEGIN_SRC sclang
//first prepare a file with some code...
(
var f = File("/tmp/loadPaths_example.scd", "w");
if(f.isOpen, {
	f.putString("\"This text is the result of a postln command which was loaded and executed by loadPaths\".postln");
}, {
	"test file could not be created - please edit the file's path above".warn;
});
f.close;
)

//then load the file...
"/tmp/loadPaths_example.scd".loadPaths; //This file posts some text
#+END_SRC

::

method::load
Load and execute the file at the path represented by the receiver.

method::loadRelative
Load and execute the file at the path represented by the receiver, interpreting the path as relative to the current document or text file. Requires that the file has been saved.

method::resolveRelative
Convert the receiver from a relative path to an absolute path, relative to the current document or text file. Requires that the current text file has been saved. Absolute paths are left untransformed.

method::standardizePath
Expand ~ to your home directory, and resolve aliases on OSX. See link::Classes/PathName:: for more complex needs. See link::Classes/File#*realpath:: if you want to resolve symlinks.
code::
#+BEGIN_SRC sclang
"~/".standardizePath; //This will print your home directory
#+END_SRC

::


method::openOS
Open file, directory or URL via the operating system. On OSX this is implemented via teletype::open::, on Linux via
teletype::xdg-open:: and on Windows via teletype::start::.
code::
#+BEGIN_SRC sclang
Platform.userConfigDir.openOS;
"http://supercollider.sf.net".openOS;
#+END_SRC

::

subsection::Pathname Support

Also see link::#-+/+:: for path concatenation.

method::shellQuote
Return a new string suitable for use as a filename in a shell command, by enclosing it in single quotes ( teletype::':: ).
If the string contains any single quotes they will be escaped.
discussion::
You should use this method on a path before embedding it in a string executed by link::#-unixCmd:: or link::#-systemCmd::.
code::
#+BEGIN_SRC sclang
unixCmd("ls " + Platform.userExtensionDir.shellQuote)
#+END_SRC

::
note::
This works well with shells such as strong::bash::, other shells might need different quotation/escaping.
Apart from usage in the construction of shell commands, strong::escaping is not needed:: for paths passed to methods like pathMatch(path) or File.open(path).
::

method::absolutePath
method::asAbsolutePath
Return this path as an absolute path by prefixing it with link::Classes/File#*getcwd:: if necessary.

method::asRelativePath
Return this path as relative to the specified path.
argument::relativeTo
The path to make this path relative to.

method::withTrailingSlash
Return this string with a trailing slash if that was not already the case.

method::withoutTrailingSlash
Return this string without a trailing slash if that was not already the case.

method::basename
Return the filename from a Unix path.
code::
#+BEGIN_SRC sclang
"Imaginary/Directory/fish.rtf".basename;
#+END_SRC

::

method::dirname
Return the directory name from a Unix path.
code::
#+BEGIN_SRC sclang
"Imaginary/Directory/fish.rtf".dirname;
#+END_SRC

::

method::splitext
Split off the extension from a filename or path and return both in an link::Classes/Array:: as [path or filename, extension].
code::
#+BEGIN_SRC sclang
"fish.rtf".splitext;
"Imaginary/Directory/fish.rtf".splitext;
#+END_SRC

::

subsection::YAML and JSON parsing

method::parseYAML
Parse this string as YAML/JSON.
returns::
A nested structure of link::Classes/Array::s (for sequences), link::Classes/Dictionary##Dictionaries:: (for maps) and link::Classes/String::s (for scalars).

method::parseYAMLFile
Same as code::parseYAML:: but parse a file directly instead of a string. This is faster than reading a file into a string and then parse it.

subsection::Document Support

method::newTextWindow
Create a new link::Classes/Document:: with this.
code::
#+BEGIN_SRC sclang
"Here is a new Document".newTextWindow;
#+END_SRC

::

method::openDocument
Create a new link::Classes/Document:: from the path corresponding to this. The selection arguments will preselect the indicated range in the new window. Returns this.
code::
#+BEGIN_SRC sclang
(
String.filenameSymbol.asString.openDocument(10, 20)
)
#+END_SRC

::

method::findHelpFile
Returns the path for the helpfile named this, if it exists, else returns nil.
code::
#+BEGIN_SRC sclang
"Document".findHelpFile;
"foobar".findHelpFile;
#+END_SRC

::

method::help
Performs link::#-findHelpFile:: on this, and opens the file it if it exists, otherwise opens the main helpfile.
code::
#+BEGIN_SRC sclang
"Document".help;
"foobar".help;
#+END_SRC

::

subsection::Misc methods

method::speak
Sends string to the speech synthesisier of the OS. (OS X only.) see: link::Classes/Speech::
code::
#+BEGIN_SRC sclang
"hi i'm talking with the default voice now, i guess".speak;
#+END_SRC

::

method::inspectorClass
Returns class link::Classes/StringInspector::.


subsection::Drawing Support

The following methods must be called within an Window-drawFunc or a SCUserView-drawFunc function, and will only be visible once the window or the view is refreshed. Each call to Window-refresh SCUserView-refresh will 'overwrite' all previous drawing by executing the currently defined function.

See also: link::Classes/Window::, link::Classes/UserView::, link::Classes/Color::, and link::Classes/Pen::.

note::
for cross-platform GUIs, use code::Pen.stringAtPoint, Pen.stringInRect, Pen.stringCenteredIn, Pen.stringLeftJustIn, Pen.stringRightJustIn:: instead.
::

method::draw
Draws the String at the current 0@0 link::Classes/Point::. If not transformations of the graphics state have taken place this will be the upper left corner of the window. See also link::Classes/Pen::.
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
	"abababababa\n\n\n".scramble.draw
};
w.refresh
)
#+END_SRC

::

method::drawAtPoint
Draws the String at the given link::Classes/Point:: using the link::Classes/Font:: and link::Classes/Color:: specified.
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
w.view.background_(Color.white);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawAtPoint(
		100@100,
		Font("Courier", 30),
		Color.blue(0.3, 0.5))
};
w.refresh;
)
#+END_SRC

::

method::drawInRect
Draws the String into the given link::Classes/Rect:: using the link::Classes/Font:: and link::Classes/Color:: specified.
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
r = Rect(100, 100, 100, 100);
w.view.background_(Color.white);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawInRect(r, Font("Courier", 12), Color.blue(0.3, 0.5));
	Pen.strokeRect(r);
};
w.refresh;
)
#+END_SRC

::

method::drawCenteredIn
Draws the String into the given Rect using the Font and Color specified.
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
w.view.background_(Color.white);
r = Rect(100, 100, 100, 100);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawCenteredIn(
		r,
		Font("Courier", 12),
		Color.blue(0.3, 0.5)
	);
	Pen.strokeRect(r);
};
w.refresh;
)
#+END_SRC

::

method::drawLeftJustIn
Draws the String into the given Rect using the Font and Color specified.
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
w.view.background_(Color.white);
r = Rect(100, 100, 100, 100);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawLeftJustIn(
		r,
		Font("Courier", 12),
		Color.blue(0.3, 0.5)
	);
	Pen.strokeRect(r);
};
w.refresh;
)
#+END_SRC

::

method::drawRightJustIn
Draws the String into the given link::Classes/Rect:: using the link::Classes/Font:: and link::Classes/Color:: specified.
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
w.view.background_(Color.white);
r = Rect(100, 100, 100, 100);
w.drawFunc = {
	"abababababa\n\n\n".scramble.drawRightJustIn(
		r,
		Font("Courier", 12),
		Color.blue(0.3, 0.5)
	);
	Pen.strokeRect(r);
};
w.refresh;
)
#+END_SRC

::

method::bounds
Tries to return a link::Classes/Rect:: with the size needed to fit this string if drawed with given font.
argument:: font
A link::Classes/Font::

** class:: SubsampleOffset
summary:: Offset from synth start within one sample.
related:: Classes/ControlRate, Classes/RadiansPerSample, Classes/SampleDur, Classes/SampleRate, Classes/OffsetOut
categories::  UGens>Info


Description::

When a synth is created from a time stamped osc-bundle, it starts
calculation at the next possible block (normally 64 samples). Using an
OffsetOut UGen, one can delay the audio so that it matches sample
accurately.


For some synthesis methods, one needs subsample accuracy. SubsampleOffset
provides the information where, within the current sample, the synth was
scheduled. It can be used to offset envelopes or resample the audio
output.


classmethods::

method::ir

Examples::

code::
#+BEGIN_SRC sclang

// example: demonstrate cubic subsample interpolation


// impulse train that can be moved between samples
(
SynthDef(\Help_SubsampleOffset, { |out, addOffset|
	var in, dt, sampDur, extraSamples, sampleOffset, resampledSignal;
	in = Impulse.ar(2000, 0, 0.3); // some input.
	sampDur = SampleDur.ir; 	// duration of one sample
	extraSamples = 4;			// DelayC needs at least 4 samples buffer
	sampleOffset = 1 - SubsampleOffset.ir; // balance out subsample offset
	sampleOffset = sampleOffset + MouseX.kr(0, addOffset); // add a mouse dependent offset
	// cubic resampling:
	resampledSignal = DelayC.ar(in,
							maxdelaytime: sampDur * (1 + extraSamples),
							delaytime: sampDur * (sampleOffset + extraSamples)
					);
	OffsetOut.ar(out, resampledSignal)
}).add;
)

// create 2 pulse trains 1 sample apart, move one relatively to the other.
// when cursor is at the left, the impulses are adjacent, on the right, they are
// exactly 1 sample apart.

(
var dt = s.sampleRate.reciprocal; // 1 sample delay
s.sendBundle(0.2, [9, \Help_SubsampleOffset, s.nextNodeID, 1, 1, \out, 40, \addOffset, 3]);
s.sendBundle(0.2 + dt, [9, \Help_SubsampleOffset, s.nextNodeID, 1, 1, \out, 40, \addOffset, 0]);
)

s.scope(1, 40, zoom: 0.2);





// example of a subsample accurate sine grain:
// (I don't hear a difference to normal sample accurate grains, but maybe
// someone could add an example that shows the effect)

(
SynthDef("Help_Subsample_Grain",
	{ arg out=0, freq=440, sustain=0.005, attack=0.001;
		var env, offset, sig, sd;

		sd = SampleDur.ir;
		offset = (1 - SubsampleOffset.ir) * sd;
		// free synth after delay:
		Line.ar(1,0, attack + sustain + offset, doneAction:2);
		env = EnvGen.kr(Env.perc(attack, sustain, 0.2));
		sig = SinOsc.ar(freq, 0, env);

		sig = DelayC.ar(sig, sd * 4, offset);
		OffsetOut.ar(out, sig);
	}, [\ir, \ir, \ir, \ir]).add;
)

(
	Routine {
		loop {
			s.sendBundle(0.2, [9, \Help_Subsample_Grain, -1, 1, 1, \freq, 1000]);
			rrand(0.001, 0.002).wait;
		}
	}.play;
)
#+END_SRC

::

** CLASS:: Sum3
summary:: Sum three signals
categories:: UGens>Algebraic
related:: Classes/Mix

DESCRIPTION::
Sum three signals. Internal ugen to efficiently mix three signals. Should be used via link::Classes/Mix::.

CLASSMETHODS::
private:: new1

METHOD:: new

Construct UGen.
** CLASS:: Sum4
summary:: Sum four signals
categories:: UGens>Algebraic
related:: Classes/Mix

DESCRIPTION::
Sum four signals. Internal ugen to efficiently mix three signals. Should be used via link::Classes/Mix::.

CLASSMETHODS::
private:: new1

METHOD:: new

Construct UGen.
** class:: Sweep
summary:: Triggered linear ramp
categories::  UGens>Triggers

Description::

Starts a linear raise by rate/sec from zero when trig input crosses from
non-positive to positive.


classmethods::
private:: categories

method::ar, kr

argument::trig

triggers when trig input crosses from non-positive to positive.


argument::rate

rate/sec raise rate


Examples::

code::
#+BEGIN_SRC sclang
// using sweep to modulate sine frequency
(
{ var trig;
	trig = Impulse.kr(MouseX.kr(0.5, 20, 1));
	SinOsc.ar(Sweep.kr(trig, 700) + 500, 0, 0.2)
}.play;
)


// using sweep to index into a buffer
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
{ var trig;
	trig = Impulse.kr(MouseX.kr(0.5, 10, 1));
	BufRd.ar(1, b, Sweep.ar(trig, BufSampleRate.ir(0)))
}.play;
)

// backwards, variable offset
(
{ var trig, pos, rate;
	trig = Impulse.kr(MouseX.kr(0.5, 10, 1));
	rate = BufSampleRate.ir(0);
	pos = Sweep.ar(trig, rate.neg) + (BufFrames.ir(0) * LFNoise0.kr(0.2));
	BufRd.ar(1, b, pos)
}.play;
)

// raising rate
(
{ var trig, rate;
	trig = Impulse.kr(MouseX.kr(0.5, 10, 1));
	rate = Sweep.kr(trig, 2) + 0.5;
	BufRd.ar(1, b, Sweep.ar(trig, BufSampleRate.ir(0) * rate))
}.play;
)

b.free
#+END_SRC

::

Sweep can be used as a resettable link::Classes/Phasor:: or link::Classes/Line:: - one that can start, pause, resume and stop. To get a resettable link::Classes/XLine:: behavior change the code::linlin:: to code::linexp:: in the SynthDef below.
code::
#+BEGIN_SRC sclang
(
SynthDef(\lineReset, {|start= 0, end= 1, dur= 1, t_trig= 1, run= 1|
	var phasor= (Sweep.ar(t_trig, 1/dur*run)).linlin(0, 1, start, end, \minmax);
	phasor.poll;
	Out.ar(0, SinOsc.ar(phasor, 0, 0.2));
}).add;
)
a= Synth(\lineReset, [\start, 400, \end, 800, \dur, 2])
a.set(\t_trig, 1)
a.set(\run, 0)
a.set(\run, 1)
a.set(\t_trig, 1)
a.free

//shorter duration and downwards...
a= Synth(\lineReset, [\start, 1000, \end, 500, \dur, 0.5])
a.set(\t_trig, 1)
a.set(\run, 0)
a.set(\run, 1)
a.set(\t_trig, 1)
a.free
#+END_SRC

::
** class::Symbol
summary::unique name
categories::Core

description::
A Symbol is a name that is guaranteed to be unique. They can be used to represent
symbolic constant values, link::Classes/Dictionary:: keys, etc.

Symbols are represented syntactically as literals which are described in link::Reference/Literals::

subsection::Creating a Symbol

A symbol can be written by surrounding characters by single quotes (may include whitespace):

code::'foo bar'::

Or by a preceeding backslash (then it may not include whitespace):

code::\foo::

A String can be converted into a symbol:

code::"arbeit".scramble.asSymbol;::

classmethods::
private::new

instancemethods::

subsection::Testing

method::isClassName

Answer whether the symbol can be a class name. This does not say if the class exists.

code::
#+BEGIN_SRC sclang
\Array.isClassName;
\Bauxite.isClassName;
#+END_SRC

::

method::isMetaClassName

Answer whether the symbol can be meta class name. This does not say if the class exists.

code::
#+BEGIN_SRC sclang
\Meta_Array.isMetaClassName;
#+END_SRC

::

method::isSetter

Answer whether the symbol has a trailing underscore.

code::
#+BEGIN_SRC sclang
'action_'.isSetter;
#+END_SRC

::

method::isPrimitiveName

Answer whether the symbol is a valid primitive name

code::
#+BEGIN_SRC sclang
'_SymbolIsClassName'.isPrimitiveName;
#+END_SRC

::

subsection::Conversion

method::asString

Convert to a String

method::asInteger

Convert to an Integer

method::asClass

Answer the Class named by the receiver.

method::asSetter

Return a symbol with a trailing underscore added.

method::asGetter

Return a symbol with a trailing underscore removed.

method::ascii

return the ascii codes as an array

method::asSpec

Convert to a ControlSpec

method::asTuning

Convert to a Tuning

method::asScale

Convert to a Scale

subsection::Environments

Symbols are used as keys to look up objects in dictionaries and environments, but also in arrays.
See link::Classes/IdentityDictionary::, link::Classes/Environment::, link::Classes/Event::

code::
#+BEGIN_SRC sclang
a = ();
a.put(\commune, 1871);
a.at(\commune);
#+END_SRC

::

method::envirPut

put a value to the current environment using receiver as key

method::envirGet

return a value from the current environment using receiver as key
discussion::
code::
#+BEGIN_SRC sclang
\foo.envirPut(100);
\foo.envirGet;
\foo.envirPut(nil);
#+END_SRC

::

subsection::Math

Symbols respond to all unary and binary math operations by returning themselves. The result of any math operation between a Number or other math object and a Symbol is to return the Symbol. This allows for example operations on lists of notes which contain 'rest's to preserve the rests.

code::Pseq([1, 3, \rest, 2, 4] + 8);::

method::applyTo

Use the symbol as a method selector and perform the message on firstArg, with args as arguments. This is used for mixing functions with method selectors (see also: Function).
discussion::
code::
#+BEGIN_SRC sclang
'%'.applyTo(2553, 345);
['+', '-', '*', { |a, b| a.rand + b.rand } ].choose.applyTo(2, 3);
#+END_SRC

::


subsection::Synthesis

Inside SynthDefs and UGen functions, symbols can be used to conventiently specify control inputs of different rates and with lags (see:  NamedControl, ControlName, and Control).


method::kr

Return a control rate NamedControl input with a default value (val), and if supplied, with a lag. If val is an array, the control will be multichannel.
discussion::
code::
#+BEGIN_SRC sclang
a = { SinOsc.ar(\freq.kr(440, 1.2)) }.play;
a.set(\freq, 330);
a.release;
a = { SinOsc.ar(\freq.kr([440, 460], 1.2)) }.play;
a.setn(\freq, [330, 367]);
a.release;
#+END_SRC

::

method::ar

Return an audio rate NamedControl input with a default value (val), and if supplied, with a lag. If val is an array, the control will be multichannel.

method::ir

Return an intitalization rate NamedControl input with a default value (val). If val is an array, the control will be multichannel.

method::tr

Return a TrigControl input with a default value (val). If val is an array, the control will be multichannel.
discussion::
code::
#+BEGIN_SRC sclang
a = { Ringz.ar(T2A.ar(\trig.tr), \freq.kr(500, 1), 0.8) }.play;
a.set(\freq, 330, \trig, 1);
a.set(\freq, 830, \trig, 1);
a.release;
#+END_SRC

::

** CLASS::SymbolArray
summary::an array whose indexed slots are all of the same type
related::Classes/Int8Array, Classes/Int16Array, Classes/Int32Array, Classes/FloatArray, Classes/DoubleArray
categories::Collections>Ordered

DESCRIPTION::
These classes implement arrays whose indexed slots are all of the same type.
list::
## Int8Array - 8 bit integer
## Int16Array - 16 bit integer
## Int32Array - 32 bit integer
## FloatArray - 32 bit floating point
## DoubleArray - 64 bit floating point
## SymbolArray - symbols
::

INSTANCEMETHODS::

method::readFromStream
** class:: SyncSaw
summary:: Hard sync sawtooth wave.
related:: Classes/Saw, Classes/VarSaw, Classes/LFSaw
categories::  UGens>Generators>Deterministic


Description::

A sawtooth wave that is hard synched to a fundamental pitch. This
produces an effect similar to  moving formants or pulse width modulation.
The sawtooth oscillator has its phase reset when the sync oscillator
completes a cycle. This is not a band limited waveform, so it may alias.


classmethods::

method::ar, kr

argument::syncFreq

Frequency of the fundamental.


argument::sawFreq

Frequency of the slave synched sawtooth wave. Should always be
greater than
code::syncFreq:: .


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang

{ SyncSaw.ar(100, Line.kr(100, 800, 12), 0.1) }.play;


(
plot { [
	SyncSaw.ar(800, 1200),
	Impulse.ar(800) // to show sync rate
] }
)

(
plot { [
	SyncSaw.ar(800, Line.kr(800, 1600, 0.01)), // modulate saw freq
	Impulse.ar(800) // to show sync rate
] }
)

// scoping the saw: hit 's' when focused on the scope window to compare the channels
(
scope {
	var freq = 400;
	[
	SyncSaw.ar(freq, freq * MouseX.kr(1, 3)), // modulate saw freq
	Impulse.ar(freq) // to show sync rate
] * 0.3 }
)
#+END_SRC

::

** class:: Synth
summary:: Client-side representation of a synth node on the server
categories:: Server>Nodes, Server>Abstractions
related:: Classes/Node, Classes/SynthDef

description::

A Synth is the client-side representation of a synth node on the server. A Synth represents a single sound producing unit.  What it does is defined in a link::Classes/SynthDef::, which specifies what link::Classes/UGen::s are used and how they are patched together.
It also specifies what inputs and outputs the Synth will have. A SynthDef is thus a kind of fixed pattern, upon which Synths are be based. (Despite this, a given SynthDef can provide a surprising amount of variation.) For more detail on SynthDefs, their construction, and how to send them to a server, see the link::Classes/SynthDef:: help file.

For more on the important distinction between client objects and server nodes, see link::Guides/ClientVsServer::. For information on creating nodes without using objects, see link::Guides/NodeMessaging::.

subsection:: Order of Execution
Order of execution is a crucial issue when creating Synths which interact with each other.
code::
#+BEGIN_SRC sclang
	sound ->  filter
#+END_SRC

::
If a sound is to be passed through a filter, the synth that does the filtering must be later in the order of execution than the synth which is its input.  The computer must calculate a buffer's worth of sound, and then the computer moves on to calculate a buffer's worth of the filtered version of that sound.

The actual interconnection between synth nodes is accomplished with buses. See link::Classes/Bus:: and link::Reference/Server-Architecture:: for details.

See the link::Guides/Order-of-execution:: help file for a more detailed discussion of this important topic.

subsection:: Bundling

Some of the methods below have two versions: a regular one which sends its corresponding message to the server immediately, and one which returns the message in an link::Classes/Array:: so that it can be added to a bundle.
It is also possible to capture the messages generated by the regular methods using Server's automated bundling capabilities. See link::Classes/Server:: and link::Guides/Bundled-Messages:: for more details.

classmethods::
Synth is a subclass of Node, and thus many of its most useful and important methods are documented in the link::Classes/Node:: help file.

private:: stop, play, sampleRate

subsection:: Creation with Immediate Instantiation on the Server
method:: new
Create and return a new Synth object, and immediately start the corresponding synth node on the server.

argument:: defName
A String or Symbol specifying the name of the SynthDef to use in creating the Synth.

argument:: args
An optional link::Classes/Array:: specifying initial values for the link::Classes/SynthDef::'s arguments (controls). These are specified in pairs of control name or index and value. If names are used they can be specified with either link::Classes/String::s or link::Classes/Symbol::s. e.g. code:: [\frequency, 440, \amplitude, 1, ...] ::.
Values that are arrays are sent using OSC array type-tags ($[ and $]).  These values will be assigned to subsequent controls.

argument:: target
A target for this Synth. If target is not a link::Classes/Group:: or Synth, it will be converted as follows: If it is a link::Classes/Server::, it will be converted to the link::Reference/default_group:: of that server. If it is nil, to the default_group of the default Server. If it is an integer, it is created relative to a group with that id.

argument:: addAction
one of the following Symbols:
definitionlist::
## \addToHead || (the default) add at the head of the group specified by target
## \addToTail || add at the tail of the group specified by target
## \addAfter || add immediately after target in its server's node order
## \addBefore || add immediately before target in its server's node order
## \addReplace || replace target and take its place in its server's node order
::
Note: A Synth is not a valid target for \addToHead and \addToTail.

discussion::
code::
#+BEGIN_SRC sclang
s.boot;
// create a Synth at the head of the default Server's default group
// based on the SynthDef "default"
x = Synth.new("default");
s.queryAllNodes; // note the default group (ID 1)
x.free;

// Using an arrayed control
// run this block first to make the SynthDef
(
SynthDef("help-synth", {| freq = #[440, 450, 460], out = 0 |
	Out.ar(out, Mix(SinOsc.ar(freq, 0, 0.1)));
}).add;
)

// then this a short while later
x = Synth("help-synth", [freq: [500,501,510] ]);

x = Synth("help-synth", [freq: [500,501,510] ]);
x.set(\freq, [1,2,3] * 400 + [1,2,3], \out, 1);
x.set(\freq, [3] * 400 + [1,2,3], \out, 1);
x.free;
#+END_SRC

::

method:: newPaused
As code::new:: above, but creates a node which is paused. This can be started by calling code::run:: on it.
code::
#+BEGIN_SRC sclang
s.boot;
x = Synth.newPaused("default");
s.queryAllNodes; // see I'm here
x.run; // true is the default
x.run(false); // pause me again
x.free;
#+END_SRC

::

method:: grain
A convenience method which will create a synth node with an node ID of -1. Such a node cannot be messaged after creation. As such this method does not create an object, and returns nil. For details of its arguments see code::new:: above.
returns:: nil

subsection:: Convenience methods for add actions
The following convenience methods correspond to the add actions of code::Synth.new:: :

method:: after
Create and return a Synth and add it immediately after aNode.

method:: before
Create and return a Synth and add it immediately before aNode.

method:: head
Create and return a Synth. If code::aGroup:: is a link::Classes/Group:: add it at the head of that group. If it is a link::Classes/Server::, add it at the head of the link::Reference/default_group:: of that server. If it is nil, add it at the head of the default_group of the default server. If it is an integer, it is created relative to a group with that id.

method:: tail
Create and return a Synth. If code::aGroup:: is a link::Classes/Group:: add it at the tail of that group. If it is a link::Classes/Server::, add it at the tail of the link::Reference/default_group:: of that server. If it is nil, add it at the tail of the default_group of the the default server. If it is an integer, it is created relative to a group with that id.

method:: replace
Create and return a Synth and use it to replace code::nodeToReplace::, taking its place in its server's node order.

subsection:: Creation without Instantiation on the Server

For use in message bundles it is also possible to create a Synth object in the client app without immediately creating a synth node on the server. Once done one can call methods which create messages to add to a bundle, which when sent to the server will instantiate the synth.

method:: basicNew
Create and return a Synth object without creating a synth node on the server.
argument:: defName
A String or Symbol specifying the name of the SynthDef to use in creating the Synth.
argument:: server
An optional instance of Server. If nil this will default to the default Server.
argument:: nodeID
An optional node ID number. If not supplied one will be generated by the Server's NodeIDAllocator. Normally you should not need to supply an ID.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
x = Synth.basicNew("default", s); // Create without sending
s.sendBundle(nil, x.newMsg;); // Now send a message; create at the head of s' default group
s.queryAllNodes;
x.free;
#+END_SRC

::

After creation, use instance methods code::newMsg, addToHeadMsg, addToTailMsg, addBeforeMsg, addAfterMsg, addReplaceMsg:: to instantiate this synth on the server. See link::#instancemethods#Instance Methods:: below.



instancemethods::
Synth is a subclass of Node, and thus many of its most useful and important methods are documented in the link::Classes/Node:: help file.

private:: prepareForProxySynthDef, play

method:: defName
Returns:: the name of this Synth's SynthDef.

subsection:: Creation without Instantiation on the Server
Use class method code::basicNew:: to create a Synth without instantiating it on the server. Then use the following instance methods:
method:: newMsg
See *new above for details of addActions and args.
Returns:: a message of the type s_new which can be bundled. When sent to the server this message will instantiate this synth. If target is nil, it will default to the default_group of the Server specified in *basicNew when this Synth was created. The default addAction is \addToHead.

method:: addToHeadMsg
See *new above for details on args.
Returns:: a message of the type s_new which can be bundled. When sent to the server this message will instantiate this synth. If aGroup is a Group it will be added at the head of that group. If it is nil, it will be added at the head of the default_group of this Synth's server (as specified when *basicNew was called).

method:: addToTailMsg
See *new above for details on args.
Returns:: a message of the type s_new which can be bundled. When sent to the server this message will instantiate this synth. If aGroup is a Group it will be added at the tail of that group. If it is nil, it will be added at the tail of the default_group of this Synth's server (as specified when *basicNew was called).

method:: addBeforeMsg
See *new above for details on args.
Returns:: a message of the type s_new which can be bundled. When sent to the server this message will instantiate this synth, immediately before aNode.

method:: addAfterMsg
See *new above for details on args.
Returns:: a message of the type s_new which can be bundled. When sent to the server this message will instantiate this synth, immediately after aNode.

method:: addReplaceMsg
See *new above for details on args.
Returns:: a message of the type s_new which can be bundled. When sent to the server this message will instantiate this synth, replacing nodeToReplace in the server's node order.

subsection:: Control
For further methods of controlling Synths (set, map, etc.), see the link::Classes/Node:: helpfile.

method:: get, getMsg
Query the server for the current value of a link::Classes/Control:: (argument).
argument:: index
a control name or index
argument:: action
a Function which will be evaluated with the value passed as an argument when the reply is received.
discussion::
code::
#+BEGIN_SRC sclang
s.boot;
(
SynthDef("help-Synth-get", { arg freq = 440;
	Out.ar(0, SinOsc.ar(freq, 0, 0.1));
}).add;
)
x = Synth("help-Synth-get");
x.set(\freq, 220 + 440.rand);
x.get(\freq, { arg value; ("freq is now:" + value + "Hz").postln; });
x.free;
#+END_SRC

::

method:: getn, getnMsg
Query the server for the current values of a sequential range of link::Classes/Control::s (arguments).
argument:: index
a control name or index
argument:: count
the number of sequential controls to query, starting at index.
argument:: action
a Function which will be evaluated with an link::Classes/Array:: containing the values passed as an argument when the reply is received.

method:: set
Set the values of one or more link::Classes/Control::s.
discussion::
Example:
code::
#+BEGIN_SRC sclang
x.set(\freq, 440, \amp, 0.5)
#+END_SRC

::

method:: seti
Set part of an arrayed control.
argument:: ... args
A sequence of strong:: name, index, value :: triplets.

definitionlist::
## name || The name of the arrayed control
## index || The index into the array
## value || The new value to set, can be an array to set a range of elements.
::

discussion::
note::
The synthdef has to be .add'ed, so that it is stored in the link::Classes/SynthDescLib::.
::
Example:
code::
#+BEGIN_SRC sclang
(
s.waitForBoot {
    SynthDef(\helpSeti, { |freqs = #[100,150,200,250]|
        Out.ar(0, SinOsc.ar(freqs.poll,0,0.1).sum ! 2)
    }).add;
    s.sync;
    x = Synth(\helpSeti);
}
)
x.seti(\freqs,2,600); // set only the third element
x.seti(\freqs,1,[400,410]); // set second and third element
x.free;
#+END_SRC

::

Examples::
code::
#+BEGIN_SRC sclang
// boot the default server
s = Server.default; // just to be sure
s.boot;


(
// send a synth def to server
SynthDef("tpulse", { arg out = 0,freq = 700, sawFreq = 440.0;
	Out.ar(out, SyncSaw.ar(freq, sawFreq, 0.1));
}).add;
)

// Here the defaults for *new will result in a Synth at the head of the default group
// of the default Server. This will use the SynthDef's default arguments;
y = Synth.new("tpulse");
y.free;

// The same done explicitly
y = Synth.new("tpulse", nil, s, \addToHead);
y.free;

// With some arguments
y = Synth.new("tpulse", [\freq, 350, \sawFreq, 220]);
y.free;

// make a new synth
y = Synth("tpulse");

// pause
y.run(false);

y.run(true);

// set a control by argument name
y.set("freq", 200);

// or by index
y.set(2, 100.0);

// modulate out to bus number 1 (the right speaker)
y.set(0, 1);

//  multiple set commands in one message
y.set("out", 0, "freq",300);

// free the synth from the server
y.free;
#+END_SRC

::

subsection:: Filtering
code::
#+BEGIN_SRC sclang
(
// first collect some things to play with
SynthDef("moto-rev", { arg out=0;
	var x;
	x = RLPF.ar(LFPulse.ar(SinOsc.kr(0.2, 0, 10, 21), [0,0.1], 0.1),
		100, 0.1).clip2(0.4);
	Out.ar(out, x);
}).add;

SynthDef("bubbles", { arg out=0;
	var f, zout;
	f = LFSaw.kr(0.4, 0, 24, LFSaw.kr([8,7.23], 0, 3, 80)).midicps;
	zout = CombN.ar(SinOsc.ar(f, 0, 0.04), 0.2, 0.2, 4); // echoing sine wave
	Out.ar(out, zout);
}).add;


SynthDef("rlpf",{ arg out=0,ffreq=600,rq=0.1;
	ReplaceOut.ar( out, RLPF.ar( In.ar(out), ffreq,rq) )
}).add;


SynthDef("wah", { arg out, rate = 1.5, cfreq = 1400, mfreq = 1200, rq=0.1;
	var zin, zout;

	zin = In.ar(out, 2);
	cfreq = Lag3.kr(cfreq, 0.1);
	mfreq = Lag3.kr(mfreq, 0.1);
	rq   = Ramp.kr(rq, 0.1);
	zout = RLPF.ar(zin, LFNoise1.kr(rate, mfreq, cfreq), rq, 10).distort
					* 0.15;

	// replace the incoming bus with the effected version
	ReplaceOut.ar( out , zout );

}).add;

SynthDef("modulate",{ arg out = 0, freq = 1, center = 440, plusMinus = 110;
	Out.kr(out, SinOsc.kr(freq, 0, plusMinus, center));
}).add;
)

// execute these one at a time

// y is playing on bus 0
y = Synth("moto-rev",["out",0]);

// z is reading from bus 0 and replacing that; It must be *after* y
z = Synth.after(y,"wah",["out",0]);

// stop the wah-ing
z.run(false);

// resume the wah-ing
z.run(true);

// add a rlpf after that, reading and writing to the same buss
x = Synth.after(z,"rlpf",["out",0]);

// create another rlpf after x
t = Synth.after(x,"rlpf",["out",0]);

x.set("ffreq", 400);

x.set(\ffreq, 800); // Symbols work for control names too

// Now let's modulate x's ffreq arg
// First get a control Bus
b = Bus.control(s, 1);

// now the modulator, *before* x
m = Synth.before(x, "modulate", [\out, b]);

// now map x's ffreq to b
x.map("ffreq", b);

m.set("freq", 4, "plusMinus", 20);

x.free;
z.free;
m.free;

// now place another synth after y, on the same bus
// they both write to the buss, adding their outputs
r = Synth.after(y,"bubbles",["out",0]);

y.free;

r.free;

// look at the Server window
// still see 4 Ugens and 1 synth?
// you can't hear me, but don't forget to free me
t.free;
#+END_SRC

::

** class:: SynthDef
summary:: Client-side representation of a synth definition
categories:: Server>Abstractions
related:: Classes/Synth, Reference/Synth-Definition-File-Format, Classes/SynthDesc

description::

The server application uses synth definitions as templates for creating link::Classes/Synth:: nodes.
(Methods such as link::Classes/Function#play#Function-play::, etc. are simply conveniences which automatically create such a def.)
The SynthDef class encapsulates the client-side representation of a given def, and provides methods for creating new defs, writing them to disk, and streaming them to a server.

SynthDef is one of the more complicated classes in SC and an exhaustive explanation of it is beyond the scope of this document. As such, the examples at the bottom of this document and those found in the various tutorials accessible from link::Help:: may be necessary to make some aspects of its use clear.

subsection:: UGen Graph Functions and Special Argument Forms

The core of a def is its link::Classes/UGen##unit generator:: graph function.
This is an instance of link::Classes/Function:: which details how the def's unit generators are interconnected, its inputs and outputs, and what parameters are available for external control.
In a synth based on the def, arguments to the function will become instances of link::Classes/Control::.
These can have default values, or can be set at the time the synth is created.
After creation they will be controllable through link::Classes/Node::'s code::set:: and code::setn:: methods, or the n_set and n_setn link::Browse#OpenSoundControl#OSC:: messages.

There are four special types of arguments, which are treated differently:
definitionlist::
## audio rate
|| Arguments that begin with "a_" (e.g. code::a_input::), or that are specified as code::\ar:: in the def's rates argument (see below), will be able to read and audio rate bus when mapped to it with code::/n_mapa::.
## initial rate
|| Arguments that begin with "i_" (e.g. code::i_freq::), or that are specified as code::\ir:: in the def's rates argument (see below), will be static and non-modulatable. They will not respond to code::/n_set:: or code::/n_map::. This is slightly more efficient in terms of CPU than a regular arg.
## trigger rate
|| Arguments that begin with "t_" (e.g. code::t_trig::), or that are specified as code::\tr:: in the def's rates argument (see below), will be made as a link::Classes/TrigControl::. Setting the argument will create a control-rate impulse at the set value. This is useful for triggers.
## literal arrays
|| Arguments which have literal arrays as default values (see link::Reference/Literals::) result in multichannel controls, which can be set as a group with link::Classes/Node#setn#Node-setn:: or code::/n_setn::. When setting such controls no bounds checking is done, so you are responsible for making sure that you set the correct number of arguments.
::

See the examples below for more detail on how this works.

Certain argument names (such as 'out' to specify an out bus) are in such common use that adopting them might be said to constitute 'good style'.
One of these, 'gate' when used to control the gate input of an link::Classes/EnvGen::, deserves special mention, as it allows one to use Node's release method. See link::Classes/Node:: for an example and more detail.

subsection:: Static versus Dynamic Elements

It is important to understand that although a single def can provide a great deal of flexibility through its arguments, etc., it is nevertheless a static entity.
A def's link::Classes/UGen:: graph function (and the SC code within it) is evaluated only when the def is created.
Thus statements like while, do, collect etc. will have no further effect at the time the def is used to create a Synth, and it is important to understand that a UGen graph function should not be designed in the same way as functions in the language, where multiple evaluations can yield different results. It will be evaluated once and only once.
note:: code::if:: is implemented as a linear signal crossfade when the receiver is an UGen ::

There are other ways of achieving similar results, however, often using UGens such as Rand. For example, the following def will have a single randomly generated frequency, which will be the same for every Synth based on it:
code::
#+BEGIN_SRC sclang
(
SynthDef(\help_notRand, {
	Out.ar(0,
		SinOsc.ar(rrand(400, 800), 0, 0.2) * Line.kr(1, 0, 1, doneAction: 2)
	)
}).add;
)
a = Synth(\help_notRand);
b = Synth(\help_notRand); // the same freq as a
#+END_SRC

::
This one on the other hand will have a different random freq for each Synth created:
code::
#+BEGIN_SRC sclang
(
SynthDef(\help_isRand, {
	Out.ar(0,
		SinOsc.ar(Rand(400, 800), 0, 0.2) * Line.kr(1, 0, 1, doneAction: 2)
	)
}).add;
)
a = Synth(\help_isRand);
b = Synth(\help_isRand); // a different randomly selected freq
#+END_SRC

::


ClassMethods::
private:: initClass, prNew

method:: new
Create a SynthDef instance, evaluate the ugenGraphFunc and build the ugenGraph.
argument:: name
A link::Classes/String:: or link::Classes/Symbol:: (i.e. "name" or \name). This name will be used to refer to the SynthDef when creating a Synth based upon it, and should be unique.
argument:: ugenGraphFunc
An instance of Function specifying how the def's UGens are interconnected. See the discussion above for information on how the Function's arguments are specified.
argument:: rates
An optional Array of specifications for the ugenGraphFunc's arguments. The order corresponds to the order of arguments. See the examples below to see how these are used.

A specification can be:
definitionlist::
## nil/zero || A standard control rate link::Classes/Control:: is created.
## \ar || An audio rate link::Classes/AudioControl:: is created.
## a float || the Control will have a lag of the specified time. This can be used to create
smooth transitions between different values. t_ and i_ args cannot be lagged.
## \ir || The Control can be set only at creation ('initial rate'). See discussion above.
## \tr || The Control is used as a trigger. See discussion above.
::

argument:: prependArgs
An optional link::Classes/Array:: of objects which will be passed as the first arguments to the ugenGraphFunc when it is evaluated. Arguments which receive values in this way will not be converted to instances of link::Classes/Control::. See the code::wrap:: example below for an example of how this can be used.

argument:: variants
An optional link::Classes/Event:: containing default argument settings. These can override the defaults specified in the ugenGraphFunc. When creating a Synth a variant can be requested by appending the defName argument in the form  'name.variant' or "name.variant". See example below.

argument:: metadata
An optional link::Classes/Event:: containing additional, user-defined information that is relevant to the use of the SynthDef in the client. The SynthDef itself is sent to the server for audio rendering; metadata are strictly client-side descriptive information. Currently the 'specs' key in the event is reserved for link::Classes/ControlSpec::s to be associated with SynthDef arguments (this is useful for automatic GUI construction). Metadata can be persisted to disk and loaded automatically as part of a SynthDesc. See the link::Classes/SynthDesc:: help file for more details.


method:: wrap
Wraps a function within an enclosing synthdef.
discussion::
Arguments to the wrapped function are automatically promoted to be SynthDef controls, using the same rules applied to arguments of the main UGen function. For a very simple example:
code::
#+BEGIN_SRC sclang
d = SynthDef(\demoWrapping, { |out|
	Out.ar(out, SynthDef.wrap({ |freq| SinOsc.ar(freq) }))
});

d.allControlNames;
#+END_SRC

::
Prints: code:: [ ControlName  P 0 out control 0, ControlName  P 1 freq control 0 ] ::.

The outer function declares the argument 'out', and the wrapped function has 'freq' as its argument. The resulting SynthDef has both arguments as controls, exactly as if the outer function included both as arguments.

The rates array behaves as described earlier. code::PrependArgs:: allows values or unit generators to be passed into the inner function from the enclosing SynthDef context. Any inner function argument that receives a prependArg value (including nil) will use that value, suppressing creation of a control for that argument. The longer example below demonstrates this technique.

This is very useful for mass-producing SynthDefs that have a common "shell" defining features such as enveloping or triggering mechanisms that apply to different subgraphs of unit generators. The common features need be written only once; the UGens that differ between the SynthDefs are plugged into the supporting architecture.

method:: synthDefDir
Get or set the default directory to which defs are written.

method:: removeAt
Remove the synthdef code::name:: from the SynthDescLib named code::libname:: and from its servers.

method:: writeOnce
Create a new SynthDef and write it to disk, but only if a def file with this name does not already exist. This is useful in class definitions so that the def is not written every time the library is compiled. Note that this will not check for differences, so you will need to delete the defFile to get it to rebuild. Default for dir is to use the path specified by code::SynthDef.synthDefDir::.


InstanceMethods::

method:: add
Adds the synthdef to the link::Classes/SynthDescLib:: specified by libname, and sends it to the library's servers. No defFile is written; all operations take place in memory.

discussion::
After using this method, the synthdef can be used with event streams as in code::store()::, but without the permanent artifact of a file on disk.

A server can be added by code:: SynthDescLib.global.addServer(server) ::.

Note that the "dir" and "mdPlugin" arguments do not exist for this method. Because no file is written, there is no need to specify a directory or write a metadata file.

code::
#+BEGIN_SRC sclang
(
SynthDef(\help_synth, { |out, freq = 800, sustain = 1, amp = 0.1|
	Out.ar(out,
		SinOsc.ar(freq, 0, 0.2) * Line.kr(amp, 0, sustain, doneAction: 2)
	)
}).add;
)
#+END_SRC

::

method:: name
Return this def's name.

method:: func
Return this def's ugenGraphFunc.

method:: variants
Return an Event containing this def's variants.

method:: allControlNames
An array of link::Classes/ControlName::'s for the controls.

subsection:: Special purpose methods
(for most purposes, the method add is recommended)

method:: writeDefFile
Writes the def as a file called name.scsyndef in a form readable by a server. Default for dir is synthdefs/. Defs stored in the default directory will be automatically loaded by the local and internal Servers when they are booted.

method:: load
Write the defFile and send a message to server to load this file. When this asynchronous command is completed, the completionMessage (a valid OSC message) is immediately executed by the server. Default for dir is synthdefs/.

method:: send
Compile the def and send it to server without writing to disk (thus avoiding that annoying SynthDef buildup). When this asynchronous command is completed, the completionMessage (a valid OSC message) is immediately executed by the server.

method:: store
Write the defFile and store it in the SynthDescLib specified by libname, and send a message to the library's server to load this file. When this asynchronous command is completed, the completionMessage (a valid OSC  message) is immediately executed by the server. Default for libname is \global, for dir is synthdefs/. This is needed to use defs with the event stream system. See Streams and Pattern.
argument:: libname
name of the link::Classes/SynthDescLib::
argument:: dir
argument:: completionMsg
argument:: mdPlugin
(optional) The metadata plug-in class that will be used to persist metadata. If not supplied, the default plug-in is used. See the SynthDesc help file for details.


method:: play
A convenience method which compiles the def and sends it to target's server. When this asynchronous command is completed, it create one synth from this definition, using the argument values specified in the Array args.  For a list of valid addActions see link::Classes/Synth::. The default is \addToHead.
Returns:: a corresponding Synth object.


Examples::

subsection:: Basic
code::
#+BEGIN_SRC sclang
// Note that constructions like SynthDef(...) and Synth(...) are short for SynthDef.new(...), etc.
// With SynthDef it is common to chain this with calls on the resulting instance,
// e.g. SynthDef(...).add or SynthDef(...).play

// make a simple def and send it to the server

s.boot;
SynthDef(\SimpleSine, {|freq = 440| Out.ar(0, SinOsc.ar(freq, 0, 0.2)) }).add;

// the above is essentially the same as the following:
d = SynthDef.new(\SimpleSine, {|freq = 440| Out.ar(0, SinOsc.ar(freq, 0, 0.2)) });
d.add;

// now make a synth from it, using the default value for freq, then another with a different value
x = Synth(\SimpleSine);
y = Synth(\SimpleSine, [\freq, 660]);

// now change the freq value for x
x.set(\freq, 880);

x.free; y.free;

// using the play convenience method
x = SynthDef(\SimpleSine, {|freq = 440| Out.ar(0, SinOsc.ar(freq, 0, 0.2)) }).play
x.free;
#+END_SRC

::

subsection:: Argument Rates
code::
#+BEGIN_SRC sclang
// the following two defs are equivalent. The first uses a 't_' arg:
(
SynthDef(\trigTest, {|t_trig=0, freq=440| // t_trig creates a TrigControl
	Out.ar(0, SinOsc.ar(freq+[0,1], 0, Decay2.kr(t_trig, 0.005, 1.0)));
}, [0, 4]		// lag the freq by 4 seconds (the second arg), but not t_trig (won't work anyway)
);
)

// This second version makes trig a \tr arg by specifying it in the rates array.
(
SynthDef(\trigTest2, {|trig=0, freq=440|
	Out.ar(0, SinOsc.ar(freq+[0,1], 0, Decay2.kr(trig, 0.005, 1.0)));
	}, [\tr, 4]		// lag the freq (lagtime: 4s), \tr creates a TrigControl for trig
).add;
)

// Different way of writing the same thing
(
SynthDef(\trigTest2, {
	Out.ar(0, SinOsc.ar(\freq.kr(440, 4) + [0,1], 0, Decay2.kr(\trig.tr, 0.005, 1.0)));
}).add;
)


// Using the second version create a synth
z = Synth.head(s, \trigTest2);

// now trigger the decay envelope
z.set(\trig, 1); 				// you can do this multiple times
z.set(\trig, 1, \freq, 220); 	// hear how the freq lags
z.set(\trig, 1, \freq, 880);

z.free; //free the synth
#+END_SRC

::

subsection:: Variants
code::
#+BEGIN_SRC sclang
// create a def with some variants
(
SynthDef(\vartest, {|out=0, freq=440, amp=0.2, a = 0.01, r = 1|
	// the EnvGen with doneAction: 2 frees the synth automatically when done
	Out.ar(out, SinOsc.ar(freq, 0, EnvGen.kr(Env.perc(a, r, amp), doneAction: 2)));
}, variants: (alpha: [a: 0.5, r: 0.5], beta: [a: 3, r: 0.01], gamma: [a: 0.01, r: 4])
).add;
)

// now make some synths. First using the arg defaults
Synth(\vartest);

// now the variant defaults
Synth('vartest.alpha');
Synth('vartest.beta');
Synth('vartest.gamma');

// override a variant
Synth('vartest.alpha', [\release, 3, \freq, 660]);
#+END_SRC

::

subsection:: Literal Array Arguments
code::
#+BEGIN_SRC sclang
// freqs has a literal array of defaults. This makes a multichannel Control of the same size.
(
SynthDef(\arrayarg, { | amp = 0.1, freqs = #[300, 400, 500, 600], gate = 1 |
	var env, sines;
	env = Linen.kr(gate, 0.1, 1, 1, 2) * amp;
	sines = SinOsc.ar(freqs +.t [0,0.5]).cubed.sum; // A mix of 4 oscillators
	Out.ar(0, sines * env);
}, [0, 0.1, 0]).add;
)

x = Synth(\arrayarg);
x.setn(\freqs, [440, 441, 442, 443]);

// Don't accidentally set too many values, or you may have unexpected side effects
// The code below inadvertantly sets the gate arg, and frees the synth
x.setn(\freqs, [300, 400, 500, 600, 0]);

// Mr. McCartney's more complex example
(
fork {
	z = Synth(\arrayarg);

	2.wait;
	10.do {
		z.setn(\freqs, {exprand(200,800.0)} ! 4);
		(2 ** (0..3).choose * 0.2).wait;
	};

	z.set(\amp, -40.dbamp);

	10.do {
		z.setn(\freqs, {exprand(200,800.0)} ! 4);
		(2 ** (0..3).choose * 0.2).wait;
	};
	2.wait;

	z.release;
};
)
#+END_SRC

::

subsection:: Wrapping Example: 'factory' production of effects defs
code::
#+BEGIN_SRC sclang
// The makeEffect function below wraps a simpler function within itself and provides
// a crossfade into the effect (so you can add it without clicks), control over wet
// and dry mix, etc.
// Such functionality is useful for a variety of effects, and SynthDef-wrap
// lets you reuse the common code.
(
// the basic wrapper
~makeEffect = {| name, func, lags, numChannels = 2 |

	SynthDef(name, {| i_bus = 0, gate = 1, wet = 1|
		var in, out, env, lfo;
		in = In.ar(i_bus, numChannels);
		env = Linen.kr(gate, 2, 1, 2, 2); // fade in the effect

		// call the wrapped function. The in and env arguments are passed to the function
		// as the first two arguments (prependArgs).
		// Any other arguments of the wrapped function will be Controls.
		out = SynthDef.wrap(func, lags, [in, env]);

		XOut.ar(i_bus, wet * env, out);
	}, [0, 0, 0.1] ).add;

};
)

// now make a wah
(
~makeEffect.value(\wah, {|in, env, rate = 0.7, ffreq = 1200, depth = 0.8, rq = 0.1|
	// in and env come from the wrapper. The rest are controls
 	var lfo;
	lfo = LFNoise1.kr(rate, depth * ffreq, ffreq);
	RLPF.ar(in, lfo, rq, 10).distort * 0.15; },
	[0.1, 0.1, 0.1, 0.1],  // lags for rate ffreq, depth and rq
	2	// numChannels
);
)

// now make a simple reverb
(
~makeEffect.value(\reverb, {|in, env|
	// in and env come from the wrapper.
	var input;
	input = in;
	16.do({ input = AllpassC.ar(input, 0.04, Rand(0.001,0.04), 3)});
	input; },
	nil,  // no lags
	2	// numChannels
);
)

// something to process
x = { {Decay2.ar(Dust2.ar(3), mul: PinkNoise.ar(0.2))} ! 2}.play;

y = Synth.tail(s, \wah);
z = Synth.tail(s, \reverb, [\wet, 0.5]);

// we used an arg named gate, so Node-release can crossfade out the effects
y.release;

// setting gate to zero has the same result
z.set(\gate, 0);

x.free;
#+END_SRC

::

subsection:: common argument names: out and gate
code::
#+BEGIN_SRC sclang
// arguments named 'out' and 'gate' are commonly used to specify an output bus and
// EnvGen gate respectively. Although not required, using them can help with consistency
// and interchangeability. 'gate' is particularly useful, as it allows for Node's release
// method.
(
SynthDef(\synthDefTest, {|out, gate=1, freq=440|
	// doneAction: 2 frees the synth when EnvGen is done
	Out.ar(out, SinOsc.ar(freq) * EnvGen.kr(Env.asr(0.1, 0.3, 1.3), gate, doneAction:2));
}).store; // use store for compatibility with pattern example below
)

x = Synth(\synthDefTest, [\out, 0]); // play out through hardware output bus 0 (see Out.help)
x.release; // releases and frees the synth (if doneAction is > 2; see EnvGen)

//equivalent:

x = Synth(\synthDefTest); // out defaults to zero, if no default arg is given.
x.set(\gate, 0);

// if value is negative, it overrides the release time, to -1 - gate
x = Synth(\synthDefTest);
x.set(\gate, -5); // 4 second release

//equivalent:
x = Synth(\synthDefTest);
x.release(4);

// if the out arg is used in a standard way, it can always be changed without knowing the synth def
x = Synth(\synthDefTest, [\out, 0]);
x.set(\out, 1); //play through channel 1
x.release;

// Another good example of this is with patterns, which can use gate to release notes
(
Pbind(
	\instrument, \synthDefTest,
	\freq, Pseq([500, 600, Prand([200, 456, 345],1)], inf),
	\legato, Pseq([1.5, 0.2], inf),
	\dur, 0.4,
	\out, Pseq([0, 1], inf)
).play;
)
#+END_SRC

::

** class:: SynthDesc
summary:: Description of a synth definition
categories:: Server>Nodes
related:: Classes/SynthDef, Classes/Synth

description::
Contains a description of a link::Classes/SynthDef::, including its name, control names and default values.
Information is also stored on its outputs and inputs and whether it has a gate control.

SynthDescs are needed by the event stream system, so when using link::Classes/Pbind::, the instruments' default parameters are derived from the SynthDesc.

subsection:: Creation
SynthDescs are created by link::Classes/SynthDescLib::, by reading a compiled synth def file.
code::
#+BEGIN_SRC sclang
SynthDescLib.global.read("synthdefs/default.scsyndef");
SynthDescLib.global.synthDescs.at(\default)
SynthDescLib.global.at(\default) // shortcut, same as line above
#+END_SRC

::

code::aSynthDef.store:: and code::aSynthDef.add:: also create a synthDesc in the global library.
definitionlist::
## .store || saves a synthdef file on disk (like .load);
## .add || creates the synthDesc wholly in memory and sends the synthdef to registered servers.
::
code::
#+BEGIN_SRC sclang
(
SynthDef("test", { arg out, freq, xFade;
	XOut.ar(out, xFade, SinOsc.ar(freq))
}).store
);
#+END_SRC

::

Browse the properties of SynthDescs:
code::
#+BEGIN_SRC sclang
SynthDescLib.global.browse;
#+END_SRC

::

section:: SynthDescs and SynthDef metadata

Metadata associated with a link::Classes/SynthDef:: consists of an link::Classes/Event:: (a syntactically shorter form of an identity dictionary) containing information about the SynthDef that is useful to the client, and which cannot be inferred from the binary .scsyndef stream.

For example, by listing argument names and link::Classes/ControlSpec::s under the 'specs' key in the event, the client can use the specs to build a link::Classes/GUI:: allowing control over all the SynthDef's inputs, with sensible range mappings. (The "window" button in the SynthDescLib browser does exactly this -- any ControlSpecs listed in the metadata will be used for the corresponding synth input's slider.)

Currently only the 'specs' key is reserved. Other keys may be used as needed for specific applications. As the use of SynthDef metadata evolves, other keys may be standardized.

subsection:: Creation and access
Metadata are specified when creating a link::Classes/SynthDef::. If the SynthDef is .store'd (or .added'd) into a SynthDescLib, the metadata become part of the SynthDesc as well. Thereafter, the metadata can be accessed through SynthDescLib:
code::
#+BEGIN_SRC sclang
SynthDescLib.global[\synthDefName].metadata
#+END_SRC

::

subsection:: Persistence and metadata plug-ins
Storing a SynthDef into the library with .store persists the SynthDef on disk. Metadata may also be persisted at the same time by using the appropriate metadata plug-in class. The plug-in is responsible for writing a separate metadata file into the synthdefs directory, and reading the file back at the same time that a SynthDesc is created for a .scsyndef file using SynthDesc.read or SynthDescLib.global.read.

The currently available plug-ins are:
definitionlist::
## AbstractMDPlugin || A dummy plug-in, which writes no metadata. This is the default, so that users who are not interested in metadata will not find extra files in the synthdefs directory.
## TextArchiveMDPlugin || Writes the metadata as a SuperCollider text archive -- metadata.writeArchive(path).
::
Other plug-ins may be written at a later date, to support sharing metadata with applications in other languages using formats like JSON (JavaScript Object Notation) or XML.

You may specify a global default metadata plug-in as follows:
code::
#+BEGIN_SRC sclang
SynthDesc.mdPlugin = ... plug-in class name ...;
#+END_SRC

::
Metadata are not written when using code::SynthDef().load(server)::. This is because SynthDesc exists to describe a SynthDef to the client, whereas SynthDef is really just an abstraction to create a link::Classes/UGen:: graph for the server.

subsection:: Automatic population
You may write a function to populate entries into the metadata automatically, based on the SynthDesc object. This function executes when reading a SynthDesc from disk, when using .add, and before writing a metadata file (in .store).
code::
#+BEGIN_SRC sclang
SynthDesc.populateMetadataFunc = { |synthdesc|
	... do work here ...
};
#+END_SRC

::

subsection:: Synchronization
Whenever a .scsyndef file is written, any existing metadata files will be deleted so that a new .scsyndef file will not exist on disk with out-of-date metadata.

subsection:: Reading
When reading a SynthDesc, metadata files will be checked and one will be read, regardless of format. (Even if the default SynthDesc.mdPlugin is different from the file format on disk, the disk file will be read using the appropriate plug-in anyway.)

There should be only one metadata file at a time. However, in the case of conflicts, the default SynthDesc.mdPlugin will be preferred. The file extension identifies the format.

subsection:: Metadata Examples
code::
#+BEGIN_SRC sclang
s.boot;

d = SynthDef(\mdDemo, { |out, freq, cutoff, volume, gate = 1|
	var	sig = LPF.ar(Saw.ar(freq, volume), cutoff),
		env = EnvGen.kr(Env.adsr, gate, doneAction: 2);
	Out.ar(out, (sig * env) ! 2)
}).add;

SynthDescLib.global[\mdDemo].makeWindow;

// Note in the resulting window that Freq has a slider, but Cutoff and Volume do not.
// This is because there are no global specs for the argument names 'cutoff' and 'volume'.


// Same SynthDef, but adding metadata
// \freq and \amp exist in the global ControlSpec collection -- Spec.specs
// They are converted to real ControlSpecs using .asSpec

d = SynthDef(\mdDemo, { |out, freq, cutoff, volume, gate = 1|
	var	sig = LPF.ar(Saw.ar(freq, volume), cutoff),
		env = EnvGen.kr(Env.adsr, gate, doneAction: 2);
	Out.ar(out, (sig * env) ! 2)
}, metadata: (specs: (cutoff: \freq, volume: \amp))).add;

SynthDescLib.global[\mdDemo].makeWindow;

// Now cutoff has a slider for frequency and volume has amplitude scaling


// Store the SynthDef along with metadata
d.store(mdPlugin: TextArchiveMDPlugin);

"ls %mdDemo.*".format(SynthDef.synthDefDir.escapeChar($ )).unixCmd;

// In addition to .scsyndef, there's also .txarcmeta - "text archive metadata"

// Load a fresh SynthDesc from disk for it
// The SynthDesc.read interface is a bit weird - e will be a dictionary holding the SynthDesc
e = SynthDesc.read(SynthDef.synthDefDir ++ "mdDemo.scsyndef");

// Metadata have been successfully read from disk!
// You could even do the above after recompiling and the MD would be there
e[\mdDemo].metadata

e[\mdDemo].makeWindow;
#+END_SRC

::

classmethods::
private:: initClass

method:: read
adds all synthDescs in a path to a dict

instancemethods::

method:: name
returns:: the name of the SynthDef

method:: controls
returns:: an array of instances of link::Classes/ControlName::, each of which
have the following fields: name, index, rate, defaultValue
discussion::
code::
#+BEGIN_SRC sclang
SynthDescLib.global.at(\default).controlNames.postln;
#+END_SRC

::

method:: controlDict
An link::Classes/IdentityDictionary:: of the link::Classes/ControlName::'s, indexed by name.
This can be used for fast lookup of control index by name, for example to set a specific element of a multichannel control.

method:: controlNames
returns:: an array of Strings with the names of controls

method:: outputs
returns:: an array of link::Classes/IODesc:: that describes the available outputs.
method:: inputs
returns:: an array of link::Classes/IODesc:: that describes the available inputs.

method:: hasGate
is true if the Synthdef has a gate input

method:: canFreeSynth
is true if the link::Classes/Synth:: can free itself (via some means, usually a doneAction)
discussion::
This can be used to decide if to remove a Synth directly via free-message.
code::
#+BEGIN_SRC sclang
SynthDescLib.global.at(\default).canFreeSynth;
#+END_SRC

::

method:: msgFunc
the function which is used to create an array of arguments for
playing a synth def in patterns
discussion::
code::
#+BEGIN_SRC sclang
SynthDescLib.global.synthDescs.at(\default).msgFunc.postcs;
#+END_SRC

::

** class:: SynthDescLib
summary:: SynthDesc library
categories:: Server>Nodes
related:: Classes/SynthDesc

description::
See link::Classes/SynthDesc::

** CLASS::SystemClock
categories::Scheduling>Clocks
summary:: Clock running on separate accurately timed thread
related::Classes/AppClock, Classes/TempoClock

DESCRIPTION::

SystemClock is more accurate, but cannot call Cocoa primitives. AppClock is less accurate (uses NSTimers) but can call Cocoa primitives.

See link::Classes/Clock:: for general explanation of how clocks operate.

CLASSMETHODS::

method::sched
The float you return specifies the delta to resched the function for. Returning nil will stop the task from being rescheduled.
code::
#+BEGIN_SRC sclang
(
SystemClock.sched(0.0,{ arg time;
	time.postln;
	rrand(0.1,0.9);
});
)
#+END_SRC

::
code::
#+BEGIN_SRC sclang
(
SystemClock.sched(2.0,{
	"2.0 seconds later".postln;
	nil;
});
)
#+END_SRC

::

method::clear
Clear the SystemClock's scheduler to stop it.
code::
#+BEGIN_SRC sclang
SystemClock.clear;
#+END_SRC

::

method::schedAbs
code::
#+BEGIN_SRC sclang
(
SystemClock.schedAbs( (thisThread.seconds + 4.0).round(1.0),{ arg time;
	("the time is exactly " ++ time.asString
		++ " seconds since starting SuperCollider").postln;
});
)
#+END_SRC

::

method::play
Calls to the cocoa framework (including all GUI) may not be made directly from actions triggered by SystemClock or incoming socket messages (OSCFunc).

To get around this, use code::{ }.defer ::. This will execute the function using the AppClock and is equivalent to code::AppClock.sched(0, function)::

code::
#+BEGIN_SRC sclang
(
var w, r;
w = Window.new("trem", Rect(512, 256, 360, 130));
w.front;
r = Routine({ arg time;
	60.do({ arg i;
		0.05.yield;
		{
			w.bounds = w.bounds.moveBy(10.rand2, 10.rand2);
			w.alpha = cos(i*0.1pi)*0.5+0.5;
		}.defer;
	});
	1.yield;
	w.close;
});
SystemClock.play(r);
)
#+END_SRC

::
This example is only to show how to make calls to Cocoa/GUI when scheduling with the SystemClock. If you only wish to control the GUI, use AppClock.
** class:: T2A
summary:: Control rate trigger to audio rate trigger converter
categories:: UGens>Conversion, UGens>Triggers
related:: Classes/T2K, Classes/K2A, Classes/A2K

description::
Converts control rate trigger into audio rate trigger (maximally one per control period).

classmethods::
method:: ar

argument:: in
input signal.
argument:: offset
sample offset within control period.

examples::
code::
#+BEGIN_SRC sclang
// example
(
{
	var trig = Impulse.kr(MouseX.kr(1, 100, 1));
	Ringz.ar(T2A.ar(trig), 800, 0.01) * 0.4
}.play;
)

// compare with K2A
(
{
	var trig = Impulse.kr(200);
	[T2A.ar(trig), K2A.ar(trig)].lag(0.001)
}.plot2(10/200);
)

// removing jitter by randomising offset
(
{
	var trig = Impulse.kr(MouseX.kr(1, 100, 1));
	Ringz.ar(T2A.ar(trig, WhiteNoise.kr.range(0, s.options.blockSize - 1)), 800, 0.01) * 0.4
}.play;
)
#+END_SRC

::
** class:: T2K
summary:: Audio rate trigger to control rate trigger converter
categories:: UGens>Conversion, UGens>Triggers
related:: Classes/T2A, Classes/K2A, Classes/A2K

description::
Converts audio rate trigger into control rate trigger, using the maxiumum trigger in the input during each control period.

classmethods::
method:: kr

argument:: in
input signal.

examples::
code::
#+BEGIN_SRC sclang
// this does not work:
(
{
	var trig = Dust.ar(4);
	Trig.kr(trig, 0.1) * SinOsc.ar(800) * 0.1
}.play;
)

// this works:
(
{
	var trig = T2K.kr(Dust.ar(4));
	Trig.kr(trig, 0.1) * SinOsc.ar(800) * 0.1
}.play;
)
#+END_SRC

::
** class:: TBall
summary:: physical model of bouncing object
categories:: UGens>Filters>Nonlinear, UGens>Generators>PhysicalModels
related:: Classes/Ball, Classes/Spring

description::
models the impacts of a bouncing object that is reflected by a vibrating surface

classmethods::

method:: ar, kr

argument::in
modulated surface level

argument::g
gravity

argument::damp
damping on impact

argument::friction
proximity from which on attraction to surface starts

examples::
code::
#+BEGIN_SRC sclang
// mouse x controls switch of level
// mouse y controls gravity
(
{
	var t, sf;
	sf = K2A.ar(MouseX.kr > 0.5) > 0;
	t = TBall.ar(sf, MouseY.kr(0.01, 1.0, 1), 0.01);
	Pan2.ar(Ringz.ar(t * 10, 1200, 0.1), MouseX.kr(-1,1));
}.play;
)


// mouse x controls step noise modulation rate
// mouse y controls gravity
(
{
	var t, sf, g;
	sf = LFNoise0.ar(MouseX.kr(0.5, 100, 1));
	g = MouseY.kr(0.01, 10, 1);
	t = TBall.ar(sf, g, 0.01, 0.002);
	Ringz.ar(t * 4, [600, 645], 0.3);
}.play;
)

// mouse x controls sine modulation rate
// mouse y controls friction
// gravity changes slowly
(
{
	var f, g, h, fr;
	fr = MouseX.kr(1, 1000, 1);
	h = MouseY.kr(0.0001, 0.001, 1);
	g = LFNoise1.kr(0.1, 3, 5);
	f = TBall.ar(SinOsc.ar(fr), g, 0.1, h);
	Pan2.ar(Ringz.ar(f, 1400, 0.04),0,5)
}.play;
)

// sine frequency rate is modulated with a slow sine
// mouse y controls friction
// mouse x controls gravity
(
{
	var f, g, h, fr;
	fr = LinExp.kr(SinOsc.kr(0.1), -1, 1, 1, 600);
	h = MouseY.kr(0.0001, 0.001, 1);
	g = MouseX.kr(1, 10);
	f = TBall.ar(SinOsc.ar(fr), g, 0.1, h);
	Pan2.ar(Ringz.ar(f, 1400, 0.04),0,5)
}.play;
)

// this is no mbira: vibrations of a bank of resonators that are
// triggered by some bouncing things that bounce one on each resonator

// mouse y controls friction
// mouse x controls gravity
(
	{
	var sc, g, d, z, lfo, rate;
	g = MouseX.kr(0.01, 100, 1);
	d = MouseY.kr(0.00001, 0.2);
	sc = #[451, 495.5, 595, 676, 734.5]; //azande harp tuning by B. Guinahui
	lfo = LFNoise1.kr(1, 0.005, 1);
	rate = 2.4;
	rate = rate * sc.size.reciprocal;
	z = sc.collect { |u,i|
		var f, in;
		in = Decay.ar(
				Mix(Impulse.ar(rate, [1.0, LFNoise0.kr(rate / 12)].rand, 0.1)), 					0.001
			);
		in = Ringz.ar(in,
					Array.fill(4, { |i| (i+1) + 0.1.rand2 }) / 2
					* Decay.ar(in,0.02,rand(0.5,1), lfo)						* u,
					Array.exprand(4, 0.2, 1).sort
					);
		in = Mix(in);
		f = TBall.ar(in * 10, g, d, 0.001);

		in + Mix(Ringz.ar(f, u * Array.fill(4, { |i| (i+1) + 0.3.rand2 }) * 2, 0.1))
	};
	Splay.ar(z) * 0.8
	}.play;
)
#+END_SRC

::

** class:: TChoose
summary:: Randomly select one of several inputs
categories:: UGens>Triggers, UGens>Random
related:: Classes/TWChoose

description::
An output is selected randomly on recieving a trigger from an array of inputs.

TChoose returns a combination of link::Classes/Select:: and link::Classes/TIRand::.

classmethods::
method:: ar, kr

argument:: trig
argument:: array

examples::
code::
#+BEGIN_SRC sclang
(
{
	var a;
	a = [
			SinOsc.ar,
			Saw.ar,
			Pulse.ar
		];
	TChoose.ar(Dust.ar(MouseX.kr(1, 1000, 1)), a) * 0.2

}.play;
)
#+END_SRC

::

note:: all the ugens are continously running. This may not be the most efficient way if each input is  cpu-expensive.::
** class:: TDelay
summary:: Trigger delay.
categories::  UGens>Triggers, UGens>Delays


Description::

Delays a trigger by a given time. Any triggers which arrive in the time
between an input trigger and its delayed output, are ignored.


classmethods::

method::ar, kr

argument::in

Input trigger signal.


argument::dur

Delay time in seconds.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	z = Impulse.ar(2);
	[z * 0.1, ToggleFF.ar(TDelay.ar(z, 0.5)) * SinOsc.ar(mul: 0.1)]
}.scope)
#+END_SRC

::
** class:: TDuty
summary:: Demand results as trigger from demand rate UGens.
related:: Classes/Demand, Classes/Duty
categories::  UGens>Demand


Description::

A value is demanded each UGen in the list and output as a trigger
according to a stream of duration values. The unit generators in the list
should be 'demand' rate.


When there is a trigger at the reset input, the demand rate UGens in the
list and the duration are reset. The reset input may also be a demand
UGen, providing a stream of reset times.


classmethods::

method::ar, kr

argument::dur

Time values. Can be a demand UGen or any signal. The next trigger
value is acquired after duration.


argument::reset

Trigger or reset time values. Resets the list of UGens and the
duration UGen when triggered. The reset input may also be a
demand UGen, providing a stream of reset times.


argument::level

Demand UGen providing the output values.


argument::doneAction

A doneAction that is evaluated when the duration stream ends. See

link::Reference/UGen-doneActions::  for more detail.


argument::gapFirst
when 0 (default), the UGen does the first level poll immediately and then waits for the first durational value. When this is 1, the UGen initially polls the first durational value, waits for that duration, and then polls the first level (along with polling the next durational value). So gapFirst > 0 makes TDuty behave like link::Classes/TDuty_old::.

Examples::

code::
#+BEGIN_SRC sclang

// examples

s.boot;


// play a little rhythm

{ TDuty.ar(Dseq([0.1, 0.2, 0.4, 0.3], inf)) }.play; // demand ugen as durations



// amplitude changes
(
	{
		var trig;
		trig = TDuty.ar(
				Dseq([0.1, 0.2, 0.4, 0.3], inf), // demand ugen as durations
				0,
				Dseq([0.1, 0.4, 0.01, 0.5, 1.0], inf) // demand ugen as amplitude
			);
		Ringz.ar(trig, 1000, 0.1)

	}.play;
)

(
	{
		var trig;
		trig = TDuty.ar(
				MouseX.kr(0.001, 2, 1), // control rate ugen as durations
				0,
				Dseq([0.1, 0.4, 0.01, 0.5, 1.0], inf)
			);
		Ringz.ar(trig, 1000, 0.1)

	}.play;
)




// demand ugen as audio oscillator

(
	{
		var a, trig, n=5, m=64;
		a = {
			var x;
			x = { 0.2.rand2 } ! m;
			x = x ++ ({  Drand({ 0.2.rand2 } ! n) } ! m.rand);
			Dseq(x.scramble, inf)
		} ! n;
		trig = TDuty.ar(
				MouseX.kr(1, 2048, 1) * SampleDur.ir * [1, 1.02],
				0,
				Dswitch1(a, MouseY.kr(0, n-1))
			);
		Ringz.ar(trig, 1000, 0.01)

	}.play;
)


// single impulses

(
SynthDef("delta_demand", { arg amp=0.5, out;
	OffsetOut.ar(out,
		TDuty.ar(Dseq([0]), 0, amp, 2)
	)
}).send(s);
)

fork { 10.do { s.sendBundle(0.2, ["/s_new", "delta_demand", -1]); 1.0.rand.wait } };


// chain of impulses
(
SynthDef("delta_demand2", {
	OffsetOut.ar(0,
		TDuty.ar(Dgeom(0.05, 0.9, 20), 0, 0.5, 2)
	)
}).send(s);
)

fork { 10.do { s.sendBundle(0.2, ["/s_new", "delta_demand2", -1]); 1.0.rand.wait } };



// multichannel expansion

(
	{
		var t;
		t = TDuty.ar(
				Drand([Dgeom(0.1, 0.8, 20), 1, 2], inf) ! 2,
				0,
				[Drand({ 1.0.rand } ! 8, inf), Dseq({ 1.0.rand } ! 8, inf)] * 2
			);
		x = Ringz.ar(t, [400, 700], 0.1) * 0.1;

	}.play;
)
#+END_SRC

::

** class:: TDuty_old
summary:: Deprecated ugen
related:: Classes/TDuty
categories:: UGens>Deprecated

description::
This class is deprecated, use link::Classes/TDuty:: instead.

** class:: TExpRand
summary:: Triggered exponential random number generator.
related:: Classes/ExpRand, Classes/IRand, Classes/LinRand, Classes/NRand, Classes/Rand, Classes/TIRand, Classes/TRand
categories:: UGens>Random, UGens>Triggers


Description::

Generates a random float value in exponential distribution from
code::lo::  to  code::hi::  each time the
trigger signal changes from nonpositive to positive values
code::lo::  and  code::hi::  must both have
the same sign and be non-zero.


classmethods::

method::ar, kr

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

argument::trig

The trigger. Trigger can be any signal. A trigger happens when
the signal changes from non-positive to positive.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	var trig = Dust.kr(10);
	SinOsc.ar(
			TExpRand.kr(300.0, 3000.0, trig)
		) * 0.1
}.play;
)

(
{
	var trig = Dust.ar(MouseX.kr(1, 8000, 1));
	SinOsc.ar(
			TExpRand.ar(300.0, 3000.0, trig)
		) * 0.1
}.play;
)
#+END_SRC

::

** class:: TGrains
summary:: Buffer granulator.
categories::  UGens>Buffer, UGens>Generators>Granular

Description::
Triggers generate grains from a buffer. Each grain has a Hanning envelope
code::
#+BEGIN_SRC sclang
(sin2(x) for x from 0 to π)
#+END_SRC

::
and is panned between two channels of multiple outputs.

classmethods::

method::ar

argument::numChannels
Number of output channels.

argument::trigger
At each trigger, the following arguments are sampled and used as
the arguments of a new grain. A trigger occurs when a signal
changes from non-positive to positive value.

If the trigger is audio rate then the grains will start with
sample accuracy.

argument::bufnum
The index of the buffer to use. It must be a one channel (mono)
buffer.

argument::rate
1.0 is normal, 2.0 is one octave up, 0.5 is one octave down -1.0
is backwards normal rate… etc.

argument::centerPos
The position in the buffer in seconds at which the grain envelope
will reach maximum amplitude.

argument::dur
Duration of the grain in seconds.

argument::pan
A value from -1 to 1. Determines where to pan the output in the
same manner as
link::Classes/PanAz:: .

argument::amp
Amplitude of the grain.

argument::interp
1, 2, or 4. Determines whether the grain uses (1) no
interpolation, (2) linear interpolation, or (4) cubic
interpolation.


Examples::

code::
#+BEGIN_SRC sclang

s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

(
{
	var trate, dur, rate;
	trate = MouseY.kr(2,200,1);
	dur = 4 / trate;
	rate = Dseq([10, 1, 1, 0.5, 0.5, 0.2, 0.1], inf);
	TGrains.ar(2, Impulse.ar(trate), b, rate, MouseX.kr(0,BufDur.kr(b)), dur, Dseq([-1, 1], inf), 0.1, 2);
}.scope(zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(8,120,1);
	dur = 12 / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(zoom: 4);
)

// 4 channels
(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(8,120,1);
	dur = 12 / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(4, clk, b, 1, pos, dur, pan, 0.1);
}.scope(4, zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(8,120,1);
	dur = 4 / trate;
	clk = Dust.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(zoom: 4);
)



(
{
	var trate, dur, clk, pos, pan;
	trate = LinExp.kr(LFTri.kr(MouseY.kr(0.1,2,1)),-1,1,8,120);
	dur = 12 / trate;
	clk = Impulse.ar(trate);
	pos = MouseX.kr(0,BufDur.kr(b));
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(zoom: 4);
)


(
{
	var trate, dur, clk, pos, pan;
	trate = 12;
	dur = MouseY.kr(0.2,24,1) / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = 100;
	dur = 8 / trate;
	clk = Impulse.kr(trate);
	pos = Integrator.kr(BrownNoise.kr(0.001));
	pan = WhiteNoise.kr(0.6);
	TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
}.scope(zoom: 4);
)

(
{
	var trate, dur, clk, pos, pan;
	trate = MouseY.kr(1,400,1);
	dur = 8 / trate;
	clk = Impulse.kr(trate);
	pos = MouseX.kr(0,BufDur.kr(b));
	pan = WhiteNoise.kr(0.8);
	TGrains.ar(2, clk, b, 2 ** WhiteNoise.kr(2), pos, dur, pan, 0.1);
}.scope(zoom: 4);
)


(
{
	var trate, dur;
	trate = MouseY.kr(2,120,1);
	dur = 1.2 / trate;
	TGrains.ar(2, Impulse.ar(trate), b, (1.2 ** WhiteNoise.kr(3).round(1)), MouseX.kr(0,BufDur.kr(b)), dur, WhiteNoise.kr(0.6), 0.1);
}.scope(zoom: 4);
)


// demand ugens as inputs
(
{
	var trate, dur, z, d;
	trate = MouseX.kr(1, 100, 1);
	d = { Dwhite(0.1, 0.2, 1) };
	z = {
		Drand([Dgeom(0.1, 1 + d.value, Diwhite(20, 40)), Dgeom(1, 1 - d.value, Diwhite(20, 40))])
	};
	TGrains.ar(2,
		Impulse.ar(trate),
		bufnum: 10,
		rate: Dseq([1, 1, z.value, 0.5, 0.5, 0.2, 0.1, 0.1, 0.1, 0.1], inf) * 2 + 1,
		centerPos: Dseq(z.dup(8), inf),
		dur: Dseq([1, d.value, 1, z.value, 0.5, 0.5, 0.1, z.value] * 2, inf) / trate,
		pan: Dseq([1, 1, 1, 0.5, 0.2, 0.1, 0, 0, 0], inf) * 2 - 1,
		amp: Dseq([1, 0, z.value, 0, 2, 1.0, 1, 0.1, 0.1], inf)
	);
}.scope(zoom: 4);
)

b.free
#+END_SRC

::
** class:: TIRand
summary:: Triggered integer random number generator.
related:: Classes/ExpRand, Classes/IRand, Classes/LinRand, Classes/NRand, Classes/Rand, Classes/TExpRand, Classes/TRand, Classes/TChoose
categories:: UGens>Random, UGens>Triggers


Description::

Generates a random integer value in uniform distribution from
code::lo::  to  code::hi::  each time the
trigger signal changes from nonpositive to positive values.


classmethods::

method::ar, kr

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

argument::trig

The trigger. Trigger can be any signal. A trigger happens when
the signal changes from non-positive to positive.


Examples::

code::
#+BEGIN_SRC sclang

(
SynthDef("help-TIRand", {
	var trig, outBus;
	trig = Dust.kr(10);
	outBus = TIRand.kr(0, 1, trig); //play on random channel between 0 and 1
	Out.ar(outBus, PinkNoise.ar(0.2))

}).play;
)

(
{
	var trig = Dust.kr(10);
	SinOsc.ar(
			TIRand.kr(4, 12, trig) * 100
		) * 0.1
}.play;
)

(
{
	var trig = Dust.ar(MouseX.kr(1, 8000, 1));
	SinOsc.ar(
			TIRand.ar(4, 12, trig) * 100
		) * 0.1
}.play;
)
#+END_SRC

::

** class:: TRand
summary:: Triggered random number generator.
related:: Classes/ExpRand, Classes/IRand, Classes/LinRand, Classes/NRand, Classes/Rand, Classes/TExpRand, Classes/TIRand
categories:: UGens>Random, UGens>Triggers


Description::

Generates a random float value in uniform distribution from
code::lo::  to  code::hi::  each time the
trigger signal changes from nonpositive to positive values.


classmethods::

method::ar, kr

argument::lo
Lower limit of the output range.

argument::hi
Upper limit of the output range.

argument::trig

The trigger. Trigger can be any signal. A trigger happens when
the signal changes from non-positive to positive.


Examples::

code::
#+BEGIN_SRC sclang

(
{
	var trig = Dust.kr(10);
	SinOsc.ar(
			TRand.kr(300, 3000, trig)
		) * 0.1
}.play;
)

(
{
	var trig = Dust.ar(MouseX.kr(1, 8000, 1));
	SinOsc.ar(
			TRand.ar(300, 3000, trig)
		) * 0.1
}.play;
)
#+END_SRC

::

** class:: TWChoose
summary:: Randomly select one of several inputs
categories:: UGens>Triggers, UGens>Random
related:: Classes/TChoose

description::
An output is selected randomly on recieving a trigger from an array of inputs.

the code::weights:: of this choice are determined from the weights array.

If code::normalize:: is set to 1 the weights are continuously normalized (this is an extra overhead) when using fixed values the code::normalizeSum:: method can be used to normalize the values.

TWChoose is a composite of link::Classes/TWindex:: and link::Classes/Select::.

classmethods::
method:: ar, kr

argument:: trig
argument:: array
argument:: weights
argument:: normalize

examples::
code::
#+BEGIN_SRC sclang
(
{
	var a;
	a = [
			SinOsc.ar,
			Saw.ar,
			Pulse.ar
		];
	TWChoose.ar(Dust.ar(MouseX.kr(1, 1000, 1)), a, [0.99, 0.05, 0.05].normalizeSum) * 0.2

}.play;
)
#+END_SRC

::

note:: all the ugens are continously running. This may not be the most efficient way if each input is  cpu-expensive.::
** class:: TWindex
summary:: Triggered windex.
categories:: UGens>Random, UGens>Triggers


Description::

When triggered, returns a random index value based on array as a list of
probabilities. By default the list of probabilities should sum to 1.0,
when the normalize flag is set to 1, the values get normalized
by the UGen (less efficient).


classmethods::

method::ar, kr

argument::in

The trigger. Trigger can be any signal. A trigger happens when
the signal changes from non-positive to positive.


argument::array
The list of probabilities.

argument::normalize
Controls whether to normalize the probability values.

Examples::

code::
#+BEGIN_SRC sclang

//assuming normalized values
(

a = SynthDef("help-TWindex",{ arg w1=0.0, w2=0.5, w3=0.5;

	var trig, index;
	trig = Impulse.kr(6);
	index = TWindex.kr(trig, [w1, w2, w3]);

	Out.ar(0,
		SinOsc.ar(
			Select.kr(index,[400, 500, 600]),
			0, 0.2
		)
	)
}).play;

)

a.setn(0, [0,0,1].normalizeSum);
a.setn(0, [1,1,1].normalizeSum);
a.setn(0, [1,0,1].normalizeSum);


//modulating probability values
(

a = SynthDef("help-TWindex",{ arg w1=0.0, w2=0.5;

	var trig, index;
	trig = Impulse.kr(6);
	index = TWindex.kr(
					trig,
					[w1, w2, SinOsc.kr(0.3, 0, 0.5, 0.5)],//modulate probability
					1 //do normalisation
		);

	Out.ar(0,
		SinOsc.ar(
			Select.kr(index,[400, 500, 600]),
			0, 0.2
		)
	)
}).play;

)

a.setn(0, [0,0]);
a.setn(0, [1,1]);
a.setn(0, [1,0]);
a.setn(0, [0,1]);
#+END_SRC

::
** class:: TabFileReader
summary:: file reader for tab separated data
related:: Classes/File
categories:: Files

description::
TabFileReader reads tab/return delimited files into 2D arrays.

For semi-colon-delimited files use link::Classes/SemiColonFileReader::. For comma-separated files use link::Classes/CSVFileReader::. For space-delimited files, or custom delimiters, use link::Classes/FileReader::.

Examples::

code::
#+BEGIN_SRC sclang
(
// write a test file:
f = File("TabDelTest.sc", "w");
f.write(
"Some	tab-	delimited	items	in	line	1

and	then	some	more	in	line	3
"
);
f.close;
)


	// open file, read and put strings into array, close file.
x = TabFileReader.read("TabDelTest.sc").postcs;

	// can skip empty lines:
x = TabFileReader.read("TabDelTest.sc", true).postcs;

	// do file open/close by hand if you prefer:
f = File("TabDelTest.sc", "r"); f.isOpen;
t = TabFileReader(f);
t.read;
f.close;

(
// write a test file with numbers:
f = File("TabDelTestNum.sc", "w");

(1..10).do { |n| f.write(n.asString ++ Char.tab); };
f.close;
)

x = TabFileReader.read("TabDelTestNum.sc").postcs;
x.collect(_.collect(_.interpret));	// convert to numbers.

	// or you can do it immediately:
x = TabFileReader.readInterpret("TabDelTestNum.sc").postcs;

(
// write a test file with numbers:
f = File("TabDelTestNum.sc", "w");

(1..100).do { |n|
	f.write(n.asString ++ if (n % 10 != 0, Char.tab, Char.nl)); };
f.close;
)


x = TabFileReader.readInterpret("TabDelTestNum.sc").postln;
#+END_SRC

::
** CLASS:: TabletSlider2D
redirect:: implClass
summary:: An extended Slider2D responding to Wacom tablet
categories:: GUI>Views
related:: Classes/TabletView

DESCRIPTION::

TabletSlider2D inherits most of its functionality from link::Classes/Slider2D::. Aside from that it receives extended wacom tablet data.

note:: TabletSlider2D is only available in Cocoa GUI ::

strong::Drag-and-drop:: returns and accepts a Point, describing the current x and y value.

All the strong::mouse actions:: ( link::Classes/Slider2D#-action#action::, link::Classes/View#-mouseDownAction#mouseDownAction::, and link::Classes/View#-mouseUpAction#mouseUpAction:: ) receive the following arguments:

table::

## view || the view

## x || subpixel location in view

## y || subpixel location in view

## pressure || 0..1

## tiltX || 0 (max. left) ... 1 (max. right)

## tiltY || 0 (max. down) ... 1 (max. up)

## deviceID || All tablet-pointer events generated in the period between the device entering and leaving tablet proximity have the same device ID. Therefore, when working with multiple tablets / mice, you can match actions by looking at the deviceID.

## buttonNumber || 0 left, 1 right, 2 middle wheel click.

## clickCount || double click, triple click ... most relevant for the mouseDown, but still valid for the dragged and mouseUp

## absoluteZ || the wheel on the side of some mice

## rotation || in degrees. Used for example on the "4d mouse", and the "art marker". Note: on Mac OS X 10.4.11 using an Intuos3 tablet with Art Marker, the returned value must be multiplied by 1024 to actually obtain degrees (bug?).

::

CLASSMETHODS::
PRIVATE:: key

EXAMPLES::

SUBSECTION:: Basic use

code::
#+BEGIN_SRC sclang
(
var window;
var slider;

window = Window("2DSlider", Rect(100,100, 140 ,140));
window.front;

slider = TabletSlider2D(window, Rect(20, 20,80, 80))
    .x_(0.5).y_(1);
slider.mouseDownAction = { arg view,x,y,pressure,tiltx,tilty,deviceID, buttonNumber,clickCount;
    ["down",view,x,y,pressure,tiltx,tilty,deviceID, buttonNumber,clickCount].postln;
};
slider.action = { arg view,x,y,pressure,tiltx,tilty,deviceID, buttonNumber,clickCount;
    [view,x,y,pressure,tiltx,tilty,deviceID, buttonNumber,clickCount].postln;
};
slider.mouseUpAction = { arg view,x,y,pressure,tiltx,tilty,deviceID, buttonNumber,clickCount;
    ["up",view,x,y,pressure,tiltx,tilty,deviceID, buttonNumber,clickCount].postln;
};
slider.setProperty(\clipInBounds,0)
)
#+END_SRC

::

SUBSECTION:: Drag and drop Points

code::
#+BEGIN_SRC sclang
(
w = Window("TabletSlider2D", Rect(100,100, 500 ,300));
w.view.decorator = FlowLayout(w.view.bounds);

t = TabletSlider2D(w, Rect(20, 20,280, 280))
        .x_(0.5)    // initial location of x
        .y_(1)  // initial location of y
        .knobColor_(Color.rand)
        .action_({|sl|
            [\sliderX, sl.x, \sliderY, sl.y].postln;
        });
t.step_(0.01);

n = CompositeView.new(w, 200@300);
n.decorator = FlowLayout(n.bounds);

v = { |i| DragBoth(n, Rect(0, i * 20, 200, 20)).align_(\center).background_(Color.rand) }.dup(5);
StaticText.new(n,200@150).string_("hold down cmd and drag points from the slider to the drag slots, or reverse").stringColor_(Color.white);

w.front;
)
#+END_SRC

::

SUBSECTION:: A sound example

code::
#+BEGIN_SRC sclang
(
s.waitForBoot({

    var w, v,int,synth;

    synth=SynthDef("help-TabletSlider2D",{ arg freq=440,int1=5,int2 = -5,
                ffreqInterval=0,rq=0.4,gate=0.0;
        var p,c,d,f;
        c=LFNoise1.kr(0.1,0.45,0.55);
        d=LFNoise1.kr(0.1,0.45,0.55);
        f=LFNoise1.kr(0.1,2);
        p=Pulse.ar([ freq * int1.midiratio + f , freq, freq * int2.midiratio - f],
                [c,d,c],0.2);
        Out.ar(0,
            RLPF.ar(Mix.ar(p),freq * ffreqInterval.midiratio,rq)
                * EnvGen.kr(Env.adsr, gate, gate)
        )
    },[0.1,0.1,0.1,0.1,0.1,nil]).play(s);

    w = Window.new.front;

    int = ControlSpec(-48,48,\linear,1);

    v = TabletSlider2D(w,Rect(10,10,380,380));
    v.background = Color.blue.alpha_(0.2);
    v.knobColor = Color.red;
    v.action = { arg view,x,y,pressure,tiltx,tilty;
        synth.set(
                \int1, int.map(x),
                \int2, int.map(y),
                \ffreqInterval, int.map(pressure),
                \gate, pressure.postln
            );
    };

    v.mouseDownAction = { arg view,x,y,pressure;
        synth.set(
                \freq , rrand(30,80).midicps,
                \gate, pressure.postln
            )
    };
    v.mouseUpAction = { arg view,x,y,pressure;
        synth.set( \gate, 0.postln )
    };
});
)
#+END_SRC

::
** CLASS:: TabletView
redirect:: implClass
summary:: A view responding to Wacom tablet
categories:: GUI>Views
related:: Classes/TabletSlider2D

DESCRIPTION::

An otherwise featureless view that receives extended wacom tablet data. It can also be used with a normal mouse but with less resolution.

note::
TabletView is not implemented in Qt GUI, and is only available in other GUI kits on Mac OS X.

To use it in SwingOSC, install the JNI library:

code:: $ cp JNITablet/build/libJNITablet.jnilib /Library/Java/Extensions/ ::

or make a symbolic link:

code:: $ ln -s <absolutePathToSwingOSC>/JNITablet/build/libJNITablet.jnilib /Library/Java/Extensions/ ::
::

strong::Drag-and-drop:: returns and accepts a Point, describing the current x and y value.

The default link::Classes/View#-action#action:: is triggered when dragging the mouse inside the view.

All the strong::mouse actions:: ( link::Classes/View#-action#action::, link::Classes/View#-mouseDownAction#mouseDownAction::, and link::Classes/View#-mouseUpAction#mouseUpAction:: ) receive the following arguments:

table::

## view || the view

## x || subpixel location in view

## y || subpixel location in view

## pressure || 0..1

## tiltX || -1 (max. left) ... +1 (max. right)

## tiltY || -1 (max. down) ... +1 (max. up)

## deviceID || All tablet-pointer events generated in the period between the device entering and leaving tablet proximity have the same device ID. Therefore, when working with multiple tablets / mice, you can match actions by looking at the deviceID.

## buttonNumber || 0 left, 1 right, 2 middle wheel click. see also buttonMask below.

## clickCount || double click, triple click ... most relevant for the mouseDown, but still valid for the dragged and mouseUp

## absoluteZ || the wheel on the side of some mice

## rotation || in degrees. Used for example on the "4d mouse", and the "art marker". Note: on Mac OS X 10.4.11 using an Intuos3 tablet with Art Marker, the returned value must be multiplied by 1024 to actually obtain degrees (bug?).

::

These additional arguments are only delivered in SwingOSC:

table::

## absoluteX || the absolute horizontal pen position on tablet (in tablet-native high-resolution)

## absoluteY || the absolute vertical pen position on tablet (in tablet-native high-resolution)

## buttonMask || a flag mask of all buttons on the pen / tablet. you can extract each button's state using a bitAnd: buttonMask.bitAnd( 1 << n ) where n = 0, 1, 2, ...

## tanPressure || Tangential pressure is also known as barrel pressure.

::

note::
If using a mouse (even a wacom) rather than a pen, the x and y will be integer pixel values, rather than subpixel floats.  Wacom stylus devices have higher resolution than the screen.  Pressure will be 1 for mouse down, 0 for mouse up.
::

CLASSMETHODS::

PRIVATE:: key

INSTANCEMETHODS::

METHOD:: proximityAction
    note:: Only in SwingOSC GUI ::

    The action will be called with the following arguments:

table::

## view || true to indicate that a pointing device is entering the proximity of its tablet and false when it is leaving it.

## entering || true to indicate that a pointing device is entering the proximity of its tablet and false when it is leaving it.

## deviceID || All tablet-pointer events generated in the period between the device entering and leaving tablet proximity have the same device ID. Therefore, when working with multiple tablets / mice, you can match actions by looking at the deviceID.

## pointingDeviceTypes ||
0 NSUnknownPointingDevice
1 NSPenPointingDevice
2 NSCursorPointingDevice
3 NSEraserPointingDevice

## systemTabletID || If multiple tablets are connected to the system, the system-tablet ID is incremented for each subsequent one. If there is only one tablet device, its system-tablet ID is zero.

## pointingDeviceID || This index is significant for multimode (or Dual Tracking) tablets that support multiple concurrent pointing devices; the index is incremented for each pointing device that comes into proximity. Otherwise, zero is always returned.

## tabletID || Returns the USB model identifier of the tablet device associated with the receiver.

## uniqueID || Also known as tool ID, this is a unique number recorded in the chip inside every pointing device. The unique ID makes it possible to assign a specific pointing device to a specific tablet.
::




EXAMPLES::

SUBSECTION:: Basic use

code::
#+BEGIN_SRC sclang
(
w = Window.new;
t = TabletView(w,Rect(40,40,300,300));
t.background = Color.white;
w.acceptsMouseOver = true;
w.front;

f = { arg what, x, y, pressure, tiltx, tilty, deviceID, buttonNumber, clickCount,
    absoluteZ, rotation, absoluteX, absoluteY, buttonMask, tanPressure;
    ("%: x %  y %  press %  tiltx %  tilty %  clicks %  absX %  absY %  absZ %  rota %  mask %\n")
    .postf(
        what, x.round( 0.01 ), y.round( 0.01 ), pressure.round( 0.01 ),
        tiltx.round( 0.01 ), tilty.round( 0.01 ), clickCount, absoluteX, absoluteY, absoluteZ,
        rotation.round( 0.01 ), buttonMask
    );
};

t.mouseDownAction   = { arg view ... params; f.value( "down", *params )};
t.action            = { arg view ... params; f.value( "drag", *params )};
t.mouseUpAction     = { arg view ... params; f.value( "up  ", *params )};
t.mouseOverAction   = { arg view ... params; f.value( "over", *params )};
)
#+END_SRC

::

SUBSECTION:: A sound example

code::
#+BEGIN_SRC sclang
s.boot

(
SynthDef("help-2DTabletSlider", {
    arg freq = 440, int1 = 5, int2 = -5, ffreqInterval = 0, rq = 0.4, gate = 0.0;
    var p,c,d,f;
    c=LFNoise1.kr(0.1,0.45,0.55);
    d=LFNoise1.kr(0.1,0.45,0.55);
    f=LFNoise1.kr(0.1,2);
    p=Pulse.ar([ freq * int1.midiratio + f , freq, freq * int2.midiratio - f],
        [c,d,c], 0.2);
    Out.ar(0,
        RLPF.ar(Mix.ar(p),freq * ffreqInterval.midiratio,rq)
            * EnvGen.kr(Env.adsr, gate, gate)
    )
},[0.1,0.1,0.1,0.1,0.1,nil]).send(s);
)

(
var w, v,freq,int,synth;
synth = Synth("help-2DTabletSlider");
w = Window.new.front;

freq = ControlSpec(100,3000,\exp);
int = ControlSpec(-48,48,\linear,1);

v = TabletView(w,Rect(10,10,380,380));
v.background = Color.blue.alpha_(0.2);
v.action = { arg view,x,y,pressure,tiltx,tilty;
    synth.set(
        \int1, int.map(x),
        \int2, int.map(y),
        \ffreqInterval, int.map(pressure),
        \gate, pressure.postln
    );
};

v.mouseDownAction = { arg view,x,y,pressure;
    synth.set(
        \freq , rrand(30,80).midicps,
        \gate, pressure.postln
    )
};
v.mouseUpAction = { arg view,x,y,pressure;
    synth.set( \gate, 0.postln )
};
)
#+END_SRC

::

SUBSECTION:: Detecting proximity

note:: Only in SwingOSC GUI ::

code::
#+BEGIN_SRC sclang
(
w = JSCWindow.new;
t = JSCTabletView(w,Rect(40,40,300,300));
t.background = Color.white;
w.acceptsMouseOver = true;
w.front;

t.proximityAction = { arg view, entering, deviceID, pointingDeviceType,
    systemTabletID, pointingDeviceID, tabletID, uniqueID;

    var what = if( entering, "enter", "exit " );
    ("%: deviceID %  pointingDeviceType %  systemTabletID % pointingDeviceID %  tabletID %  uniqueID %\n")
    .postf(
        what, deviceID, pointingDeviceType, systemTabletID,
        pointingDeviceID, tabletID, uniqueID
    );
};
)
#+END_SRC

::

SUBSECTION:: JSCTabletView is a also a user view

note:: Only in SwingOSC GUI ::

code::
#+BEGIN_SRC sclang
(
var x = 150, y = 150, pressure = 0, tiltx = 0, tilty = 0, rota = 0, colr = Color.white;

w = JSCWindow.new;
t = JSCTabletView( w,Rect( 40, 40, 300, 300 ));
t.background = Color.white;
w.front;

f = { arg view, argX, argY, argPressure, argTiltX, argTiltY, deviceID, buttonNumber,
            clickCount, absZ, argRota;
    x = argX; y = argY; pressure = argPressure;
    tiltx = argTiltX; tilty = argTiltY;
    rota    = argRota * 1024; // * 1024 for Art Marker...
    view.refresh;
};
t.drawFunc = { arg view;
    JPen.fillColor = colr;
    JPen.fillRect( view.bounds.moveTo( 0, 0 ));
    JPen.translate( x, y );
    JPen.width = pressure * 10 + 0.5;
    JPen.rotate( rota * pi / 180 );
    JPen.skew( tiltx, tilty );
    JPen.strokeOval( Rect( -100, -100, 200, 200 ));
    JPen.line( -100 @ 0, 100 @ 0 );
    JPen.line( 0 @ -100, 0 @ 100 );
    JPen.stroke;
};

t.mouseDownAction = f;
t.action = f;
t.mouseUpAction = f;
t.proximityAction = { arg view, entering, deviceID, pointingDeviceType;
    colr = if( entering, { Color.hsv( pointingDeviceType / 4, 0.5, 1.0 )}, Color.white );
    view.refresh;
};
)
#+END_SRC

::

Here's a variation: make the above example respond only to a particular pen tools. For this, you need a pen that fires proximity actions and you need to know the pen's uniqueID (see link::#-proximityAction::). For example, my Art Marker has ID 127926421:

code::
#+BEGIN_SRC sclang
(
var filterUniqueID = 127926421; // put your own ID here
var filterDeviceID = -1;
var fProx, fAction;
fProx = t.proximityAction;
t.proximityAction = { arg view, entering, deviceID, pointingDeviceType,
                        systemTabletID, pointingDeviceID, tabletID, uniqueID;
    if( uniqueID == filterUniqueID, {
        filterDeviceID = deviceID; // now t.action only reacts to events from this deviceID
        fProx.value( view, entering, deviceID, pointingDeviceType );
    });
};
fAction = t.action;
f = { arg view, x, y, pressure, tiltX, tiltY, deviceID, buttonNumber,
            clickCount, absZ, rota;
    if( deviceID == filterDeviceID, {
        fAction.value( view, x, y, pressure, tiltX, tiltY, deviceID, buttonNumber,
                clickCount, absZ, rota );
    });
};
t.mouseDownAction = f;
t.action = f;
t.mouseUpAction = f;
)
#+END_SRC

::

SUBSECTION:: An example using 'curcial' library

code::
#+BEGIN_SRC sclang
(
Instr([\minimoog,\loose],{ arg freq=440,int1=5,int2 = -5,
            ffreqInterval=0,rq=0.4,gate=0.0;
    var p,c,d,f;
    c=LFNoise1.kr(0.1,0.45,0.55);
    d=LFNoise1.kr(0.1,0.45,0.55);
    f=LFNoise1.kr(0.1,2);
    p=Pulse.ar([ freq * int1.midiratio + f , freq, freq * int2.midiratio - f],
            [c,d,c],0.2);

    RLPF.ar(Mix.ar(p),freq * ffreqInterval.midiratio,rq)
        * EnvGen.kr(Env.adsr, gate, Latch.kr(gate,gate))

},#[
    nil,
    [[-48,48,\linear,1]],
    [[-48,48,\linear,1]],
    [[-48,48,\linear,1]]
]);

p = Patch.new([ 'minimoog', 'loose' ],[
    nil,nil,nil,nil,nil,
    KrNumberEditor(0.0,\gate) // override the default control
]);

Sheet({ arg f;
    var v,freq,int;
    freq = ControlSpec(100,3000,\exp);
    int = [-48,48,\linear,1].asSpec;

    p.topGui(f);
    v = TabletView(f,Rect(0,0,200,200));
    v.background = Color.white;
    v.action = { arg view,x,y,pressure,tiltx,tilty;
        p.args.at(1).value_( int.map( x / 200 ) ).changed;
        p.args.at(2).value_( int.map( y / 200 ) ).changed;
        p.args.at(3).value_( int.map( pressure ) ).changed;
    };
    v.mouseDownAction = { arg view,x,y,pressure;
        p.args.at(0).value_( rrand(30,80).midicps ).changed;
        p.args.at(5).value_( pressure ).changed;
    };
    v.mouseUpAction = { arg view,x,y,pressure;
        p.args.at(5).value_( 0.0 ).changed;
    };
});

)
#+END_SRC

::
** class:: Tap
summary:: Single tap into a delayline
related:: Classes/MultiTap, Classes/PlayBuf
categories::  UGens>Buffer, UGens>Delays>Buffer

Description::

The Tap UGen allows a single tap at a delay into a buffer.

Tap uses the link::Classes/PlayBuf:: UGen internally

classmethods::
private:: categories

method::ar

argument::bufnum
The index of the buffer to use

argument::numChannels
Number of channels of the buffer

argument::delaytime
Tap delay; cannot be modulated

examples::
code::
#+BEGIN_SRC sclang
// Create a buffer.
b=Buffer.alloc(s, s.sampleRate, 1); //enough space for one second of mono audio

// Write to the Buffer with BufWr, read using two Taps, one for each ear!
(
SynthDef(\helpTap, {|bufnum|
	var source, capture;

	source= SoundIn.ar(0); //use headphones to avoid feedback
	capture= BufWr.ar(source, bufnum, Phasor.ar(0,1, 0, BufFrames.ir(bufnum),1));

	Out.ar(0, Tap.ar(bufnum, 1, [0.1,0.9])); //multichannel expansion, so one tap each ear
}).send(s);
)

x=Synth(\helpTap,[\bufnum, b]);

x.free;
#+END_SRC

::

** CLASS::Task
categories::Scheduling
summary::a pauseable process
related::Classes/Routine

DESCRIPTION::
Task is a pauseable process. It is implemented by wrapping a link::Classes/PauseStream:: around a link::Classes/Routine::. Most of its methods (start, stop, reset) are inherited from PauseStream.

Tasks are not 100% interchangeable with Routines.

list::
## Condition does not work properly inside of a Task.
## Stopping a task and restarting it quickly may yield surprising results (see example below), but this is necessary to prevent tasks from becoming unstable if they are started and/or stopped in rapid succession.
::

CLASSMETHODS::

method::new
argument::func
A Function to be evaluated.
argument::clock
A Clock in which to play the link::Classes/Routine::. If you do not provide a Clock the default is an instance of link::Classes/TempoClock::. Remember that methods which call Cocoa primitives (i.e. GUI functions) must be played in link::Classes/AppClock::.

INSTANCEMETHODS::

method::play
argument::argClock
(optional) Override the clock assigned in Task.new.
argument::doReset
If true, the task will start over from the beginning. Default is false (task will resume where it was when it was last stopped).
argument::quant
See the link::Classes/Quant:: helpfile.


subsection::Other control methods

method::start
Restart the task from the beginning.

method::resume
Resume the task where it left off.

method::pause
Stop playing now.

method::stop
Stop playing now. (Pause and stop have the same implementation.)

method::reset
Set the stream to restart from the beginning the next time it's played.

subsection::Notifications

Other objects might need to be aware of changes in the state of a task. The following notifications are broadcast to dependents registered with the Task object.

list::
## strong::\userPlayed:: - Sent at the time the user calls play, start or resume.
## strong::\playing:: - Sent at the time the task begins playing on the clock (corresponding to quant).
## strong::\userStopped:: - Sent at the time the user calls pause or stop.
## strong::\stopped:: - Sent at the time the task is finally removed from the clock (this is the time when the next event would have occurred if the task had not been stopped). If the task function completes on its own, this notification is sent without 'userStopped' being sent previously.
::

EXAMPLES::

subsection::What happens if you stop and start the task too quickly?
code::
#+BEGIN_SRC sclang
(
t = Task({
	50.do({ arg i;
		i.squared.postln;
		0.5.wait;
	});
});
)

t.start;
t.pause;
t.resume;
t.reset;
t.stop;

// unexpected behavior here
(
t = Task({
	["go", thisThread.clock.beats].postln;
	inf.do({ arg i;
		2.wait;
		[ "wake up", i ].postln;
	});
});

fork {
	t.start;
	0.1.wait;
	t.stop;
	0.1.wait;
	t.start;
	6.wait;
	t.stop;
};
)

[ go, 1702.114411906 ]
[ go, 1704.114411906 ]
#+END_SRC

::

Based on the forked thread, you would expect the second "go" line of output to occur 0.2 seconds after the first, but in fact it happens two seconds later (the same amount of time the task waits between iterations). This is because the task must not schedule itself on the clock more than once. When the task is stopped, it remains scheduled until it wakes up again (based on its wait time). If, during this interval, the task were restarted, there would be two references to the task in the scheduler queue -- a situation that is irrecoverable short of stopping everything with command-period.

As a result, Task should be used for processes that need to start and stop relatively infrequently, but for which maximum stability is required. If you need fine-grained control over when and how the process stops and resumes (as is the case, for instance, with condition), link::Classes/Routine:: is preferred.
** class:: TaskProxy
summary:: event stream reference
categories:: Libraries>JITLib>Patterns
related:: Classes/Tdef

description::
Keeps a reference to a task (time pattern) that can be replaced while playing. It plays on when the old stream ended and a new stream is set and schedules the changes to the beat.

ClassMethods::

method::new
create a new instance with a function (the source). the source should be a strong::routine function:: (see link::Classes/Tdef::) or a strong::pattern:: of time values.

method::default
a default source, if none is given. the default is a loop that does nothing with a 1.0 beat wait time.

method::defaultQuant
set the default quantization value for the class. (default: 1.0). can be a pair [quant, offset]

InstanceMethods::

method::source
set the source. If a quantization is given, schedule this change to the next beat the object is a strong::routine function::, which is evaluated in a protected way, so that failure will notify the proxy that it has stopped. The object can also be a strong::pattern:: of time values.

method::clear
set the source to nil

method::quant
get or set the quantization value. can be a pair [quant, offset]

method::condition
provide a condition under which the pattern is switched when a new one is inserted. the stream value and a count is passed into the function. the methods strong::count_(n):: simply counts up to n and switches the pattern then

method::reset
switch the pattern immediately. (stuck conditions can be subverted by this)

method::envir
provide a default environment for the proxy. If given, it is used as an environment for the routine function. When set for the first time, the routine pattern is rebuilt.

method::set
set arguments in the environment. If there is none, it is created and the routine pattern is rebuilt.

method::endless
returns a link::Classes/Proutine:: that plays the proxy endlessly, replacing strong::nil:: with a strong::default:: value (1 s. wait time). This allows to create streams that idle on until a new pattern is inserted.

subsection::a) using it as stream reference

method::source
set the routine function / pattern (internally done by *new(key, obj)

method::embedInStream
just like any stream, embeds itself in stream

subsection::b) using it as EventStreamPlayer

method::play
starts the TaskProxy and creates a player. if you want to play multiple instances, use strong::.playOnce(clock, protoEvent, quant)::

argument::argClock
which clock to use. if nil then the TempoClock.default is used.

argument::doReset
A link::Classes/Boolean::

argument::quant
can be an array of [quant, phase]

method::stop
stops the player

method::player
the current player (if the TaskProxy is simply used in other streams this is nil)

method::pause, resume, reset
perform player method

method::isPlaying
returns true if TaskProxy is running. if a TaskProxy is playing and its stream ends, it will schedule a stream for playing as soon as a new one is assigned to it.

Examples::

subsection::a) using TaskProxy as a player

code::
#+BEGIN_SRC sclang
// create an empty Tdef and play it.
x = TaskProxy.new;
x.play;


x.source = { loop { "ggggggggggggggggg9999ggg999ggg999gg".scramble.postln; 0.5.wait; } };


x.source = { loop { "---------////----------------------".scramble.postln; 0.25.wait; } };
x.source = { loop { thisThread.seconds.postln; 1.wait; } };
x.source = { loop { thisThread.seconds.postln; 1.01.wait; } };

TempoClock.default.tempo = 2;

x.source = { "the end".postln };
x.source = { "one more".postln };
x.source = { 10.do { "ten more".scramble.postln; 0.25.wait; } };
x.source = { loop { "many more".scramble.postln; 0.25.wait; } };

TempoClock.default.tempo = 1;

x.stop;
x.play;
x.stop;
#+END_SRC

::


code::
#+BEGIN_SRC sclang
// sound example

(
// load a synthdef
s.boot;
SynthDef("pdef_grainlet",
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.3), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)
x.play;

(
x.source = {
	loop {
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, rrand(600, 640));
		0.1.wait;
	}
}
)

(
x.source = {
	var x;
	x = Pseries(300, 20, 100).loop.asStream;
	loop {
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, x.next);
		0.05.wait;
	}
}
)

(
x.source = {
	var x;
	x = Plazy { Pseries(300 + 300.rand, 10 + 30.rand, 10 + 30.rand) }.loop.asStream;
	loop {
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, x.next);
		0.05.wait;
	}
}
)

// metronome
(
y = TaskProxy {
	loop { s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, 1500); 1.wait; }
};
y.play;
)

// play ending stream once
(
x.source = {
	var x, dt;
	dt = [0.1, 0.125, 0.05].choose;
	x = Plazy { Pseries(1300 + 300.rand, 110 + 130.rand, 16) }.asStream;
	x.do { arg item;
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, item);
		dt.wait;
	}
}
)

... and so on ...

x.stop;
y.stop;
#+END_SRC

::

subsection::b) embedding TaskProxy into other Tasks / Routines

code::
#+BEGIN_SRC sclang
(
#a, c = { TaskProxy.new } ! 2;
a.source = { "one".postln; 1.wait; "two".postln };
c.source = { var z; z = Synth(\default); 0.5.wait; z.release };
r = Task {
	"counting...".postln;
	2.wait;
	a.embedInStream;
	1.wait;
	c.embedInStream;
	"done.".postln;
};
)

r.play; // play a stream

c.source = { var z; z = Synth(\default, [\freq, 300]); 1.5.wait; z.release }; // change the def

r.reset;
r.play;

// of course TaskProxies can be used in other Tdefs:
(
b = TaskProxy.new;
b.source = {
	"counting...".postln;
	2.wait;
	a.embedInStream;
	1.wait;
	c.embedInStream;
	"done.".postln;
};
)
b.playOnce;

// if one wants to branch off a stream in a separate thread, asStream is used.
(
Routine {
	c.asStream.play;
	0.1.wait;
	c.asStream.play;
	0.1.wait;
	a.asStream.play;

}.play;
)
#+END_SRC

::
** class:: TaskProxyGui
summary:: a superclass for Guis for PatternProxies
categories:: Libraries>JITLib>GUI
related:: Classes/TdefGui, Classes/PdefGui

description::

Please see link::Classes/TdefGui:: and link::Classes/PdefGui:: for examples!
** class:: Tdef
summary:: task reference definition
categories:: Libraries>JITLib>Patterns
related:: Classes/TaskProxy, Classes/Task, Classes/Routine

description::
Pdefn provides an interface to its superclass TaskProxy. Tdef keeps a reference to a task ( strong::time pattern:: ) that can be replaced while playing. It continues playing when the old stream ended and a new stream is set and schedules the changes to the beat. One Tdef may be used in many tasks in different places. A change in the task definition Tdef propagates through all tasks.

code::
#+BEGIN_SRC sclang
Tdef(key)	//returns the instance
Tdef(key, func)	//defines the task and returns the instance, like Pdef and Ndef.
#+END_SRC

::

Graphical overview over all current Tdefs: link::Classes/TdefAllGui::. Overview: link::Overviews/JITLib::

subsection::First Example

code::
#+BEGIN_SRC sclang
Tdef(\x, { loop { 0.5.wait; "aaaaaaaaaaaaaazz".scramble.postln } }).play;
Tdef(\x, { loop { 0.125.wait; "aazz".scramble.postln } });
Tdef(\x, { loop { 0.5.wait; (note: 14.rand).play } });
Tdef(\x, { loop { 0.5.wait; (note: 14.rand + [0, 3, 6, 7].keep(4.rand)).play } });
Tdef(\x).stop;
Tdef(\x).play;
Tdef(\x).clear;
#+END_SRC

::

ClassMethods::

private::initClass

subsection::Creation

method::new
Store the task in a global dictionary under key, replacing its routine function with the new one.

Using strong::*new(key):: you can access the pattern at that key (if none is given, a default task is created)

method::default
Default source, if none is given. The default task has a function that waits in 1.0 beat steps and does nothing.

method::removeAll
Remove all proxies from the global dictionary ( link::#*all:: )

method::clear
Clear all proxies, setting their source to silence.

method::all
Set or return the environment ( link::Classes/IdentityDictionary:: ) that stores all instances.

method::defaultQuant
Set the default quantisation for new instances (default: 1.0). This can be an array [quant, phase, timingOffset, outset]

InstanceMethods::

subsection::Changing the definition / setting the source

One Tdef may have many tasks in different places. A change in the task definition Tdef propagates through all tasks. The change does not have to be immediate - there is a scheme to schedule when the change becomes effective: a strong::quant:: and strong::clock:: (like elsewhere) and a strong::condition::.

method::quant
Set the quantisation time for beat accurate scheduling.

argument::val
can be an array strong::[quant, phase, timingOffset, outset] ::, or just strong::[quant, phase]:: etc.

method::condition
Provide a condition under which the pattern is switched when a new one is inserted. The stream value and a count value is passed into the function.

method::count
Create and update condition that simply counts up to n and switches the pattern then

method::reset
Switch the task immediately (stuck conditions can be subverted by this).

method::envir
Set the environment (an link::Classes/Event::) for the Tdef. strong::It is passed as first argument into the Task function::.

method::set
Set arguments in the default event. If there is none, it is created and the task routine is rebuilt.

method::clear
Set the source to nil

method::endless
Returns a link::Classes/Prout:: that plays the task endlessly, replacing strong::nil:: with a strong::default:: value 1. This allows to create streams that idle on until a new pattern is inserted.

subsection::Tdef as stream reference

A single Tdef may serve as a definition for multiple tasks. These methods show how to fork off separate routines from one instance. Even if they run in different contexts, their definition may still be changed.

method::fork
Play an independent task in parallel.

argument::quant
can be an array of [quant, phase, offset], or a link::Classes/Quant:: value.

method::embed
Pass a value (typically an link::Classes/Event::) into the task function, and embed the Tdef in the stream.

method::embedInStream
just like any pattern, embeds itself in stream

subsection::Tdef as EventStreamPlayer

For live coding, each Tdef also may control one instance that plays one task. This is a link::Classes/PauseStream::, accessible in the instance variable link::#-player::.

method::play
Starts the Tdef and creates a player.

argument::quant
can be an array of [quant, phase, offset] or a link::Classes/Quant:: value.

method::stop
Stops the player

method::player
Return the current player (if the Tdef is simply used in other streams this is nil)

method::pause, resume, reset
Perform this method on the player.

method::isPlaying
Returns true if player is running. If a Tdef is playing and its stream ends, it will schedule a stream for playing strong::as soon as a new one is assigned to it::. If it is stopped by strong::stop::, it won't.

Examples::

subsection::Tdef as a Task player

code::
#+BEGIN_SRC sclang
Tdef(\x).play; // create an empty Tdef and play it.

Tdef(\x, { loop({ "ggggggggggggggggg9999ggg999ggg999gg".scramble.postln; 0.5.wait; }) });


Tdef(\x, { loop({ "---------////----------------------".scramble.postln; 0.25.wait; }) });
Tdef(\x, { loop({ thisThread.seconds.postln; 1.wait; }) });
Tdef(\x, { loop({ thisThread.seconds.postln; 1.01.wait; }) });

TempoClock.default.tempo = 2;

Tdef(\x, { "the end".postln });
Tdef(\x, { "one more".postln });
Tdef(\x, { 10.do({ "ten more".scramble.postln; 0.25.wait; }) });
Tdef(\x, { loop({ "lots more".scramble.postln; 0.25.wait; }) });

TempoClock.default.tempo = 1;

Tdef(\x).stop;
Tdef(\x).play;

Tdef(\x).clear;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// sound example

(
// load a synthdef
s.boot;
SynthDef(\pdef_grainlet,
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.3), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)
Tdef(\x).play;

(
Tdef(\x, {
	loop({
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, rrand(600, 640));
		0.1.wait;
	})
})
)

(
Tdef(\x, {
	var x;
	x = Pseries(300, 20, 100).loop.asStream;
	loop({
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, x.next);
		0.05.wait;
	})
})
)

(
Tdef(\x, {
	var x;
	x = Plazy({ Pseries(300 + 300.rand, 10 + 30.rand, 10 + 30.rand) }).loop.asStream;
	loop({
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, x.next);
		0.05.wait;
	})
})
)

// metronome
Tdef(\y, { loop({ s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, 1500); 1.wait; }) }).play;

// play ending stream once
(
Tdef(\x, {
	var x, dt;
	dt = [0.1, 0.125, 0.05].choose;
	x = Plazy({ Pseries(1300 + 300.rand, 110 + 130.rand, 16) }).asStream;
	x.do({ arg item;
		s.sendMsg("/s_new", "pdef_grainlet", -1,0,0, \freq, item);
		dt.wait;
	})
})
)

// ... and so on ...

Tdef(\x).stop;
Tdef.removeAll;
#+END_SRC

::

subsection::Embed and fork: Tdef within other Tasks / Routines

code::
#+BEGIN_SRC sclang
// embed plays tdefs in sequence within a task.
(
Tdef(\a, { "one".postln; 1.wait; "two".postln });
Tdef(\c, { var z; z = Synth(\default); 0.5.wait; z.release });
r = Task({
	"counting...".postln;
	2.wait;
	Tdef(\a).embed;
	1.wait;
	Tdef(\c).embed;
	"done.".postln;
});
)

r.play; // play a stream

Tdef(\c, { var z; z = Synth(\default, [\freq, 300]); 1.5.wait; z.release }); // change the def

r.reset;
r.play;

// of course Tdefs can be used in other Tdefs:
(
Tdef(\a, { 10.do { |i| (" a: " + i).postln; 0.3.wait; } });
Tdef(\b, { 15.do { |i| ("\t\t b: " + i).postln; 0.2.wait; } });
Tdef(\c, { 5.do { |i| ("\t\t\t\t c: " + i).postln; 0.5.wait; } });

Tdef(\d, {
	"embed - sequence.".postln;
	1.wait;
	Tdef(\a).embed;
	1.wait;
	Tdef(\b).embed;
	1.wait;
	Tdef(\c).embed;

	"done.".postln;
});
)
Tdef(\d).play;

// to start a tdef in its own separate thread, thus branching into parallel threads,
// one can use .fork, or .playOnce
(
Tdef(\a, { 10.do { |i| (" a: " + i).postln; 0.3.wait; } });
Tdef(\b, { 15.do { |i| ("\t\t b: " + i).postln; 0.2.wait; } });
Tdef(\c, { 5.do { |i| ("\t\t\t\t c: " + i).postln; 0.5.wait; } });

Tdef(\d, {
	"fork - parallel.".postln;
	1.wait;
	Tdef(\a).fork;
	1.wait;
	Tdef(\b).fork;
	1.wait;
	Tdef(\c).fork;

	"done.".postln;
});
)
#+END_SRC

::

subsection::Tdef as a time pattern

Instead of using a link::Classes/Pdefn:: for time values, it can be useful to use a Tdef. When changing its source, it keeps the stream of values synchronized to its clock.

code::
#+BEGIN_SRC sclang
(
// load a synthdef
s.boot;
SynthDef("pdef_grainlet",
	{ arg out=0, freq=440, sustain=0.05;
		var env;
		env = EnvGen.kr(Env.perc(0.01, sustain, 0.3), doneAction:2);
		Out.ar(out, SinOsc.ar(freq, 0, env))
	}).add;
)



Tdef(\z, Pseq([1, 1, 1, 0.5, 0.5], inf));

(
Pset(\instrument, \pdef_grainlet,
	Ppar([
		Pbind(
			\dur, Tdef(\z),
			\note, Pseq([1, 3, 2, 1, 0], inf),
			\x, Pfunc { TempoClock.default.elapsedBeats.postln } // posts the onset times
		),
		Pbind(
			\dur, 4, // reference beat
			\sustain, 0.1,
			\note, 8
		)
	])
).play(quant:1);
)


Tdef(\z, Prand([1, 1, 0.23, 0.5, 0.5], inf)); // exchange time pattern
Tdef(\z, Pseq([1, 1, 1, 1], inf)); // pattern stays in sync.
Tdef(\z, Pseq([1, 1, 1, 0.5, 0.5], inf)); // but might be in different order.
					// to avoid this, set quant to an appropriate value.
#+END_SRC

::
** class:: TdefAllGui
summary:: see all Tdefs and their state
categories:: Libraries>JITLib>GUI
related:: Classes/TdefGui, Classes/PdefGui, Classes/PdefAllGui

description::

TdefAllGui uses link::Classes/TdefGui:: views to display all Tdefs, or a selection.

Overview: link::Overviews/JITLib::

ClassMethods::

subsection::Creation

method::new

argument::numItems
the maximum number of Pdefs that can be shown.

argument::parent
a parent view on which to display. If nil, a new window is created; strong::parent:: can also be an existing window or a composite view.

argument::bounds
a desired size and position where to display a JITGui. can be nil, a link::Classes/Point::, or a link::Classes/Rect::. JITGuis know their minimum size ( strong::minSize:: ), and if bounds is nil, minSize is used. if bounds is a point or rect, it will be set to at least minSize. With a rect one can also supply a position where to display. If a point,shown size is the maximum of bounds and minSize.

argument::makeSkip
///// Not Done Yet, but on the list

A flag whether to make a skipjack.

argument::options
///// Not Done Yet, but on the list

the only option for PdefAllGui will be [\makeEdit]. adding a "front" PdefGui that also shows the front Pdef's envir.

Examples::

code::
#+BEGIN_SRC sclang
(
Tdef(\a, { |e| 100.do { |i| i.postln; 0.5.wait } });
Tdef(\b, { |e| 100.do { |i| Tdef(\a).set(\otto, 8.rand); exprand(0.1, 3.0).wait } });
t = TdefAllGui(8);
)

	// if you have too many Tdefs, an ezscroller lets you select
"abcdefghijk".do { |ch| Tdef(ch.asSymbol) };

	// you can also filter which ones you see:
Tdef(\a_otti);
Tdef(\a_hannerl);
Tdef(\a_dede);

	// or better from gui
t.filtering_(true);
t.prefix_("a_");

	// if prefix is "", it will filter anything with "_" in it.
t.prefix_("");
t.filtering_(false);
#+END_SRC

::
** class:: TdefEditor
summary:: will be replaced - please use TdefGui now!
categories:: Libraries>JITLib>GUI
related:: Classes/TdefGui

description::

warning::
has been rewritten and renamed link::Classes/TdefGui::, which has largely the same functionality, but is more consistent and more flexible. There are some changes to the *new method:

definitionList::
## instead of || *new(px, nVars, height, width, parent, makeWatcher)
## TdefGui uses || *new (object, numItems, parent, bounds, extras)
::

strong::px:: is now strong::object::, strong::nVars:: is now strong::numItems::, strong::width & height:: can be put as strong::bounds: height @ width ::, strong::parent:: is still strong::parent::, strong::makeWatcher:: is now strong::makeSkip:: .

Please see link::Classes/TdefGui:: for more details.
::class:: TdefGui
summary:: a line of editing controls for a Tdef, and optionally its envir
categories:: Libraries>JITLib>GUI
related:: Classes/TdefAllGui, Classes/PdefGui, Classes/PdefAllGui

description::

A gui showing the link::Classes/Tdef::'s name, playing state, source state, and envir state. Optionally, its envir can also be edited.

subsection::First example

code::
#+BEGIN_SRC sclang
g = TdefGui();			// make a TdefGui
g.object = Tdef(\a);		// show when a Tdef is put in
Tdef(\a, { "boing".postln }); 	// show whether it has a source
Tdef(\a).play; 			// show whether playing, stopped, or ended, and pausable
Tdef(\a).set(\abc, 123); 	// show whether the tdef has an envir

g = TdefGui(Tdef(\a), 3);	// with an envirgui for 3 items
Tdef(\a).set(\a, 12, \lofreq, [1, 10], \str, "someString", \oops, \oneSymbolTooMany);

(				// put it in an existing window - margin becomes 0@0
w = Window().front; w.addFlowLayout;
TdefGui(Tdef(\a), 0, w);
TdefGui(Tdef(\a), 3, w);
)
#+END_SRC

::

subsection::Details on the GUI elements

definitionList::
## name button
|| when selected, typing the delete key will delete its Tdef.
## play/stop button
|| indicates whether the tdef is playing:
table::
## " >" || if stopped,
## " _" || if playing and active,
## " |" || if it is playing, but the stream has ended.
::
## pause/resume button
|| only visible if one can pause or resume the Tdef, i.e. while it is playing.
table::
## "paus" || shown when you can pause it,
## "rsum" || shown when you can resume it.
::
## src button
|| opens a document to edit the source (function) of the Tdef.
table::
## green || a source exists,
## white || the source is nil.
::
## env button
|| strong::click:: opens a document to edit the envir of the Tdef, strong::option-click:: opens a new TdefGui with a big enough link::Classes/EnvirGui:: for the Tdef's envir.
table::
## green || the Tdef has an envir,
## white || the envir is nil.
::
::

ClassMethods::

subsection::Creation Methods

method::new
Create a new link::Classes/JITGui:: that will be watching an object and display its state.

argument::object
the object to watch

argument::numItems
the number of display items to use, e.g. how many fields for text, or how many EZSliders for single-number parameters.

argument::parent
a parent view on which to display. If nil, a new window is created; strong::parent:: can also be an existing window or a composite view.

argument::bounds
a desired size and position where to display a JITGui. can be nil, a link::Classes/Point::, or a link::Classes/Rect::. JITGuis know their minimum size ( strong::minSize:: ), and if bounds is nil, minSize is used. if bounds is a point or rect, it will be set to at least minSize. With a rect one can also supply a position where to display. If a point,shown size is the maximum of bounds and minSize

argument::makeSkip
A flag whether to make a skipjack. If one uses a TdefGui as part of a larger gui ensemble, one may want to call checkUpdate on all of them together, not with separate skipJacks.

argument::options
a list of additional information, e.g. flags about optional buttons. (this is used is some subclasses)

InstanceMethods::

method::object
a link::Classes/Tdef::, or nil

method::numItems
the number of items in the envirGui

method::parent
the parent view

method::bounds
the bounds of the link::#-zone::

method::zone
the link::Classes/CompositeView:: within which the TdfGui is shown


method::nameBut, playBut, pauseBut, srcBut, envBut
the buttons

method::envirGui
the gui for the Tdef's envir - if numItems > 0.

method::object
put an object in the gui.

method::moveTo
(if the jitGui is in its own window)

move it to some specific location.

method::clear
(if the jitGui is in its own window)

set the TdefGui's object to nil

method::close
(if the jitGui is in its own window)

and close its window.

subsection::Internal methods

method::srcString
a compileString that recreates the Tdef.

code::
#+BEGIN_SRC sclang
// assume g from above is still there
g.srcString;
#+END_SRC

::

method::editString
a compileString that recreates the Tdef's envir at edKey.

method::editStrings
a compileString that recreates the Tdef's envir at edKeys.

argument::edKey
Default value is nil.

code::
#+BEGIN_SRC sclang
// assume g from above is still there
g.editString;
Tdef(\a).set(\foo, \bar);
g.editString(\foo);

g.editStrings;
#+END_SRC

::

method::getUsedKeys
the keys in use in the envir

code::
#+BEGIN_SRC sclang
g.getUsedKeys;
#+END_SRC

::

method::openDoc
open a document with some strings at some location. used with src button, env button.

code::
#+BEGIN_SRC sclang
g.openDoc(g.editStrings);
#+END_SRC

::

method::makeEnvirGui
make an envirGui within zone.

Examples::

code::
#+BEGIN_SRC sclang
(
Tdef(\a, { |e| 100.do { |i| i.postln; 0.5.wait } });
t = TdefGui(Tdef(\a), 4);
Tdef(\a).set(\freq, 200, \dur, 0.1, \otto, 12, \ann, 1234);
)

Tdef(\a).stop;
Tdef(\a).play;
Tdef(\a).pause;
Tdef(\a).resume;

t.object_(nil);
t.object_(Tdef(\a));

(
w = Window("put it in a selfmade window").front;
w.addFlowLayout;
w.view.decorator.shift(50, 50);
TdefGui(Tdef(\a), 12, w)
)

Tdef(\b, { |e| 100.do { |i| Tdef(\a).set(\otto, 8.rand); exprand(0.1, 3.0).wait } });
Tdef(\b).play;
TdefGui(Tdef(\b));

	// see all Tdefs:
TdefAllGui(16);
#+END_SRC

::
** class:: TempoBusClock
summary:: a clock that synchronizes its tempo with the server
categories:: Libraries>JITLib>NodeProxy
related:: Classes/TempoClock

ClassMethods::

method::new
return a new instance.

argument::control
can be anything that responds to the message code::set(key, val, ...):: e.g. a link::Classes/Synth:: or a link::Classes/NodeProxy::. The control key set is "tempo". otherwise TempoBusClock works just like a link::Classes/TempoClock:: .

Examples::

code::
#+BEGIN_SRC sclang
(
a = { |tempo=1| Ringz.ar(Impulse.ar(tempo), [501, 500], 1/tempo) }.play;
t = TempoBusClock(a);
Task { loop { "klink".postln; 1.wait } }.play(t);
);

t.tempo = 1.3;
t.tempo = 0.5;
t.tempo = 1.0;


// in ProxySpace, a TempoBusClock can be added together with a ~tempo NodeProxy:

p = ProxySpace.push(s);
p.makeTempoClock;
p.clock; // now the ProxySpace's clock is a TempoBusClock

~out.play;
~out = { Ringz.ar(Impulse.ar(~tempo.kr), [501, 500], 1/~tempo.kr) * 0.3 };
p.clock.tempo = 1.3;

// patterns and tasks are synchronized:

~out2.play;
~out2 = Pbind(\dur, 1, \note, Pwhite(0, 7, inf));

p.clock.tempo = 3;
p.clock.tempo = 1;
#+END_SRC

::
** CLASS::TempoClock
categories::Scheduling>Clocks
summary::tempo based scheduler
related::Classes/AppClock, Classes/SystemClock

DESCRIPTION::

TempoClock is a scheduler like link::Classes/SystemClock::, but it schedules relative to a strong::tempo:: in beats per second.

See link::Classes/Clock:: for general explanation of how clocks operate.

CLASSMETHODS::

private::initClass

method::new
Creates a new TempoClock scheduler with the given tempo and starting times. If not supplied, strong::tempo:: defaults to one, strong::beats:: defaults to zero and strong::seconds:: defaults to the current elapsed time since SuperCollider startup. The default queueSize is 256, see link::#-queue::.
code::
#+BEGIN_SRC sclang
t = TempoClock.new(1, 0, Main.elapsedTime.ceil);
#+END_SRC

::

method::default
Sets or gets the permanent default TempoClock instantiated at startup.
code::
#+BEGIN_SRC sclang
TempoClock.default.beats // beats since default TempoClock was started
#+END_SRC

::

subsection::Methods that allow TempoClock to act as TempoClock.default

method::stop, play, sched, schedAbs, clear, tempo, etempo, beats, beats2secs, secs2beats, nextTimeOnGrid, timeToNextBeat, setTempoAtBeat, setTempoAtSec, setMeterAtBeat, beatsPerBar, baseBarBeat, baseBar, playNextBar, beatDur, elapsedBeats, beats2bars, bars2beats, bar, nextBar, beatInBar

INSTANCEMETHODS::

private::prDump, prStart, prStop, prClear

method::stop
Destroys the scheduler and releases the OS thread running the scheduler.

method::clear
Removes all tasks from the scheduling queue.

method::tempo
Sets or gets the current tempo in beats per second.
code::
#+BEGIN_SRC sclang
t= TempoClock.new;
t.tempo_(2.0); // equivalent to t.tempo = 2.0;
t.tempo;
t.tempo_(72/60) // 72 beats per minute
t.tempo;
#+END_SRC

::

method::permanent
Sets or gets a link::Classes/Boolean:: value indicating whether the clock will survive cmd-period. If false the clock is stopped (and thus removed) on cmd-period. If true the clock survives cmd-period. It is false by default.

method::beats
Returns the appropriate beat time of the clock from any thread. If the receiver is the clock of the current thread, this returns the current logical time: code::thisThread.beats::. If the receiver is not the current thread's clock then this translates the current thread's logical time in seconds to this clock's logical time in beats.

method::schedAbs
Schedules a function to be evaluated at a particular strong::beat::. If the function returns an link::Classes/Integer:: or a link::Classes/Float::, it will be re-evaluated at the logical time plus the returned value. The function receives a number of default arguments, see link::#-play:: example below.

method::sched
Schedules a function to be evaluated strong::delta:: beats from the current logical time in this clock. If the receiver is the clock of the current thread, the delta is applied to the current logical time. If the receiver is not the current thread's clock then the delta is applied to the clock's elapsed time.

method::play
Plays task (a function) at the next beat, where strong::quant:: is 1 by default. Shortcut for link::#-schedAbs::; see link::#-seconds:: and link::#-nextTimeOnGrid:: for further details on time and quant.
code::
#+BEGIN_SRC sclang
t= TempoClock.default;
t.play({arg beats, time, clock; [beats, time, clock].postln});
#+END_SRC

::

method::playNextBar
Plays task (a function) at the next bar using link::#-schedAbs::.

method::queue
Returns the scheduling queue Array in the form [beat, function]. The maximum number of items is determined by the clock's queueSize argument upon instantiation. The default queueSize of 256 allows 128 functions to be in the queue at any time.

method::beatDur
Returns the duration in seconds of a current whole beat.

method::beatsPerBar
Gets or sets the number of beats per bar. The default is 4. Setting must be done from within the scheduling thread, e.g.
code::
#+BEGIN_SRC sclang
t= TempoClock.new;
t.schedAbs(t.nextBar, {t.beatsPerBar_(3)});
t.beatsPerBar;
#+END_SRC

::

method::bar
Returns the current bar. See link::#-bars2beats:: for returning beat of current bar.

method::nextBar
Returns the number of beats at the next bar line relative to the beat argument. If strong::beat:: is not supplied, returns the beat at which the next bar begins.

method::beatInBar
Returns the current bar beat (as a link::Classes/Float::) in relation to link::#-beatsPerBar::. Values range from 0 to < beatsPerBar.

method::baseBar
Returns bar at which link::#-beatsPerBar:: was last changed. If beatsPerBar has not been changed since the clock was created, returns 0.

method::baseBarBeat
Returns beat at which the link::#-beatsPerBar:: was last changed. If beatsPerBar has not been changed since the clock was created, returns 0.

method::beats2bars
Returns a bar as a float relative to link::#-baseBarBeat::.

method::bars2beats
Returns a beat relative to link::#-baseBar::.
code::
#+BEGIN_SRC sclang
t= TempoClock.default;
t.bars2beats(t.bar) // downbeat of the current bar
#+END_SRC

::

method::timeToNextBeat
Returns the logical time to next beat. strong::quant:: is 1 by default, relative to baseBarBeat, see link::#-nextTimeOnGrid::.

method::nextTimeOnGrid
With default values, returns the next whole beat. strong::quant:: is 1 by default, strong::phase:: is 0. quant is relative to link::#-baseBarBeat::, such that
code::
#+BEGIN_SRC sclang
t= TempoClock.default;
t.nextTimeOnGrid(t.beatsPerBar) == t.nextBar // => true
#+END_SRC

::
Together strong::quant:: and strong::phase:: are useful for finding the next n beat in a bar, e.g. code::nextTimeOnGrid(4, 2):: will return the next 3rd beat of a bar (of 4 beats), whereas code::nextBar-2:: may return an elapsed beat.

method::elapsedBeats
Returns the current elapsed time in beats. This is equivalent to code::tempoClock.secs2beats(Main.elapsedTime)::. It is often preferable to use link::#-beats:: instead of elapsedBeats because beats uses a thread's logical time.

method::seconds
Returns the current elapsed time. (This method is inherited from link::Classes/Clock::.)

method::beats2secs
Converts absolute strong::beats:: to absolute strong::seconds::, returning the elapsed time of the clock at the given strong::beats::. Only works for times in the current tempo. If the tempo changes any computed time in future will be wrong.
code::
#+BEGIN_SRC sclang
t= TempoClock.default;
t.beats2secs(t.beats) // equivalent to t.seconds
t.beats2secs(0) // how many seconds after startup did beat 0 occur?
#+END_SRC

::

method::secs2beats
Converts absolute strong::seconds:: to absolute beats. Only works for times in the current tempo. If the tempo changes any computed time in future will be wrong.

EXAMPLES::

code::
#+BEGIN_SRC sclang
t = TempoClock(1); // create a TempoClock

// schedule an event at next whole beat
t.schedAbs(t.beats.ceil, { arg beat, sec; [beat, sec].postln; 1 });

t.tempo = 2;
t.tempo = 4;
t.tempo = 0.5;
t.tempo = 1;

t.clear;

t.schedAbs(t.beats.ceil, { arg beat, sec; [beat, sec].postln; 1 });

t.stop;
#+END_SRC

::
code::
#+BEGIN_SRC sclang
(
// get elapsed time, round up to next second
v = Main.elapsedTime.ceil;

// create two clocks in a 5:2 relation, starting at time v.
t = TempoClock(1, 0, v);
u = TempoClock(0.4, 0, v);

// start two functions at beat zero in each clock.
t.schedAbs(0, { arg beat, sec; [\t, beat, sec].postln; 1 });
u.schedAbs(0, { arg beat, sec; [\u, beat, sec].postln; 1 });
)

(
u.tempo = u.tempo * 3;
t.tempo = t.tempo * 3;
)

(
u.tempo = u.tempo * 1/4;
t.tempo = t.tempo * 1/4;
)

(
t.stop;
u.stop;
)
#+END_SRC

::
code::
#+BEGIN_SRC sclang
(
// get elapsed time, round up to next second
v = Main.elapsedTime.ceil;

// create two clocks, starting at time v.
t = TempoClock(1, 0, v);
u = TempoClock(1, 0, v);

// start two functions at beat zero in each clock.
// t controls u's tempo. They should stay in sync.
t.schedAbs(0, { arg beat, sec; u.tempo = t.tempo * [1,2,3,4,5].choose; [\t, beat, sec].postln; 1 });
u.schedAbs(0, { arg beat, sec; [\u, beat, sec].postln; 1 });
)

(
u.tempo = u.tempo * 3;
t.tempo = t.tempo * 3;
)

(
u.tempo = u.tempo * 1/4;
t.tempo = t.tempo * 1/4;
)

(
t.stop;
u.stop;
)
#+END_SRC

::
** CLASS:: TextField
redirect:: implClass
summary:: A view displaying editable text
categories:: GUI>Views

DESCRIPTION::
A view displaying editable text.


CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::


SUBSECTION:: Data

METHOD:: string
	The text displayed in the view.

	argument::
		A String.

METHOD:: object
	If link::#-setBoth:: is true, setting this variable also sets link::#-string:: to the value interpreted link::Classes/Object#-asString#as String::.

	argument::
		Any object, typically one which makes sense to display as a string, such as a Float.

METHOD:: setBoth
	A variable stating whether setting link::#-object:: will also set link::#-string::.

	argument::
		A Boolean.

METHOD:: value
	Gets the same as link::#-string::, but when setting also sets link::#-string:: to the value interpreted link::Classes/Object#-asString#as String:: regardless of the link::#-setBoth:: flag.

	argument::
		Any object, typically one which makes sense to display as a string, such as a Float.

METHOD:: valueAction
	Sets link::#-value:: and triggeres link::#-action::.


SUBSECTION:: Appearance

METHOD:: align
	The alignment of the displayed text. See link::Reference/gui_alignments:: for possible values.

METHOD:: font
	The font used to display the text.

	argument::
		A Font.

METHOD:: stringColor
	The color used to display the text.

	argument::
		A Color.

METHOD:: background
	Setting this variable colors the inside of the field under the text with the given color.

	argument::
		A Color.


SUBSECTION:: Actions

METHOD:: action
	The action object evaluated whenever the user changes the text.


SUBSECTION:: Drag and drop

METHOD:: defaultGetDrag
	returns::
		The displayed link::#-string::.

METHOD:: defaultCanReceiveDrag
	returns::
		Always true.

METHOD:: defaultReceiveDrag
	Sets link::#-valueAction:: to the current drag data.


EXAMPLES::
code::
#+BEGIN_SRC sclang
(
w = Window.new.front;
a = TextField(w, Rect(10, 10, 150, 20));
a.string = "hi there";
a.action = {arg field; field.value.postln; };
)

// does not do the action
a.value = "yo";
a.string = "oy";

a.valueAction_("this is not a pipe"); //does the action, if the value has changed
a.doAction; //evaluates the action with the content of the text field as an argument

a.background_(Color.grey);
a.stringColor_(Color.white);
a.align_(\center);
#+END_SRC

::

** CLASS:: TextView
redirect:: implClass
summary:: A view displaying editable formatted text
categories:: GUI>Views

DESCRIPTION::

TextView consists of an area where strong::multi-line text:: can be typed in and edited.

Using the view's methods, the text can be formatted: different strong::font:: and strong::text color:: can be applied to parts of the text. Text can also be inserted, removed, and selected programmatically.

The view can strong::open text documents:: and load from them both strong::plain text::, as well as formatted text in strong::HTML::, although it can not save the text back to files. However, you can get the contents of the view using the link::#-string:: method and then implement saving on your own, but the -string method will only return plain text, regardless of how the contents of the view are formatted.

note:: strong::Cocoa GUI:: can also load files in the strong::Rich Text Format::. ::

CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::

SUBSECTION:: Text and Formatting

METHOD:: open
	Opens a file at code::path:: and loads text from it.

	The file can be in plain text or HTML (or RTF, in Cocoa GUI) format. Note however that saving formatted text in the view is not supported.

	If loading the text from the file succeeds, it will replace any current contents of the view.

	argument:: path
		A String.

METHOD:: string
	The entire displayed contents of the view, as plain text.

	Setting this variable will replace any current contents of the view.

	argument::
		A String.

METHOD:: setString
	Inserts the code::string:: at code::rangeStart:: position, replacing code::rangeSize:: amount of following characters. If code::rangeSize:: is 0, the text will be inserted without any characters being removed.

	argument:: string
		A String - the text to insert.
	argument:: rangeStart
		An Integer position within the text, in characters.
	argument:: rangeSize
		An Integer amount of characters.

METHOD:: currentLine
	NOTE::Only in Qt GUI::
	The plain text of the line at text cursor.

METHOD:: setFont
	Applies the code::font:: to code::rangeSize:: amount of characters following the code::rangeStart:: position.

	argument:: font
		A Font to apply to the desired range of text.
	argument:: rangeStart
		An Integer position within the text, in characters.
	argument:: rangeSize
		An Integer amount of characters.

METHOD:: setStringColor
	Applies the code::color:: to code::rangeSize:: amount of characters following the code::rangeStart:: position.

	argument:: color
		A Color to apply to the desired range of text.
	argument:: rangeStart
		An Integer position within the text, in characters.
	argument:: rangeSize
		An Integer amount of characters.

METHOD:: syntaxColorize
	Applies colors to text throughout the entire contents of the view, according to the SuperCollider language syntax highlighting scheme.




SUBSECTION:: Text Selection

METHOD:: selectedString
	The plain text contained in the current selection.

	When getting this variable and there is no selection, the entire line at text cursor is returned (equivalent to link::#-currentLine::).

	Setting this variable will replace text in the selection with the argument, or do nothing if there is no selection.

	argument::
		A String.
	returns::
		A String.

METHOD:: selectionStart
	The starting position of the selection. If no text is selected this variable represents the cursor position.

	returns::
		An Integer position within the text, in characters.

METHOD:: selectionSize
	The size of the current selection.

	returns::
		An Integer amount of characters - 0 if no text is selected.

METHOD:: select

	note:: Not available in strong::Cocoa GUI::. ::

	Selects code::size:: amount of characters following the code::start:: position. The cursor will remain at the end of the new selection.

	argument:: start
		An Integer position within the text, in characters.
	argument:: size
		An Integer amount of characters.




SUBSECTION:: Appearance

METHOD:: font
	The default font of the entire text. This font applies to any text to which a font has not been applied using link::#-setFont::.

	argument::
		A Font.

METHOD:: stringColor
	The default color of the entire text. This color applies to any text to which a color has not been applied using link::#-setStringColor::.

METHOD:: tabWidth
	The width of tab characters as they are displayed.




SUBSECTION:: Interaction

METHOD:: editable
	Whether the contents of the view are editable, i.e. the text can be typed in and deleted by the user.

	argument::
		A Boolean.

METHOD:: enterInterpretsSelection
	Whether the selection will be interpreted and invoked as SuperCollider code when Ctrl/Cmd/Shift + Enter key combination is pressed.

	Defaults to code::false::.

	argument::
		A Boolean.

METHOD:: usesTabToFocusNextView
	Whether the tab key will - instead of inserting a tab character into the text - switch focus to the next view (as usual for other views).

	Defaults to code::false::.

	argument::
		A Boolean.

METHOD:: hasHorizontalScroller
	Whether the horizontal scroller is shown.

	Note that if link::#-autohidesScrollers:: is code::true:: the scroller may be hidden despite this variable being set to code::true::. Since the TextView typically wraps text into the next line when a line reaches the edge of the view, the horizontal scroller may never be shown, unless link::#-autohidesScrollers:: is code::false::.

	Defaults to code::true::.

	argument::
		A Boolean.

METHOD:: hasVerticalScroller
	Whether the vertical scroller is shown.

	Note that if link::#-autohidesScrollers:: is code::true:: the scroller may be hidden despite this variable being set to code::true::.

	Defaults to code::true::.

	argument::
		A Boolean.

METHOD:: autohidesScrollers
	Whether each of the scrollers will be automatically hidden if there is no use for it, i.e. the content is not scrollable in the direction of the scroller.

	If link::#-hasHorizontalScroller:: or link::#-hasVerticalScroller:: is code::false::, the respective scroller will always be hidden, regardless of this variable.

	Defaults to code::true::.

	argument::
		A Boolean.



SUBSECTION:: Drag and Drop

note:: Default drag-and-drop behavior of TextView is not defined in standard SC methods (see link::Classes/View#subclassing::), but in the view implementation instead (except for link::#-defaultGetDrag:: in Qt GUI). It may or may not be overridable by adding your own handlers (see link::Classes/View#Drag and drop::), depending on the GUI kit in use.
::

Dragging from TextView will give the selected text in a String as drag data, while dropping will accept any object and insert it link::Classes/Object#-asString#as String:: at the drop location.

You can also drag files from outside SuperCollider onto a TextView, and it will insert their URLs at the drop location.

METHOD:: defaultGetDrag
	note:: Only present in strong::Qt GUI:: ::

	returns::
		The link::#-selectedString::.



EXAMPLES::

code::
#+BEGIN_SRC sclang
(
w = Window.new("Text View Example",Rect(100,Window.screenBounds.height-400, 520,300)).front;
t = TextView(w.asView,Rect(10,10, 500,200))
    .focus(true);
)

// Using the Window you just created, try these in succession, and test how the text view responds
t.mouseUpAction_{|it, x, y, modifiers, buttonNumber, clickCount, pos| [pos].postln};
t.autohidesScrollers_(false);
t.hasVerticalScroller_(false);
t.hasVerticalScroller_(true);
t.hasHorizontalScroller_(false);
t.hasHorizontalScroller_(true);
t.autohidesScrollers_(true);

t.open("Help/GUI/Main-GUI/Button.html"); // load an html file

// selective editing and formatting
t.setStringColor (Color.red, 5, 5);
t.setFont (Font("Courier",12), 5, 10);
t.setString ("\nA replacement String\n", 12, 6);

// compare with these methods, which change everything
t.font_(Font("Courier",14));
t.stringColor_(Color.blue);
#+END_SRC

::
** class::Thread
summary::The context of code evaluation
categories::Core>Kernel
related:: Classes/Routine

description::

note:: A SuperCollider Thread is strong::not an operating system thread::. Although they
have some conceptual similarities, they do not correspond.
::

A Thread represents the strong::context:: within which code runs. It is also said that
code runs "emphasis::on:: a Thread". A Thread records the strong::state:: of code
execution, and thus provides support for code to be suspended at any time, and then
resumed where it left off. It is then said that the Thread itself is strong::suspended and
resumed::.

There is always one link::Classes/Process#-mainThread#main Thread:: belonging to the
link::Classes/Process:: - it is the Thread on which the top-level code runs. Another
Thread may be started using an instance of the Thread's subclass link::Classes/Routine::
 which will run a link::Classes/Function:: in the context of its own (there is no use in
instantiating the Thread class itself).

When code on a Thread starts or resumes another Thread (Routine), the former Thread
becomes the latter's strong::parent::, and the latter its strong::child::. The parent
Thread's execution is strong::blocked:: until the child Thread finishes or is suspended,
at which point the parent Thread continues execution. The strong::current:: Thread may be
accessed using link::#.thisThread#thisThread::, while a Thread's parent may be accessed
using link::#-parent::.

A Thread has
list::
## associated link::#-beats#logical time::
## an associated link::#-clock#Clock::
## own link::#-randSeed#random number seed::
## own link::#-exceptionHandler#exception handler::
::

method:: thisThread

The global pseudo-variable code::thisThread:: always represents the current Thread, i.e.
the context in which the current code is running. It can be either the
link::Classes/Process#-mainThread#main Thread:: or the link::Classes/Routine:: running the
current code.

See also: link::Classes/Clock#Scheduling and Threads::.

code::
#+BEGIN_SRC sclang
// example
thisThread.beats;
thisThread.seconds;
thisThread.clock;
#+END_SRC

::

classMethods::

method::new

Creates an instance of Thread, passing it the Function with code to run.

note:: There is no good use in instantiating a Thread, because this class offers no method
of starting the given Function. Instead, use the Thread's subclass
link::Classes/Routine::. The only purpose of this constructor is for Routine to call it
within its own constructor.
::


argument::func
A Function with code for the Thread to run.

argument::stackSize
Call stack size (an Integer).

instanceMethods::

method:: parent
The parent Thread that started or resumed this Thread.

discussion::

The parent Thread's execution is blocked until the child Thread finishes or is suspended.

When a child Thread is started or resumed, it inherits certain aspects from its parent:
list::
## associated link::#-clock#Clock::
## associated link::#-beats#logical time::
::


method::beats
Get or set the current logical time of the Thread in beats. This will be the same
as the time in seconds, unless this Thread's link::#-clock#clock:: is
link::Classes/TempoClock::, and the clock's link::Classes/TempoClock#-tempo#tempo::
 is other than code::1::.

Setting code::beats:: also sets link::#-seconds:: to
code:: thisThread.clock.beats2secs(beats) ::.

discussion::

There are several sources of logical time:
list::
## When code is run from the code editor, the command line, or in response to OSC
and MIDI messages, the link::Classes/Process#-mainThread#main Thread::'s logical time is
set to the current strong::physical time:: (see link::Classes/Process#*elapsedTime::).

## When code strong::scheduled:: on a link::Classes/Clock:: is run, the
link::Classes/Process#-mainThread#main Thread::'s logical time is set to the time the code
was scheduled for.

## Child Threads strong::inherit:: logical time from their link::#-parent#parents::
 - whenever a Thread (Routine) is started or resumed, its logical time is set to
that of the parent Thread.
::

However, a Thread's logical time may also be set strong::manually:: (using this
method or link::#-seconds::). It may be useful to change the strong::current:: Thread's
time in order to manipulate behavior of streams that use the current logical time for
their operation (e.g. streams created by link::Classes/Pstep:: and
link::Classes/Pseg:: patterns). This will affect all code running within the current
Thread, as well as any child Threads, due to logical time inheritance. Note however
that changing strong::another:: Thread's time will have no effect, because the time
will be overridden by inheritance as soon as the Thread is run; likewise, any changes
to the current Thread's time only have effect until the Thread is suspended
(it link::Classes/Object#-yield#yields::) and resumed again.

See also: link::Classes/Clock#Scheduling and Threads::.

method::seconds
Get or set the current logical time of the Thread in seconds.

Setting code::seconds:: also sets link::#-beats:: to
code::thisThread.clock.secs2beats(seconds)::.

See link::#-beats:: for general discussion on Threads and logical time.

method::clock
Get or set the Thread's associated link::Classes/Clock::.

discussion::

There are several ways a Clock becomes associated with a Thread:
list::
## When code is run from the code editor, the command line, or in response to OSC and
MIDI messages, the link::Classes/Process#-mainThread#main Thread::'s clock is set to
link::Classes/SystemClock::.

## When code strong::scheduled:: on a Clock is run, that clock becomes the
link::Classes/Process#-mainThread#main Thread::'s clock.

## Child Threads strong::inherit:: the associated clock from their
link::#-parent#parents::.
::

A Thread's associated clock may also be set strong::manually:: using this method. Setting
the strong::current:: Thread's clock is useful to manipulate further behavior of the
Thread or its child Threads, but the clock will be reset the next time the Thread
is resumed, due to clock inheritance. For the same reason, setting
strong::another:: Thread's clock will have no effect on code running on it.

See also: link::Classes/Clock#Scheduling and Threads::.

method::isPlaying
Returns:: true if it is playing.

method::state

The internal state values for a Thread instance can be polled:
table::
## 0 || not started
## 7 || running
## 8 || stopped
::

subsection::Seeding the random number generator

see also: link::Reference/randomSeed::

method::randSeed
Set the random number generator seed using a single integer.
discussion::
Example:
code::
#+BEGIN_SRC sclang
g = thisThread.randSeed = 4;
10.do{1.0.rand2.postln};
#+END_SRC

::

method::randData

Get or set the three integer array which defines the internal basis for the random number generator.  You can use this to get back the exact same random number sequence, and it provides a mechanism for automatic replay for generative music.
discussion::
Example:
code::
#+BEGIN_SRC sclang
g = thisThread.randData;
10.do{1.0.rand2.postln};
#+END_SRC

::
code::
#+BEGIN_SRC sclang
// each time the seed is reset, the random number generation should give the same sequence
thisThread.randData_(Int32Array[ -662787342, 1546785953, 1661466823 ]);
10.do{1.0.rand2.postln};
#+END_SRC

::

** class::Thunk
summary::unevaluated value
categories::Core>Kernel

description::

Thunk, "past tense of think", can be used 	when a calculation may, or may not have to be performed at a later point in time, and its value is needed several times. This is an example of lazy evaluation, and can be used to avoid unnecessary calculations and to make state immutable.

classMethods::

method::new

argument::function
some function that returns the desired value

instanceMethods::

method::value

return the value. If calculation is done, use previous value, otherwise do calculation.

examples::

code::
#+BEGIN_SRC sclang
// so for example, random values will result in a single instance:
a = Thunk({ \done.postln; rrand(2.0, 8.0) });
a.value; // posts "done"
a.value;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// it is an AbstractFunction, so one can use it for math operations:

a = Thunk({ rrand(2.0, 8.0) });
b = a * 5 / (a - 1);
b.value;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// lazy evaluation

a = Thunk({ \done1.postln; Array.fill(10000, { |i| i + 6 % 5 * i / 2 }) }); // some calculation.
b = Thunk({ \done2.postln;Array.fill(10000, { |i| i + 5 % 6 * i / 3 }) });// some other calculation.
c = [a, b].choose + 700;
(c * c * c).value; // caclulation happens here, and only once.

// compare to a function:

a = { \done1.postln; Array.fill(10000, { |i| i + 6 % 5 * i / 2 }) }; // some calculation.
b = { \done2.postln;Array.fill(10000, { |i| i + 5 % 6 * i / 3 }) };// some other calculation.
c = [a, b].choose + 700;
(c * c * c).value; // calculation happens here, but 3 times (for each c)
#+END_SRC

::

** class:: Timer
summary:: Returns time since last triggered.
categories::  UGens>Triggers

Description::
Timer returns time since last triggered.

classmethods::
private:: categories

method::ar, kr

argument::trig

A trigger occurs when trig signal crosses from non-positive to positive.


Examples::

code::
#+BEGIN_SRC sclang

// using timer to modulate sine frequency: the slower the trigger is the higher the frequency
(
{ var trig;
	trig = Impulse.kr(MouseX.kr(0.5, 20, 1));
	SinOsc.ar(Timer.kr(trig) * 500 + 500, 0, 0.2)
}.play;
)
#+END_SRC

::

** class:: ToggleFF
summary:: Toggle flip flop.
related:: Classes/SetResetFF
categories::  UGens>Triggers


Description::

Toggles between 0 and 1 upon receiving a trigger.


classmethods::

method::ar, kr

argument::trig

Trigger input.


Examples::

code::
#+BEGIN_SRC sclang

(
play({
	SinOsc.ar((ToggleFF.ar(Dust.ar(XLine.kr(1,1000,60))) * 400) + 800, 0, 0.1)
}))
#+END_SRC

::

** class:: TouchResponder
summary:: allow functions to be registered to respond to MIDI aftertouch events
related:: Classes/MIDIFunc, Classes/MIDIdef, Classes/MIDIResponder, Classes/CCResponder
categories:: External Control>MIDI

Description::
note:: SC 3.5 added the link::Classes/MIDIFunc:: and link::Classes/MIDIdef:: classes. These are faster, and aim to have a more convenient, logical and consistent interface, which shares a common design with link::Classes/OSCFunc:: and link::Classes/OSCdef::.They still lack some features of the MIDIresponder classes.::
ClassMethods::

method::new

argument::function
A link::Classes/Function:: to be evaluated. Arguments passed to the function are: src, chan, value.

argument::src
The src number may be the system UID (obtained from code:: MIDIClient.sources[index].uid ::) or the index of the source in the code:: MIDIClient.sources :: array. nil matches all.

argument::chan
An link::Classes/Integer:: between 0 and 15 that selects which MIDI channel to match. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 2 }

argument::value
An link::Classes/Integer:: between 0 and 127 to filter values. nil matches all. May also be a link::Classes/Function:: which will be evaluated to determine the match. eg: { |val| val < 50 }

argument::install
If true, install the responder automatically so it is active and ready to respond. If false, then it will be inactive.

argument::swallowEvent
If true, then if the midi event is matched, cease testing any further responders. Note that doing this will prevent any other responders of this type from responding, including ones added behind the scenes in classes. Note also that this functionality is sensitive to the order in which responders are added. 

InstanceMethods::

method::learn
Wait for the next aftertouch message, reset self to match src, chan.
code::
#+BEGIN_SRC sclang
(
c = TouchResponder({ |src,chan,value|
		[src,chan,value].postln;
	});
	c.learn; // wait for the first touch message
)
TouchResponder.removeAll
#+END_SRC

::


Examples::

code::
#+BEGIN_SRC sclang
(
	c = TouchResponder({ |src,chan,val|
		[src,chan,val].postln;
		},
		nil, // any source
		nil, // any channel
		nil // any value
	)
)

c.remove
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
	c = TouchResponder({ |src,chan,val|
		[src,chan,val].postln;
		},
		nil, // any source
		nil, // any channel
		(50..90) // values within this range
	)
)

c.remove
#+END_SRC

::
** CLASS:: TreeView
redirect:: implClass
summary:: A view displaying a tree of items with columns
categories:: GUI>Views

DESCRIPTION::

A view that displays a hierarchy of items. It is divided into rows and column: each row represents an item, and each column represents a different data field of the items.

The items are represented in code by instances of link::Classes/QTreeViewItem::, returned by the various TreeView methods. Top level items are added via the TreeView interface, while child items are added via the QTreeViewItem interface, which also allows to manipulate items in more detail after their creation.

Items can be visually sorted with link::#-sort::, or by clicking on one of the column headers, if link::#-canSort:: is enabled.

Each item can hold other views in each of its data fields, which allows for rich graphical interaction. See link::Classes/QTreeViewItem#-setView::.


CLASSMETHODS::

PRIVATE:: key

INSTANCEMETHODS::

PRIVATE:: prForEachColumnDataPair
PRIVATE:: prValidItem


SUBSECTION:: Data

METHOD:: columns
	Gets or sets the number of columns (data fields) and their names. When setting a smaller number of columns than the current the extra columns will be removed, and hence all the data stored stored in those columns.

	ARGUMENT::
		An array of Strings for column names.

METHOD:: numColumns
	The total number of columns (data fields).

METHOD:: addItem
	Append a new top-level item.

	ARGUMENT:: strings
		An array of Strings (or nil), each for the text of one data field.
	RETURNS::
		An instance of QTreeViewItem representing the new item.

METHOD:: insertItem
	Insert a new top-level item at code::index::.

	ARGUMENT:: index
		The position at which to insert the item.
	ARGUMENT:: strings
		An array of Strings (or nil), each for the text of one data field.
	RETURNS::
		An instance of QTreeViewItem representing the new item.

METHOD:: removeItem
	Remove the given code::item::. After the item is removed, any usage of the related QTreeViewItems will have no effect.

	ARGUMENT::
		An instance of QTreeViewItem.

METHOD:: numItems
	The total number of items.

METHOD:: clear
    Removes all items.

METHOD:: currentItem
	Gets or sets the currently selected item.

	ARGUMENT::
		An instance of QTreeViewItem.
	RETURNS::
		An instance of QTreeViewItem or nil, if no current item.

METHOD:: itemAt
	The item at code::index::.



SUBSECTION:: Appearance

METHOD:: sort
	Sort items by data in code::column::. This works regardless of link::#-canSort::.

	NOTE:: Sorting has no effect on the logical order of the items, it only affects how they are displayed. ::

	ARGUMENT:: column
		The integer column index to sort by.
	ARGUMENT:: descending
		Whether to sort in descending or ascending fashion. The default is ascending.

PRIVATE:: background


SUBSECTION:: Interaction

METHOD:: canSort
	Whether the user can sort the items by clicking on a column header.

	When setting to code::true::, the items will be sorted immediately according to the current sorting column. While code::true::, the view will also automatically sort new items.

	The default is code::false::.

	See also: link::#-sort::.




SUBSECTION:: Actions

METHOD:: itemPressedAction
	The object to be evaluated when a mouse button is pressed on an item, passing this view as the argument.

METHOD:: onItemChanged
	The object to be evaluated whenever the current item changes, passing this view as the argument.
** class:: Trig
summary:: Timed trigger.
related:: Classes/Trig1
categories::  UGens>Triggers


Description::

When a nonpositive to positive transition occurs at the input, Trig
outputs the level of the triggering input for the specified duration,
otherwise it outputs zero.


classmethods::

method::ar, kr

argument::in

Trigger. Trigger can be any signal. A trigger happens when the
signal changes from non-positive to positive.


argument::dur

Duration of the trigger output.


Examples::

code::
#+BEGIN_SRC sclang

{ Trig.ar(Dust.ar(1), 0.2) * FSinOsc.ar(800, 0.5) }.play

{ Trig.ar(Dust.ar(4), 0.1) }.play
#+END_SRC

::

** class:: Trig1
summary:: Timed trigger.
related:: Classes/Trig
categories::  UGens>Triggers


Description::

When a nonpositive to positive transition occurs at the input, Trig1
outputs 1 for the specified duration, otherwise outputs 0.


classmethods::

method::ar, kr

argument::in

Trigger. Trigger can be any signal. A trigger happens when the
signal changes from non-positive to positive.


argument::dur

Duration of the trigger output.


Examples::

code::
#+BEGIN_SRC sclang

{ Trig1.ar(Dust.ar(1), 0.2) * FSinOsc.ar(800, 0.5) }.play


To create a fixed duration gate
(

SynthDef("trig1",{ arg dur=0.125;
	var gate;
	gate = Trig1.kr(1.0,dur);
	OffsetOut.ar(0,
		SinOsc.ar(800, 0.3)
		* EnvGen.kr(
			Env([0,0.1,0.1,0],[0.01,1.0,0.01],[-4,4],2),
			gate,
			doneAction: 2)
	)
}).send(s);

Routine({
	1.0.wait;
	100.do({
		s.sendBundle(0.05,["s_new", "trig1" ,-1,0,0,0,rrand(0.02,0.25)]);
		0.25.wait
	})
}).play(SystemClock)

)

This should sound like a continous sine wave, although it is actually a series of 0.25 second synths.
(
SynthDef("trig1",{
	var gate;
	gate = Trig1.kr(1.0,0.25);
	OffsetOut.ar(0,
		SinOsc.ar(800, 0.3)
		* EnvGen.kr(
			Env([0,0.1,0.1,0],[0.01,1.0,0.01],[-4,4],2),
			gate,
			doneAction: 2)
	)
}).send(s);

Routine({
	1.0.wait;
	100.do({
		s.sendBundle(0.05,["s_new", "trig1" ,-1]);
		0.25.wait
	})
}).play(SystemClock)

)
#+END_SRC

::

** class:: TrigControl
summary:: FIXME: TrigControl purpose.
related:: Classes/Control, Classes/LagControl
categories::  UGens>Synth control, UGens>Undocumented


Description::

FIXME: TrigControl description.


classmethods::

method::kr, ir

argument::values

FIXME: explain parameter values.


method::names

argument::names

FIXME: explain parameter names.


returns:: Returns:

A newly created
link::Classes/UGen:: .


** class::True
categories::Core
summary::true logical value

description::
see link::Classes/Boolean::
** CLASS::Tuning
summary::represents a musical tuning
related::Classes/Scale
categories:: Tuning

DESCRIPTION::
Represents a musical tuning (e.g. equal temperament, just intonation, etc.). Used in conjunction with link::Classes/Scale:: to generate pitch information.

code::
#+BEGIN_SRC sclang
t = Tuning.et12;
t.semitones;		// [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ]
t.ratios;		// [ 1, 1.0594630943591, 1.1224620483089, 1.1892071150019, etc. ]

Pbind(\scale, Scale.major(t), \degree, Pseq((0..7) ++ (6..0) ++ [\rest], 1), \dur, 0.25).play;

// use non-standard tuning
t = Tuning.just;
t.semitones;		// [ 0, 1.1173128526978, 2.0391000173077, 3.1564128700055, etc. ]
t.ratios.collect(_.round(0.001));	// [ 1, 1.067, 1.125, 1.2, 1.25, 1.333, 1.406, 1.5, etc. ]

Pbind(\scale, Scale.major(t), \degree, Pseq((0..7) ++ (6..0) ++ [\rest], 1), \dur, 0.25).play;
#+END_SRC

::

subsection::Creation

strong::just, pythagorean, werckmeister, johnston, partch, wcAlpha, bp, etc.::

Creates a tuning from the library stored in link::Classes/TuningInfo::. For a complete list of available tunings, execute
code::
#+BEGIN_SRC sclang
Tuning.directory
#+END_SRC

::

CLASSMETHODS::

method::et
Creates an equal-tempered scale based on pitchesPerOctave.

method::choose
Creates a random tuning from the library, constrained by size (which defaults to 12).
code::
#+BEGIN_SRC sclang
Scale.major(Tuning.choose).tuning.name;
#+END_SRC

::

method::new
Creates a Tuning using some or all of the parameters as follows: strong::tuning:: can be the name of a library tuning (in which case that tuning is returned); an array of floats representing the semitone values of the tuning (in which case pitchesPerOctave will be set to the size of the array regardless of the second parameter); or nil (in which case the default tuning for strong::pitchesPerOctave:: will be returned). strong::octaveRatio:: defaults to 2.0, but can be set differently for stretched or compressed tunings.
code::
#+BEGIN_SRC sclang
Tuning.new(\et12);	// standard equal temperament
// custom tuning
Tuning.new(#[ 0, 0.795, 2.251, 3.251, 4.036, 4.680, 5.915, 7.221, 8.013, 9.29, 9.930, 11.032 ]);
Tuning.new((0..11).collect(_ * (2.08 ** (1/12))), 2.08, "Stretched ET12");
#+END_SRC

::

INSTANCEMETHODS::

private::storeOn, storedKey, storeArgs, printOn

method::semitones
Returns an array of semitone values for the pitch set. link::#-as::(Array) is equivalent; link::#-as::(List) returns it as a list, etc.

method::cents
Returns a array of cent values for the pitch set.

method::ratios
Returns a tuned array of ratios for the pitch set.

EXAMPLES::

For examples of use, see the link::Classes/Scale:: help file.
** class:: TwoPole
summary:: Two pole filter.
related:: Classes/TwoZero
categories::  UGens>Filters>Linear


Description::

A two pole filter. This provides lower level access to setting of pole
location. For general purposes  link::Classes/Resonz::  is better.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Frequency of pole angle.


argument::radius

Radius of pole. Should be between 0 and +1.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang

{ TwoPole.ar(WhiteNoise.ar(0.005), 2000, 0.95) }.play

{ TwoPole.ar(WhiteNoise.ar(0.005), XLine.kr(800,8000,8), 0.95) }.play

{ TwoPole.ar(WhiteNoise.ar(0.005), MouseX.kr(800,8000,1), 0.95) }.play
#+END_SRC

::

** CLASS::TwoWayIdentityDictionary
summary::associative collection mapping keys to values and back
related::Classes/IdentityDictionary
categories::Collections>Unordered

DESCRIPTION::
Similar to link::Classes/IdentityDictionary::, but allows to go efficiently from element to key and back. The contents of a TwoWayIdentityDictionary are strong::unordered::. You must not depend on the order of items.

INSTANCEMETHODS::

private::init

method::getID
Find the key for a given object. If object is not element of the dictionary, it returns nil.

EXAMPLES::

code::
#+BEGIN_SRC sclang
a = TwoWayIdentityDictionary.new;
a.put(\test, 999);
a.put(["some", "strings"], 1200);
a.at(\test);
a.getID(999);
a.getID(1200);
a.getID(888); // nil
#+END_SRC

::class:: TwoZero
summary:: Two zero filter.
related:: Classes/TwoPole
categories::  UGens>Filters>Linear


Description::

A two zero filter.


classmethods::

method::ar, kr

argument::in

The input signal.


argument::freq

Frequency of zero angle.


argument::radius

Radius of zero.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang

{ TwoZero.ar(WhiteNoise.ar(0.125), XLine.kr(20,20000,8), 1) }.play
#+END_SRC

::

** class:: UGen
summary:: Abstract superclass of all unit generators
categories:: UGens, Server>Abstractions
related:: Browse#UGens, Guides/Tour_of_UGens, Guides/UGens-and-Synths

description::

UGens represent calculations with signals. They are the basic building blocks of synth definitions on the server, and are used to generate or process both audio and control signals. The many subclasses of UGen are the client-side representations of unit generators, and are used to specify their parameters when constructing synth definitions (see link::Classes/SynthDef::).

subsection:: Interface
All UGens respond to one or more of the following class methods:
list::
## code:: ar(arg1, arg2, ... ) ::
## code:: kr(arg1, arg2, ... ) ::
## code:: ir(arg1, arg2, ... ) ::
::

They return a new instance of UGen that calculates at audio/control rate or at initialization only (ir). Some UGens, like link::Classes/Rand::, use the code::*new:: method instead. These methods are implemented in subclasses, where argument names and their meaning depend on the case.

If any argument is an array, they return an array of UGens ( see: link::Guides/Multichannel-Expansion:: ). If the combination of rates between arguments and ugen are not allowed, calling the methods will throw an error. This method adds the UGen to the current SynthDef, so it only fully works inside a UGen function.
code::
#+BEGIN_SRC sclang
{ Blip.ar(Blip.kr(4, 5, 500, 60), 59, 0.1) }.play;
#+END_SRC

::

subsection:: Documentation of mul and add arguments

A great number of UGens take arguments for code::mul:: and code::add:: in their code::*ar:: and code::*kr:: methods. Because these arguments are so ubiquitous, they are not general documented in the individual help files.
Mul and add simply refer to a constant or signal by which to multiply the output of the UGen, and a constant or signal to add to the output of the UGen. (mul happens before add.) They thus correspond in many cases to scaling the amplitude of the UGen signal in the case of mul, and adding a constant or DC offset in the case of add.
In most cases the defaults for mul and add are 1 and 0 respectively, and they are commonly implemented using a automatically generated link::Classes/MulAdd:: UGen for efficiency. See also the code::range:: and code::madd:: methods below.

classmethods::
private:: categories

method:: buildSynthDef
Returns:: the SynthDef in which the UGen is situated.
Discussion::
code::
#+BEGIN_SRC sclang
{ UGen.buildSynthDef.dump; Silent.ar }.play;
#+END_SRC

::

subsection:: Internally used class methods

method:: multiNew
These methods are responsible for multichannel expansion. They call code::*new1(rate, ...args):: for each parallel combination. Most code::*ar/*kr:: methods delegate to link::#*multiNewList::.
argument:: ... args
The first argument is rate, then the rest of the arguments. code::(rate, ...args)::

method:: multiNewList
See link::#*multiNew::.
argument:: args
An array where the first argument is rate, then the rest of the arguments. code::([rate, ...args])::

method:: new1
This method returns a single instance of the UGen, not multichannel expanded. It is called inside multiNewList, whenever a new single instance is needed.

method:: methodSelectorForRate
argument:: rate
A link::Classes/Symbol::, code:: \audio, \control, \scalar ::
Returns::
An appropriate message selector ( link::Classes/Symbol:: like code:: \ar, \kr, \ir :: ) for the given rate.

method:: replaceZeroesWithSilence
Returns::
A new link::Classes/Array::, where every zero is replaced by a link::Classes/Silent:: UGen.
discussion::
This is required internally sometimes for UGens like link::Classes/Out::.

instancemethods::

subsection:: Convenience Methods

method:: scope

Displays the output of this UGen in an individual link::Classes/Stethoscope:: window.
argument::name
The name of the window
argument::bufsize
Buffer size
argument::zoom
Zoom factor

discussion::
code::
#+BEGIN_SRC sclang
s.boot

{ Ringz.ar(PinkNoise.ar([0.1, 0.2]).scope(\pink), 2000, 1, 0.25) }.play; // multichannel works
s.scope; // can still separately scope the output of the server
#+END_SRC

::

method:: poll

Polls the output of this UGen every interval seconds, and posts the result.

argument::trig
Trig frequency
argument::label
A symbol to label the output
argument::trigid
Numerical ID
discussion::
The default trig is 10, which converts to 10 triggers per second (or every 0.1 seconds). See link::Classes/Poll:: for more info on polling.
code::
#+BEGIN_SRC sclang
{ SinOsc.ar(LFNoise0.ar(2).range(420, 460).poll(label: \LFNoise), 0, 0.2) }.play;

// multichannel polling:
(
{
    var freqs = SinOsc.ar([0.2, 0.3]).range(420, 460);
    freqs.poll(label: [\freq1, \freq2]);
    SinOsc.ar(freqs, 0, 0.2);
}.play;
)
#+END_SRC

::


method:: dpoll

Like code::poll::, only that code::dpoll:: is used for Demand ugens. See link::Classes/Poll:: for more info on polling.

method:: range

Scales the output of this UGen to be within the range of code::lo:: and code::hi::.
discussion::
Note that code::range:: expects the default output range, and thus should not be used in conjunction with mul and add arguments.
code::
#+BEGIN_SRC sclang
{ SinOsc.ar(SinOsc.ar(0.3).range(440, 660), 0, 0.5) * 0.1 }.play;
#+END_SRC

::

method:: exprange

Maps the output of this UGen exponentially to be within the range of code::lo:: and code::hi:: using a link::Classes/LinExp:: UGen.
discussion::
code::lo:: and code::hi:: should both be non-zero and have the same sign. Note that code::exprange:: expects the default output range, and thus should not be used in conjunction with mul and add arguments.
code::
#+BEGIN_SRC sclang
{ SinOsc.ar(SinOsc.ar(0.3).exprange(440, 6600), 0, 0.5) * 0.1 }.play;
#+END_SRC

::

method:: unipolar

Scales the output of this UGen to be between code::(0..mul):: range (default 1).
discussion::
Note that code::unipolar:: expects the default output range, and thus should not be used in conjunction with mul and add arguments.
code::
#+BEGIN_SRC sclang
{ SinOsc.ar(300, 0, 0.5) * SinOsc.kr(2).unipolar * 0.1 }.play;
#+END_SRC

::

method:: bipolar

Scales the output of this UGen to be between code::(-mul..mul):: range (default 1).
discussion::
Note that code::bipolar:: expects the default output range, and thus should not be used in conjunction with mul and add arguments.
code::
#+BEGIN_SRC sclang
{ SinOsc.ar(500 + LFPulse.ar(4).bipolar(40), 0, 0.5) * 0.1 }.play;
#+END_SRC

::

method:: clip
Wraps the receiver in a link::Classes/Clip:: UGen, clipping its output at code::lo:: and code::hi::.

method:: fold
Wraps the receiver in a link::Classes/Fold:: UGen, folding its output at code::lo:: and code::hi::.

method:: wrap
Wraps the receiver in a link::Classes/Wrap:: UGen, wrapping its output at code::lo:: and code::hi::.

method:: blend
Blends code::this:: with code::that:: by wrapping the receiver in an link::Classes/XFade2:: (if code::this:: or code::that:: are audio-rate UGens) or link::Classes/LinXFade2:: UGen.
note:: The code::blendFrac:: argument is between 0 and 1::


method:: lag
Wraps the receiver in a link::Classes/Lag:: UGen, smoothing its output by code::t1:: seconds lagtime. If a second argument is given, it wraps it in a link::Classes/LagUD:: UGen.

method:: lag2
Wraps the receiver in a link::Classes/Lag2:: UGen, smoothing its output by code::t1:: seconds lagtime. If a second argument is given, it wraps it in a link::Classes/Lag2UD:: UGen.

method:: lag3
Wraps the receiver in a link::Classes/Lag3:: UGen, smoothing its output by code::t1:: seconds lagtime. If a second argument is given, it wraps it in a link::Classes/Lag3UD:: UGen.

method:: lagud
Wraps the receiver in a link::Classes/LagUD:: UGen, smoothing its output by code::lagtimeU:: and code::lagtimeD::.

method:: lag2ud
Wraps the receiver in a link::Classes/Lag2UD:: UGen, smoothing its output by code::lagtimeU:: and code::lagtimeD::.

method:: lag3ud
Wraps the receiver in a link::Classes/Lag3UD:: UGen, smoothing its output by code::lagtimeU:: and code::lagtimeD::.

method:: varlag
Wraps the receiver in a link::Classes/VarLag:: UGen, smoothing its output by code::time:: seconds.

method:: slew
Wraps the receiver in a link::Classes/Slew:: UGen, limiting the slope of its output.

method:: degreeToKey

Wraps the receiver in a link::Classes/DegreeToKey:: UGen.

method:: minNyquist

Wraps the receiver in a code::min:: link::Classes/BinaryOpUGen::, such that the lesser of the receiver's output and the Nyquist frequency is output. This can be useful to prevent aliasing.

method:: linlin
Wraps the receiver so that a linear input range is mapped to a linear output range.

discussion::
The clip argument can be one of the four:
table::
## code::nil:: || do not clip at outMin or outMax
## code::\minmax:: || clip at outMin or outMax
## code::\min:: || clip at outMin
## code::\max:: || clip at outMax
::
Example:
code::
#+BEGIN_SRC sclang
{ Line.ar(-1, 5, 0.1).linlin(0, 3, -1, 1) }.plot(0.1);

// modulate some values
(
{ Line.ar(-1, 5, 0.1).lincurve(SinOsc.ar(100), SinOsc.ar(130) + 3, -1, 1, clip: nil) }
    .plot(0.1, minval: -15, maxval: 5)
)
#+END_SRC

::

method:: linexp

Wraps the receiver so that a linear inputrange is mapped to an exponential output range.
discussion::
outMin and outMax must be nonzero and of the same sign. For clip argument, see code::linlin:: above.
code::
#+BEGIN_SRC sclang
{ Line.ar(-1, 5, 0.1).linexp(0, 3, 0.01, 1) }.plot(0.1);
#+END_SRC

::

method:: explin

Wraps the receiver so that an exponential inputrange is mapped to a linear output range.
discussion::
inMin and inMax must be nonzero and of the same sign. For clip argument, see code::linlin:: above.
code::
#+BEGIN_SRC sclang
{ Line.ar(1, 5, 0.1).explin(1, 3, -1, 1) }.plot(0.1);
#+END_SRC

::

method:: expexp

Wraps the receiver so that an exponential inputrange is mapped to an exponential output range.
discussion::
outMin, outMax, inMin and inMax must be nonzero and of the same sign. For clip argument, see code::linlin:: above.
code::
#+BEGIN_SRC sclang
{ Line.ar(1, 5, 0.1).expexp(1, 3, 0.01, 1) }.plot(0.1);
#+END_SRC

::

method:: lincurve

Wraps the receiver so that a linear inputrange is mapped to a curve-like exponential output range.
discussion::
outMin and outMax may be zero and of the different sign. For clip argument, see code::linlin:: above.
code::
#+BEGIN_SRC sclang
{ Line.ar(-1, 5, 0.1).lincurve(0, 3, -1, 1, curve: -4) }.plot(0.1);

// modulate the curve. Unlike with numbers and CurveSpec, the curve absolute value
// should not be much smaller than 0.5.
{ SinOsc.ar(100).lincurve(-1, 1, -1, 1, XLine.kr(-3, -100, 0.1)) * 0.1 }.plot(0.1);
#+END_SRC

::

method:: curvelin
Wraps the receiver so that a  curve-like exponential inputrange is mapped to a linear output range.
discussion::
inMin and inMax may be zero and of the different sign. For clip argument, see code::linlin:: above.
code::
#+BEGIN_SRC sclang
{ Line.ar(-1, 5, 0.1).curvelin(0, 3, -1, 1, curve: -4) }.plot(0.1);
#+END_SRC

::

method:: prune
Limits the receiver range to one of the four clip modes, see code::linlin:: above.

method:: checkBadValues
Wraps the receiver in a link::Classes/CheckBadValues:: UGen with the corresponding code::id:: and code::post:: flag.

method:: if
Outputs trueUGen when the receiver outputs 1, falseUGen when the receiver outputs 0. If the receiver outputs a value between 0 and 1, a mixture of both will be played.
discussion::
This is implemented as: code::(this * (trueUGen - falseUGen)) + falseUGen)::

Note that both trueUGen and falseUGen will be calculated regardless of whether they are output, so this may not be the most efficient approach.
code::
#+BEGIN_SRC sclang
// note different syntax in these two examples
{ if( LFNoise1.kr(1.0, 0.5, 0.5) , SinOsc.ar, Saw.ar ) * 0.1 }.play;

{ Trig1.ar(Dust.ar(3), 0.2).lag(0.1).if(FSinOsc.ar(440), FSinOsc.ar(880)) * 0.1 }.play;
#+END_SRC

::

method:: @
Dynamic geometry support. Returns code::Point(this, y)::.
discussion::
code::
#+BEGIN_SRC sclang
{ (SinOsc.ar(1001) @ SinOsc.ar(1207)).rho }.scope;
#+END_SRC

::

method:: asComplex
Complex math support. Returns code::Complex(this, 0.0)::.

method:: dumpArgs
Posts a list of the arguments for this UGen and their values.


subsection:: Other Instance Methods

The following methods and instance variables are largely used in the construction of synth definitions, synth descriptions (see link::Classes/SynthDesc::), UGen class definitions, etc., and are usually not needed for general use.
Users should not attempt to set any of these values in general code.

method:: synthDef
The SynthDef which contains the UGen.

method:: inputs
The array of inputs to the UGen.

method:: rate
The output rate of the UGen which is one of the link::Classes/Symbol::s code::\audio::, or code::\control::.

method:: signalRange
Returns:: A symbol indicating the signal range of the receiver. Either code::\bipolar:: or code::\unipolar::.

method:: numChannels
Returns:: The number of output channels.
discussion::
For a UGen, this will always be 1, but link::Classes/Array:: also implements this method, so multichannel expansion is supported. See link::Guides/Multichannel-Expansion::.

method:: numInputs
Returns:: The number of inputs for this UGen.

method:: numOutputs
Returns:: The number of outputs for this UGen.

method:: name
Returns:: The Class name of the receiver as a link::Classes/String::.

method:: madd
Wraps the receiver in a link::Classes/MulAdd:: UGen.
discussion::
This is for the most part only used in UGen class definitions in order to allow efficient implementation of code::mul:: and code::add:: arguments.

method:: isValidUGenInput
Returns:: true

method:: asUGenInput
Returns:: the receiver
discussion::
This method is implemented in a number of classes in order to allow objects like link::Classes/Node::s, link::Classes/Bus::ses, and link::Classes/Buffer::s to be passed directly as UGen inputs and link::Classes/Synth:: args.

method:: copy
Returns:: the receiver.
discussion::
Thus UGen-dup effectively returns a reference to the original and is a convenient way to copy a mono signal to multiple channels.
code::
#+BEGIN_SRC sclang
{ SinOsc.ar(Rand(200, 4000), 0, 0.2).dup }.plot // this is the same UGen
#+END_SRC

::
Function-dup evaluates that function multiple times, thus potentially returning distinct UGens.
code::
#+BEGIN_SRC sclang
{ { SinOsc.ar(Rand(200, 4000), 0, 0.2) }.dup }.plot // these are different UGens
#+END_SRC

::


subsection:: Internally used instance methods

method:: methodSelectorForRate
See link::#*methodSelectorForRate::

method:: init
By default, this method stores the inputs (e.g. the arguments to code::*ar:: and code::*kr::) in the UGen.
discussion::
This may be overridden to do other initialisations, as long as the inputs are set correctly.

** class::UnaryOpFunction
summary::represent a unary oparation on a function
related:: Classes/UnaryOpStream, Classes/Punop, Classes/BinaryOpFunction, Classes/NAryOpFunction
categories::Core

description::
Operating on functions instead of numbers, what results is not a result of the calculation, but a structure that represents that calculation.

examples::

code::
#+BEGIN_SRC sclang
a = 2.sqrt; // result is square root of two (approximate floating point).
a = { b }.sqrt; // result is  a UnaryOpFunction
b = 2;
a.value; // now it is evaluated, and the result is calculated
b = 9;
a.value; // again, with a different value.
#+END_SRC

::

code::
#+BEGIN_SRC sclang
// sound example
(
var a = { 19.rand };
var b = a.sqrt;
fork {
	15.do {
		(instrument: \default, note: [a.value, b.value]).play;
		0.3.wait;
	}
}
)
#+END_SRC

::
** class:: UnaryOpStream
summary:: stream modified by a unary operator
related:: Classes/BinaryOpStream, Classes/NAryOpStream
categories:: Streams-Patterns-Events

description::

A UnaryOpStream is created as a result of a unary math operation on a Stream. It is defined to respond to strong::next:: by returning the result of the math operation on the strong::next:: value from the stream. It responds to strong::reset:: by resetting the Stream.

Examples::

code::
#+BEGIN_SRC sclang
x = Routine { 6.do { arg i; i.yield; } }.squared;
x.dump;
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
x = Routine { 6.do { arg i; i.yield; } }.squared;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
x.next.postln;
)
#+END_SRC

::
** class:: UnaryOpUGen
summary:: Apply a unary operation to the values of an input ugen
categories:: UGens>Algebraic
related:: Classes/BinaryOpUGen, Classes/UnaryOpFunction, Classes/Punop, Overviews/Operators

description::
UnaryOpUGens are created as the result of a unary operator applied to a link::Classes/UGen::.
code::
#+BEGIN_SRC sclang
(SinOsc.ar(200).abs).dump;
(LFSaw.ar(200).sin).dump;
#+END_SRC

::
As in the examples given here, you don't usually need to instantiate UnaryOpUGen yourself.

The unary and binary operators are defined in link::Classes/UGen::'s superclass link::Classes/AbstractFunction::, which creates the
BinaryOpUGen as a result of the operation.

See link::Overviews/Operators:: for an overview of common operators.

classmethods::

method::new
return a new instance that applies the operator code::selector:: to the ugen code::a::

argument:: selector
The selector symbol for the unary operator
argument:: a
operand

examples::
code::
#+BEGIN_SRC sclang
a = WhiteNoise.ar; // a WhiteNoise
b = a.squared; // a UnaryOpUGen.
b.operator; // squared

// sound example

{ var a = LFSaw.ar(300).range(0, 2pi); a.sin * 0.1 }.play;

// Plotting the "abs" unary operator (via the server):

{ SinOsc.ar(300).abs }.plot
#+END_SRC

::
** class::UniqueID
summary::source for unique numbers
categories::Core

classmethods::

method::initClass

initialize the starting id.

method::next

get next id, which is unique to the system

examples::

code::
#+BEGIN_SRC sclang
// example
UniqueID.next;
UniqueID.next;
UniqueID.next;
#+END_SRC

::class:: UnixFILE
summary:: An abstract class
related:: Classes/File, Classes/Pipe
categories:: Files

InstanceMethods::

private::prGetLine, addOpenFile

method::isOpen
Returns whether the file is open. An open request can fail if a file cannot be found for example. This method lets you test that the open call succeeded.

method::pos
Answer the current file position

argument::offset
an offset in bytes.

argument::origin
one of the following link::Classes/Integer::s:
definitionList::
## 0 || seek from beginning of file.
## 1 || seek from current position in file.
## 2 || seek from end of file.
::

method::write
Writes an item to the file.

argument::item
one of the following:
definitionList::
## link::Classes/Float:: ||
## link::Classes/Integer:: ||
## link::Classes/Char:: ||
## link::Classes/Color:: ||
## link::Classes/Symbol:: || writes the name of the Symbol as a C string.
## link::Classes/RawArray:: || write the bytes from any RawArray in big endian.
::

method::getLine
reads and returns a link::Classes/String:: up to lesser of next newline or 1023 chars.

method::getChar
read one byte and return as a link::Classes/Char::.

method::getInt8
read one byte and return as a link::Classes/Integer::.

method::getInt16
read two bytes and return as an link::Classes/Integer::.

method::getInt32
read four bytes and return as an link::Classes/Integer::.

method::getFloat
read four bytes and return as a link::Classes/Float::.

method::getDouble
read eight bytes and return as a link::Classes/Float::.

method::putChar
write a link::Classes/Char:: as one byte.

method::putInt8
write an link::Classes/Integer:: as one byte. That is a signed link::Classes/Integer:: value between -128 and 127.

method::putInt16
write an link::Classes/Integer:: as two bytes.

method::putInt32
write an link::Classes/Integer:: as four bytes.

method::putFloat
write a link::Classes/Float:: as four bytes.

method::putDouble
write a link::Classes/Float:: as eight bytes.

method::putString
write a null terminated link::Classes/String::.
** class:: Unpack1FFT
summary:: Unpack a single value (magnitude or phase) from an FFT chain
categories:: UGens>FFT
related:: Classes/PackFFT, Classes/UnpackFFT


Unpack1FFT(chain, bufsize, binindex, whichmeasure=0)

description::
Takes an FFT chain and extracts a single scalar value as a demand-rate stream. To call it you need a "demander" which fires whenever the FFT chain fires - this is normally achieved using link::Classes/PackFFT:: but can also be done using link::Classes/Demand::.

Note::
The main purpose of this UGen is as a component in pvcollect, pvcalc, and pvcalc2 processes. You're welcome to use it on its own - the example below shows basic usage. But most people won't typically need to use it directly.
::

classmethods::
private:: categories

method:: new

argument:: chain
an FFT chain
argument:: bufsize
the size of the expected input FFT frames
argument:: binindex
the integer index of the bin you want to query
argument:: whichmeasure
0 for magnitude and 1 for phase. None of these arguments can be modulated.

examples::
code::
#+BEGIN_SRC sclang
(
s.boot.doWhenBooted{
	c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
}
)

// Let's extract the DC component - i.e. the magnitude at index zero.
(
x = {
	var fftsize = 1024;
	var sig, chain, unp;
	sig = PlayBuf.ar(1, c, BufRateScale.kr(c), loop: 1);
	chain = FFT(LocalBuf(fftsize), sig);

	unp = Unpack1FFT(chain, b.numFrames, 0, 0);

	// Demand some data from the unpacker
	Demand.kr(chain>=0, 0, unp).poll(chain>=0, "unpacked value");

	(sig*0.1).dup;
}.play(s);
)
x.free;
#+END_SRC

::

** class:: UnpackFFT
summary:: Unpack an FFT chain into separate demand-rate FFT bin streams
categories:: UGens>FFT
related:: Classes/PackFFT, Classes/Unpack1FFT

description::
Takes an FFT chain and separates the magnitude and phase data into separate demand-rate streams, for arithmetic manipulation etc.

This is technically a demand-rate UGen. The actual "demand" is usually created by PackFFT later on in the graph, which requests the values in order to re-pack the data. This allows for processing to occur imbetween...

See also pvcollect, pvcalc and pvcalc2 methods ( in link::Classes/PV_ChainUGen:: ) which provide convenient ways to process audio in the frequency domain. The help for pvcollect includes notes on efficiency considerations.

classmethods::
private:: categories

method:: new
argument:: chain
FFT chain
argument:: bufsize
FFT buffer size
argument:: frombin
limiting analysis to the bins of interest
argument:: tobin
limiting analysis to the bins of interest
returns::
A list from DC up to Nyquist of code:: [mag[0], phase[0], mag[1], phase[1], ... mag[nyquist], phase[nyquist]]. ::
discussion::
Note that you do have to decide your FFT buffer size in advance, since this determines how many values the UGen will output.
code::
#+BEGIN_SRC sclang
#magsphases = UnpackFFT(chain, bufsize)
#+END_SRC

::

examples::
code::
#+BEGIN_SRC sclang
(
s.boot.doWhenBooted {
	var fftsize = 1024;
	b = Buffer.alloc(s, fftsize, 1);
	c = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
}
)

// This one just drags out various the values and posts them - a little bit pointless!
(
x = {
	var sig, chain, unp;
	sig = SinOsc.ar;
	sig = PlayBuf.ar(1, c, BufRateScale.kr(c), loop: 1);
	chain = FFT(b, sig);

	// Using the frombin & tobin args makes it much more efficient, limiting analysis to the bins of interest
	unp = UnpackFFT(chain, b.numFrames, frombin: 0, tobin: 4);

	// Demand some data from the unpacker.
	// NOTE: At present, Demand.kr is unable to handle more than 32 inputs,
	// so using frombin & tobin to limit the number of bins is compulsory.
	Demand.kr(chain>=0, 0, unp).collect{|anunp, index|
		anunp.poll(chain>=0, if(index % 2 == 0,  "Magnitude", "Phase")+(index/2).floor);
	};

	(sig*0.1).dup;
}.play(s);
)
x.free;

// Now a simple frequency-domain manipulation, square-rooting the magnitudes AND phases.
(
x = {
	var in, chain, magsphases;
	in = PlayBuf.ar(1, c, BufRateScale.kr(c), loop: 1);
	chain = FFT(b, in);
	magsphases = UnpackFFT(chain, b.numFrames);
	magsphases = magsphases.collect(_.sqrt);
	PackFFT(chain, b.numFrames, magsphases);
	Out.ar(0, 0.25 * IFFT(chain).dup);
}.play(s);
)
x.free;
#+END_SRC

::

** CLASS:: UserView
redirect:: implClass
summary:: A custom drawn view using Pen
categories:: GUI>Views
related:: Classes/Pen

DESCRIPTION::
An empty view on which you can draw using the link::Classes/Pen:: class.

This view displays and does nothing by itself, but allows you to define how it will be drawn, and expects you to define its entire mode of interaction using mouse, key, and drag and drop actions.

To define how the view is drawn you set the link::#-drawFunc:: variable to a link::Classes/Function:: within which you can use the link::Classes/Pen:: class to draw graphical primitives, such as lines, rectangles, elipses, curves, and also text.

This class offers convenient mechanisms for creating animations, that is, to automatically redraw itself in regular time intervals. See the link::#animation#Animation:: section of this document.

For a guide to using this view, see link::Guides/GUI-Introduction#Custom views::. For a tutorial on how to write a emphasis::subclass:: of UserView to make your own custom view classes, see the link::Guides/UserView-Subclassing:: guide.



CLASSMETHODS::

PRIVATE:: key



INSTANCEMETHODS::

SUBSECTION:: Drawing

METHOD:: drawFunc

	Sets the Function to evalute whenever the view is asked to redraw itself. This may be, for example, due to being hidden and shown again, being resized, another view moving on top of it, or after the link::Classes/View#-refresh:: method has been called.

	Within that Function you are allowed to use the link::Classes/Pen:: class to draw withing the bounds of the view. All the coordinates given to methods of Pen are relative to the top-left corner of the view. Usage of Pen is not allowed outside of that Function.

	The Function will be passed this view as the argument when evaluated.

argument::
	A Function.


METHOD:: background
	Sets the color used to fill the whole area occupied by the view below the drawing done in link::#-drawFunc::. You can set the background at any moment, even within the code::drawFunc::, but any drawing done in that Function will always be displayed on top of the background.

	argument::
		A Color.

METHOD:: drawingEnabled
	Whether the link::#-drawFunc:: will be called when the view is redrawing itself. Note that link::#-background:: will be painted regardless of this variable.

	The default value is code::true::.

	argument::
		A Boolean.

METHOD:: clearOnRefresh
	Whether the view shall clear the last drawing done in link::#-drawFunc:: before being redrawn.

	If this is code::false::, the view will continuously draw on top of all the previous drawing whenever it is redrawn, until link::#-clearDrawing:: is called.

	The default value is code::true::.

	note:: On OSX this functionality is only available for the version >= 10.4. ::

	argument::
		A Boolean.

METHOD:: clearDrawing
	If link::#-clearOnRefresh:: is code::false::, you can call this method to manually clear any drawing done in link::#-drawFunc:: so far.



SUBSECTION:: Animation

METHOD:: animate
	Whether the view shall redraw itself internally at a regular time interval (frame rate). See link::#-frameRate:: for the way to adjust that interval.

	note:: This method is strong::not:: available in strong:: SwingOSC GUI ::. ::

	The default value is code::false::.

	argument::
		A Boolean.

METHOD:: frameRate
	The interval at which the view regularily redraws itself, if link::#-animate:: is code::true::.

	In strong:: Qt GUI :: you can change the desired frame rate by setting this variable.

	In strong:: Cocoa GUI :: this variable is not settable. Instead, use code::thisProcess.setDeferredTaskInterval(1/fps):: to change the global interval used for animation frame rate.

	The default frame rate is 60fps.

	note:: Getting the value of this variable will return the average actual frame rate. If it is lower than the desired frame rate set as described above, that implies that the view tries but does not manage to redraw itself at that frame rate. The reason may typically be that the drawing defined in link::#-drawFunc:: is computationally too demanding for the system.
	::

argument:: fps
	A Float defining the interval between frames of animation, in frames per second.

METHOD:: frame

	The count of frames drawn while link::#-animate:: is code::true::; it will increase by 1 every time the view is redrawn.

	If animation is stopped and started again (by setting code::animate:: to code::false:: and then code::true:: again), the frame count is restarted.

	returns:: An Integer.



SUBSECTION:: Actions

	The UserView by itself does not respond to any interaction by the user. You can define the modes of interaction entirely on your own using mouse and keyboard actions. See link::Guides/GUI-Introduction#Actions and hooks: make that button do something!#Actions and Hooks:: for detailed explanation.

	Note that there is no default mode of interaction with the UserView, so link::Classes/View#-action:: will never be triggered, if you don't implement that yourself.

EXAMPLES::

'Introduction to GUI' contains an link::Guides/GUI-Introduction#Custom views#example:: with elaborate explanation on how to use UserView. Below are further examples.

For a tutorial on how to write a emphasis::subclass:: of UserView to make your own custom view classes, see the link::Guides/UserView-Subclassing:: guide.

SUBSECTION:: Basic Usage

Resize the window or click on the UserView to refresh the drawing:

code::
#+BEGIN_SRC sclang
(
w=Window.new;
v=UserView(w, w.view.bounds.insetBy(50,50));
v.resize = 5;
v.background_(Color.rand);
v.drawFunc={|uview|
		Pen.moveTo(0@uview.bounds.height.rand);
		Pen.lineTo(uview.bounds.width@uview.bounds.height.rand);
		Pen.stroke;
	};
v.mouseDownAction={v.refresh};
w.front;
)
#+END_SRC

::

Coordinates are relative to the UserView. Try resizing the window:

code::
#+BEGIN_SRC sclang
(
var func;

func = {|me|
	Pen.use{
		10.do{
			Color.red(rrand(0.0, 1), rrand(0.0, 0.5)).set;
			Pen.addArc((400.exprand(2))@(100.rand), rrand(10, 100), 2pi.rand, pi);
			Pen.perform([\stroke, \fill].choose);
		}
	}
};

w = Window.new("DrawFunc Examples").front;
w.view.background_(Color.white);

3.do{|i|
	v = UserView(w, Rect(20+(i*120), 100, 100, 100))
		.drawFunc_(func);
	v.resize=3; // the func coordinates ar valid even though the view move on resize
	v.background_(Color.rand);
};

w.refresh;
)
#+END_SRC

::

SUBSECTION:: Responding to mouse clicks and movement

Using link::Classes/View#Mouse actions#mouse actions:: you can make UserView change the way it is drawn in response to mouse interaction. The sequence of examples below will guide you through the various possibilities.

Clicking and moving the mouse on each of the painted squares in the following example will redraw them differently. See interpreter output for posted information that you can use in the mouse actions.

code::
#+BEGIN_SRC sclang
(
var drawFunc, mouseDownFunc, mouseUpFunc, mouseMoveFunc, sat = 0, startX;

drawFunc = {|me|
	Pen.use{
		10.do{
			Color.red(rrand(0.0, 1), rrand(0.3, 0.8)).set;
			Pen.addArc((400.exprand(2))@(100.rand), rrand(10, 50), 2pi.rand, pi);
			Pen.perform([\stroke, \fill].choose);
		}
	}
};

mouseDownFunc = {|me, x, y, mod|
	startX = x;
	postf("begin path: x=% realtive mouse coordinates:%\n",startX, x@y);
};

mouseUpFunc = {|me, x, y, mod|
	postf("end path: (startX-x)==% mouse coordinates:%\n",(startX-x), x@y);
};

mouseMoveFunc = {|me, x, y, mod|
	sat = ((startX-x)/100);
	(x@y).postln;
	me.refresh;
};

w = Window.new.front;
w.view.background_(Color.white);
3.do{|i|
	v = UserView(w, Rect(20+(i*120), 100, 100, 100));
	v.background_(Color.rand);
	v.drawFunc = drawFunc;
	v.mouseDownAction = mouseDownFunc;
	v.mouseUpAction = mouseUpFunc;
	v.mouseMoveAction = mouseMoveFunc;
};
w.refresh;
)
#+END_SRC

::

The following example uses the link::#-clearOnRefresh:: option to prevent the UserView from clearing its contents when redrawn. Clicking and moving the mouse within each square will draw ever more arcs on top of each other.

code::
#+BEGIN_SRC sclang
(
var func, views;

func = {|me|
	Pen.use{
		1.do{
			Color(
				rrand(0.0, 1),
				rrand(0.0,0.2),
				rrand(0.0, 0.8),
				rrand(0.4, 0.8)
			).set;
			Pen.addArc((400.exprand(2))@(100.rand), rrand(10, 50), 2pi.rand, pi);
			Pen.perform([\stroke, \fill].choose);
		}
	}
};

w = Window.new("DrawFunc Examples").front;
w.view.background_(Color.white);
views = {|i|
	v = UserView(w, Rect(20+(i*120), 100, 100, 100));
	v.background = Color.rand;
	v.drawFunc = func;
	v.mouseMoveAction = {|me| me.refresh };
	v.clearOnRefresh_(false);
} ! 3;
w.refresh;
)
#+END_SRC

::

The following example uses the link::#-clearOnRefresh:: option to keep the old contents when redrawn, allowing you to draw a line which follows the mouse cursor by clicking and draging on the view.

It also uses the mouse position to compute the color of the line.

code::
#+BEGIN_SRC sclang
(
var w, txt, lines, points, drawLine;

drawLine = { |points, bounds|
	var p0;
	points.do { |p,i|
		if(i == 0){
			p0 = p;
		}{
			Pen.moveTo(p0);
			Pen.lineTo(p);
			Color(
				(p.x/bounds.width).clip(0,1),
				1.0-(p.x/bounds.width).clip(0,1),
				(p.y/bounds.height).clip(0,1)
			).set;
			Pen.stroke;
			p0 = p;
		}
	};
};

w = Window("draw on me", Rect(128, 64, 340, 360));

v = UserView(w,w.view.bounds)
	.clearOnRefresh_(false)
	.mouseDownAction_({|v,x,y|
		points = [x@y];
	})
	.mouseMoveAction_({|v,x,y|
		points = points.add(x@y);
		v.refresh;
	})
	.mouseUpAction_({|v,x,y|
		points = points.add(x@y);
		lines = lines.add(points);
		points = nil;
		v.refresh;
	})
	.background_(Color.white)
	.drawFunc_{|me|
		var r = me.bounds;

		Pen.use {
			Pen.width = 1;
			Color.black.set;

			lines.do { |linePoints|
				drawLine.value(linePoints, r);
			};
			lines = nil;

			drawLine.value(points, r);
			if( points.size > 0 ) { points = [points.last] };
		};
	};

w.front;
)
#+END_SRC

::

SUBSECTION:: Animation

The following is an animation with mouse interaction. Click and drag in the view to move the center of the rotating object.

code::
#+BEGIN_SRC sclang
(
var width = 400, height = 400, mx = 0, my = 0, pt, r;

w = Window("animation and mouse interaction", Rect(100, 200, width, height), false);

u = UserView(w, Rect(0, 0, width, height));
u.background = Color.black;
u.animate = true; //animate this view

// allocate data in advance, for optimization:
pt = Point();
r = Rect();

u.drawFunc = {
	Pen.fillColor = Color.green;
	Pen.stringAtPoint(u.frameRate.asString, Point(10, 10)); // display frame rate
	Pen.stringAtPoint(u.frame.asString, Point(10, 30)); // display frame counter
	Pen.color = Color.white;
	pt.x=mx;
	pt.y=my;
	100.do{|i|
		Pen.moveTo(pt);
		pt.x = sin(u.frame*0.04.neg+i)*(5*i)+mx; //use .frame to drive animation
		pt.y = cos(u.frame*0.05+i)*(5*i)+my;
		r.left=pt.x;
		r.top=pt.y;
		r.width=i;
		r.height=i;
		Pen.lineTo(pt);
		Pen.fillStroke;
		Pen.addOval(r);
		Pen.fillStroke;
	};
};
u.mouseDownAction = {|v, x, y|
	mx = x;
	my = y;
};
u.mouseMoveAction = u.mouseDownAction;
w.front;
)

u.animate = false; //animation can be paused and resumed
u.animate = true;
w.close; //stops animation
#+END_SRC

::

A simple ball animation:

code::
#+BEGIN_SRC sclang
(
var width = 400, height = 400, xspeed = 3, yspeed = 2, x = width*0.5, y = height*0.5;
w = Window("ball", Rect(100, 200, width, height));
u = UserView(w, Rect(0, 0, width, height));
u.background = Color.black;
u.animate = true;
u.drawFunc = {
	if(x<0 or:{x>width}, {xspeed = 0-xspeed});
	if(y<0 or:{y>height}, {yspeed = 0-yspeed});
	x = x+xspeed;
	y = y+yspeed;
	Pen.fillColor = Color.white;
	Pen.fillOval(Rect.aboutPoint(Point(x, y), 8, 8));
};
w.front;
)

( //replace the drawFunc above while running
u.drawFunc = {
	Pen.fillColor = Color.red;
	Pen.fillOval(Rect(200, 200, sin(u.frame*0.031)*200, sin(u.frame*0.044)*200));
	Pen.fillOval(Rect(200, 200, sin(u.frame*0.052)*200, sin(u.frame*0.065)*200));
	Pen.fillOval(Rect(200, 200, sin(u.frame*0.073)*200, sin(u.frame*0.086)*200));
}
)

//close the window to stop
w.close;
#+END_SRC

::

An animation that makes a good use of the link::#-clearOnRefresh:: option to keep the old contents when redrawing.

note:: In strong::Cocoa GUI:: this functionality is only available on Mac OS X version >= 10.4. ::

code::
#+BEGIN_SRC sclang
(
var width = 640, height = 480, w, theta = 0, drawFunc;
w = Window( "trails", Rect( 128, 64, width, height ), false );
drawFunc = { arg view;
	var x = 20 * sin( theta ), y = 42 * cos( theta );
	theta = theta + 0.01;
	//draw a semitransparent rect filling the screen:
	Pen.fillColor_( Color.red( 0.2, 0.1 ));
	Pen.fillRect( Rect( 0, 0, width, height ));
	Pen.strokeColor_( Color.white );
	Pen.translate( width * 0.5, height * 0.5 );
	6.do { arg i;
		Pen.rotate( theta * (1 - (i / 6)) );
		Pen.scale( 0.7 + (i * 0.4), 0.4 + (i * 0.5) );
		Pen.strokeOval( Rect.aboutPoint( Point( x, y ), 60, 40 ));
	};
};
x = UserView( w, Rect( 10, 10, width - 20, height - 20 ))
	.canFocus_( false )
	.drawFunc_( drawFunc )
	.clearOnRefresh_( false );

w.front;
x.animate = true
)
#+END_SRC

::

SUBSECTION:: Usage of refreshInRect(aRect)

note:: This functionality is only available in strong::Cocoa GUI:: ::

The code::refreshInRect:: method constrains the receiver's refresh area to the rectangle passed in aRect. You may use Quartz Debug's flash screen updates to see the refresh area of the view

code::
#+BEGIN_SRC sclang
(
var userView, win, blob = Rect(0, 0, 50, 50), trackblob=false, pmouse;

a = SCImage.new("/Library/Desktop Pictures/Ripples Blue.jpg");

win = SCWindow.new("refreshInRect Test", Rect(400, 400, 600, 200), scroll:true).front;
win.onClose_({ a.free; });

userView = SCUserView(win, Rect(10,10,2000,800))
	.backgroundImage_(a, 5)
	.drawFunc_({|me|
		Color.blue.setFill;
		Pen.fillRect(blob);
	})
	.mouseDownAction_({|v, x, y, mod|
		pmouse = x@y;
		trackblob = blob.containsPoint(pmouse);
	})
	.mouseUpAction_({|v, x, y, mod|
		trackblob = false;
	})
	.mouseMoveAction_({|v, x, y, mod|
		var refresh, mouse, delta;
		mouse = x@y;

		if(trackblob, {
			refresh = blob.copy;
			delta = mouse-pmouse;
			blob = blob.moveBy(delta.x, delta.y);
			refresh = refresh.union(blob);
			v.refreshInRect(refresh);
		});
		pmouse = mouse;
	});

blob = blob.moveBy(userView.bounds.left, userView.bounds.top);
userView.bounds.postln;
)
#+END_SRC

::
** class:: VDiskIn
summary:: Stream in audio from a file, with variable rate
categories:: UGens>InOut, UGens>Buffer
related:: Classes/PlayBuf, Classes/BufRd, Classes/DiskIn

description::
Continuously play a longer soundfile from disk. This requires a buffer to be preloaded with one buffer size of sound.

classmethods::
method:: ar

argument:: numChannels
number of channels

argument:: bufnum
buffer number
Note:: The Buffer's numFrames must be a power of two and is recommended to be at least 65536 -- preferably 131072 or 262144. Smaller buffer sizes mean more frequent disk access, which can cause glitches. ::

argument:: rate
controls the rate of playback. Values below 4 are probably fine, but the higher the value, the more disk activity there is, and the more likelihood there will be a problem.

warning::
the rate does have a practical limit. The following must be true: rate < Buffer's size / ( 2 * s.options.blockSize) e.g with typical default values, this wil be 32768 / (2 * 64) = 256.
::

If the rate is too high, the UGen will not execute, posting a warning.

argument:: loop
If loop is set to 1, the soundfile will loop.

argument:: sendID
If a sendID is given, the UGen sends an osc message with this id and the file position each time it reloads the buffer: code::['/diskin', nodeID, sendID, frame]::

discussion::
This UGen will set the link::Classes/Done##'done' flag:: when finished playing.

examples::
code::
#+BEGIN_SRC sclang
b = Buffer.cueSoundFile(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 1);

x = { VDiskIn.ar(1, b, LFNoise2.kr(0.2).range(0.5, 2), 1, loop:1) }.play;

b.close;

// again
// note the like named instance method, but different arguments
b.cueSoundFile(Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0);

x.free; b.close; b.free;


// cue and play right away
(
SynthDef("help-VDiskin", { arg bufnum = 0;
	Out.ar(0, VDiskIn.ar(1, bufnum, MouseX.kr(0.5, 2.0)));
}).send(s);
)
(
x = Synth.basicNew("help-VDiskin");
m = { arg buf; x.addToHeadMsg(nil, [\bufnum, buf])};

b = Buffer.cueSoundFile(s,Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff",0,1, completionMessage: m);
)

x.free; b.close; b.free;	// clean up



// sending back the file position.
// note:
// the ugen knows nothing of the loop (apply a modulo).
// if you load another file, you need to free the buffer and re-allocate it (see below)

b = Buffer.cueSoundFile(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 1, bufferSize: 4096);
c = SoundFile(Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff").info;
x = { VDiskIn.ar(1, b, LFNoise2.kr(0.2).range(0.2, 0.9), 1, sendID: 14) }.play;

// register to receive this message

(
o = OSCFunc({ arg msg;
	var sendID = msg[2];
	var index = msg[3];
	msg.postln;
	"id: % pos: % frames (% sec)\n"
		.postf(sendID, index % c.numFrames, (index % c.numFrames / c.sampleRate));
},'/diskin', s.addr)
);

b.close; b.free;

b.alloc; b.cueSoundFile(Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0); c = SoundFile(Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff").info;

x.free; b.close; b.free; o.free; // clean up eventually
#+END_SRC

::

The same example in OSC Messaging style, see link::Guides/NodeMessaging::
code::
#+BEGIN_SRC sclang
// allocate a disk i/o buffer
s.sendMsg("/b_alloc", 0, 65536, 1);

// open an input file for this buffer, leave it open
s.sendMsg("/b_read", 0, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 65536, 0, 1);

// create a diskin node
s.sendMsg("/s_new", "help-VDiskin", x = s.nextNodeID, 1, 1);

s.sendMsg("/b_close", 0); // close the file (very important!)


// again
// don't need to reallocate and Synth is still reading
s.sendMsg("/b_read", 0, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 0, 0, 1);

s.sendMsg("/n_free", x); // stop reading

s.sendMsg("/b_close", 0); // close the file.

s.sendMsg("/b_free", 0); // frees the buffer
#+END_SRC

::
** CLASS:: VLayout
summary:: A layout that distributes views in a vertical line
categories:: GUI>Layout
related:: Classes/HLayout, Classes/GridLayout, Classes/StackLayout, Guides/GUI-Layout-Management
redirect:: implClass

DESCRIPTION::
See documentation of superclass link::Classes/QLineLayout:: for details.

CLASSMETHODS::

PRIVATE:: key
PRIVATE:: layoutClass
** class:: VLayoutView
redirect:: implClass
summary:: A container view that arranges its children vertically
categories:: GUI>Views
related:: Classes/HLayoutView, Classes/CompositeView

DESCRIPTION::

note::
In Qt GUI, this class has been rendered strong::obsolete:: by a special set of layout classes; they are easier to use and more flexible. See link::Classes/VLayout:: for an equivalent to this class, and link::Guides/GUI-Layout-Management:: for a general description of the Qt layout system.
::

VLayoutView can be a parent to other views, and it automatically arranges its child views in vertical order, expanding their width to its own bounds. Only the height of the children is relevant.

When arranging its children, VLayoutView takes the values of their 'minHeight' and 'maxHeight' properties into account. This is useful when a child's link::Classes/View#-resize#resize:: mode is set to 4, 5, or 6. See link::#examples:: below.

VLayoutView inherits some useful formatting methods from its superclasses.

note::
VLayoutView is designed mainly for grouping and placing widgets. While you can set it to accept key presses, it does not accept mouse clicks or drags.
::

CLASSMETHODS::
PRIVATE:: key

EXAMPLES::

code::
#+BEGIN_SRC sclang
(
q = 10;
w = Window.new;

v = VLayoutView(w,Rect(10,10,300,300));

Array.fill(q,{ arg i;
    Slider(v,Rect(0,0,75,20)).value_(i / q)
});

w.front
)

// show the area of the view.
v.background_(Color.rand) // The sliders automatically expand to the optimal width
#+END_SRC

::


Stretching the layout view; Slider height is fixed:

code::
#+BEGIN_SRC sclang
(
q = 10;
w = Window.new;

v = VLayoutView(w,Rect(10,10,300,300));
v.background_(Color.rand);
v.resize = 5; // elastic
Array.fill(q,{ arg i;
    var s;
    s = Slider(v,Rect(0,0,55,20));// The bounds.width are irrelevant here. They expand to the optimal width
    s.value = i / q;
    s
});
StaticText(v, Rect(0,0,55,20)).background_(Color.rand).string_("Some Example Text").align_(\center);
w.front
)
#+END_SRC

::

Stretching the layout view and the contents; if all the contents are elastic, the heights of the contents are perfectly divided up. In this example, the StaticText is not elastic in order to preserve its height.

code::
#+BEGIN_SRC sclang
(
q = 10;
w = Window.new;

v = VLayoutView(w,Rect(10,10,300,300));
v.background_(Color.rand);
v.resize = 5; // elastic
Array.fill(q,{ arg i;
    var s;
    s = Slider(v,Rect(0,0,75,20));
    s.resize = 5; // elastic
    s.value = i / q;
    s
});
StaticText(v, Rect(0,0,55,40))
    .background_(Color.rand).string_("Some Example Text")
    .align_(\center);

w.front
)
#+END_SRC

::

Mixed stretching modes:
code::
#+BEGIN_SRC sclang
(
q = 5;
w = Window.new;

v = VLayoutView(w,Rect(10,10,300,300));
v.resize = 5; // elastic
v.background_(Color.grey);
Array.fill(q,{ arg i;
    var s;
    s = Slider(v,Rect(0,0,75,20)).background_(Color.rand);
    s.value = i / 5;
    if(i < 2,{
        s.resize = 5; // some elastic
        s.setProperty(\minHeight,20);
    },{
        s.resize = 1; // some not elastic
    });
    s
});
StaticText(v, Rect(0,0,55,20)).background_(Color.rand).string_("Some Example Text").align_(\center);

w.front
)
#+END_SRC

::

Set minimum heights; beware that if the layout view height is smaller than the combined height of all the contents, things might disappear when you try to handle them with the mouse:

code::
#+BEGIN_SRC sclang
(
q = 5;
w = Window.new;

v = VLayoutView(w,Rect(10,10,300,300));
v.resize = 5; // elastic
v.background_(Color.grey);
Array.fill(q,{ arg i;
    var s;
    s = Slider(v,Rect(0,0,75,20)).background_(Color.blue.alpha_(0.2));
    s.value = i / 5;
    s.resize = 5;
    s.setProperty(\minHeight,20);
    s.setProperty(\maxHeight,40);
    s
});
w.front
)
#+END_SRC

::

Spacing:

code::
#+BEGIN_SRC sclang
(
q = 10;
w = Window.new;

v = VLayoutView(w,Rect(10,10,300,300));
v.setProperty(\spacing,0);

Array.fill(q,{
    Slider(v,Rect(0,0,75,20))
});

w.front
)
#+END_SRC

::


Nesting: use VLayoutView and HLayoutView in combination:
code::
#+BEGIN_SRC sclang
(
q = 10;
w = Window.new("nesting",Rect(30,30,400,700));

v = VLayoutView(w,Rect(10,10,300,600));

v.background = Color.rand;

Array.fill(q,{ arg i;
    Slider(v,Rect(0,0,75,20)).value_(i / q)
});

StaticText(v, Rect(0,0,55,20)).background_(Color.rand).string_("Some Example Text").align_(\center);

h = HLayoutView(v,Rect(10,10,300,300));

Array.fill(q,{ arg i;
    Slider(h,Rect(0,0,20,70)).value_(i / q)
});
h.background = Color.rand;

w.front
)
#+END_SRC

::
** class:: VOsc
summary:: Variable wavetable oscillator.
related:: Classes/COsc, Classes/Osc, Classes/OscN, Classes/VOsc3
categories::  UGens>Generators>Deterministic


Description::

A wavetable lookup oscillator which can be swept smoothly across
wavetables. All the wavetables must be allocated to the same size.
Fractional values of table will interpolate between two adjacent tables.


This oscillator requires at least two buffers to be filled with a
wavetable format signal. This preprocesses the Signal into a form which
can be used efficiently by the Oscillator. The buffer size must be a
power of 2.


This can be achieved by creating a link::Classes/Buffer:: object and sending it one of
the "b_gen" messages ( sine1, sine2, sine3 ) with the wavetable flag set to true.


This can also be achieved by creating a link::Classes/Signal:: object and sending it
the link::Overviews/Methods#asWavetable#asWavetable:: message, saving it to disk, and having the server load
it from there.


If you use Buffer objects to manage buffer numbers, you can use the
[*allocConsecutive] method to allocate a continuous block of buffers.
See the link::Classes/Buffer:: helpfile for details.


note::

VOsc requires the b_gen sine1 wavetable flag to be ON.

::

classmethods::

method::ar, kr

argument::bufpos

Buffer index. Can be swept continuously among adjacent wavetable
buffers of the same size.


argument::freq

Frequency in Hertz.


argument::phase

Phase offset or modulator in radians.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang

(
s = Server.local;
// allocate and fill tables 0 to 7
8.do({ arg i;
	var n, a;
	// allocate table
	s.sendMsg(\b_alloc, i, 1024);
	// generate array of harmonic amplitudes
	n = (i+1)**2;
	a = Array.fill(n, { arg j; ((n-j)/n).squared.round(0.001) });
	// fill table
	s.performList(\sendMsg, \b_gen, i, \sine1, 7, a);
});
)

(
SynthDef("help-VOsc",{ arg out=0, bufoffset=0;
	var x;
	// mouse x controls the wavetable position
	x = MouseX.kr(0,7);
	Out.ar(out,
		VOsc.ar(bufoffset+x, [120,121], 0, 0.3)
	)
}).play(s,[\out, 0, \bufoffset, 0]);
)

(
8.do({ arg i;
	var a;
	s.sendMsg(\b_alloc, i, 1024); // allocate table
	// generate array of harmonic amplitudes
	a = Array.fill(i, 0) ++ [0.5, 1, 0.5];
	// fill table
	s.performList(\sendMsg, \b_gen, i, \sine1, 7, a);
});
)

(
8.do({ arg i;
	var a;
	s.sendMsg(\b_alloc, i, 1024); // allocate table
	// generate array of harmonic amplitudes
	a = Array.fill(32,0);
	12.do({ arg i; a.put(32.rand, 1) });
	// fill table
	s.performList(\sendMsg, \b_gen, i, \sine1, 7, a);
});
)

(
8.do({ arg i;
	var a;
	s.sendMsg(\b_alloc, i, 1024); // allocate table
	// generate array of harmonic amplitudes
	n = (i+1)**2;
	a = Array.fill(n, { arg j; 1.0.rand2 });
	// fill table
	s.performList(\sendMsg, \b_gen, i, \sine1, 7, a);
});
)
#+END_SRC

::

** class:: VOsc3
summary:: Three variable wavetable oscillators.
related:: Classes/COsc, Classes/Osc, Classes/OscN, Classes/VOsc
categories::  UGens>Generators>Deterministic


Description::

A wavetable lookup oscillator which can be swept smoothly across
wavetables. All the wavetables must be allocated to the same size.
Fractional values of table will interpolate between two adjacent tables.
This unit generator contains three oscillators at different frequencies,
mixed together.


This oscillator requires at least two buffers to be filled with a
wavetable format signal. This preprocesses the Signal into a form which
can be used efficiently by the Oscillator. The buffer size must be a
power of 2.


This can be achieved by creating a link::Classes/Buffer:: object and sending it one of
the "b_gen" messages ( sine1, sine2, sine3 ) with the wavetable flag set to true.


This can also be achieved by creating a link::Classes/Signal:: object and sending it
the link::Overviews/Methods#asWavetable#asWavetable:: message, saving it to disk, and having the server load
it from there.


If you use Buffer objects to manage buffer numbers, you can use the
[*allocConsecutive] method to allocate a continuous block of buffers.
See the link::Classes/Buffer:: helpfile for details.


note::

VOsc3 requires the b_gen sine1 wavetable flag to be ON.

::

classmethods::

method::ar, kr

argument::bufpos

Buffer index. Can be swept continuously among adjacent wavetable
buffers of the same size.


argument::freq1

Frequency in Hertz of the 1st oscillator.


argument::freq2

Frequency in Hertz of the 2nd oscillator.


argument::freq3

Frequency in Hertz of the 3rd oscillator.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang

(
s = Server.local;
// allocate and fill tables 0 to 7
8.do({ arg i;
	var n, a;
	// allocate table
	s.sendMsg(\b_alloc, i, 1024);
	// generate array of harmonic amplitudes
	n = (i+1)**2;
	a = Array.fill(n, { arg j; ((n-j)/n).squared.round(0.001) });
	// fill table
	s.performList(\sendMsg, \b_gen, i, \sine1, 7, a);
});
)

(
SynthDef("help-VOsc",{ arg out=0, bufoffset=0, freq=240;
	var x;
	// mouse x controls the wavetable position
	x = MouseX.kr(0,7);
	Out.ar(out,
		VOsc3.ar(bufoffset+x, freq+[0,1],freq+[0.37,1.1],freq+[0.43, -0.29], 0.3)
	)
}).play(s,[\out, 0, \bufoffset, 0]);
)

(
8.do({ arg i;
	var a;
	s.sendMsg(\b_alloc, i, 1024); // allocate table
	// generate array of harmonic amplitudes
	a = Array.fill(i, 0) ++ [0.5, 1, 0.5];
	// fill table
	s.performList(\sendMsg, \b_gen, i, \sine1, 7, a);
});
)

(
8.do({ arg i;
	var a, n;
	s.sendMsg(\b_alloc, i, 1024); // allocate table
	// generate array of harmonic amplitudes
	n = (i+1)*8;
	a = Array.fill(n,0);
	(n>>1).do({ arg i; a.put(n.rand, 1) });
	// fill table
	s.performList(\sendMsg, \b_gen, i, \sine1, 7, a);
});
)

(
8.do({ arg i;
	var a;
	s.sendMsg(\b_alloc, i, 1024); // allocate table
	// generate array of harmonic amplitudes
	n = (i+1)**2;
	a = Array.fill(n, { arg j; 1.0.rand2 });
	// fill table
	s.performList(\sendMsg, \b_gen, i, \sine1, 7, a);
});
)

(
var a;
a = Array.fill(64, { arg j; 1.0.rand2 });
8.do({ arg i;
	s.sendMsg(\b_alloc, i, 1024); // allocate table
	// generate array of harmonic amplitudes
	n = (i+1)**2;
	// fill table
	s.performList(\sendMsg, \b_gen, i, \sine1, 7, a.extend(n.asInteger));
});
)

(
var a;
a = Array.fill(64, { arg j; 1/(j+1) });
8.do({ arg i;
	s.sendMsg(\b_alloc, i, 1024); // allocate table
	// generate array of harmonic amplitudes
	n = (i+1)**2;
	// fill table
	s.performList(\sendMsg, \b_gen, i, \sine1, 7, a.extend(n.asInteger));
});
)
#+END_SRC

::

** class:: VarLag
summary:: Variable shaped lag
related:: Classes/Lag, Classes/Ramp, Classes/Slew
categories::  UGens>Filters>Linear


Description::
Similar to link::Classes/Lag:: but with other curve shapes than exponential.
A change on the input will take the specified time to reach the new value.
Useful for smoothing out control signals.

classmethods::

method::ar, kr

argument::in

The input signal.


argument::time

Lag time in seconds.

argument::curvature
Control curvature if strong::warp:: input is 5 (default).
0 means linear, positive and negative numbers curve the segment up and down.

argument::warp
Determines the shape. The possible values are:
table::
## code::\step:: || || flat segment
## code::\linear:: || code::\lin:: || linear segment, the default
## code::\exponential:: || code::\exp:: || natural exponential growth and decay. In this case, the levels must all be nonzero and the have the same sign.
## code::\sine:: || code::\sin:: || sinusoidal S shaped segment.
## code::\welch:: || code::\wel:: || sinusoidal segment shaped like the sides of a Welch window.
## code::\squared::  || code::\sqr:: || squared segment
## code::\cubed:: || code::\cub:: || cubed segment
::

All values above will ignore strong::curvature:: input.

note::
When controlling this from the outside, use code::Env.shapeNumber(symbol):: to get the numeric value for each shape.
::

argument::start
Initial value. If not specified, same as the input signal.

argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang
(
// used to lag pitch
{
    SinOsc.ar(                              // sine wave
        VarLag.kr(                            // lag the modulator
            LFPulse.kr(1).range(100,400),   // frequency modulator
            0.2,                            // lag time
            Line.kr(-8, 8, 15, doneAction:2) // modulate shape
        ),
        0,                                  // sine phase
        0.3                                 // sine amplitude
    )
}.play
)
#+END_SRC

::

code::
#+BEGIN_SRC sclang
(
x = play { |amp=0, time=0, curve=0, warp=5|
    PinkNoise.ar(VarLag.kr(amp, time, curve, warp) ! 2)
}
)

x.set(\amp, 1, \time, 5, \warp, Env.shapeNumber(\sin)) // s-shaped curve up
x.set(\amp, 0, \time, 1, \warp, Env.shapeNumber(\lin)) // linear down

x.set(\amp, 1, \time, 2, \warp, 5, \curve, 7); // slow curvature
x.set(\amp, 0, \time, 0);

x.set(\amp, 1, \time, 2, \warp, 5, \curve, -7); // fast curvature
x.set(\amp, 0, \time, 0);

x.free;
#+END_SRC

::

** class:: VarSaw
summary:: Variable duty saw
related:: Classes/Saw, Classes/SyncSaw, Classes/LFSaw
categories::  UGens>Generators>Deterministic


Description::

Sawtooth-triangle oscillator with variable duty.


classmethods::
private:: categories

method::ar, kr

argument::freq
frequency in Hertz

argument::iphase
initial phase offset in cycles ( 0..1 )

argument::width
duty cycle from zero to one.

argument::mul

argument::add

Examples::

code::
#+BEGIN_SRC sclang

play({
	VarSaw.ar(
		LFPulse.kr(3, 0, 0.3, 200, 200),
		0,
		LFTri.kr(1.0).range(0,1), //width
		0.1)
});


play({ VarSaw.ar(LFPulse.kr(3, 0, 0.3, 200, 200), 0, 0.2, 0.1) });

// compare:

play({ LFPulse.ar(LFPulse.kr(3, 0, 0.3, 200, 200), 0, 0.2, 0.1) });
#+END_SRC

::

** class:: Vibrato
summary:: The Vibrato oscillator models a slow frequency modulation.
categories::  UGens>Generators>Deterministic, UGens>Generators>Stochastic, UGens>Filters>Pitch

Description::

Vibrato is a slow frequency modulation. Consider the systematic deviation in pitch of a singer around a fundamental frequency, or a violinist whose finger wobbles in position on the fingerboard, slightly tightening and loosening the string to add shimmer to the pitch. There is often also a delay before vibrato is established on a note. This UGen models these processes; by setting more extreme settings, you can get back to the timbres of FM synthesis. You can also add in some noise to the vibrato rate and vibrato size (modulation depth) to make for a more realistic motor pattern.

The vibrato output is a waveform based on a squared envelope shape with four stages marking out 0.0 to 1.0, 1.0 to 0.0, 0.0 to -1.0, and -1.0 back to 0.0. Vibrato rate determines how quickly you move through these stages.


classmethods::

method::ar, kr

argument::freq

Fundamental frequency in Hertz. If the Vibrato UGen is running at audio rate, this must not be a constant, but an actual audio rate UGen (see example below)

argument::rate

Vibrato rate, speed of wobble in Hertz. Note that if this is set to a low value (and definitely with 0.0), you may never get vibrato back, since the rate input is only checked at the end of a cycle.

argument::depth

Size of vibrato frequency deviation around the fundamental, as a proportion of the fundamental. 0.02 = 2% of the fundamental.

argument::delay

Delay before vibrato is established in seconds (a singer tends to attack a note and then stabilise with vibrato, for instance).

argument::onset

Transition time in seconds from no vibrato to full vibrato after the initial delay time.

argument::rateVariation

Noise on the rate, expressed as a proportion of the rate; can change once per cycle of vibrato.

argument::depthVariation

Noise on the depth of modulation, expressed as a proportion of the depth; can change once per cycle of vibrato. The noise affects independently the up and the down part of vibrato shape within a cycle.

argument::iphase

Initial phase of vibrato modulation, allowing starting above or below the fundamental rather than on it.

Examples::

code::
#+BEGIN_SRC sclang

//vibrato at 1 Hz, note the use of DC.ar UGen; a constant of 400.0 doesn't work
{SinOsc.ar(Vibrato.ar(DC.ar(400.0),1,0.02) )}.play

//compare: k-rate freq input can be a constant
{SinOsc.ar(Vibrato.kr(400.0,1,0.02))}.play

//control rate and rateVariation
{SinOsc.ar(Vibrato.ar(DC.ar(400.0),MouseX.kr(2.0,100.0),0.1,1.0,1.0,MouseY.kr(0.0,1.0),0.1) )}.play

//control depth and depthVariation
{SinOsc.ar(Vibrato.ar(DC.ar(400.0),LFNoise1.kr(1,3,7),MouseX.kr(0.0,1.0),1.0,1.0,MouseY.kr(0.0,1.0),0.1) )}.play

#+END_SRC

::





** CLASS:: View
redirect:: implClass
summary:: The basic visible element of GUI
categories:: GUI>Views

DESCRIPTION::
The View class is the superclass of all view classes.

The view is the basic visible element of which the graphical user interface is composed. It occupies a rectangular space on screen within which it draws itself to display some data or to indicate a mode of interaction between the user and the program. Views receive keyboard and mouse events generated by the user and respond to them by controlling the behavior of the program. They also display information about the state of the program and the data on which it operates.



CLASSMETHODS::

PRIVATE:: key

METHOD:: new

Creates a new instance of View and makes it a child of another View or Window, effectively placing it within the parent's visual space. If there is a link::#-decorator#decorator:: installed on the parent, it will manage the position of the new View.

note::

strong::Qt GUI: ::

The 'parent' argument may be omitted, in which case the view will be displayed as a window on its own, when link::Classes/QView#-front#shown::.

The 'bounds' argument may be omitted, in which case the view will be created with its preferred size at position (0,0).

If a parent is given and there is a layout installed on it, the layout will manage the position and size of this view and the 'bounds' argument will have no effect.
::

argument:: parent
The instance of View or Window that the new View will become a child of.

argument:: bounds
A Rect or a Point describing size and position of the new View. If a Point is given, its coordinates will denote the view's size, while the view's position will be (0,0). Position is measured relative to the parent's top-left corner.

returns::
note::
SuperCollider has different GUI kits implementing the same functionality on different platforms. The View's constructor will return an instance of the equivalent class of the currently active GUI kit. See link::Guides/GUI-Introduction:: for detailed explanation.
::


METHOD:: globalKeyDownAction

	A settable class variable containing an object (e.g. an instance of Function or FunctionList) which is evaluated (i.e. link::Classes/Object#-value#value:: method is called on it) whenever a key is pressed, independently of keyboard focus. See also link::#-addAction::.

	When the action object is evaluated, it is passed the following arguments: view, char, modifiers, unicode, keycode.

METHOD:: globalKeyUpAction

	A settable class variable containing an object (e.g. an instance of Function or FunctionList) which is evaluated (i.e. link::Classes/Object#-value#value:: method is called on it) whenever a key is released, independently of keyboard focus. See also link::#-addAction::.

	When the action object is evaluated, it is passed the following arguments: view, char, modifiers, unicode, keycode.


METHOD:: currentDrag

	A class variable holding the content of the current drag. It is set by beginDrag.


METHOD:: currentDragString

	A class variable holding the content of the current drag as link::Classes/Object#-asCompileString#"compile string"::. It is set by beginDrag.




INSTANCEMETHODS::

SUBSECTION:: Hierarchy and existence

METHOD:: parent
	returns:: The view's parent view, or nil if the view is a top view.

METHOD:: parents
	returns:: An array of all the parents, grandparents, etc., of the view.

METHOD:: getParents
	returns:: Same as link::#-parents#parents::.

METHOD:: children
	returns:: An array of all immediate children of the view.

METHOD:: remove
	Removes the view from its parent view (if any) and destroys the view. After this method is called, the view is not usable anymore.

METHOD:: removeAll
	Removes all the children of the view and destroys them. After this method is called, the former child views are not usable anymore.

METHOD:: close
	note:: only in Qt GUI ::

	If link::#-deleteOnClose:: is true, this method has the same effect as link::#-remove::, otherwise makes the view invisible.

METHOD:: isClosed
	returns:: A Boolean stating whether the view has been destroyed.

METHOD:: notClosed
	returns:: A Boolean, the opposite of 'isClosed'.

METHOD:: asView
	Method that allows compatibility with Window and other classes that are not real subclasses of View, but implement a part of its interface.

	returns:: This view.

SUBSECTION:: Visibility

METHOD:: visible
	Gets or sets wether the view is visible.

	In Qt:

	Making a child view invisible means it does not occupy any space from the standpoint of the layout that contains it, so the layout will distribute the space the view occupied when visible among other views. When the view becomes visible again it is given back the same space.

	If the view has no parent, setting this to true has the same effect as link::#-front::, and setting it to false closes the window without destroying it.

	argument::
		A Boolean stating the visibility of the view.

METHOD:: front
	note:: only in Qt GUI ::
	If the view does not have a parent, displays it on the screen as a window (it has the same effect as setting link::#-visible:: to true), otherwise it has no effect.

METHOD:: minimize
	note:: only in Qt GUI ::
	If the view is a window, hides it (only keep it present in the dock/taskbar/etc.).

METHOD:: unminimize
	note:: only in Qt GUI ::
	If the view is a window, restores the its previous state after being minimized.

METHOD:: fullScreen
	note:: only in Qt GUI ::
	If the view is a window, displays it full-screen.

METHOD:: endFullScreen
	note:: only in Qt GUI ::
	If the view is a window, restores its previous state after being displayed full-screen.

METHOD:: alwaysOnTop
	note:: only in Qt GUI ::

	If the view is a window, gets or sets whether it should always stay on top of other windows.

	argument:: boolean
		A Boolean stating whether the view should always stay on top.




SUBSECTION:: Size and position

METHOD:: bounds

	Gets or sets both the position and the size of the view. The position is relative to the parent view's top-left corner. Some containers, such as HLayoutView and VLayoutView, will use only the width and height of a child view's bounds.

	The setter takes a Rect or a Point interpreted link::Classes/Point#-asRect#as Rect::. The getter always returns a Rect.

METHOD:: absoluteBounds

	returns:: A Rect describing the absolute position and the size of the view on the screen.

METHOD:: sizeHint
	note:: only in Qt GUI ::
	returns:: A Size describing the preferred size of the view to comfortably display its contents and allow useful interaction.

METHOD:: minSizeHint
	note:: only in Qt GUI ::

	returns:: A Size describing the minimum size of the view to be able to display its contents and allow any interaction.

METHOD:: maxSize
	note:: only in Qt GUI ::
	Set maximum allowed size of the view. The view will not be able to grow larger than this size, neither by user interaction nor programmatically.

	argument:: size
		A Size.

METHOD:: minSize
	note:: only in Qt GUI ::
	Set minimum allowed size of the view. The view will not be able to shrink smaller than this size, neither by user interaction nor programmatically.

	argument:: size
		A Size.


METHOD:: fixedSize
	note:: only in Qt GUI ::
	Set both minimum and maximum allowed size of the view, thus making it non-resizable.

	argument:: size
		A Size.

METHOD:: fixedWidth
	note:: only in Qt GUI ::
	Set both minimum and maximum allowed width of the view, thus making it non-resizable.

	argument:: width
		An Int.

METHOD:: fixedHeight
	note:: only in Qt GUI ::
	Set both minimum and maximum allowed height of the view, thus making it non-resizable.

	argument:: height
		An Int.

METHOD:: maxWidth
	note:: only in Qt GUI ::
	Set maximum allowed width of the view, the view will not be able to grow larger in width, neither by user interaction nor programmatically.

	argument:: width
		An Int.


METHOD:: minWidth
	note:: only in Qt GUI ::
	Set minimum allowed width of the view, the view will not be able to shrink smaller in width, neither by user interaction nor programmatically.

	argument:: width
		An Int.


METHOD:: maxHeight
	note:: only in Qt GUI ::
	Set maximum allowed height of the view, the view will not be able to grow larger in height, neither by user interaction nor programmatically.

	argument:: height
		An Int.



METHOD:: minHeight
	note:: only in Qt GUI ::
	Set minimum allowed height of the view, the view will not be able to shrink smaller in height, neither by user interaction nor programmatically.

	argument:: height
		An Int.

METHOD:: moveTo
	note:: only in Qt GUI ::
	Move the view to new position, preserving its size.

	argument:: x
		An Int: the horizontal position of the new position.

	argument:: y
			An Int: the vertical position of the new position.

METHOD:: resizeTo
	note:: only in Qt GUI ::
	Resize the view, preserving its position.

	argument:: width
		An Int: the new horizontal size of the view.

	argument:: height
		An Int: the new vertical size of the view.

METHOD:: resize
	Determines what happens with the view's position and size when its parent is resized. See link::Guides/GUI-Introduction#view:: for further explanation.

	argument::
		An Int (1 to 9) defining the auto-resize behavior. See link::Reference/Resize:: for a list of valid resize modes.

METHOD:: decorator
	note:: only in Qt GUI ::

	Get or set the decorator object, that automatically manages the positioning of new children of the view when they are created. See link::Guides/GUI-Introduction#decorators:: for further explanation.

	argument::
		An instance of a decorator class (e.g. FlowLayout).

METHOD:: addFlowLayout
	note:: only in Qt GUI ::

	A convenience method which sets decorator to a new instance of FlowLayout. See link::Classes/FlowLayout:: for examples.

	argument:: margin
		A Point describing the link::Classes/FlowLayout#-margin#margin:: of the FlowLayout.

	argument:: gap
		A Point describing the link::Classes/FlowLayout#-gap#gap:: of the FlowLayout.

	returns:: The new FlowLayout instance.

METHOD:: flow
	note:: only in Qt GUI ::

	Creates a FlowView as a child of the view, and then evalutes the object given in the 'func' argument. It is most common to pass a Function for 'func' in which the FlowView is filled with other child views.

	argument:: func
		The object that will be evaluated after the creation of the FlowView, passing the new FlowView instance as an argument.

	argument:: bounds
		A Rect to set as the bounds of the FlowView, or nil, implying the size of this view and position (0,0).

		After 'func' is evaluated, the FlowView will be resized to fit its contents and cast away any extra space it occupies.

	returns:: The new FlowView instance.

METHOD:: layout
	note:: only in Qt GUI ::

	Get or set the layout object, that automatically manages the position and the size of the children of the view dynamically, in relation to the view's size. See link::Guides/GUI-Introduction#layouts:: for further explanation.

	argument::
		An instance of a subclass of QLayout.




METHOD:: mapToGlobal
	note:: only in Qt GUI ::

	Map a point relative to this view's top-left to absolute position on screen.

	argument::
		A Point describing a position relative to the view.

	returns::
		A Point describing the same position, but relative to the screen.


SUBSECTION:: Appearance

METHOD:: name
	note:: only in Qt GUI ::

	If the view is a window, sets its title

	argument::
		A String containing text for the window title.


METHOD:: alpha
	note:: only in Qt GUI ::

	If the view is a window, this controls its transparency.

	argument:: aFloat
		A Float between 0.0 (invisible) and 1.0 (opaque).

METHOD:: font
	note:: Only in Qt every view has this method. In other GUI kits, only some views have it. ::
	The font used by the view to display text (if any).

	argument::
		A Font.


METHOD:: background
	Get or set the color of whatever is considered the background of the view.

	argument::
		A Color.


METHOD:: focusColor
	Get or set the color used to display keyboard focus on the view.

	argument::
		A Color.

METHOD:: palette
	note:: Only available in Qt GUI ::

	Get or set the palette to be used by the view.

	When setting a palette, only those colors that have been set on the palette will take effect, other colors will be inherited from the parent view's palette, or QtGUI. See also link::Classes/QPalette#-hasColor::.

	When getting a palette, it will return everytime a new copy of the view's palette. Therefore, if you wish to change the view's palette, you have to set the changed palette back on the view:

code::
#+BEGIN_SRC sclang
	w = Window().front.layout_( HLayout( a = Slider() ) );
	a.action = { |a|
		a.palette = a.palette.buttonText_( if(a.value > 0.5){Color.red}{Color.green} );
	};
	a.valueAction = 0.0;
#+END_SRC

::

	To dynamically modify the view's palette, it is thus more efficient, if possible, to keep a palette instance to operate on. Note that this is also more efficient than using methods like link::Classes/Slider#-knobColor::, since internally they use the above approach:

code::
#+BEGIN_SRC sclang
	w = Window().front.layout_( HLayout( a = Slider() ) );
	p = QPalette();
	a.action = { |a|
		a.palette = p.buttonText_( if(a.value > 0.5){Color.red}{Color.green} );
	};
	a.valueAction = 0.0;
#+END_SRC

::

	See link::Classes/QPalette:: for detailed explanation of how palettes work.

	argument::
		A QPalette.

METHOD:: refresh
	Redraws the view and all its children.


SUBSECTION:: Common behavior


METHOD:: userCanClose
	note:: only in Qt GUI ::

	If the view is a window, sets or gets whether the user can close it via mouse or key actions.

	argument::
		A Boolean.


METHOD:: deleteOnClose
	note:: only in Qt GUI ::

	Sets or gets whether the view should be destroyed when closed.

	argument::
		A Boolean.

METHOD:: enabled
	Sets or gets whether the view allows the user to interact with it. Usually, when a view is disabled it will be displayed differently (typically it will be greyed out).

	argument::
		A Boolean.


METHOD:: canFocus
	Sets or gets whether the view can receive keyboard focus.

	argument::
		A Boolean.

METHOD:: focus
	If 'flag' is true, gives keyboard focus to the view (if possible), otherwise removes the keayboard focus from it.

	argument:: flag
		A Boolean.

METHOD:: hasFocus

	returns:: A Boolean, stating whether the view currently has the keyboard focus.

METHOD:: acceptsMouse
    note:: Only in Qt GUI ::

    Sets or gets whether the view responds to mouse interaction. If code::false::, the view will be completely transparent for mouse and interaction will be possible with any view under.

    Defaults to code::true::.

    argument::
        A Boolean.

METHOD:: acceptsMouseOver
	If this is a top view, this variable defines whether the view and all its children receive mouse-over events. The default is code::false::.

	See also: link::#-mouseOverAction::.

	argument::
		A Boolean.


SUBSECTION:: Actions in general

METHOD:: action
	Gets or sets the default action of the view, i.e. the object to be evaluated when the user interacts with the view in an essential way (e.g. a Button is clicked, a ListView item is selected, etc.).

	argument:: func
		Any object to set as default action, usually a Function or a FunctionList. When evaluated, it will be passed the view as an argument.


METHOD:: doAction
	Evaluates the default link::#-action#action::.


METHOD:: addAction
METHOD:: removeAction

	Adds/removes 'func' to or from the list of objects in the variable determined by 'selector'. If 'selector' is not an Array or a List, it will become one, containing the previous object plus 'func'.

	This is useful for adding functionality to existing frameworks that have action functions already.

	argument:: func
		Any object to add as an action, usually a Function.

	argument:: selector
		A Symbol containing the name of the action variable to which 'func' will be added. In other words, 'add' method will be invoked on that variable; by default that is \action, but any other (sensible) instance or class variable of the view could work (e.g. \globalKeyDownAction or \mouseUpAction or \onClose, etc.). See the other action variables below.

SUBSECTION:: Key and mouse event processing

In strong::Cocoa and SwingOSC:: GUI kits, a key event occurring on a view can propagate to the parent view, and trigger the parent's key action, if either the child's action returns code::nil::, or the child has no action assigned for that key event. This has also been referred to as "key event bubbling".

In strong::Qt:: GUI, however, both mouse and key events can propagate to the parent view. Event processing works differently: by default, after a mouse or key action is evaluated, the control returns to the C++ implementation of the view, and if no response to the particular mouse or key event is implemented there, it propagates to the parent.

If you wish to control whether the event will be propagated or not, return code::true:: or code::false:: from the action. True means you have responded to the event, and the propagation will be stopped; false means you are not interested in the event, and the event will propagate. However, returning either code::true:: or code::false:: will completely bypass the view's C++ implementation, so it will not get a chance at responding to the event with its standard behavior. Use this feature with care.

SUBSECTION:: Mouse actions

Use the methods below to set or get the view's actions in response to mouse interaction with the view. A view must be enabled for the mouse actions to work.

note::
In Qt GUI, Mouse actions are subject to emphasis::event propagation::. See link::#Key and mouse event processing:: for details.
::

When the mouse action object is evaluated, it is passed one or more arguments from the following list (in that order):

list::
## strong::view:: - the view
## strong::x:: - the x coordinate
## strong::y:: - the y coordinate
## strong::modifiers:: - A bitwise or of integers indicating the modifier keys in effect. For a list of these, see link::Reference/Modifiers::.
## strong::buttonNumber:: - 0-left, 1-right, 2-middle, etc.
## strong::clickCount:: - the number of clicks within the system click time limit. At least 1.
::

METHOD:: mouseDownAction
    The object to be evaluated when a mouse button is pressed on the view.

    The following arguments are passed at evaluation: strong::view, x, y, modifiers, buttonNumber, clickCount::. See link::#Mouse actions:: for explanation of arguments.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

METHOD:: mouseUpAction
    The object to be evaluated when a mouse button is released after it was pressed on the view.

    The following arguments are passed at evaluation: strong::view, x, y, modifiers::. See link::#Mouse actions:: for explanation of arguments.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

METHOD:: mouseMoveAction
    The object to be evaluated whenever the mouse pointer moves after a mouse button was pressed on the view.

    The following arguments are passed at evaluation: strong::view, x, y, modifiers::. See link::#Mouse actions:: for explanation of arguments.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

METHOD:: mouseOverAction
    The object to be evaluated when the mouse pointer moves over the view with no mouse buttons pressed.

    The following arguments are passed at evaluation: strong::view, x, y::. See link::#Mouse actions:: for explanation of arguments.

    The object is evaluated only when link::Classes/Window#-acceptsMouseOver:: of the containing Window (or, in Qt, link::#-acceptsMouseOver:: of the top View) is code::true::.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

METHOD:: mouseWheelAction
    note:: strong:: Only in Qt GUI :: ::

    The object to be evaluated when the mouse wheel is used while the mouse is pointing onto the view.

    The following arguments are passed at evaluation: strong::view, x, y, modifiers, xDelta, yDelta::. See link::#Mouse actions:: for explanation of arguments.

    The xDelta and yDelta arguments express rotation in horizontal and vertical direction, respectively. The value is in degrees (typically, an event occurs every 15 degrees), and can be positive or negative, depending on the direction of rotation.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

METHOD:: mouseEnterAction
    note:: strong:: Only in Qt GUI :: ::

    The object to be evaluated when the mouse pointer enters the view.

    The following arguments are passed at evaluation: strong::view, x, y::. See link::#Mouse actions:: for explanation of arguments.

METHOD:: mouseLeaveAction
    note:: strong:: Only in Qt GUI :: ::

    The object to be evaluated when the mouse pointer leaves the view.

    The following arguments are passed at evaluation: strong::view, x, y::. See link::#Mouse actions:: for explanation of arguments.


SUBSECTION:: Key actions

Use the methods below to set or get the view's actions in response to keyboard interaction when the view has the keyboard focus.

note::
Key actions are subject to emphasis::event propagation::. See link::#Key and mouse event processing:: for details.
::

When the key action object is evaluated, it is passed one or more arguments from the following list (in that order):

list::
## strong::view:: - The view.

## strong::char:: - The character associated with the key, possibly unprintable. Character sequences (for example é) get passed as two characters, the first one blank ( ), the second one is the unmodified character (e). This will also vary depending on the nationality the keyboard is set to. note:: In Qt GUI only printable characters are passed. If a key is not associated with any printable character, nil will be passed instead.::

## strong::modifiers:: - A bitwise or of integers indicating the modifier keys in effect. You can examine individual flag settings using the C bitwise AND operator. For a list of these, see link::Reference/Modifiers::.

## strong::unicode:: - The Integer unicode number associated with the 'char' passed.

## strong::keycode:: - The hardware dependent keycode indicating the physical key. This will vary from machine to machine, but is useful for building musical interfaces using the computer keyboard. warning::Function key modifier in combination with another key may change the latter's keycode.::

## strong::key:: - In Qt GUI, an Integer denoting a key, corresponding to the "Key" enum of the Qt C++ API. Comparing this value is the most reliable way to check which key was pressed. For a list of possible values, see: link::http://qt-project.org/doc/qt-4.8/qt.html#Key-enum::.
::

note::
In Cocoa GUI, for various reasons the following key events don't make it through to SuperCollider:
list::
## most command modifiers
## ctl-tab
## ctl-escape
## tab and shift tab are currently trapped by SC itself for cycling the focus through the views.
::
::


METHOD:: keyDownAction
    The object to be evaluated when a key is pressed.

    The following arguments are passed at evaluation: strong::view, char, modifiers, unicode, keycode, key::. See link::#Key actions:: for explanation of arguments. Note that they 'key' argument is only passed in Qt GUI.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

    If no code::keyDownAction:: is set, link::#-defaultKeyDownAction:: is called instead, and its return value controls the event propagation.

METHOD:: keyUpAction
    The object to be evaluated when a key is released.

    The following arguments are passed at evaluation: strong::view, char, modifiers, unicode, keycode, key::. See link::#Key actions:: for explanation of arguments. Note that they 'key' argument is only passed in Qt GUI.

    The return value of evaluation controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

    If no code::keyUpAction:: is set, link::#-defaultKeyUpAction:: is called instead, and its return value controls the event propagation.

METHOD:: keyModifiersChangedAction
    The object to be evaluated when a modifier key is pressed or released.

    The following arguments are passed at evaluation: strong::view, modifiers::.


SUBSECTION:: Drag and drop

Use the methods below to define or override how the view handles drag&drop operations.

METHOD:: beginDragAction
	Sets or gets the object evaluated when a drag&drop operation is initiated.

	At evaluation, the following arguments will be passed: strong:: view, x, y ::. The view expects an object to be returned which will become the data subject to the drag&drop operation. Returning nil will prevent the drag&drop operation to begin.

	If this variable is nil (the default) the view's link::#-defaultGetDrag:: method is called instead.

METHOD:: canReceiveDragHandler
	Sets or gets the object evaluated when the mouse pointer moves over the view while a drag&drop operation is taking place.

	At evaluation, the following arguments will be passed: strong:: view, x, y ::. The view expects the link::#*currentDrag#drag&drop data:: to be examined, and a Boolean returned stating whether the view can make use of that data. If true is returned, the data may be dropped on the view, otherwise the drop event will not be handled by this view.

	If this variable is nil (the default) the view's link::#-defaultCanReceiveDrag:: method is called instead.

METHOD:: receiveDragHandler
	Sets or gets the object evaluated when a drag&drop operation finishes on this view.

	At evaluation, the following arguments will be passed: strong:: view, x, y ::. The link::#*currentDrag#drag&drop data:: is expected to be applied to the view in some way.

	If this variable is nil (the default) the view's link::#-defaultReceiveDrag:: method is called instead.


METHOD:: dragLabel
	Sets or gets the text displayed by the mouse pointer during the drag&drop operation. It is expected to be set while handling the beginning of the operation, i.e. in link::#-beginDragAction:: or link::#-defaultGetDrag::.

	argument::
		A String containing the text to be displayed.




SUBSECTION:: Other actions and hooks

METHOD:: focusGainedAction
	note:: only in Qt and SwingOSC GUI::

	Sets or gets the object to be evaluated when the view gains the keyboard focus. It is passed the view as an argument.

METHOD:: focusLostAction
	note:: only in Qt and SwingOSC GUI::

	Sets or gets the object to be evaluated when the view looses the keyboard focus. It is passed the view as an argument.

METHOD:: toFrontAction
	note:: only in Qt GUI ::

	Sets or gets the object to be evaluated when the view becomes the active window. It is passed the view as an argument.

METHOD:: endFrontAction
	note:: only in Qt GUI ::

	Sets or gets the object to be evaluated when the view becomes the active window. It is passed the view as an argument.

METHOD:: onResize
	note:: only in Qt GUI ::

	Sets or gets the object to be evaluated when the view changes its size. It is passed the view as an argument.

METHOD:: onMove
	note:: only in Qt GUI ::

	Sets or gets the object to be evaluated when the view changes position relatively to its parent. It is passed the view as an argument.

METHOD:: onClose

	Sets or gets the object to be evaluated when the view is destroyed (i.e. link::#-close#closed:: or link::#-remove#removed::). It is passed the view as an argument.




SUBSECTION:: Subclassing

The following methods are the default handlers of key press and release events. When subclassing, override them to implement custom functionality. Many view classes in the standard library do that.

METHOD:: defaultKeyDownAction

	The method called when a key is pressed and link::#-keyDownAction:: is nil. Subclass it to define your own functionality on key presses.

	See link::#Key actions:: for explanation of arguments.

    The return value controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.

METHOD:: defaultKeyUpAction

	The method called when a key is released and link::#-keyUpAction:: is nil.  Subclass it to define your own functionality on key-release.

	See link::#Key actions:: for explanation of arguments.

	The return value controls the event propagation to parent view. See link::#Key and mouse event processing:: for details.


METHOD:: keyDown
	Handles response to a key press event. First evaluates link::#*globalKeyDownAction::, then calls link::#-handleKeyDownBubbling::.

	note::
	In Qt GUI, instead of calling link::#-handleKeyDownBubbling::, this method directly triggers the action and returns, forwarding the action's return value. See link::#Key actions:: for detailed explanation.
	::

	See link::#Key actions:: for explanation of arguments.

	returns:: strong:: Only in Qt GUI: :: A Boolean, stating whether the event was handled or not (and will not or will propagate to the parent view, respectively), or the view, in which case it lets the Qt view implementation handle the event.

METHOD:: keyUp

	Handles response to a key release event. Sets link::#-keyTyped:: to 'char', evaluates link::#*globalKeyUpAction::, and then calls link::#-handleKeyUpBubbling::.

	note::
	In Qt GUI, instead of calling link::#-handleKeyUpBubbling::, this method directly triggers the action and returns, forwarding the action's return value. See link::#Key actions:: for detailed explanation.
	::

	See link::#Key actions:: for explanation of arguments.

	returns:: strong:: Only in Qt GUI: :: A Boolean, stating whether the event was handled or not (and will not or will propagate to the parent view, respectively), or the view, in which case it lets the Qt view implementation handle the event.

METHOD:: keyModifiersChanged
	Handles response to a modifier key press or release event. Calls link::#-handleKeyModifiersChangedBubbling::.

	note::
	In Qt GUI, instead of calling link::#-handleKeyModifiersChangedBubbling::, a modifier key press or release event also produces a normal key press or release event, and it is the handling of those events that will determine propagation to the parent.
	::

	See link::#Key actions:: for explanation of arguments.

METHOD:: handleKeyDownBubbling
	note:: Only in Cocoa and SwingOSC GUI ::
	Triggers key-down action and propagates the key event to the parent view, if the action returns nil.

METHOD:: handleKeyUpBubbling
	note:: Only in Cocoa and SwingOSC GUI ::
	Triggers key-up action and propagates the key event to the parent view, if the action returns nil.

METHOD:: handleKeyModifiersChangedBubbling
	note:: Only in Cocoa and SwingOSC GUI ::
	Triggers key-modifiers-changed action and propagates the key event to the parent view, if the action returns nil.

METHOD:: keyTyped

	An instance variable containing the key just typed (after it is released).



METHOD:: mouseDown
	Handles response to a mouse button press event. Evaluates link::#-mouseDownAction::.

	See link::#Mouse actions:: for explanation of arguments.

METHOD:: mouseUp
	Handles response to a mouse button release event. Evaluates link::#-mouseDownAction::.

	See link::#Mouse actions:: for explanation of arguments.

METHOD:: mouseMove
	Handles response to mouse pointer moving after a mouse button has been pressed on the view. Evaluates link::#-mouseMoveAction::.

	See link::#Mouse actions:: for explanation of arguments.

METHOD:: mouseOver
	Handles response to mouse pointer moving over the view with no mouse buttons pressed. Evaluates link::#-mouseOverAction::.

	This method is called only if link::Classes/Window#-acceptsMouseOver:: of the containing Window (or, in Qt, link::#-acceptsMouseOver:: of the top View) is code::true::.

	See link::#Mouse actions:: for explanation of arguments.

METHOD:: mouseEnter
	note:: strong:: Only in Qt GUI :: ::

	Handles response to mouse pointer entering the view. Evaluates link::#-mouseEnterAction::.

METHOD:: mouseLeave
	note:: strong:: Only in Qt GUI :: ::

	Handles response to mouse pointer leaving the view. Evaluates link::#-mouseLeaveAction::.



METHOD:: defaultGetDrag

	The view's default method to determine the content of the drag&drop operation just initiated.

	returns:: The object to be set as link::#*currentDrag::. If nil is returned, the drag&drop operation will not begin.

METHOD:: defaultCanReceiveDrag

	The view's default evaluation whether the content of the ongoing drag&drop operation can be accepted.

	returns:: A Boolean stating whether link::#*currentDrag:: is useful. If false is returned, the drop will not be handled by this view.

METHOD:: defaultReceiveDrag

	The view's default handling of the data dropped on it (stored in link::#*currentDrag::).

METHOD:: beginDrag
	Handles initiation of a drag&drop operation. Evaluates link::#-beginDragAction:: or calls link::#-defaultGetDrag:: if the former is nil, then stores the object returned into link::#*currentDrag::, and the object interpreted as link::Classes/Object#-asCompileString#"compile string":: into link::#*currentDragString::. Returns whether link::#*currentDrag:: is not nil.

	note:: The description of arguments and return value is valid strong:: only for Qt GUI: ::. In other GUI kits this method has no arguments and its return value is insignificant. ::

	argument:: x
		Current horizontal position of the mouse pointer.

	argument:: y
		Current vertical position of the mouse pointer.

	returns:: A Boolean stating whether the drag&drop operation shall begin.

METHOD:: canReceiveDrag
	Handles evaluation whether the view can accept the current drag&drop data. Evaluates link::#-canReceiveDragHandler:: or calls link::#-defaultCanReceiveDrag:: if the former is nil, then forwards the return value.

	note:: The description of arguments is valid strong:: only for Qt GUI: ::. In other GUI kits this method has no arguments. ::

	argument:: x
		Current horizontal position of the mouse pointer.

	argument:: y
		Current vertical position of the mouse pointer.

	returns:: A Boolean stating whether the current drag&drop content can be dropped on the view.

METHOD:: receiveDrag
	Handles the end of the drag&drop operation. Evaluates link::#-receiveDragHandler:: or calls link::#-defaultReceiveDrag:: if the former is nil, then sets link::#*currentDrag:: and link::#*currentDragString:: to nil.

	argument:: x
		Current horizontal position of the mouse pointer.

	argument:: y
		Current vertical position of the mouse pointer.
** class:: ViewRedirect
summary:: An abstract super class for gui redirection classes
categories:: GUI>Kits
related:: Classes/GUI, Overviews/GUI-Classes, Guides/GUI-Introduction

description::
You will never call this class directly, but will only call its subclasses. ViewRedirect is the abstract superclass of all gui redirect classes. These subclasses in turn use the code::GUI.myView:: mechanism to redirect to the currently active gui kit. ViewRedirect's subclasses provide a simple syntax for creating gui views and widgets, while transparently making the code work with different gui kits.

Each subclass uses a code::*key:: class method to return a key appropriate to the desired link::Classes/GUI:: redirect method:

code::
#+BEGIN_SRC sclang
MyGUIClass : ViewRedirect { *key { ^\myGUIClass }}
#+END_SRC

::

classmethods::

method:: redirectQueries
argument:: bool
A link::Classes/Boolean:: indicating whether or not code::openClassFile:: queries will redirect to the active implementation class (Cocoa or Swing). The default is code::false::.

** class:: Volume
summary:: Model for the global volume of the synthesis server
categories:: Server

description::
Internally used by Server.

classmethods::
method:: new
Create and return a new instance of Volume for a given server,
ranging from code::startBus:: over code::numChans:: (usually the server's number of output bus channels).
argument:: server
a server
argument:: startBus
start bus
argument:: numChans
number of channels
argument:: min
minimum volume in decibel
argument:: max
minimum volume in decibel
argument:: persist
whether to persist a reset

instancemethods::

method:: play
run the synth that controls the volume. If mute is true, mute the output. (default: false)

method:: free
free the synth that controls the volume.

method:: mute
mute output

method:: unmute
unmute output

method:: volume
set the volume (in db)

method:: lag
set the lag time that dampens volume changes

method:: setVolumeRange
set the volume range

method:: gui
create a volume gui.

examples::
code::
#+BEGIN_SRC sclang
v = s.volume;

v.min;
v.max;
v.volume = rrand(-50, 5);
v.setVolumeRange(-90, 8);
v.mute;
v.unmute;

// separate window
v.gui;
#+END_SRC

::

** class:: Warp
summary:: specification of a shape for a mapping of numerical input
related:: Classes/ControlSpec, Classes/Spec
categories:: Control, Spec

description::
The subclasses of Warp specify translations from input (a number) to an output (another number). This is an abstract class - already available shapes are emphasis::linear, exponential, sine, cosine, decibel, curve:: (this is similar to the curves in envelopes, see also link::Classes/Env::).

Warps are internally created by link::Classes/ControlSpec::. Usually they are created by the message strong::asWarp::, understood by symbols and numbers. A warp has a link::Classes/Spec:: to specify a certain range of input and output values.

code::
#+BEGIN_SRC sclang
// create a new warp:
a = \exp.asWarp;
a = -4.asWarp; // a curve warp;
#+END_SRC

::

ClassMethods::

private::initClass

InstanceMethods::

method::map
Maps and constrains a strong::value:: between 0 and 1 to the output domain.

method::unmap
in the output domain to a value in the range between 0 and 1.

code::
#+BEGIN_SRC sclang
g = -3.asWarp;
g.map(0.5);
g.unmap(0.9);

// fore and back translation should be identical:
g.unmap(g.map(0.5));
#+END_SRC

::
** class:: Warp1
summary:: Warp a buffer with a time pointer
categories:: UGens>Buffer, UGens>Generators>Granular

description::
Inspired by Chad Kirby's SuperCollider2 Warp1 class, which was inspired by Richard Karpen's sndwarp for CSound. A granular time strecher and pitchshifter.

classmethods::
private:: categories

method:: ar
argument::numChannels
the number of channels in the soundfile used in bufnum.

argument::bufnum
the buffer number of a mono soundfile.

argument::pointer
the position in the buffer.  The value should be between 0 and 1, with 0 being the begining
of the buffer, and 1 the end.

argument::freqScale
the amount of frequency shift. 1.0 is normal, 0.5 is one octave down, 2.0 is one octave up.
Negative values play the soundfile backwards.

argument::windowSize
the size of each grain window.

argument::envbufnum
the buffer number containing a singal to use for the grain envelope. -1 uses a built-in
Hanning envelope.

argument::overlaps
the number of overlaping windows.

argument::windowRandRatio
the amount of randomness to the windowing function.  Must be between 0 (no
randomness) to 1.0 (probably to random actually)

argument::interp
the interpolation method used for pitchshifting grains. 1 = no interpolation. 2 = linear.
		4 = cubic interpolation (more computationally intensive).

argument::mul

argument::add

Examples::
code::
#+BEGIN_SRC sclang
s.boot;

(
var winenv;
// a custom envelope - not a very good one, but you can hear the difference between this
// and the default
winenv = Env([0, 1, 0], [0.5, 0.5], [8, -8]);
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff");
z = Buffer.sendCollection(s, winenv.discretize, 1);

SynthDef(\warp, {arg buffer = 0, envbuf = -1;
	var out, pointer, filelength, pitch, env, dir;
	// pointer - move from beginning to end of soundfile over 15 seconds
	pointer = Line.kr(0, 1, 15);
	// control pitch with MouseX
	pitch = MouseX.kr(0.5, 2);
	env = EnvGen.kr(Env([0.001, 1, 1, 0.001], [0.1, 14, 0.9], 'exp'), doneAction: 2);
	out = Warp1.ar(1, buffer, pointer, pitch, 0.1, envbuf, 8, 0.1, 2);
	Out.ar(0, out * env);
}).send(s);

)

// use built-in env
x = Synth(\warp, [\buffer, b, \envbuf, -1])

// switch to the custom env
x.set(\envbuf, z)
x.set(\envbuf, -1);

x.free;
#+END_SRC

::

** CLASS::Wavetable
summary::sampled audio buffer in wavetable format
related::Classes/Signal
categories:: Signals

DESCRIPTION::
A Wavetable is a FloatArray in a special format used by SuperCollider's interpolating oscillators. Wavetables cannot be created by strong::new::.

CLASSMETHODS::

method::sineFill
Fill a Wavetable of the given size with a sum of sines at the given amplitudes and phases. The Wavetable will be normalized.
code::
#+BEGIN_SRC sclang
Wavetable.sineFill(512, 1.0/[1, 2, 3, 4, 5, 6]).plot;
#+END_SRC

::
argument::size
must be a power of 2.
argument::amplitudes
an Array of amplitudes for each harmonic beginning with the fundamental.
argument::phases
an Array of phases in radians for each harmonic beginning with the fundamental.

method::chebyFill
Fill a Wavetable of the given size with a sum of Chebyshev polynomials at the given amplitudes for use in waveshaping by the link::Classes/Shaper:: ugen. The Wavetable will be normalized.
code::
#+BEGIN_SRC sclang
Wavetable.chebyFill(513, [1]).plot;
Wavetable.chebyFill(513, [0, 1]).plot;
Wavetable.chebyFill(513, [0, 0, 1]).plot;
Wavetable.chebyFill(513, [0.3, -0.8, 1.1]).plot;
#+END_SRC

::
argument::size
must be a power of 2 plus 1, eventual wavetable is next power of two size up.
argument::amplitudes
an Array of amplitudes for each Chebyshev polynomial beginning with order 1.
argument::normalize
A link::Classes/Boolean::.

INSTANCEMETHODS::

method::plot
Plot the Wavetable in a window. The arguments are not required and if not given defaults will be used.
code::
#+BEGIN_SRC sclang
Wavetable.sineFill(512, [0.5]).plot;
Wavetable.sineFill(512, [1]).plot("Table 1", Rect(50, 50, 150, 450));
#+END_SRC

::
argument::name
a String, the name of the window.
argument::bounds
a Rect giving the bounds of the window.
argument::minval
the minimum value in the plot. Defaults to the highest value in the data.
argument::maxval
the maximum value in the plot. Defaults to the lowest value in the data.
argument::parent
a window to place the plot in. If nil, one will be created for you.

method::asSignal
Convert the Wavetable into a Signal.
code::
#+BEGIN_SRC sclang
Wavetable.sineFill(512, [1]).asSignal.plot;
#+END_SRC

::
** class:: WebView
redirect:: implClass
summary:: Web page display and browser
categories:: GUI>Views

DESCRIPTION::

WebView displays web pages and provides all the standard browsing functionality.

CLASSMETHODS::

PRIVATE:: key

METHOD:: clearCache

  Clears all the memory caches, so that link::#-reload#reloading:: a page is ensured to reload all the resources.


INSTANCEMETHODS::


SUBSECTION:: Navigation

METHOD:: url

    Gets the current URL, or navigates to a new one.

METHOD:: reload

    Reloads the current page.

METHOD:: back

    Navigates to the previous page in history.

METHOD:: forward

    Navigates to the next page in history.

METHOD:: findText

    Finds and selects the next instance of given text on the current page. When the given text changes, the search starts anew.

    Argument:: string
        The text to find; a String.

    Argument:: reverse
        Whether to search in reverse direction; a Boolean.


SUBSECTION:: Data

METHOD:: html

    Gets or sets the displayed html content.

    Argument::
        A String.

METHOD:: plainText

    Tries to extract plain text from the displayed content, and returns it.
    Returns:: A String.

METHOD:: title

    The title of the current page.
    Returns:: A String.

METHOD:: selectedText

    The currently selected text.
    Returns:: A String.


SUBSECTION:: Behavior and appearance

METHOD:: enterInterpretsSelection
    Whether pressing Ctrl+Return or Ctrl+Enter while some text is selected should evaluate the selection as SuperCollider code.
    Argument::
        A Boolean.

METHOD:: setFontFamily
    Sets a specific font family to be used in place of a CSS-specified generic font family.
    Argument:: generic
        The CSS generic font family to assign a font to; one of the following symbols: code::\standard, \fixed, \serif, \sansSerif, \cursive, \fantasy::.
    Argument:: specific
        A font family name to be assigned to the generic family; a String.


SUBSECTION:: Actions

METHOD:: onLoadFinished
    Sets the object to be evaluated when a page has loaded successfully, passing the view as the argument.

METHOD:: onLoadFailed
    Sets the object to be evaluated when a page has failed to load, passing the view as the argument.

METHOD:: onLinkActivated
    Sets the object to be evaluated when the user triggers a link, passing the view and the URL of the link (as String) as the arguments.

    When this is set to other than nil, WebView will stop handling links altogether. Setting this to nil will restore WebView link handling again.

METHOD:: onReload
    Sets the object to be evaluated whenever a page reload is requested, passing the view and the URL to be reloaded (as String) as the arguments.

    When this is set to other than nil, WebView will do nothing on reload requests. Setting this to nil will restore WebView reload handling again.


SUBSECTION:: JavaScript

METHOD:: evaluateJavaScript
    Evaluates the given JavaScript code in the context of the current page.
    Argument::
        A String.
** class:: WhiteNoise
summary:: White noise.
related:: Classes/BrownNoise, Classes/GrayNoise, Classes/ClipNoise, Classes/PinkNoise
categories::  UGens>Generators>Stochastic


Description::

Generates noise whose spectrum has equal power at all frequencies.


classmethods::

method::ar, kr

argument::mul
Output will be multiplied by this value.

argument::add
This value will be added to the output.

Examples::

code::
#+BEGIN_SRC sclang

(
SynthDef("help-WhiteNoise", { arg out=0;
	Out.ar(out,
		WhiteNoise.ar(0.25)
	)
}).play;
)
#+END_SRC

::

** class:: WiiMote
summary:: use the Nintendo (tm) Wii Remote
related:: Classes/GeneralHID
categories:: External Control

description::
The WiiMote class allows you to access the WiiMote from SuperCollider, both to receive data from the device, as well as send data to the device.

subsection::Some Important Issues Regarding WiiMote

This class has been developed to work both on the Mac and on Linux. The interface is mostly the same, but there are some usage issues on the Mac.
Personally, I found that it works better with an external BlueTooth receiver, than with the internal one (tested on the MacBook Pro). I also found that on the Mac, I have to connect, disconnect and then reconnect to get everything to work properly.

The IR options, as well as the Classic controller have not been tested (due to lack of access to either complementary device by the developer).

This class is not implemented for Windows, and thus will not work on that platform.

ClassMethods::

private::initClass, prStart, prStop, prDiscover

method::new
note::
Should not be called directly. See link::#*discover::.
::

method::start
Starts the eventloop. Called automatically by link::#*discover::, so no real need to call this method.

argument::updtime
updatetime of the eventloop in milliseconds.

method::discover
Discovers a new device. This calls for the creation of a new device and class instance by calling the method link::#*new::. ( strong::new:: should not be called directly). This method is synchronous, and will block until a device is found or until it times out.

When discover is called, the buttons 1 and 2 on the Wii Remote should be pushed to put the device in discovery mode.

returns:: A new WiiMote object for the device discovered, or code::nil:: if no device was discovered.

discussion::
Example to start up:
code::
#+BEGIN_SRC sclang
w = WiiMote.discover;   // discover a new device
w.battery;              // post the battery status of the device

// cleanup:
WiiMote.closeAll;       // close all devices
WiiMote.stop;
#+END_SRC

::

method::all
Returns an link::Classes/Array:: with all WiiMote devices.

method::closeAll
Close all WiiMote devices.

method::stop
Stops the eventloop. Only really necessary on Mac, but use it for cross platform robustness.

InstanceMethods::

private::prInit, prOpen, prClose, prAddress, prConnect, prDisconnect, prCalibration, prEnable, prEnableExpansion, prEnableIRSensor, prEnableMotionSensor, prEnableButtons, prSetVibration, prWiiSetLED, prHandleBatteryEvent, prHandleExtensionEvent, prHandleButtonEvent, prHandleNunchukEvent, prHandleClassicEvent, prHandleIREvent, prHandleAccEvent, prHandleEvent, prReadError, prConnectAction, prDisconnectAction

method::dumpEvents
dump incoming events for debugging purposes.

method::spec
Returns the device specification, with symbolic names for each item. Each name links to the current value.

method::actionSpec
Returns the device action specification, with symbolic names for each item. Each name in the dictionary links to an action to be performed upon receiving a new value.

method::closeAction
Set an action to be performed when the device closes.

method::connectAction
Set an action to be performed when the device connects.

method::disconnectAction
Set an action to be performed when the device disconnects.

method::at
Get the value of a device property at the given key.

method::setAction
Set an action to be performed when the value of strong::key:: changes. The key name must be one that occurs in the spec.

method::removeAction
Remove the previously defined action at the strong::key::.

method::close
Close the device.

subsection::The properties of the Wii Remote

method::battery
Returns the current battery status of the device.

method::ext_type
Returns the extension type that is connected.

method::remote_buttons
Returns an link::Classes/Array:: with the current button values.

method::remote_motion
Returns an link::Classes/Array:: with the current acceleration values (x,y,z, orientation). Orientation is Mac only.

method::remote_ir
Returns an link::Classes/Array:: with the found IR objects. (not tested!).

method::remote_led
Returns an link::Classes/Array:: with the current LED values.

method::setLEDState
Set the LED with number strong::id:: to value strong::value:: (1=on, 0=off).

method::rumble
Turn on the rumble, strong::value:: (1=on, 0=off).

method::enable
Enable the device.

method::enableExpansion
Enable the device expansion (nunchuk or classic controller).

method::enableButtons
Enable the buttons on the device.

method::enableMotionSensor
Enable the motion sensor on the device.

method::enableIRSensor
Enable the IR sensor on the device.

subsection::The properties of the NunChuk

method::nunchuk_buttons
Returns an link::Classes/Array:: with the current button values.

method::nunchuk_motion
Returns an link::Classes/Array:: with the current acceleration values (x,y,z, orientation). Orientation is Mac only.

method::nunchuk_stick
Returns an link::Classes/Array:: with the current stick values.

subsection::The properties of the Classic Controller

method::classic_buttons
Returns an link::Classes/Array:: with the current button values.

method::classic_stick1
Returns an link::Classes/Array:: with the current stick values of stick 1.

method::classic_stick2
Returns an link::Classes/Array:: with the current stick values of stick 2.

method::classic_analog
Returns an link::Classes/Array:: with the current analog values.

Examples::

code::
#+BEGIN_SRC sclang
// Example to start up and view values
WiiMote.start;    // start the eventloop
w = WiiMote.discover; // discover a new device (wait for post about connected)

WiiMote.all;      // post an array of all devices

x = WiiMoteGUI.new( w ); // create a GUI (only covers the WiiMote and NunChuk currently)

w.enableMotionSensor( 1 );
w.enableExpansion( 1 );

w.setLEDState( 0,1 ); // turn the first LED on
w.rumble( 1 ); // rumble the device
w.rumble( 0 ); // rumble the device

w.setAction( \bA, { |v| v.postln; } ); // post the value when button A changes.
w.removeAction( \bA );

// (MacOSX) if you do not see any changes in the motion sensors, then the connection is bad.
// push the red button inside the battery compartment, or the buttons 1 and 2 on the WiiMote and start over again to discover...

WiiMote.discover; // discover a new device
WiiMote.all;      // post an array of all devices

w = WiiMote.all[1];
x.w.close; // close previous window
x = WiiMoteGUI.new( w ); // create a GUI (only covers the WiiMote and NunChuk currently)

// now it should work..., if not, repeat the exercise...


// clean up
WiiMote.closeAll; // close all devices
WiiMote.stop;
x.w.close;
#+END_SRC

::

subsection:: IR tracking
This example shows a window displaying the objects being tracked by the WiiMote IR camera.
code::
#+BEGIN_SRC sclang
(
var q, w, u;
q = WiiMote.discover;
if(q.isNil) {
    "No wiimote found, aborting.".error;
} {
    q.enableIRSensor(1);
    w = Window("IR sensor", Rect(100, 100, 400, 400)).front;
    w.onClose = { q.close };
    u = UserView(w, Rect(0, 0, 400, 400));
    u.background = Color.black;
    u.drawFunc = {
        var p;
        q.remote_ir.do {|ir, i|
            if(ir.valid>0) {
                p = Point(ir.posx*400, ir.posy*400);
                Pen.addArc(p, ir.size*500.0, 0, pi*2);
                Pen.fillColor = Color.hsv(i/5, 1, 1);
                Pen.fill;
                Pen.stringAtPoint(
                    "% @ % %".format(
                        ir.posx.round(0.01),
                        ir.posy.round(0.01),
                        (ir.size*1000).floor
                    ),
                    p,
                    Font(Font.defaultSansFace, 9),
                    Color.white
                );
            };
        };
    };
    u.animate = true;
};
)
#+END_SRC

::

** CLASS:: Window
redirect:: implClass
summary:: Top-level container of views
categories:: GUI>Views

DESCRIPTION::

The Window is the most fundamental element of the GUI. It occupies a rectangular space on the screen within which other GUI elements (Views) are displayed.

A child view is added into a window by passing the window to the view's constructor. See link::Classes/View#*new::.

note::
In strong::Qt GUI:: there is no distinction between windows, views, and containers; a View can be displayed directly on screen, and can contain other views. Therefore, visual descriptions of Window and most of the methods that are specific to Window in other GUI kits, also apply to and make part of View in Qt, and are thus shared by all its subclasses.

The Window class is provided in Qt GUI for compatibility as well as convenience: e.g. unlike View, Window will be created by default in the center of the screen, and various aspects can be conveniently controlled using its constructor arguments.
::

The Window is usually drawn with a bar on its top edge that displays the window's title which you can set in the link::#*new#constructor::, or using link::#-name::.



CLASSMETHODS::

PRIVATE:: key

METHOD:: new

	Creates a new Window instance. You will need to call link::#-front:: on it to become visible.

	argument:: name
		A String for the text that will be displayed in the title bar. The default is 'panel'.
	argument:: bounds
		A Rect specifying position and size of the window. The size does not include the border and title bar. Position is measured from the bottom-left corner of the screen (this is different than link::Classes/View#-bounds::). The default is size 400x400 at position 128x64, but in Qt the window is centered on the screen by default.
	argument:: resizable
		A Boolean indicating whether this window is resizable by the user. The default is code::true::.
	argument:: border
		A Boolean indicating whether this window has a border. Borderless windows have no title bar and thus can only be closed in code. The default is code::true::.
	argument:: server
		This is a dummy argument which is here to provide compatibility with SwingOSC and has no effect.
	argument:: scroll
		A Boolean indicating whether this window will add scrollbars if its contents exceed its bounds. If this is set to code::true::, then link::Classes/View#-resize:: settings will be ignored for contained views. The default is false.

METHOD:: allWindows

	An array of all existing Window instances.

METHOD:: closeAll

	Calls link::#-close:: an all existing Window instances.

METHOD:: initAction

	The default action object to be evaluated whenever a new Window is instantiated.

METHOD:: screenBounds

	Returns a Rect with the size of the screen in pixels

METHOD:: availableBounds

	Returns a Rect describing the area of the screen that windows can actually occupy (i.e. excluding the Mac dock, the task bar, or similar).




INSTANCEMETHODS::

SUBSECTION:: View hierarchy

METHOD:: view
	When a Window is created, it creates a container view, accessible using this method, that occupies the whole area of the window, and which will be used as the actual parent of the child widgets.

	returns::
		A View.

METHOD:: asView
	Equivalent to link::#-view::

METHOD:: currentSheet
	note:: Only in Cocoa GUI ::
	returns:
		The current modal sheet attached to this window, if it exists. See link::Classes/SCModalSheet::.




SUBSECTION:: Visibility

METHOD:: front
	Displays the window on the screen (In Qt GUI this has the same effect as setting link::#-visible:: to true).

METHOD:: minimize
	Hides the window, only keeping its representation in the dock, taskbar, etc..

METHOD:: unminimize
	Restores the window's previous state after being minimized.

METHOD:: fullScreen
	Displays the window full-screen.

METHOD:: endFullScreen
	Restores the window's previous state after being displayed full-screen.

METHOD:: alwaysOnTop
	Whether the window should always stay on top of other windows, even when it is not the active one.

	argument::
		A Boolean.

METHOD:: visible
	note:: only in Qt GUI ::

	Whether the window is visible.

	Setting this to code::true:: has the same effect as link::#-front::, and setting it to false closes the window without destroying it.

	argument::
		A Boolean.

METHOD:: close

	Closes and destroys the window.

METHOD:: isClosed
	returns:: A Boolean stating whether the view has been closed.




SUBSECTION:: Geometry

METHOD:: bounds

	The position and size of the window. The position is relative to the bottom-left corner of the screen.

	argument::
		A Rect or a Point interpreted link::Classes/Point#-asRect#as Rect::.
	returns::
		A Rect.

METHOD:: setTopLeftBounds

	A convenience method that, unlike link::#-bounds::, sets the bounds by measuring position from the top-left corner of the screen, and vertically offset by code::menuSpacer::.

	argument:: rect
		A Rect.
	argument:: menuSpacer
		An Integer amount of pixels.

METHOD:: setInnerExtent

	Resizes the window, keeping its position intact.

	In strong:: Qt GUI ::, this is equivalent to link::Classes/View#-resizeTo:: called on the link::#-view::.

	argument:: w
		An Integer width in pixels.
	argument:: h
		An Integer height in pixels.

METHOD:: sizeHint
	note:: only in Qt GUI ::
	Redirects to link::Classes/View#-sizeHint:: of the link::#-view::.

METHOD:: minSizeHint
	note:: only in Qt GUI ::
	Redirects to link::Classes/View#-minSizeHint:: of the link::#-view::.

METHOD:: addFlowLayout

	A convenience method which sets code::decorator:: of the link::#-view:: to a new instance of FlowLayout. See link::Classes/FlowLayout:: for examples.

	argument:: margin
		A Point describing the link::Classes/FlowLayout#-margin#margin:: of the FlowLayout.

	argument:: gap
		A Point describing the link::Classes/FlowLayout#-gap#gap:: of the FlowLayout.

	returns:: The new FlowLayout instance.

METHOD:: layout
	note:: only in Qt GUI ::
	Redirects to link::Classes/View#-layout:: of the link::#-view::.



SUBSECTION:: Appearance

METHOD:: name
	The title of the window.

	argument::
		A String.

METHOD:: background
	The background color of the window.

	argument::
		A Color.

METHOD:: alpha
	The transparancy of the window.

	argument::
		A Float between 0.0 (invisible) and 1.0 (opaque).

METHOD:: refresh
	Redraws the window and all its children.



SUBSECTION:: Interaction

METHOD:: userCanClose
	Whether the user can close the window. The default is code::true::.

	argument::
		A Boolean.

METHOD:: acceptsClickThrough
	Whether the window receives clicks when it is not front-most. The default is code::true::.

	argument::
		A Boolean.

METHOD:: acceptsMouseOver
	Whether the window and all its children receive mouse-over events. The default is code::false::.

	See also: link::Classes/View#-acceptsMouseOver:: and link::Classes/View#-mouseOverAction::.

	argument::
		A Boolean.



SUBSECTION:: Actions and hooks

METHOD:: drawFunc
	Just like the link::Classes/UserView::, the window can be given a Function to evalute whenever it is asked to redraw itself, so you can use the link::Classes/Pen:: class to draw on the window. See link::Classes/UserView#-drawFunc:: for explanation.

	argument::
		A Function.

METHOD:: toFrontAction

	The action object to be evaluated whenever the window becomes the active one.

METHOD:: endFrontAction

	The action object to be evaluated whenever the window ceases to be the active one.

METHOD:: onClose

	The action object to be evaluated when the window is closed.

METHOD:: addToOnClose

	Adds an object to link::#-onClose::, wrapping the current value into an Array, if it is not yet.

METHOD:: removeFromOnClose

	Removes an object from link::#-onClose::, if the latter is an Array.



EXAMPLES::

subsection:: Adding Views

code::
#+BEGIN_SRC sclang
(
var w;
w = Window("my name is... panel", Rect(128, 64, 340, 360));

32.do({ arg i;
    b = Button(w, Rect(rrand(20,300),rrand(20,300), 75, 24));
    b.states = [["Start "++i, Color.black, Color.rand],
        ["Stop "++i, Color.white, Color.red]];
});
w.front;
)
#+END_SRC

::


subsection:: Using Decorator

code::
#+BEGIN_SRC sclang
(
var w;
w = Window("my name is... panel", Rect(128, 64, 340, 360));

w.view.decorator = FlowLayout(w.view.bounds);
// w.addFlowLayout; // you can als write this instead of the line above

w.view.background = Color(0.6,0.8,0.8);
32.do({ arg i;
    b = Button(w, Rect(rrand(20,300),rrand(20,300), 75, 24));
    b.states = [["Start "++i, Color.black, Color.rand],
        ["Stop "++i, Color.white, Color.red]];
});

w.front;
)
#+END_SRC

::


subsection:: Setting Bounds

code::
#+BEGIN_SRC sclang
// use screenbounds for precise placement from the top
(
x = Window.new("test", Rect(100,Window.screenBounds.height-180,300,100));x.front;
)

// bounds.top refers to the bottom edge of the window,
// measured from the bottom of the screen. Different than in View.
x.bounds_(Rect(100,400,300,300));
#+END_SRC

::


subsection:: Borderless Window

code::
#+BEGIN_SRC sclang
w = Window.new(border:false).front; // can't be manually closed
w.close; // so close it in code
#+END_SRC

::


subsection:: Window with Scrollers

code::
#+BEGIN_SRC sclang
(
w = Window(scroll: true); // you must set this when the window is created
c = Slider2D(w, Rect(0, 0, 1500, 300));
d = Slider(w, Rect(0, 310, 20, 300));
c.background = Color.grey.alpha = 0.6;
d.background = Color.grey.alpha = 0.6;
w.front;
)
#+END_SRC

::


subsection::onClose

code::
#+BEGIN_SRC sclang
(
x = Window.new.front;
x.alpha = 0.8;
x.onClose_({ y = Synth.new(\default) }); //close the window and the synth plays
)
x.close;
y.free;
#+END_SRC

::


subsection:: Drawing on Window with Pen

code::
#+BEGIN_SRC sclang
(
var w, much = 0.02, string, synth;

w = Window.new("gui", Rect(100, 100, 300, 500)).front;
w.view.background_(Color.new255(153, 255, 102).vary);

string = "gui ".dup(24).join;

w.drawFunc = Routine {
    var i = 0;
    var size = 40;
    var func = { |i, j| sin(i * 0.07 + (j * 0.0023) + 1.5pi) * much + 1 };
    var scale;
    var font = Font("Helvetica", 40).boldVariant;
    loop {
        i = i + 1;
        Pen.font = font;
        string.do { |char, j|

            scale = func.value(i, j).dup(6);

            Pen.fillColor = Color.new255(0, 120, 120).vary;
            Pen.matrix = scale * #[1, 0, 0, 1, 1, 0];
            Pen.stringAtPoint(char.asString,
                ((size * (j % 9)) - 10) @ (size * (j div: 9))
            );
        };
        0.yield // stop here, return something unimportant
    }
};

{ while { w.isClosed.not } { w.refresh; 0.04.wait; } }.fork(AppClock);

w.front;

)
#+END_SRC

::
** class:: Wrap
summary:: Wrap a signal outside given thresholds.
related:: Classes/Clip, Classes/Fold
categories::  UGens>Maths


Description::

This differs from the  link::Classes/BinaryOpUGen::  link::Overviews/Methods#wrap2#wrap2:: in that it
allows one to set both low and high thresholds.


classmethods::

method::ar, kr

argument::in

Signal to be wrapped.


argument::lo

Low threshold of wrapping.


argument::hi

High threshold of wrapping.


Examples::

code::
#+BEGIN_SRC sclang

s.boot;

{ Wrap.ar(SinOsc.ar(440, 0, 0.2), -0.15, 0.15) }.scope;
#+END_SRC

::

** class:: WrapIndex
summary:: Index into a table with a signal.
related:: Classes/Index, Classes/Shaper
categories::  UGens>Buffer


Description::

The input signal value is truncated to an integer value and used as an
index into the table. Out-of-range index values are wrapped cyclically to
the valid range.


classmethods::

method::ar, kr

argument::bufnum

Index of the buffer.


argument::in

The input signal.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


Examples::

code::
#+BEGIN_SRC sclang

(
// indexing into a table
s = Server.local;
t = [ 200, 300, 400, 500, 600, 800 ];
b = Buffer(s,t.size,1);

// alloc and set the values
s.listSendMsg( b.allocMsg( b.setnMsg(0, t) ).postln );

SynthDef("help-Index",{ arg out=0,i_bufnum=0;
	Out.ar(0,
		SinOsc.ar(
			WrapIndex.kr(
				i_bufnum,
				MouseX.kr(0, t.size * 3)
			),
			0,
			0.5
		)
	)
}).play(s,[\i_bufnum,b.bufnum]);

)
#+END_SRC

::

** class:: XFade2
summary:: Equal power two channel cross fade.
related:: Classes/LinXFade2
categories::  UGens>Multichannel>Select


Description::

Two channel equal power crossfader.


classmethods::

method::ar, kr

argument::inA

Input signal A.


argument::inB

Input signal B.


argument::pan

Crossfade position from -1 to +1.


argument::level

A control rate level input.


Examples::

code::
#+BEGIN_SRC sclang

(
SynthDef("help-XFade2", {
	Out.ar(0, XFade2.ar( Saw.ar, SinOsc.ar , LFTri.kr(0.1) ));
}).play
)
#+END_SRC

::

** class:: XLine
summary:: Exponential line generator.
related:: Classes/Line
categories::  UGens>Envelopes


Description::

Generates an exponential curve from the start value to the end value.
Both the start and end values must be non-zero and have the same sign.


classmethods::

method::ar, kr

argument::start

Starting value.


argument::end

Ending value.


argument::dur

Duration in seconds.


argument::mul

Output will be multiplied by this value.


argument::add

This value will be added to the output.


argument::doneAction

A doneAction to be evaluated when the line is completed. See

link::Reference/UGen-doneActions::  for more detail.


Examples::

code::
#+BEGIN_SRC sclang

play({ SinOsc.ar(XLine.kr(200,17000,10),0,0.1) });
#+END_SRC

::

** class:: XOut
summary:: Send signal to a bus, crossfading with previous contents.
related:: Classes/OffsetOut, Classes/Out, Classes/ReplaceOut
categories::  UGens>InOut


Description::

Send signal to a bus, crossfading with previous contents.
code::xfade::  is a level for the crossfade between what
is on the bus and what you are sending. The algorithm is equivalent to this:

code::
#+BEGIN_SRC sclang
bus_signal = (input_signal * xfade) + (bus_signal * (1 - xfade));
#+END_SRC

::


See the link::Reference/Server-Architecture:: and link::Classes/Bus:: helpfiles for more information on
buses and how they are used.


classmethods::

method::ar, kr

argument::bus
The index of the bus to write out to. The lowest numbers are written to the audio hardware.

argument::xfade
Crossfade level.

argument::channelsArray
An Array of channels or single output to write out. You cannot change the size of this once a SynthDef has been built.

Examples::

code::
#+BEGIN_SRC sclang

(
SynthDef("help-SinOsc", { arg freq=440, out;
	Out.ar(out, SinOsc.ar(freq, 0, 0.1))
}).send(s);

SynthDef("help-XOut", { arg out=0, xFade=1;
	var source;
		source = PinkNoise.ar(0.05);

		// write to the bus, crossfading with previous contents
		XOut.ar(out, xFade, source);

}).send(s);
)

Synth("help-SinOsc", [\freq, 500]);
a = Synth.tail(s, "help-XOut");


a.set(\xFade, 0.7);
a.set(\xFade, 0.4);
a.set(\xFade, 0.0);
#+END_SRC

::

** class:: ZeroCrossing
summary:: Zero crossing frequency follower
categories:: UGens>Analysis>Pitch

description::
Outputs a frequency based upon the distance between interceptions of the X axis. The X intercepts are determined via linear interpolation so this gives better than just integer wavelength resolution. This is a very crude pitch follower, but can be useful in some situations.

classmethods::
method:: ar, kr
argument::in
Input signal.

examples::

code::
#+BEGIN_SRC sclang
s.boot;
(
{
    var a;
    a = SinOsc.ar(SinOsc.kr(1, 0, 600,700), 0, 0.1);
    [a, ZeroCrossing.ar(a) * 0.0005]
}.scope;
)
#+END_SRC

::
